module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 258);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("assert");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * util.js - utils for wmcc_core.
 */



const assert = __webpack_require__(0);
const nodeUtil = __webpack_require__(38);

/**
 * @exports utils/util
 */

const util = exports;

/*
 * Constants
 */

const inspectOptions = {
  showHidden: false,
  depth: 20,
  colors: false,
  customInspect: true,
  showProxy: false,
  maxArrayLength: Infinity,
  breakLength: 60
};

/**
 * Test whether a number is Number,
 * finite, and below MAX_SAFE_INTEGER.
 * @param {Number?} value
 * @returns {Boolean}
 */

util.isNumber = function isNumber(value) {
  return typeof value === 'number'
    && isFinite(value)
    && value >= -Number.MAX_SAFE_INTEGER
    && value <= Number.MAX_SAFE_INTEGER;
};

/**
 * Test whether an object is an int.
 * @param {Number?} value
 * @returns {Boolean}
 */

util.isInt = function isInt(value) {
  return Number.isSafeInteger(value);
};

/**
 * Test whether an object is a uint.
 * @param {Number?} value
 * @returns {Boolean}
 */

util.isUint = function isUint(value) {
  return util.isInt(value) && value >= 0;
};

/**
 * Test whether a number is a float.
 * @param {Number?} value
 * @returns {Boolean}
 */

util.isFloat = function isFloat(value) {
  return typeof value === 'number' && isFinite(value);
};

/**
 * Test whether a number is a positive float.
 * @param {Number?} value
 * @returns {Boolean}
 */

util.isUfloat = function isUfloat(value) {
  return util.isFloat(value) && value >= 0;
};

/**
 * Test whether an object is an int8.
 * @param {Number?} value
 * @returns {Boolean}
 */

util.isI8 = function isI8(value) {
  return (value | 0) === value && value >= -0x80 && value <= 0x7f;
};

/**
 * Test whether an object is an int16.
 * @param {Number?} value
 * @returns {Boolean}
 */

util.isI16 = function isI16(value) {
  return (value | 0) === value && value >= -0x8000 && value <= 0x7fff;
};

/**
 * Test whether an object is an int32.
 * @param {Number?} value
 * @returns {Boolean}
 */

util.isI32 = function isI32(value) {
  return (value | 0) === value;
};

/**
 * Test whether an object is a int53.
 * @param {Number?} value
 * @returns {Boolean}
 */

util.isI64 = function isI64(value) {
  return util.isInt(value);
};

/**
 * Test whether an object is a uint8.
 * @param {Number?} value
 * @returns {Boolean}
 */

util.isU8 = function isU8(value) {
  return (value & 0xff) === value;
};

/**
 * Test whether an object is a uint16.
 * @param {Number?} value
 * @returns {Boolean}
 */

util.isU16 = function isU16(value) {
  return (value & 0xffff) === value;
};

/**
 * Test whether an object is a uint32.
 * @param {Number?} value
 * @returns {Boolean}
 */

util.isU32 = function isU32(value) {
  return (value >>> 0) === value;
};

/**
 * Test whether an object is a uint53.
 * @param {Number?} value
 * @returns {Boolean}
 */

util.isU64 = function isU64(value) {
  return util.isUint(value);
};

/**
 * Test whether a string is a plain
 * ascii string (no control characters).
 * @param {String} str
 * @returns {Boolean}
 */

util.isAscii = function isAscii(str) {
  return typeof str === 'string' && /^[\t\n\r -~]*$/.test(str);
};

/**
 * Test whether a string is base58 (note that you
 * may get a false positive on a hex string).
 * @param {String?} str
 * @returns {Boolean}
 */

util.isBase58 = function isBase58(str) {
  return typeof str === 'string' && /^[1-9A-Za-z]+$/.test(str);
};

/**
 * Test whether a string is bech32 (note that
 * this doesn't guarantee address is bech32).
 * @param {String?} str
 * @returns {Boolean}
 */

util.isBech32 = function isBech32(str) {
  if (typeof str !== 'string')
    return false;

  if (str.toUpperCase() !== str && str.toLowerCase() !== str)
    return false;

  if (str.length < 8 || str.length > 90)
    return false;

  // it's unlikely any network will have hrp other than a-z symbols.
  return /^[a-z]{2}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]+$/i.test(str);
};

/**
 * Test whether a string is hex (length must be even).
 * Note that this _could_ await a false positive on
 * base58 strings.
 * @param {String?} str
 * @returns {Boolean}
 */

util.isHex = function isHex(str) {
  if (typeof str !== 'string')
    return false;
  return str.length % 2 === 0 && /^[0-9A-Fa-f]+$/.test(str);
};

/**
 * Test whether an object is a 160 bit hash (hex string).
 * @param {String?} hash
 * @returns {Boolean}
 */

util.isHex160 = function isHex160(hash) {
  if (typeof hash !== 'string')
    return false;
  return hash.length === 40 && util.isHex(hash);
};

/**
 * Test whether an object is a 256 bit hash (hex string).
 * @param {String?} hash
 * @returns {Boolean}
 */

util.isHex256 = function isHex256(hash) {
  if (typeof hash !== 'string')
    return false;
  return hash.length === 64 && util.isHex(hash);
};

/**
 * Test whether the result of a positive
 * addition would be below MAX_SAFE_INTEGER.
 * @param {Number} value
 * @returns {Boolean}
 */

util.isSafeAddition = function isSafeAddition(a, b) {
  // We only work on positive numbers.
  assert(a >= 0);
  assert(b >= 0);

  // Fast case.
  if (a <= 0xfffffffffffff && b <= 0xfffffffffffff)
    return true;

  // Do a 64 bit addition and check the top 11 bits.
  let ahi = (a * (1 / 0x100000000)) | 0;
  const alo = a | 0;

  let bhi = (b * (1 / 0x100000000)) | 0;
  const blo = b | 0;

  // Credit to @indutny for this method.
  const lo = (alo + blo) | 0;

  const s = lo >> 31;
  const as = alo >> 31;
  const bs = blo >> 31;

  const c = ((as & bs) | (~s & (as ^ bs))) & 1;

  let hi = (((ahi + bhi) | 0) + c) | 0;

  hi >>>= 0;
  ahi >>>= 0;
  bhi >>>= 0;

  // Overflow?
  if (hi < ahi || hi < bhi)
    return false;

  return (hi & 0xffe00000) === 0;
};

/**
 * util.inspect() with 20 levels of depth.
 * @param {Object|String} obj
 * @param {Boolean?} color
 * @return {String}
 */

util.inspectify = function inspectify(obj, color) {
  if (typeof obj === 'string')
    return obj;

  inspectOptions.colors = color !== false;

  return nodeUtil.inspect(obj, inspectOptions);
};

/**
 * Format a string.
 * @function
 * @param {...String} args
 * @returns {String}
 */

util.fmt = nodeUtil.format;

/**
 * Format a string.
 * @param {Array} args
 * @param {Boolean?} color
 * @return {String}
 */

util.format = function format(args, color) {
  if (args.length > 0 && args[0] && typeof args[0] === 'object') {
    if (color == null)
      color = Boolean(process.stdout && process.stdout.isTTY);
    return util.inspectify(args[0], color);
  }
  return util.fmt(...args);
};

/**
 * Write a message to stdout (console in browser).
 * @param {Object|String} obj
 * @param {...String} args
 */

util.log = function log(...args) {
  if (!process.stdout) {
    let msg;
    if (args.length > 0) {
      msg = typeof args[0] !== 'object'
        ? util.fmt(...args)
        : args[0];
    }
    console.log(msg);
    return;
  }

  const msg = util.format(args);

  process.stdout.write(msg + '\n');
};

/**
 * Write a message to stderr (console in browser).
 * @param {Object|String} obj
 * @param {...String} args
 */

util.error = function error(...args) {
  if (!process.stderr) {
    let msg;
    if (args.length > 0) {
      msg = typeof args[0] !== 'object'
        ? util.fmt(...args)
        : args[0];
    }
    console.error(msg);
    return;
  }

  const msg = util.format(args);

  process.stderr.write(msg + '\n');
};

/**
 * Return hrtime (shim for browser).
 * @param {Array} time
 * @returns {Array} [seconds, nanoseconds]
 */

util.hrtime = function hrtime(time) {
  if (!process.hrtime) {
    const now = util.ms();

    if (time) {
      const [hi, lo] = time;
      const start = hi * 1000 + lo / 1e6;
      return now - start;
    }

    const ms = now % 1000;

    // Seconds
    const hi = (now - ms) / 1000;

    // Nanoseconds
    const lo = ms * 1e6;

    return [hi, lo];
  }

  if (time) {
    const [hi, lo] = process.hrtime(time);
    return hi * 1000 + lo / 1e6;
  }

  return process.hrtime();
};

/**
 * Get current time in unix time (seconds).
 * @returns {Number}
 */

util.now = function now() {
  return Math.floor(util.ms() / 1000);
};

/**
 * Get current time in unix time (milliseconds).
 * @returns {Number}
 */

util.ms = function ms() {
  return Date.now();
};

/**
 * Create a Date ISO string from time in unix time (seconds).
 * @param {Number?} time - Seconds in unix time.
 * @returns {String}
 */

util.date = function date(time) {
  if (time == null)
    time = util.now();

  return new Date(time * 1000).toISOString().slice(0, -5) + 'Z';
};

/**
 * Get unix seconds from a Date string.
 * @param {String?} date - Date ISO String.
 * @returns {Number}
 */

util.time = function time(date) {
  if (date == null)
    return util.now();

  return new Date(date) / 1000 | 0;
};

/**
 * Get random range.
 * @param {Number} min
 * @param {Number} max
 * @returns {Number}
 */

util.random = function random(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
};

/**
 * Create a 32 or 64 bit nonce.
 * @param {Number} size
 * @returns {Buffer}
 */

util.nonce = function nonce(size) {
  let n, data;

  if (!size)
    size = 8;

  switch (size) {
    case 8:
      data = Buffer.allocUnsafe(8);
      n = util.random(0, 0x100000000);
      data.writeUInt32LE(n, 0, true);
      n = util.random(0, 0x100000000);
      data.writeUInt32LE(n, 4, true);
      break;
    case 4:
      data = Buffer.allocUnsafe(4);
      n = util.random(0, 0x100000000);
      data.writeUInt32LE(n, 0, true);
      break;
    default:
      assert(false, 'Bad nonce size.');
      break;
  }

  return data;
};

/**
 * String comparator (memcmp + length comparison).
 * @param {Buffer} a
 * @param {Buffer} b
 * @returns {Number} -1, 1, or 0.
 */

util.strcmp = function strcmp(a, b) {
  const len = Math.min(a.length, b.length);

  for (let i = 0; i < len; i++) {
    if (a[i] < b[i])
      return -1;
    if (a[i] > b[i])
      return 1;
  }

  if (a.length < b.length)
    return -1;

  if (a.length > b.length)
    return 1;

  return 0;
};

/**
 * Convert bytes to mb.
 * @param {Number} size
 * @returns {Number} mb
 */

util.mb = function mb(size) {
  return Math.floor(size / 1024 / 1024);
};

/**
 * Find index of a buffer in an array of buffers.
 * @param {Buffer[]} items
 * @param {Buffer} data - Target buffer to find.
 * @returns {Number} Index (-1 if not found).
 */

util.indexOf = function indexOf(items, data) {
  assert(Array.isArray(items));
  assert(Buffer.isBuffer(data));

  for (let i = 0; i < items.length; i++) {
    const item = items[i];

    assert(Buffer.isBuffer(item));

    if (item.equals(data))
      return i;
  }

  return -1;
};

/**
 * Convert a number to a padded uint8
 * string (3 digits in decimal).
 * @param {Number} num
 * @returns {String} Padded number.
 */

util.pad8 = function pad8(num) {
  assert(typeof num === 'number');
  assert(num >= 0);

  num = num.toString(10);

  switch (num.length) {
    case 1:
      return '00' + num;
    case 2:
      return '0' + num;
    case 3:
      return num;
  }

  throw new Error('Number too big.');
};

/**
 * Convert a number to a padded uint32
 * string (10 digits in decimal).
 * @param {Number} num
 * @returns {String} Padded number.
 */

util.pad32 = function pad32(num) {
  assert(typeof num === 'number');
  assert(num >= 0);

  num = num.toString(10);

  switch (num.length) {
    case 1:
      return '000000000' + num;
    case 2:
      return '00000000' + num;
    case 3:
      return '0000000' + num;
    case 4:
      return '000000' + num;
    case 5:
      return '00000' + num;
    case 6:
      return '0000' + num;
    case 7:
      return '000' + num;
    case 8:
      return '00' + num;
    case 9:
      return '0' + num;
    case 10:
      return num;
  }

  throw new Error('Number too big.');
};

/**
 * Convert a number to a padded uint8
 * string (2 digits in hex).
 * @param {Number} num
 * @returns {String} Padded number.
 */

util.hex8 = function hex8(num) {
  assert(typeof num === 'number');
  assert(num >= 0);

  num = num.toString(16);

  switch (num.length) {
    case 1:
      return '0' + num;
    case 2:
      return num;
  }

  throw new Error('Number too big.');
};

/**
 * Convert a number to a padded uint32
 * string (8 digits in hex).
 * @param {Number} num
 * @returns {String} Padded number.
 */

util.hex32 = function hex32(num) {
  assert(typeof num === 'number');
  assert(num >= 0);

  num = num.toString(16);

  switch (num.length) {
    case 1:
      return '0000000' + num;
    case 2:
      return '000000' + num;
    case 3:
      return '00000' + num;
    case 4:
      return '0000' + num;
    case 5:
      return '000' + num;
    case 6:
      return '00' + num;
    case 7:
      return '0' + num;
    case 8:
      return num;
  }

  throw new Error('Number too big.');
};

/**
 * Reverse a hex-string (used because of
 * wmccd's affinity for uint256le).
 * @param {String} data - Hex string.
 * @returns {String} Reversed hex string.
 */

util.revHex = function revHex(data) {
  assert(typeof data === 'string');
  assert(data.length > 0);
  assert(data.length % 2 === 0);

  let out = '';

  for (let i = 0; i < data.length; i += 2)
    out = data.slice(i, i + 2) + out;

  return out;
};

/**
 * Reverse an object's keys and values.
 * @param {Object} obj
 * @returns {Object} Reversed object.
 */

util.reverse = function reverse(obj) {
  const reversed = {};

  for (const key of Object.keys(obj))
    reversed[obj[key]] = key;

  return reversed;
};

/**
 * Perform a binary search on a sorted array.
 * @param {Array} items
 * @param {Object} key
 * @param {Function} compare
 * @param {Boolean?} insert
 * @returns {Number} Index.
 */

util.binarySearch = function binarySearch(items, key, compare, insert) {
  let start = 0;
  let end = items.length - 1;

  while (start <= end) {
    const pos = (start + end) >>> 1;
    const cmp = compare(items[pos], key);

    if (cmp === 0)
      return pos;

    if (cmp < 0)
      start = pos + 1;
    else
      end = pos - 1;
  }

  if (!insert)
    return -1;

  return start;
};

/**
 * Perform a binary insert on a sorted array.
 * @param {Array} items
 * @param {Object} item
 * @param {Function} compare
 * @returns {Number} index
 */

util.binaryInsert = function binaryInsert(items, item, compare, uniq) {
  const i = util.binarySearch(items, item, compare, true);

  if (uniq && i < items.length) {
    if (compare(items[i], item) === 0)
      return -1;
  }

  if (i === 0)
    items.unshift(item);
  else if (i === items.length)
    items.push(item);
  else
    items.splice(i, 0, item);

  return i;
};

/**
 * Perform a binary removal on a sorted array.
 * @param {Array} items
 * @param {Object} item
 * @param {Function} compare
 * @returns {Boolean}
 */

util.binaryRemove = function binaryRemove(items, item, compare) {
  const i = util.binarySearch(items, item, compare, false);

  if (i === -1)
    return false;

  items.splice(i, 1);

  return true;
};

/**
 * Quick test to see if a string is uppercase.
 * @param {String} str
 * @returns {Boolean}
 */

util.isUpperCase = function isUpperCase(str) {
  assert(typeof str === 'string');

  if (str.length === 0)
    return false;

  return (str.charCodeAt(0) & 32) === 0;
};

/**
 * Test to see if a string starts with a prefix.
 * @param {String} str
 * @param {String} prefix
 * @returns {Boolean}
 */

util.startsWith = function startsWith(str, prefix) {
  assert(typeof str === 'string');

  if (!str.startsWith)
    return str.indexOf(prefix) === 0;

  return str.startsWith(prefix);
};

/**
 * Get memory usage info.
 * @returns {Object}
 */

util.memoryUsage = function memoryUsage() {
  if (!process.memoryUsage) {
    return {
      total: 0,
      jsHeap: 0,
      jsHeapTotal: 0,
      nativeHeap: 0,
      external: 0
    };
  }

  const mem = process.memoryUsage();

  return {
    total: util.mb(mem.rss),
    jsHeap: util.mb(mem.heapUsed),
    jsHeapTotal: util.mb(mem.heapTotal),
    nativeHeap: util.mb(mem.rss - mem.heapTotal),
    external: util.mb(mem.external)
  };
};

/**
 * Convert int to fixed number string and reduce by a
 * power of ten (uses no floating point arithmetic).
 * @param {Number} num
 * @param {Number} exp - Number of decimal places.
 * @returns {String} Fixed number string.
 */

util.toFixed = function toFixed(num, exp) {
  assert(typeof num === 'number');
  assert(Number.isSafeInteger(num), 'Invalid integer value.');

  let sign = '';

  if (num < 0) {
    num = -num;
    sign = '-';
  }

  const mult = pow10(exp);
  let lo = num % mult;
  //const hi = (num - lo) / mult;
  let hi = (num - lo) / mult;

  lo = lo.toString(10);
  hi = hi.toString(10);

  while (lo.length < exp)
    lo = '0' + lo;

  lo = lo.replace(/0+$/, '');

  assert(lo.length <= exp, 'Invalid integer value.');

  if (lo.length === 0)
    lo = '0';

  if (exp === 0)
    return `${sign}${hi}`;

  return `${sign}${hi}.${lo}`;
};

/**
 * Parse a fixed number string and multiply by a
 * power of ten (uses no floating point arithmetic).
 * @param {String} str
 * @param {Number} exp - Number of decimal places.
 * @returns {Number} Integer.
 */

util.fromFixed = function fromFixed(str, exp) {
  assert(typeof str === 'string');
  assert(str.length <= 32, 'Fixed number string too large.');

  let sign = 1;

  if (str.length > 0 && str[0] === '-') {
    str = str.substring(1);
    sign = -1;
  }

  let hi = str;
  let lo = '0';

  const index = str.indexOf('.');

  if (index !== -1) {
    hi = str.substring(0, index);
    lo = str.substring(index + 1);
  }

  hi = hi.replace(/^0+/, '');
  lo = lo.replace(/0+$/, '');

  assert(hi.length <= 16 - exp,
    'Fixed number string exceeds 2^53-1.');

  assert(lo.length <= exp,
    'Too many decimal places in fixed number string.');

  if (hi.length === 0)
    hi = '0';

  while (lo.length < exp)
    lo += '0';

  if (lo.length === 0)
    lo = '0';

  assert(/^\d+$/.test(hi) && /^\d+$/.test(lo),
    'Non-numeric characters in fixed number string.');

  hi = parseInt(hi, 10);
  lo = parseInt(lo, 10);

  const mult = pow10(exp);
  const maxLo = modSafe(mult);
  const maxHi = divSafe(mult);

  assert(hi < maxHi || (hi === maxHi && lo <= maxLo),
    'Fixed number string exceeds 2^53-1.');

  return sign * (hi * mult + lo);
};

/**
 * Convert int to float and reduce by a power
 * of ten (uses no floating point arithmetic).
 * @param {Number} num
 * @param {Number} exp - Number of decimal places.
 * @returns {Number} Double float.
 */

util.toFloat = function toFloat(num, exp) {
  return Number(util.toFixed(num, exp));
};

/**
 * Parse a double float number and multiply by a
 * power of ten (uses no floating point arithmetic).
 * @param {Number} num
 * @param {Number} exp - Number of decimal places.
 * @returns {Number} Integer.
 */

util.fromFloat = function fromFloat(num, exp) {
  assert(typeof num === 'number' && isFinite(num));
  assert(Number.isSafeInteger(exp));
  return util.fromFixed(num.toFixed(exp), exp);
};

/**
 * Concat array of buffer
 * @param {Array} array of buffer
 * @returns {Buffer} buff.
 */

util.concatArrBuf = function concatArrBuf (arr) {
  assert(Array.isArray(arr));
  let buf = Buffer.alloc(0);
  for (let i = 0; i < arr.length; i++) {
    assert(Buffer.isBuffer(arr[i]));
    buf = Buffer.concat([buf, arr[i]]);
  }
  return buf;
};

/*
 * Helpers
 */

function pow10(exp) {
  switch (exp) {
    case 0:
      return 1;
    case 1:
      return 10;
    case 2:
      return 100;
    case 3:
      return 1000;
    case 4:
      return 10000;
    case 5:
      return 100000;
    case 6:
      return 1000000;
    case 7:
      return 10000000;
    case 8:
      return 100000000;
  }
  throw new Error('Exponent is too large.');
}

function modSafe(mod) {
  switch (mod) {
    case 1:
      return 0;
    case 10:
      return 1;
    case 100:
      return 91;
    case 1000:
      return 991;
    case 10000:
      return 991;
    case 100000:
      return 40991;
    case 1000000:
      return 740991;
    case 10000000:
      return 4740991;
    case 100000000:
      return 54740991;
  }
  throw new Error('Exponent is too large.');
}

function divSafe(div) {
  switch (div) {
    case 1:
      return 9007199254740991;
    case 10:
      return 900719925474099;
    case 100:
      return 90071992547409;
    case 1000:
      return 9007199254740;
    case 10000:
      return 900719925474;
    case 100000:
      return 90071992547;
    case 1000000:
      return 9007199254;
    case 10000000:
      return 900719925;
    case 100000000:
      return 90071992;
  }
  throw new Error('Exponent is too large.');
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * reader.js - buffer reader for wmcc_core.
 */



const assert = __webpack_require__(0);
const encoding = __webpack_require__(3);
const digest = __webpack_require__(5);

const EMPTY = Buffer.alloc(0);

/**
 * An object that allows reading of buffers in a sane manner.
 * @alias module:utils.BufferReader
 * @constructor
 * @param {Buffer} data
 * @param {Boolean?} zeroCopy - Do not reallocate buffers when
 * slicing. Note that this can lead to memory leaks if not used
 * carefully.
 */

function BufferReader(data, zeroCopy) {
  if (!(this instanceof BufferReader))
    return new BufferReader(data, zeroCopy);

  assert(Buffer.isBuffer(data), 'Must pass a Buffer.');

  this.data = data;
  this.offset = 0;
  this.zeroCopy = zeroCopy || false;
  this.stack = [];
}

/**
 * Assertion.
 * @param {Boolean} value
 */

BufferReader.prototype.assert = function assert(value) {
  if (!value)
    throw new encoding.EncodingError(this.offset, 'Out of bounds read', assert);
};

/**
 * Assertion.
 * @param {Boolean} value
 * @param {String} reason
 */

BufferReader.prototype.enforce = function enforce(value, reason) {
  if (!value)
    throw new encoding.EncodingError(this.offset, reason, enforce);
};

/**
 * Get total size of passed-in Buffer.
 * @returns {Buffer}
 */

BufferReader.prototype.getSize = function getSize() {
  return this.data.length;
};

/**
 * Calculate number of bytes left to read.
 * @returns {Number}
 */

BufferReader.prototype.left = function left() {
  this.assert(this.offset <= this.data.length);
  return this.data.length - this.offset;
};

/**
 * Seek to a position to read from by offset.
 * @param {Number} off - Offset (positive or negative).
 */

BufferReader.prototype.seek = function seek(off) {
  this.assert(this.offset + off >= 0);
  this.assert(this.offset + off <= this.data.length);
  this.offset += off;
  return off;
};

/**
 * Mark the current starting position.
 */

BufferReader.prototype.start = function start() {
  this.stack.push(this.offset);
  return this.offset;
};

/**
 * Stop reading. Pop the start position off the stack
 * and calculate the size of the data read.
 * @returns {Number} Size.
 * @throws on empty stack.
 */

BufferReader.prototype.end = function end() {
  assert(this.stack.length > 0);

  const start = this.stack.pop();

  return this.offset - start;
};

/**
 * Stop reading. Pop the start position off the stack
 * and return the data read.
 * @param {Bolean?} zeroCopy - Do a fast buffer
 * slice instead of allocating a new buffer (warning:
 * may cause memory leaks if not used with care).
 * @returns {Buffer} Data read.
 * @throws on empty stack.
 */

BufferReader.prototype.endData = function endData(zeroCopy) {
  assert(this.stack.length > 0);

  const start = this.stack.pop();
  const end = this.offset;
  const size = end - start;
  const data = this.data;

  if (size === data.length)
    return data;

  if (this.zeroCopy || zeroCopy)
    return data.slice(start, end);

  const ret = Buffer.allocUnsafe(size);
  data.copy(ret, 0, start, end);

  return ret;
};

/**
 * Destroy the reader. Remove references to the data.
 */

BufferReader.prototype.destroy = function destroy() {
  this.data = EMPTY;
  this.offset = 0;
  this.stack.length = 0;
};

/**
 * Read uint8.
 * @returns {Number}
 */

BufferReader.prototype.readU8 = function readU8() {
  this.assert(this.offset + 1 <= this.data.length);
  const ret = this.data[this.offset];
  this.offset += 1;
  return ret;
};

/**
 * Read uint16le.
 * @returns {Number}
 */

BufferReader.prototype.readU16 = function readU16() {
  this.assert(this.offset + 2 <= this.data.length);
  const ret = this.data.readUInt16LE(this.offset, true);
  this.offset += 2;
  return ret;
};

/**
 * Read uint16be.
 * @returns {Number}
 */

BufferReader.prototype.readU16BE = function readU16BE() {
  this.assert(this.offset + 2 <= this.data.length);
  const ret = this.data.readUInt16BE(this.offset, true);
  this.offset += 2;
  return ret;
};

/**
 * Read uint32le.
 * @returns {Number}
 */

BufferReader.prototype.readU32 = function readU32() {
  this.assert(this.offset + 4 <= this.data.length);
  const ret = this.data.readUInt32LE(this.offset, true);
  this.offset += 4;
  return ret;
};

/**
 * Read uint32be.
 * @returns {Number}
 */

BufferReader.prototype.readU32BE = function readU32BE() {
  this.assert(this.offset + 4 <= this.data.length);
  const ret = this.data.readUInt32BE(this.offset, true);
  this.offset += 4;
  return ret;
};

/**
 * Read uint64le as a js number.
 * @returns {Number}
 * @throws on num > MAX_SAFE_INTEGER
 */

BufferReader.prototype.readU64 = function readU64() {
  this.assert(this.offset + 8 <= this.data.length);
  const ret = encoding.readU64(this.data, this.offset);
  this.offset += 8;
  return ret;
};

/**
 * Read uint64be as a js number.
 * @returns {Number}
 * @throws on num > MAX_SAFE_INTEGER
 */

BufferReader.prototype.readU64BE = function readU64BE() {
  this.assert(this.offset + 8 <= this.data.length);
  const ret = encoding.readU64BE(this.data, this.offset);
  this.offset += 8;
  return ret;
};

/**
 * Read int8.
 * @returns {Number}
 */

BufferReader.prototype.readI8 = function readI8() {
  this.assert(this.offset + 1 <= this.data.length);
  const ret = this.data.readInt8(this.offset, true);
  this.offset += 1;
  return ret;
};

/**
 * Read int16le.
 * @returns {Number}
 */

BufferReader.prototype.readI16 = function readI16() {
  this.assert(this.offset + 2 <= this.data.length);
  const ret = this.data.readInt16LE(this.offset, true);
  this.offset += 2;
  return ret;
};

/**
 * Read int16be.
 * @returns {Number}
 */

BufferReader.prototype.readI16BE = function readI16BE() {
  this.assert(this.offset + 2 <= this.data.length);
  const ret = this.data.readInt16BE(this.offset, true);
  this.offset += 2;
  return ret;
};

/**
 * Read int32le.
 * @returns {Number}
 */

BufferReader.prototype.readI32 = function readI32() {
  this.assert(this.offset + 4 <= this.data.length);
  const ret = this.data.readInt32LE(this.offset, true);
  this.offset += 4;
  return ret;
};

/**
 * Read int32be.
 * @returns {Number}
 */

BufferReader.prototype.readI32BE = function readI32BE() {
  this.assert(this.offset + 4 <= this.data.length);
  const ret = this.data.readInt32BE(this.offset, true);
  this.offset += 4;
  return ret;
};

/**
 * Read int64le as a js number.
 * @returns {Number}
 * @throws on num > MAX_SAFE_INTEGER
 */

BufferReader.prototype.readI64 = function readI64() {
  this.assert(this.offset + 8 <= this.data.length);
  const ret = encoding.readI64(this.data, this.offset);
  this.offset += 8;
  return ret;
};

/**
 * Read int64be as a js number.
 * @returns {Number}
 * @throws on num > MAX_SAFE_INTEGER
 */

BufferReader.prototype.readI64BE = function readI64BE() {
  this.assert(this.offset + 8 <= this.data.length);
  const ret = encoding.readI64BE(this.data, this.offset);
  this.offset += 8;
  return ret;
};

/**
 * Read uint64le.
 * @returns {U64}
 */

BufferReader.prototype.readU64N = function readU64N() {
  this.assert(this.offset + 8 <= this.data.length);
  const ret = encoding.readU64N(this.data, this.offset);
  this.offset += 8;
  return ret;
};

/**
 * Read uint64be.
 * @returns {U64}
 */

BufferReader.prototype.readU64BEN = function readU64BEN() {
  this.assert(this.offset + 8 <= this.data.length);
  const ret = encoding.readU64BEN(this.data, this.offset);
  this.offset += 8;
  return ret;
};

/**
 * Read int64le.
 * @returns {I64}
 */

BufferReader.prototype.readI64N = function readI64N() {
  this.assert(this.offset + 8 <= this.data.length);
  const ret = encoding.readI64N(this.data, this.offset);
  this.offset += 8;
  return ret;
};

/**
 * Read int64be.
 * @returns {I64}
 */

BufferReader.prototype.readI64BEN = function readI64BEN() {
  this.assert(this.offset + 8 <= this.data.length);
  const ret = encoding.readI64BEN(this.data, this.offset);
  this.offset += 8;
  return ret;
};

/**
 * Read float le.
 * @returns {Number}
 */

BufferReader.prototype.readFloat = function readFloat() {
  this.assert(this.offset + 4 <= this.data.length);
  const ret = this.data.readFloatLE(this.offset, true);
  this.offset += 4;
  return ret;
};

/**
 * Read float be.
 * @returns {Number}
 */

BufferReader.prototype.readFloatBE = function readFloatBE() {
  this.assert(this.offset + 4 <= this.data.length);
  const ret = this.data.readFloatBE(this.offset, true);
  this.offset += 4;
  return ret;
};

/**
 * Read double float le.
 * @returns {Number}
 */

BufferReader.prototype.readDouble = function readDouble() {
  this.assert(this.offset + 8 <= this.data.length);
  const ret = this.data.readDoubleLE(this.offset, true);
  this.offset += 8;
  return ret;
};

/**
 * Read double float be.
 * @returns {Number}
 */

BufferReader.prototype.readDoubleBE = function readDoubleBE() {
  this.assert(this.offset + 8 <= this.data.length);
  const ret = this.data.readDoubleBE(this.offset, true);
  this.offset += 8;
  return ret;
};

/**
 * Read a varint.
 * @returns {Number}
 */

BufferReader.prototype.readVarint = function readVarint() {
  const {size, value} = encoding.readVarint(this.data, this.offset);
  this.offset += size;
  return value;
};

/**
 * Read a varint.
 * @returns {U64}
 */

BufferReader.prototype.readVarintN = function readVarintN() {
  const {size, value} = encoding.readVarintN(this.data, this.offset);
  this.offset += size;
  return value;
};

/**
 * Read a varint (type 2).
 * @returns {Number}
 */

BufferReader.prototype.readVarint2 = function readVarint2() {
  const {size, value} = encoding.readVarint2(this.data, this.offset);
  this.offset += size;
  return value;
};

/**
 * Read a varint (type 2).
 * @returns {U64}
 */

BufferReader.prototype.readVarint2N = function readVarint2N() {
  const {size, value} = encoding.readVarint2N(this.data, this.offset);
  this.offset += size;
  return value;
};

/**
 * Read N bytes (will do a fast slice if zero copy).
 * @param {Number} size
 * @param {Bolean?} zeroCopy - Do a fast buffer
 * slice instead of allocating a new buffer (warning:
 * may cause memory leaks if not used with care).
 * @returns {Buffer}
 */

BufferReader.prototype.readBytes = function readBytes(size, zeroCopy) {
  assert(size >= 0);
  this.assert(this.offset + size <= this.data.length);

  let ret;
  if (this.zeroCopy || zeroCopy) {
    ret = this.data.slice(this.offset, this.offset + size);
  } else {
    ret = Buffer.allocUnsafe(size);
    this.data.copy(ret, 0, this.offset, this.offset + size);
  }

  this.offset += size;

  return ret;
};

/**
 * Read a varint number of bytes (will do a fast slice if zero copy).
 * @param {Bolean?} zeroCopy - Do a fast buffer
 * slice instead of allocating a new buffer (warning:
 * may cause memory leaks if not used with care).
 * @returns {Buffer}
 */

BufferReader.prototype.readVarBytes = function readVarBytes(zeroCopy) {
  return this.readBytes(this.readVarint(), zeroCopy);
};

/**
 * Read a string.
 * @param {String} enc - Any buffer-supported encoding.
 * @param {Number} size
 * @returns {String}
 */

BufferReader.prototype.readString = function readString(enc, size) {
  assert(size >= 0);
  this.assert(this.offset + size <= this.data.length);
  const ret = this.data.toString(enc, this.offset, this.offset + size);
  this.offset += size;
  return ret;
};

/**
 * Read a 32-byte hash.
 * @param {String} enc - `"hex"` or `null`.
 * @returns {Hash|Buffer}
 */

BufferReader.prototype.readHash = function readHash(enc) {
  if (enc)
    return this.readString(enc, 32);
  return this.readBytes(32);
};

/**
 * Read string of a varint length.
 * @param {String} enc - Any buffer-supported encoding.
 * @param {Number?} limit - Size limit.
 * @returns {String}
 */

BufferReader.prototype.readVarString = function readVarString(enc, limit) {
  const size = this.readVarint();
  this.enforce(!limit || size <= limit, 'String exceeds limit.');
  return this.readString(enc, size);
};

/**
 * Read a null-terminated string.
 * @param {String} enc - Any buffer-supported encoding.
 * @returns {String}
 */

BufferReader.prototype.readNullString = function readNullString(enc) {
  this.assert(this.offset + 1 <= this.data.length);

  let i = this.offset;
  for (; i < this.data.length; i++) {
    if (this.data[i] === 0)
      break;
  }

  this.assert(i !== this.data.length);

  const ret = this.readString(enc, i - this.offset);

  this.offset = i + 1;

  return ret;
};

/**
 * Create a checksum from the last start position.
 * @returns {Number} Checksum.
 */

BufferReader.prototype.createChecksum = function createChecksum() {
  let start = 0;

  if (this.stack.length > 0)
    start = this.stack[this.stack.length - 1];

  const data = this.data.slice(start, this.offset);

  return digest.hash256(data).readUInt32LE(0, true);
};

/**
 * Verify a 4-byte checksum against a calculated checksum.
 * @returns {Number} checksum
 * @throws on bad checksum
 */

BufferReader.prototype.verifyChecksum = function verifyChecksum() {
  const chk = this.createChecksum();
  const checksum = this.readU32();
  this.enforce(chk === checksum, 'Checksum mismatch.');
  return checksum;
};

/*
 * Expose
 */

module.exports = BufferReader;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * encoding.js - encoding utils for wmcc_core.
 */



/**
 * @module utils/encoding
 */

const {U64, I64} = __webpack_require__(49);
const UINT128_MAX = U64.UINT64_MAX.shrn(7);
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
const encoding = exports;

/**
 * An empty buffer.
 * @const {Buffer}
 * @default
 */

encoding.DUMMY = Buffer.from([0]);

/**
 * A hash of all zeroes with a `1` at the
 * end (used for the SIGHASH_SINGLE bug).
 * @const {Buffer}
 * @default
 */

encoding.ONE_HASH = Buffer.from(
  '0100000000000000000000000000000000000000000000000000000000000000',
  'hex'
);

/**
 * A hash of all zeroes.
 * @const {Buffer}
 * @default
 */

encoding.ZERO_HASH = Buffer.from(
  '0000000000000000000000000000000000000000000000000000000000000000',
  'hex'
);

/**
 * A hash of all 0xff.
 * @const {Buffer}
 * @default
 */

encoding.MAX_HASH = Buffer.from(
  'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',
  'hex'
);

/**
 * A hash of all zeroes.
 * @const {String}
 * @default
 */

encoding.NULL_HASH =
  '0000000000000000000000000000000000000000000000000000000000000000';

/**
 * A hash of all 0xff.
 * @const {String}
 * @default
 */

encoding.HIGH_HASH =
  'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';

/**
 * A hash of all zeroes.
 * @const {Buffer}
 * @default
 */

encoding.ZERO_HASH160 = Buffer.from(
  '0000000000000000000000000000000000000000',
  'hex'
);

/**
 * A hash of all 0xff.
 * @const {String}
 * @default
 */

encoding.MAX_HASH160 = Buffer.from(
  'ffffffffffffffffffffffffffffffffffffffff',
  'hex'
);

/**
 * A hash of all zeroes.
 * @const {String}
 * @default
 */

encoding.NULL_HASH160 = '0000000000000000000000000000000000000000';

/**
 * A hash of all 0xff.
 * @const {String}
 * @default
 */

encoding.HIGH_HASH160 = 'ffffffffffffffffffffffffffffffffffffffff';

/**
 * A compressed pubkey of all zeroes.
 * @const {Buffer}
 * @default
 */

encoding.ZERO_KEY = Buffer.from(
  '000000000000000000000000000000000000000000000000000000000000000000',
  'hex'
);

/**
 * A 73 byte signature of all zeroes.
 * @const {Buffer}
 * @default
 */

encoding.ZERO_SIG = Buffer.from(''
  + '0000000000000000000000000000000000000000000000000000000000000000'
  + '0000000000000000000000000000000000000000000000000000000000000000'
  + '000000000000000000',
  'hex'
);

/**
 * A 64 byte signature of all zeroes.
 * @const {Buffer}
 * @default
 */

encoding.ZERO_SIG64 = Buffer.from(''
  + '0000000000000000000000000000000000000000000000000000000000000000'
  + '0000000000000000000000000000000000000000000000000000000000000000',
  'hex'
);

/**
 * 4 zero bytes.
 * @const {Buffer}
 * @default
 */

encoding.ZERO_U32 = Buffer.from('00000000', 'hex');

/**
 * Minimum uint32
 * @const {Number}
 * @default
 */

encoding.MIN_U32 = 0x00000000;

/**
 * Maximum uint32
 * @const {Number}
 * @default
 */

encoding.MAX_U32 = 0xffffffff;

/**
 * 8 zero bytes.
 * @const {Buffer}
 * @default
 */

encoding.ZERO_U64 = Buffer.from('0000000000000000', 'hex');

/**
 * Minimum uint32
 * @const {Number}
 * @default
 */

encoding.MIN_U64 = 0x0000000000000000;

/**
 * Maximum uint32
 * @const {Number}
 * @default
 */

encoding.MAX_U64 = 0xffffffffffffffff;

/**
 * Read uint64le as a js number.
 * @param {Buffer} data
 * @param {Number} off
 * @returns {Number}
 * @throws on num > MAX_SAFE_INTEGER
 */

encoding.readU64 = function readU64(data, off) {
  const hi = data.readUInt32LE(off + 4, true);
  const lo = data.readUInt32LE(off, true);
  enforce((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');
  return hi * 0x100000000 + lo;
};

/**
 * Read uint64be as a js number.
 * @param {Buffer} data
 * @param {Number} off
 * @returns {Number}
 * @throws on num > MAX_SAFE_INTEGER
 */

encoding.readU64BE = function readU64BE(data, off) {
  const hi = data.readUInt32BE(off, true);
  const lo = data.readUInt32BE(off + 4, true);
  enforce((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');
  return hi * 0x100000000 + lo;
};

/**
 * Read int64be as a js number.
 * @param {Buffer} data
 * @param {Number} off
 * @returns {Number}
 * @throws on num > MAX_SAFE_INTEGER
 */

encoding.readI64 = function readI64(data, off) {
  const hi = data.readInt32LE(off + 4, true);
  const lo = data.readUInt32LE(off, true);
  enforce(isSafe(hi, lo), 'Number exceeds 2^53-1');
  return hi * 0x100000000 + lo;
};

/**
 * Read int64be as a js number.
 * @param {Buffer} data
 * @param {Number} off
 * @returns {Number}
 * @throws on num > MAX_SAFE_INTEGER
 */

encoding.readI64BE = function readI64BE(data, off) {
  const hi = data.readInt32BE(off, true);
  const lo = data.readUInt32BE(off + 4, true);
  enforce(isSafe(hi, lo), 'Number exceeds 2^53-1');
  return hi * 0x100000000 + lo;
};

/**
 * Write a javascript number as a uint64le.
 * @param {Buffer} dst
 * @param {Number} num
 * @param {Number} off
 * @returns {Number} Buffer offset.
 * @throws on num > MAX_SAFE_INTEGER
 */

encoding.writeU64 = function writeU64(dst, num, off) {
  return write64(dst, num, off, false);
};

/**
 * Write a javascript number as a uint64be.
 * @param {Buffer} dst
 * @param {Number} num
 * @param {Number} off
 * @returns {Number} Buffer offset.
 * @throws on num > MAX_SAFE_INTEGER
 */

encoding.writeU64BE = function writeU64BE(dst, num, off) {
  return write64(dst, num, off, true);
};

/**
 * Write a javascript number as an int64le.
 * @param {Buffer} dst
 * @param {Number} num
 * @param {Number} off
 * @returns {Number} Buffer offset.
 * @throws on num > MAX_SAFE_INTEGER
 */

encoding.writeI64 = function writeI64(dst, num, off) {
  return write64(dst, num, off, false);
};

/**
 * Write a javascript number as an int64be.
 * @param {Buffer} dst
 * @param {Number} num
 * @param {Number} off
 * @returns {Number} Buffer offset.
 * @throws on num > MAX_SAFE_INTEGER
 */

encoding.writeI64BE = function writeI64BE(dst, num, off) {
  return write64(dst, num, off, true);
};

/**
 * Read uint64le.
 * @param {Buffer} data
 * @param {Number} off
 * @returns {U64}
 */

encoding.readU64N = function readU64N(data, off) {
  return U64.readLE(data, off);
};

/**
 * Read uint64be.
 * @param {Buffer} data
 * @param {Number} off
 * @returns {U64}
 */

encoding.readU64BEN = function readU64BEN(data, off) {
  return U64.readBE(data, off);
};

/**
 * Read int64le.
 * @param {Buffer} data
 * @param {Number} off
 * @returns {I64}
 */

encoding.readI64N = function readI64N(data, off) {
  return I64.readLE(data, off);
};
/**
 * Read int64be.
 * @param {Buffer} data
 * @param {Number} off
 * @returns {I64}
 */

encoding.readI64BEN = function readI64BEN(data, off) {
  return I64.readBE(data, off);
};

/**
 * Write uint64le.
 * @param {Buffer} dst
 * @param {U64} num
 * @param {Number} off
 * @returns {Number} Buffer offset.
 */

encoding.writeU64N = function writeU64N(dst, num, off) {
  enforce(!num.sign, off, 'Signed');
  return num.writeLE(dst, off);
};

/**
 * Write uint64be.
 * @param {Buffer} dst
 * @param {U64} num
 * @param {Number} off
 * @returns {Number} Buffer offset.
 */

encoding.writeU64BEN = function writeU64BEN(dst, num, off) {
  enforce(!num.sign, off, 'Signed');
  return num.writeBE(dst, off);
};

/**
 * Write int64le.
 * @param {Buffer} dst
 * @param {U64} num
 * @param {Number} off
 * @returns {Number} Buffer offset.
 */

encoding.writeI64N = function writeI64N(dst, num, off) {
  enforce(num.sign, off, 'Not signed');
  return num.writeLE(dst, off);
};

/**
 * Write int64be.
 * @param {Buffer} dst
 * @param {I64} num
 * @param {Number} off
 * @returns {Number} Buffer offset.
 */

encoding.writeI64BEN = function writeI64BEN(dst, num, off) {
  enforce(num.sign, off, 'Not signed');
  return num.writeBE(dst, off);
};

/**
 * Read a varint.
 * @param {Buffer} data
 * @param {Number} off
 * @returns {Object}
 */

encoding.readVarint = function readVarint(data, off) {
  let value, size;

  assert(off < data.length, off);

  switch (data[off]) {
    case 0xff:
      size = 9;
      assert(off + size <= data.length, off);
      value = encoding.readU64(data, off + 1);
      enforce(value > 0xffffffff, off, 'Non-canonical varint');
      break;
    case 0xfe:
      size = 5;
      assert(off + size <= data.length, off);
      value = data.readUInt32LE(off + 1, true);
      enforce(value > 0xffff, off, 'Non-canonical varint');
      break;
    case 0xfd:
      size = 3;
      assert(off + size <= data.length, off);
      value = data[off + 1] | (data[off + 2] << 8);
      enforce(value >= 0xfd, off, 'Non-canonical varint');
      break;
    default:
      size = 1;
      value = data[off];
      break;
  }

  return new Varint(size, value);
};

/**
 * Write a varint.
 * @param {Buffer} dst
 * @param {Number} num
 * @param {Number} off
 * @returns {Number} Buffer offset.
 */

encoding.writeVarint = function writeVarint(dst, num, off) {
  if (num < 0xfd) {
    dst[off++] = num & 0xff;
    return off;
  }

  if (num <= 0xffff) {
    dst[off++] = 0xfd;
    dst[off++] = num & 0xff;
    dst[off++] = (num >> 8) & 0xff;
    return off;
  }

  if (num <= 0xffffffff) {
    dst[off++] = 0xfe;
    dst[off++] = num & 0xff;
    dst[off++] = (num >> 8) & 0xff;
    dst[off++] = (num >> 16) & 0xff;
    dst[off++] = num >>> 24;
    return off;
  }

  dst[off++] = 0xff;
  off = encoding.writeU64(dst, num, off);
  return off;
};

/**
 * Calculate size of varint.
 * @param {Number} num
 * @returns {Number} size
 */

encoding.sizeVarint = function sizeVarint(num) {
  if (num < 0xfd)
    return 1;

  if (num <= 0xffff)
    return 3;

  if (num <= 0xffffffff)
    return 5;

  return 9;
};

/**
 * Read a varint.
 * @param {Buffer} data
 * @param {Number} off
 * @returns {Object}
 */

encoding.readVarintN = function readVarintN(data, off) {
  assert(off < data.length, off);

  if (data[off] === 0xff) {
    const size = 9;
    assert(off + size <= data.length, off);
    const value = encoding.readU64N(data, off + 1);
    enforce(value.hi !== 0, off, 'Non-canonical varint');
    return new Varint(size, value);
  }

  const {size, value} = encoding.readVarint(data, off);

  return new Varint(size, U64.fromInt(value));
};

/**
 * Write a varint.
 * @param {Buffer} dst
 * @param {U64} num
 * @param {Number} off
 * @returns {Number} Buffer offset.
 */

encoding.writeVarintN = function writeVarintN(dst, num, off) {
  enforce(!num.sign, off, 'Signed');

  if (num.hi !== 0) {
    dst[off++] = 0xff;
    return encoding.writeU64N(dst, num, off);
  }

  return encoding.writeVarint(dst, num.toInt(), off);
};

/**
 * Calculate size of varint.
 * @param {U64} num
 * @returns {Number} size
 */

encoding.sizeVarintN = function sizeVarintN(num) {
  enforce(!num.sign, 0, 'Signed');

  if (num.hi !== 0)
    return 9;

  return encoding.sizeVarint(num.toInt());
};

/**
 * Read a varint (type 2).
 * @param {Buffer} data
 * @param {Number} off
 * @returns {Object}
 */

encoding.readVarint2 = function readVarint2(data, off) {
  let num = 0;
  let size = 0;

  for (;;) {
    assert(off < data.length, off);

    const ch = data[off++];
    size++;

    // Number.MAX_SAFE_INTEGER >>> 7
    enforce(num <= 0x3fffffffffff - (ch & 0x7f), off, 'Number exceeds 2^53-1');

    // num = (num << 7) | (ch & 0x7f);
    num = (num * 0x80) + (ch & 0x7f);

    if ((ch & 0x80) === 0)
      break;

    enforce(num !== MAX_SAFE_INTEGER, off, 'Number exceeds 2^53-1');
    num++;
  }

  return new Varint(size, num);
};

/**
 * Write a varint (type 2).
 * @param {Buffer} dst
 * @param {Number} num
 * @param {Number} off
 * @returns {Number} Buffer offset.
 */

encoding.writeVarint2 = function writeVarint2(dst, num, off) {
  const tmp = [];

  let len = 0;

  for (;;) {
    tmp[len] = (num & 0x7f) | (len ? 0x80 : 0x00);
    if (num <= 0x7f)
      break;
    // num = (num >>> 7) - 1;
    num = ((num - (num % 0x80)) / 0x80) - 1;
    len++;
  }

  assert(off + len + 1 <= dst.length, off);

  do {
    dst[off++] = tmp[len];
  } while (len--);

  return off;
};

/**
 * Calculate size of varint (type 2).
 * @param {Number} num
 * @returns {Number} size
 */

encoding.sizeVarint2 = function sizeVarint2(num) {
  let size = 0;

  for (;;) {
    size++;
    if (num <= 0x7f)
      break;
    // num = (num >>> 7) - 1;
    num = ((num - (num % 0x80)) / 0x80) - 1;
  }

  return size;
};

/**
 * Read a varint (type 2).
 * @param {Buffer} data
 * @param {Number} off
 * @returns {Object}
 */

encoding.readVarint2N = function readVarint2N(data, off) {
  const num = new U64();

  let size = 0;

  for (;;) {
    assert(off < data.length, off);

    const ch = data[off++];
    size++;

    enforce(num.lte(UINT128_MAX), off, 'Number exceeds 2^64-1');

    num.ishln(7).iorn(ch & 0x7f);

    if ((ch & 0x80) === 0)
      break;

    enforce(!num.eq(U64.UINT64_MAX), off, 'Number exceeds 2^64-1');
    num.iaddn(1);
  }

  return new Varint(size, num);
};

/**
 * Write a varint (type 2).
 * @param {Buffer} dst
 * @param {U64} num
 * @param {Number} off
 * @returns {Number} Buffer offset.
 */

encoding.writeVarint2N = function writeVarint2N(dst, num, off) {
  enforce(!num.sign, off, 'Signed');

  if (num.hi === 0)
    return encoding.writeVarint2(dst, num.toInt(), off);

  num = num.clone();

  const tmp = [];

  let len = 0;

  for (;;) {
    tmp[len] = num.andln(0x7f) | (len ? 0x80 : 0x00);
    if (num.lten(0x7f))
      break;
    num.ishrn(7).isubn(1);
    len++;
  }

  enforce(off + len + 1 <= dst.length, off, 'Out of bounds write');

  do {
    dst[off++] = tmp[len];
  } while (len--);

  return off;
};

/**
 * Calculate size of varint (type 2).
 * @param {U64} num
 * @returns {Number} size
 */

encoding.sizeVarint2N = function sizeVarint2N(num) {
  enforce(!num.sign, 0, 'Signed');

  if (num.hi === 0)
    return encoding.sizeVarint2(num.toInt());

  num = num.clone();

  let size = 0;

  for (;;) {
    size++;
    if (num.lten(0x7f))
      break;
    num.ishrn(7).isubn(1);
  }

  return size;
};

/**
 * Serialize number as a u8.
 * @param {Number} num
 * @returns {Buffer}
 */

encoding.U8 = function U8(num) {
  const data = Buffer.allocUnsafe(1);
  data[0] = num >>> 0;
  return data;
};

/**
 * Serialize number as a u16.
 * @param {Number} num
 * @returns {Buffer}
 */

encoding.U16 = function U16(num) {
  const data = Buffer.allocUnsafe(2);
  data.writeUInt16LE(num, 0, true);
  return data;
};

/**
 * Serialize number as a u32le.
 * @param {Number} num
 * @returns {Buffer}
 */

encoding.U32 = function U32(num) {
  const data = Buffer.allocUnsafe(4);
  data.writeUInt32LE(num, 0, true);
  return data;
};

/**
 * Serialize number as a u32be.
 * @param {Number} num
 * @returns {Buffer}
 */

encoding.U32BE = function U32BE(num) {
  const data = Buffer.allocUnsafe(4);
  data.writeUInt32BE(num, 0, true);
  return data;
};

/**
 * Get size of varint-prefixed bytes.
 * @param {Buffer} data
 * @returns {Number}
 */

encoding.sizeVarBytes = function sizeVarBytes(data) {
  return encoding.sizeVarint(data.length) + data.length;
};

/**
 * Get size of varint-prefixed length.
 * @param {Number} len
 * @returns {Number}
 */

encoding.sizeVarlen = function sizeVarlen(len) {
  return encoding.sizeVarint(len) + len;
};

/**
 * Get size of varint-prefixed string.
 * @param {String} str
 * @returns {Number}
 */

encoding.sizeVarString = function sizeVarString(str, enc) {
  if (typeof str !== 'string')
    return encoding.sizeVarBytes(str);

  const len = Buffer.byteLength(str, enc);

  return encoding.sizeVarint(len) + len;
};

/**
 * EncodingError
 * @constructor
 * @param {Number} offset
 * @param {String} reason
 */

encoding.EncodingError = function EncodingError(offset, reason, start) {
  if (!(this instanceof EncodingError))
    return new EncodingError(offset, reason, start);

  Error.call(this);

  this.type = 'EncodingError';
  this.message = `${reason} (offset=${offset}).`;

  if (Error.captureStackTrace)
    Error.captureStackTrace(this, start || EncodingError);
};

Object.setPrototypeOf(encoding.EncodingError.prototype, Error.prototype);

/*
 * Helpers
 */

function isSafe(hi, lo) {
  if (hi < 0) {
    hi = ~hi;
    if (lo === 0)
      hi += 1;
  }

  return (hi & 0xffe00000) === 0;
}

function write64(dst, num, off, be) {
  let neg = false;

  if (num < 0) {
    num = -num;
    neg = true;
  }

  let hi = (num * (1 / 0x100000000)) | 0;
  let lo = num | 0;

  if (neg) {
    if (lo === 0) {
      hi = (~hi + 1) | 0;
    } else {
      hi = ~hi;
      lo = ~lo + 1;
    }
  }

  if (be) {
    off = dst.writeInt32BE(hi, off, true);
    off = dst.writeInt32BE(lo, off, true);
  } else {
    off = dst.writeInt32LE(lo, off, true);
    off = dst.writeInt32LE(hi, off, true);
  }

  return off;
}

function Varint(size, value) {
  this.size = size;
  this.value = value;
}

function assert(value, offset) {
  if (!value)
    throw new encoding.EncodingError(offset, 'Out of bounds read', assert);
}

function enforce(value, offset, reason) {
  if (!value)
    throw new encoding.EncodingError(offset, reason, enforce);
}


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * staticwriter.js - buffer writer for wmcc_core.
 */



const assert = __webpack_require__(0);
const encoding = __webpack_require__(3);
const digest = __webpack_require__(5);

const EMPTY = Buffer.alloc(0);
const POOLSIZE = 100 << 10;

let POOL = null;

/**
 * Statically allocated buffer writer.
 * @alias module:utils.StaticWriter
 * @constructor
 * @param {Number} size
 */

function StaticWriter(size) {
  if (!(this instanceof StaticWriter))
    return new StaticWriter(size);

  this.data = size ? Buffer.allocUnsafe(size) : EMPTY;
  this.offset = 0;
}

/**
 * Allocate writer from preallocated 100kb pool.
 * @param {Number} size
 * @returns {StaticWriter}
 */

StaticWriter.pool = function pool(size) {
  if (size <= POOLSIZE) {
    if (!POOL)
      POOL = Buffer.allocUnsafeSlow(POOLSIZE);

    const bw = new StaticWriter(0);
    bw.data = POOL.slice(0, size);
    return bw;
  }

  return new StaticWriter(size);
};

/**
 * Allocate and render the final buffer.
 * @returns {Buffer} Rendered buffer.
 */

StaticWriter.prototype.render = function render() {
  const data = this.data;
  assert(this.offset === data.length);
  this.destroy();
  return data;
};

/**
 * Get size of data written so far.
 * @returns {Number}
 */

StaticWriter.prototype.getSize = function getSize() {
  return this.offset;
};

/**
 * Seek to relative offset.
 * @param {Number} offset
 */

StaticWriter.prototype.seek = function seek(offset) {
  this.offset += offset;
};

/**
 * Destroy the buffer writer.
 */

StaticWriter.prototype.destroy = function destroy() {
  this.data = EMPTY;
  this.offset = 0;
};

/**
 * Write uint8.
 * @param {Number} value
 */

StaticWriter.prototype.writeU8 = function writeU8(value) {
  this.offset = this.data.writeUInt8(value, this.offset, true);
};

/**
 * Write uint16le.
 * @param {Number} value
 */

StaticWriter.prototype.writeU16 = function writeU16(value) {
  this.offset = this.data.writeUInt16LE(value, this.offset, true);
};

/**
 * Write uint16be.
 * @param {Number} value
 */

StaticWriter.prototype.writeU16BE = function writeU16BE(value) {
  this.offset = this.data.writeUInt16BE(value, this.offset, true);
};

/**
 * Write uint32le.
 * @param {Number} value
 */

StaticWriter.prototype.writeU32 = function writeU32(value) {
  this.offset = this.data.writeUInt32LE(value, this.offset, true);
};

/**
 * Write uint32be.
 * @param {Number} value
 */

StaticWriter.prototype.writeU32BE = function writeU32BE(value) {
  this.offset = this.data.writeUInt32BE(value, this.offset, true);
};

/**
 * Write uint64le.
 * @param {Number} value
 */

StaticWriter.prototype.writeU64 = function writeU64(value) {
  this.offset = encoding.writeU64(this.data, value, this.offset);
};

/**
 * Write uint64be.
 * @param {Number} value
 */

StaticWriter.prototype.writeU64BE = function writeU64BE(value) {
  this.offset = encoding.writeU64BE(this.data, value, this.offset);
};

/**
 * Write uint64le.
 * @param {U64} value
 */

StaticWriter.prototype.writeU64N = function writeU64N(value) {
  this.offset = encoding.writeU64N(this.data, value, this.offset);
};

/**
 * Write uint64be.
 * @param {U64} value
 */

StaticWriter.prototype.writeU64BEN = function writeU64BEN(value) {
  this.offset = encoding.writeU64BEN(this.data, value, this.offset);
};

/**
 * Write int8.
 * @param {Number} value
 */

StaticWriter.prototype.writeI8 = function writeI8(value) {
  this.offset = this.data.writeInt8(value, this.offset, true);
};

/**
 * Write int16le.
 * @param {Number} value
 */

StaticWriter.prototype.writeI16 = function writeI16(value) {
  this.offset = this.data.writeInt16LE(value, this.offset, true);
};

/**
 * Write int16be.
 * @param {Number} value
 */

StaticWriter.prototype.writeI16BE = function writeI16BE(value) {
  this.offset = this.data.writeInt16BE(value, this.offset, true);
};

/**
 * Write int32le.
 * @param {Number} value
 */

StaticWriter.prototype.writeI32 = function writeI32(value) {
  this.offset = this.data.writeInt32LE(value, this.offset, true);
};

/**
 * Write int32be.
 * @param {Number} value
 */

StaticWriter.prototype.writeI32BE = function writeI32BE(value) {
  this.offset = this.data.writeInt32BE(value, this.offset, true);
};

/**
 * Write int64le.
 * @param {Number} value
 */

StaticWriter.prototype.writeI64 = function writeI64(value) {
  this.offset = encoding.writeI64(this.data, value, this.offset);
};

/**
 * Write int64be.
 * @param {Number} value
 */

StaticWriter.prototype.writeI64BE = function writeI64BE(value) {
  this.offset = encoding.writeI64BE(this.data, value, this.offset);
};

/**
 * Write int64le.
 * @param {I64} value
 */

StaticWriter.prototype.writeI64N = function writeI64N(value) {
  this.offset = encoding.writeI64N(this.data, value, this.offset);
};

/**
 * Write int64be.
 * @param {I64} value
 */

StaticWriter.prototype.writeI64BEN = function writeI64BEN(value) {
  this.offset = encoding.writeI64BEN(this.data, value, this.offset);
};

/**
 * Write float le.
 * @param {Number} value
 */

StaticWriter.prototype.writeFloat = function writeFloat(value) {
  this.offset = this.data.writeFloatLE(value, this.offset, true);
};

/**
 * Write float be.
 * @param {Number} value
 */

StaticWriter.prototype.writeFloatBE = function writeFloatBE(value) {
  this.offset = this.data.writeFloatBE(value, this.offset, true);
};

/**
 * Write double le.
 * @param {Number} value
 */

StaticWriter.prototype.writeDouble = function writeDouble(value) {
  this.offset = this.data.writeDoubleLE(value, this.offset, true);
};

/**
 * Write double be.
 * @param {Number} value
 */

StaticWriter.prototype.writeDoubleBE = function writeDoubleBE(value) {
  this.offset = this.data.writeDoubleBE(value, this.offset, true);
};

/**
 * Write a varint.
 * @param {Number} value
 */

StaticWriter.prototype.writeVarint = function writeVarint(value) {
  this.offset = encoding.writeVarint(this.data, value, this.offset);
};

/**
 * Write a varint.
 * @param {U64} value
 */

StaticWriter.prototype.writeVarintN = function writeVarintN(value) {
  this.offset = encoding.writeVarintN(this.data, value, this.offset);
};

/**
 * Write a varint (type 2).
 * @param {Number} value
 */

StaticWriter.prototype.writeVarint2 = function writeVarint2(value) {
  this.offset = encoding.writeVarint2(this.data, value, this.offset);
};

/**
 * Write a varint (type 2).
 * @param {U64} value
 */

StaticWriter.prototype.writeVarint2N = function writeVarint2N(value) {
  this.offset = encoding.writeVarint2N(this.data, value, this.offset);
};

/**
 * Write bytes.
 * @param {Buffer} value
 */

StaticWriter.prototype.writeBytes = function writeBytes(value) {
  if (value.length === 0)
    return;

  value.copy(this.data, this.offset);

  this.offset += value.length;
};

/**
 * Write bytes with a varint length before them.
 * @param {Buffer} value
 */

StaticWriter.prototype.writeVarBytes = function writeVarBytes(value) {
  this.writeVarint(value.length);
  this.writeBytes(value);
};

/**
 * Copy bytes.
 * @param {Buffer} value
 * @param {Number} start
 * @param {Number} end
 */

StaticWriter.prototype.copy = function copy(value, start, end) {
  const len = end - start;

  if (len === 0)
    return;

  value.copy(this.data, this.offset, start, end);
  this.offset += len;
};

/**
 * Write string to buffer.
 * @param {String} value
 * @param {String?} enc - Any buffer-supported encoding.
 */

StaticWriter.prototype.writeString = function writeString(value, enc) {
  if (value.length === 0)
    return;

  const size = Buffer.byteLength(value, enc);

  this.data.write(value, this.offset, enc);

  this.offset += size;
};

/**
 * Write a 32 byte hash.
 * @param {Hash} value
 */

StaticWriter.prototype.writeHash = function writeHash(value) {
  if (typeof value !== 'string') {
    assert(value.length === 32);
    this.writeBytes(value);
    return;
  }
  assert(value.length === 64);
  this.data.write(value, this.offset, 'hex');
  this.offset += 32;
};

/**
 * Write a string with a varint length before it.
 * @param {String}
 * @param {String?} enc - Any buffer-supported encoding.
 */

StaticWriter.prototype.writeVarString = function writeVarString(value, enc) {
  if (value.length === 0) {
    this.writeVarint(0);
    return;
  }

  const size = Buffer.byteLength(value, enc);

  this.writeVarint(size);
  this.data.write(value, this.offset, enc);

  this.offset += size;
};

/**
 * Write a null-terminated string.
 * @param {String|Buffer}
 * @param {String?} enc - Any buffer-supported encoding.
 */

StaticWriter.prototype.writeNullString = function writeNullString(value, enc) {
  this.writeString(value, enc);
  this.writeU8(0);
};

/**
 * Calculate and write a checksum for the data written so far.
 */

StaticWriter.prototype.writeChecksum = function writeChecksum() {
  const data = this.data.slice(0, this.offset);
  const hash = digest.hash256(data);
  hash.copy(this.data, this.offset, 0, 4);
  this.offset += 4;
};

/**
 * Fill N bytes with value.
 * @param {Number} value
 * @param {Number} size
 */

StaticWriter.prototype.fill = function fill(value, size) {
  assert(size >= 0);

  if (size === 0)
    return;

  this.data.fill(value, this.offset, this.offset + size);
  this.offset += size;
};

/*
 * Expose
 */

module.exports = StaticWriter;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * digest.js - hash functions for wmcc_core.
 */



/**
 * @module crypto.digest
 */

const assert = __webpack_require__(0);
const crypto = __webpack_require__(24);
const native = __webpack_require__(18).binding;
const POOL64 = Buffer.allocUnsafe(64);

/**
 * Hash with chosen algorithm.
 * @param {String} alg
 * @param {Buffer} data
 * @returns {Buffer}
 */

exports.hash = function hash(alg, data) {
  return crypto.createHash(alg).update(data).digest();
};

/**
 * Hash with ripemd160.
 * @param {Buffer} data
 * @returns {Buffer}
 */

exports.ripemd160 = function ripemd160(data) {
  return exports.hash('ripemd160', data);
};

/**
 * Hash with sha1.
 * @param {Buffer} data
 * @returns {Buffer}
 */

exports.sha1 = function sha1(data) {
  return exports.hash('sha1', data);
};

/**
 * Hash with sha256.
 * @param {Buffer} data
 * @returns {Buffer}
 */

exports.sha256 = function sha256(data) {
  return exports.hash('sha256', data);
};

/**
 * Hash with sha256 and ripemd160 (OP_HASH160).
 * @param {Buffer} data
 * @returns {Buffer}
 */

exports.hash160 = function hash160(data) {
  return exports.ripemd160(exports.sha256(data));
};

/**
 * Hash with sha256 twice (OP_HASH256).
 * @param {Buffer} data
 * @returns {Buffer}
 */

exports.hash256 = function hash256(data) {
  return exports.sha256(exports.sha256(data));
};

/**
 * Hash left and right hashes with hash256.
 * @param {Buffer} left
 * @param {Buffer} right
 * @returns {Buffer}
 */

exports.root256 = function root256(left, right) {
  const data = POOL64;

  assert(left.length === 32);
  assert(right.length === 32);

  left.copy(data, 0);
  right.copy(data, 32);

  return exports.hash256(data);
};

/**
 * Create an HMAC.
 * @param {String} alg
 * @param {Buffer} data
 * @param {Buffer} key
 * @returns {Buffer} HMAC
 */

exports.hmac = function hmac(alg, data, key) {
  const ctx = crypto.createHmac(alg, key);
  return ctx.update(data).digest();
};

if (native) {
  exports.hash = native.hash;
  exports.hmac = native.hmac;
  exports.ripemd160 = native.ripemd160;
  exports.sha1 = native.sha1;
  exports.sha256 = native.sha256;
  exports.hash160 = native.hash160;
  exports.hash256 = native.hash256;
  exports.root256 = native.root256;
}


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * network.js - network object for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const networks = __webpack_require__(79);
const consensus = __webpack_require__(7);
const TimeData = __webpack_require__(80);

/**
 * Represents a network.
 * @alias module:protocol.Network
 * @constructor
 * @param {Object|NetworkType} options - See {@link module:network}.
 */

function Network(options) {
  if (!(this instanceof Network))
    return new Network(options);

  assert(!Network[options.type], 'Cannot create two networks.');

  this.type = options.type;
  this.seeds = options.seeds;
  this.magic = options.magic;
  this.port = options.port;
  this.checkpointMap = options.checkpointMap;
  this.lastCheckpoint = options.lastCheckpoint;
  this.checkpoints = [];
  this.halvingInterval = options.halvingInterval;
  this.genesis = options.genesis;
  this.genesisBlock = options.genesisBlock;
  this.pow = options.pow;
  this.block = options.block;
  this.bip30 = options.bip30;
  this.activationThreshold = options.activationThreshold;
  this.minerWindow = options.minerWindow;
  this.deployments = options.deployments;
  this.deploys = options.deploys;
  this.unknownBits = ~consensus.VERSION_TOP_MASK;
  this.keyPrefix = options.keyPrefix;
  this.addressPrefix = options.addressPrefix;
  this.requireStandard = options.requireStandard;
  this.rpcPort = options.rpcPort;
  this.minRelay = options.minRelay;
  this.feeRate = options.feeRate;
  this.maxFeeRate = options.maxFeeRate;
  this.selfConnect = options.selfConnect;
  this.requestMempool = options.requestMempool;
  this.time = new TimeData();

  this._init();
}

/**
 * Default network.
 * @type {Network}
 */

Network.primary = null;

/**
 * Default network type.
 * @type {String}
 */

Network.type = null;

/*
 * Networks (to avoid hash table mode).
 */

Network.mainnet = null;
Network.testnet = null;
Network.regtest = null;
//Network.segnet4 = null;
Network.simnet = null;

/**
 * Get a deployment by bit index.
 * @param {Number} bit
 * @returns {Object}
 */

Network.prototype._init = function _init() {
  let bits = 0;

  for (const deployment of this.deploys)
    bits |= 1 << deployment.bit;

  bits |= consensus.VERSION_TOP_MASK;

  this.unknownBits = ~bits;

  for (const key of Object.keys(this.checkpointMap)) {
    const hash = this.checkpointMap[key];
    const height = Number(key);

    this.checkpoints.push({ hash: hash, height: height });
  }

  this.checkpoints.sort(cmpNode);
};

/**
 * Get a deployment by bit index.
 * @param {Number} bit
 * @returns {Object}
 */

Network.prototype.byBit = function byBit(bit) {
  const index = util.binarySearch(this.deploys, bit, cmpBit);

  if (index === -1)
    return null;

  return this.deploys[index];
};

/**
 * Get network adjusted time.
 * @returns {Number}
 */

Network.prototype.now = function now() {
  return this.time.now();
};

/**
 * Get network ntp time.
 * @returns {Number}
 */

Network.prototype.current = function current() {
  return this.time.current();
};


/**
 * Get network adjusted time in milliseconds.
 * @returns {Number}
 */

Network.prototype.ms = function ms() {
  return this.time.ms();
};

/**
 * Create a network. Get existing network if possible.
 * @param {NetworkType|Object} options
 * @returns {Network}
 */

Network.create = function create(options) {
  if (typeof options === 'string')
    options = networks[options];

  assert(options, 'Unknown network.');

  if (Network[options.type])
    return Network[options.type];

  const network = new Network(options);

  Network[network.type] = network;

  if (!Network.primary)
    Network.primary = network;

  return network;
};

/**
 * Set the default network. This network will be used
 * if nothing is passed as the `network` option for
 * certain objects.
 * @param {NetworkType} type - Network type.
 * @returns {Network}
 */

Network.set = function set(type) {
  assert(typeof type === 'string', 'Bad network.');
  Network.primary = Network.get(type);
  Network.type = type;
  return Network.primary;
};

/**
 * Get a network with a string or a Network object.
 * @param {NetworkType|Network} type - Network type.
 * @returns {Network}
 */

Network.get = function get(type) {
  if (!type) {
    assert(Network.primary, 'No default network.');
    return Network.primary;
  }

  if (type instanceof Network)
    return type;

  if (typeof type === 'string')
    return Network.create(type);

  throw new Error('Unknown network.');
};

/**
 * Get a network with a string or a Network object.
 * @param {NetworkType|Network} type - Network type.
 * @returns {Network}
 */

Network.ensure = function ensure(type) {
  if (!type) {
    assert(Network.primary, 'No default network.');
    return Network.primary;
  }

  if (type instanceof Network)
    return type;

  if (typeof type === 'string') {
    if (networks[type])
      return Network.create(type);
  }

  assert(Network.primary, 'No default network.');

  return Network.primary;
};

/**
 * Get a network by an associated comparator.
 * @private
 * @param {Object} value
 * @param {Function} compare
 * @param {Network|null} network
 * @param {String} name
 * @returns {Network}
 */

Network.by = function by(value, compare, network, name) {
  if (network) {
    network = Network.get(network);
    if (compare(network, value))
      return network;
    throw new Error(`Network mismatch for ${name}.`);
  }

  for (const type of networks.types) {
    network = networks[type];
    if (compare(network, value))
      return Network.get(type);
  }

  throw new Error(`Network not found for ${name}.`);
};

/**
 * Get a network by its magic number.
 * @param {Number} value
 * @param {Network?} network
 * @returns {Network}
 */

Network.fromMagic = function fromMagic(value, network) {
  return Network.by(value, cmpMagic, network, 'magic number');
};

/**
 * Get a network by its WIF prefix.
 * @param {Number} value
 * @param {Network?} network
 * @returns {Network}
 */

Network.fromWIF = function fromWIF(prefix, network) {
  return Network.by(prefix, cmpWIF, network, 'WIF');
};

/**
 * Get a network by its xpubkey prefix.
 * @param {Number} value
 * @param {Network?} network
 * @returns {Network}
 */

Network.fromPublic = function fromPublic(prefix, network) {
  return Network.by(prefix, cmpPub, network, 'xpubkey');
};

/**
 * Get a network by its xprivkey prefix.
 * @param {Number} value
 * @param {Network?} network
 * @returns {Network}
 */

Network.fromPrivate = function fromPrivate(prefix, network) {
  return Network.by(prefix, cmpPriv, network, 'xprivkey');
};

/**
 * Get a network by its xpubkey base58 prefix.
 * @param {String} prefix
 * @param {Network?} network
 * @returns {Network}
 */

Network.fromPublic58 = function fromPublic58(prefix, network) {
  return Network.by(prefix, cmpPub58, network, 'xpubkey');
};

/**
 * Get a network by its xprivkey base58 prefix.
 * @param {String} prefix
 * @param {Network?} network
 * @returns {Network}
 */

Network.fromPrivate58 = function fromPrivate58(prefix, network) {
  return Network.by(prefix, cmpPriv58, network, 'xprivkey');
};

/**
 * Get a network by its base58 address prefix.
 * @param {Number} value
 * @param {Network?} network
 * @returns {Network}
 */

Network.fromAddress = function fromAddress(prefix, network) {
  return Network.by(prefix, cmpAddress, network, 'base58 address');
};

/**
 * Get a network by its bech32 address prefix.
 * @param {String} hrp
 * @param {Network?} network
 * @returns {Network}
 */

Network.fromBech32 = function fromBech32(hrp, network) {
  return Network.by(hrp, cmpBech32, network, 'bech32 address');
};

/**
 * Convert the network to a string.
 * @returns {String}
 */

Network.prototype.toString = function toString() {
  return this.type;
};

/**
 * Inspect the network.
 * @returns {String}
 */

Network.prototype.inspect = function inspect() {
  return `<Network: ${this.type}>`;
};

/**
 * Test an object to see if it is a Network.
 * @param {Object} obj
 * @returns {Boolean}
 */

Network.isNetwork = function isNetwork(obj) {
  return obj instanceof Network;
};

/*
 * Set initial network.
 */

Network.set(process.env.WMCC_NETWORK || 'mainnet');

/*
 * Helpers
 */

function cmpBit(a, b) {
  return a.bit - b;
}

function cmpNode(a, b) {
  return a.height - b.height;
}

function cmpMagic(network, magic) {
  return network.magic === magic;
}

function cmpWIF(network, prefix) {
  return network.keyPrefix.privkey === prefix;
}

function cmpPub(network, prefix) {
  return network.keyPrefix.xpubkey === prefix;
}

function cmpPriv(network, prefix) {
  return network.keyPrefix.xprivkey === prefix;
}

function cmpPub58(network, prefix) {
  return network.keyPrefix.xpubkey58 === prefix;
}

function cmpPriv58(network, prefix) {
  return network.keyPrefix.xprivkey58 === prefix;
}

function cmpAddress(network, prefix) {
  const prefixes = network.addressPrefix;

  switch (prefix) {
    case prefixes.pubkeyhash:
    case prefixes.scripthash:
    case prefixes.witnesspubkeyhash:
    case prefixes.witnessscripthash:
      return true;
  }

  return false;
}

function cmpBech32(network, hrp) {
  return network.addressPrefix.bech32 === hrp;
}

/*
 * Expose
 */

module.exports = Network;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * consensus.js - consensus constants and helpers for wmcc_core.
 */



/**
 * @module protocol/consensus
 */

const assert = __webpack_require__(0);
const BN = __webpack_require__(27);

/**
 * One wmcc in wmcoin.
 * @const {Amount}
 * @default
 */

exports.COIN = 100000000;

/**
 * Initial wmcc coin
 * `10million wmcc*wmcoin` (consensus).
 * @const {Amount}
 * @default
 */

exports.INITIAL_COIN = 10000000 * exports.COIN;

/**
 * Initial wmcc coin reserve
 * `10million wmcc*wmcoin` (consensus).
 * @const {Amount}
 * @default
 */

exports.INITIAL_COINRESERVE = 10000000 * exports.COIN;

/**
 * Maximum amount of money in satoshis:
 * `21million * 1btc` (consensus).
 * @const {Amount}
 * @default
 */

// exports.MAX_MONEY = 84000000 * exports.COIN; // ctl //

/**
 * Base block subsidy (consensus).
 * Note to shitcoin implementors: if you
 * increase this to anything greater than
 * 33 bits, getReward will have to be
 * modified to handle the shifts.
 * @const {Amount}
 * @default
 */

// exports.BASE_REWARD = 50 * exports.COIN;
exports.BASE_REWARD = 50 * exports.COIN;

/**
 * Base block reserve (consensus).
 * @const {Amount}
 * @default
 */

exports.BASE_RESERVE = 5 * exports.COIN;

/**
 * No halving
 * Half base block subsidy. Required to
 * calculate the reward properly (with
 * only 32 bit shifts available).
 * @const {Amount}
 * @default
 */

exports.HALF_REWARD = exports.BASE_REWARD; // Math.floor(exports.BASE_REWARD / 2);

/**
 * Maximum block base size (consensus).
 * @const {Number}
 * @default
 */

exports.MAX_BLOCK_SIZE = 1000000;

/**
 * Maximum block serialization size (protocol).
 * @const {Number}
 * @default
 */

exports.MAX_RAW_BLOCK_SIZE = 4000000;

/**
 * Maximum block weight (consensus).
 * @const {Number}
 * @default
 */

exports.MAX_BLOCK_WEIGHT = 4000000;

/**
 * Maximum block sigops (consensus).
 * @const {Number}
 * @default
 */

exports.MAX_BLOCK_SIGOPS = 1000000 / 50;

/**
 * Maximum block sigops cost (consensus).
 * @const {Number}
 * @default
 */

exports.MAX_BLOCK_SIGOPS_COST = 80000;

/**
 * What bits to set in version
 * for versionbits blocks.
 * @const {Number}
 * @default
 */

exports.VERSION_TOP_BITS = 0x20000000;

/**
 * What bitmask determines whether
 * versionbits is in use.
 * @const {Number}
 * @default
 */

exports.VERSION_TOP_MASK = 0xe0000000;

/**
 * Number of blocks before a coinbase
 * spend can occur (consensus).
 * @const {Number}
 * @default
 */

exports.COINBASE_MATURITY = 100;

/**
 * Amount to multiply base/non-witness sizes by.
 * @const {Number}
 * @default
 */

exports.WITNESS_SCALE_FACTOR = 4;

/**
 * nLockTime threshold for differentiating
 * between height and time (consensus).
 * Tue Nov 5 00:53:20 1985 UTC
 * @const {Number}
 * @default
 */

exports.LOCKTIME_THRESHOLD = 500000000;

/**
 * Highest nSequence bit -- disables
 * sequence locktimes (consensus).
 * @const {Number}
 */

exports.SEQUENCE_DISABLE_FLAG = (1 << 31) >>> 0;

/**
 * Sequence time: height or time (consensus).
 * @const {Number}
 * @default
 */

exports.SEQUENCE_TYPE_FLAG = 1 << 22;

/**
 * Sequence granularity for time (consensus).
 * @const {Number}
 * @default
 */

exports.SEQUENCE_GRANULARITY = 9;

/**
 * Sequence mask (consensus).
 * @const {Number}
 * @default
 */

exports.SEQUENCE_MASK = 0x0000ffff;

/**
 * Max serialized script size (consensus).
 * @const {Number}
 * @default
 */

exports.MAX_SCRIPT_SIZE = 10000;

/**
 * Max stack size during execution (consensus).
 * @const {Number}
 * @default
 */

exports.MAX_SCRIPT_STACK = 1000;

/**
 * Max script element size (consensus).
 * @const {Number}
 * @default
 */

exports.MAX_SCRIPT_PUSH = 520;

/**
 * Max opcodes executed (consensus).
 * @const {Number}
 * @default
 */

exports.MAX_SCRIPT_OPS = 201;

/**
 * Max `n` value for multisig (consensus).
 * @const {Number}
 * @default
 */

exports.MAX_MULTISIG_PUBKEYS = 20;

/**
 * The date bip16 (p2sh) was activated (consensus).
 * @const {Number}
 * @default
 */

exports.BIP16_TIME = 1512086400; // cto // Friday, December 1, 2017 12:00:00 AM

/**
 * Maximum amount of money in wmcoin
 * by block height (consensus).
 * @param {Number} block height
 * @returns {Number}
 */

exports.getMaxMoney = function getMaxMoney(height) {
  if (!height) return 0xffffffffffffffff;
  const initial = exports.INITIAL_COIN + exports.INITIAL_COINRESERVE;
  const genCoins = (exports.BASE_REWARD + exports.BASE_RESERVE)*height;
  return initial + genCoins;
};

/**
 * Convert a compact number to a big number.
 * Used for `block.bits` -> `target` conversion.
 * @param {Number} compact
 * @returns {BN}
 */

exports.fromCompact = function fromCompact(compact) {
  const exponent = compact >>> 24;
  const negative = (compact >>> 23) & 1;
  let mantissa = compact & 0x7fffff;
  let num;

  if (compact === 0)
    return new BN(0);

  if (exponent <= 3) {
    mantissa >>>= 8 * (3 - exponent);
    num = new BN(mantissa);
  } else {
    num = new BN(mantissa);
    num.iushln(8 * (exponent - 3));
  }

  if (negative)
    num.ineg();

  return num;
};

/**
 * Convert a big number to a compact number.
 * Used for `target` -> `block.bits` conversion.
 * @param {BN} num
 * @returns {Number}
 */

exports.toCompact = function toCompact(num) {
  let mantissa, exponent, compact;

  if (num.cmpn(0) === 0)
    return 0;

  exponent = num.byteLength();

  if (exponent <= 3) {
    mantissa = num.toNumber();
    mantissa <<= 8 * (3 - exponent);
  } else {
    mantissa = num.ushrn(8 * (exponent - 3)).toNumber();
  }

  if (mantissa & 0x800000) {
    mantissa >>= 8;
    exponent++;
  }

  compact = (exponent << 24) | mantissa;

  if (num.isNeg())
    compact |= 0x800000;

  compact >>>= 0;

  return compact;
};

/**
 * Verify proof-of-work.
 * @param {Hash} hash
 * @param {Number} bits
 * @returns {Boolean}
 */

exports.verifyPOW = function verifyPOW(hash, bits) {
  const target = exports.fromCompact(bits);

  if (target.isNeg() || target.cmpn(0) === 0)
    return false;

  hash = new BN(hash, 'le');

  if (hash.cmp(target) > 0)
    return false;

  return true;
};

/**
 * Calculate block subsidy.
 * @param {Number} height - Reward era by height.
 * @returns {Amount}
 */

exports.getReward = function getReward(height, interval) {
  /*const halvings = Math.floor(height / interval);

  assert(height >= 0, 'Bad height for reward.');

  // BIP 42 (well, our own version of it,
  // since we can only handle 32 bit shifts).
  // https://github.com/bitcoin/bips/blob/master/bip-0042.mediawiki
  if (halvings >= 33)
    return 0;

  // We need to shift right by `halvings`,
  // but 50 btc is a 33 bit number, so we
  // cheat. We only start halving once the
  // halvings are at least 1.
  if (halvings === 0)
    return exports.BASE_REWARD;

  return exports.HALF_REWARD >>> (halvings - 1);*/
  return exports.BASE_REWARD;
};

exports.getTotalReward = function getTotalReward(height, interval) {

  return exports.BASE_REWARD + exports.BASE_RESERVE;
};
/**
 * Test version bit.
 * @param {Number} version
 * @param {Number} bit
 * @returns {Boolean}
 */

exports.hasBit = function hasBit(version, bit) {
  const bits = version & exports.VERSION_TOP_MASK;
  const topBits = exports.VERSION_TOP_BITS;
  const mask = 1 << bit;
  return (bits >>> 0) === topBits && (version & mask) !== 0;
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * script.js - script interpreter for wmcc_core.
 */



const assert = __webpack_require__(0);
const consensus = __webpack_require__(7);
const policy = __webpack_require__(19);
const util = __webpack_require__(1);
const digest = __webpack_require__(5);
const merkle = __webpack_require__(63);
const BufferWriter = __webpack_require__(62);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const Program = __webpack_require__(81);
const Opcode = __webpack_require__(86);
const Stack = __webpack_require__(41);
const ScriptError = __webpack_require__(35);
const ScriptNum = __webpack_require__(33);
const common = __webpack_require__(28);
const encoding = __webpack_require__(3);
const secp256k1 = __webpack_require__(12);
const Address = __webpack_require__(11);
const opcodes = common.opcodes;
const scriptTypes = common.types;
const scriptTypesByVal = common.typesByVal;
const EMPTY_BUFFER = Buffer.alloc(0);

/**
 * Represents a input or output script.
 * @alias module:script.Script
 * @constructor
 * @param {Buffer|Array|Object|NakedScript} code - Array
 * of script code or a serialized script Buffer.
 * @property {Array} code - Parsed script code.
 * @property {Buffer?} raw - Serialized script.
 * @property {Number} length - Number of parsed opcodes.
 */

function Script(options) {
  if (!(this instanceof Script))
    return new Script(options);

  this.raw = EMPTY_BUFFER;
  this.code = [];

  if (options)
    this.fromOptions(options);
}

/**
 * Script opcodes.
 * @enum {Number}
 * @default
 */

Script.opcodes = common.opcodes;

/**
 * Opcodes by value.
 * @const {RevMap}
 */

Script.opcodesByVal = common.opcodesByVal;

/**
 * Script and locktime flags. See {@link VerifyFlags}.
 * @enum {Number}
 */

Script.flags = common.flags;

/**
 * Sighash Types.
 * @enum {SighashType}
 * @default
 */

Script.hashType = common.hashType;

/**
 * Sighash types by value.
 * @const {RevMap}
 */

Script.hashTypeByVal = common.hashTypeByVal;

/**
 * Output script types.
 * @enum {Number}
 */

Script.types = common.types;

/**
 * Output script types by value.
 * @const {RevMap}
 */

Script.typesByVal = common.typesByVal;

/*
 * Expose length setter and getter.
 */

Object.defineProperty(Script.prototype, 'length', {
  get() {
    return this.code.length;
  },
  set(length) {
    this.code.length = length;
    return this.code.length;
  }
});

/**
 * Inject properties from options object.
 * @private
 * @param {Object} options
 */

Script.prototype.fromOptions = function fromOptions(options) {
  assert(options, 'Script data is required.');

  if (Buffer.isBuffer(options))
    return this.fromRaw(options);

  if (Array.isArray(options))
    return this.fromArray(options);

  if (options.raw) {
    if (!options.code)
      return this.fromRaw(options.raw);
    assert(Buffer.isBuffer(options.raw), 'Raw must be a Buffer.');
    this.raw = options.raw;
  }

  if (options.code) {
    if (!options.raw)
      return this.fromArray(options.code);
    assert(Array.isArray(options.code), 'Code must be an array.');
    this.code = options.code;
  }

  return this;
};

/**
 * Insantiate script from options object.
 * @param {Object} options
 * @returns {Script}
 */

Script.fromOptions = function fromOptions(options) {
  return new Script().fromOptions(options);
};

/**
 * Instantiate a value-only iterator.
 * @returns {ScriptIterator}
 */

Script.prototype.values = function values() {
  return this.code.values();
};

/**
 * Instantiate a key and value iterator.
 * @returns {ScriptIterator}
 */

Script.prototype.entries = function entries() {
  return this.code.entries();
};

/**
 * Instantiate a value-only iterator.
 * @returns {ScriptIterator}
 */

Script.prototype[Symbol.iterator] = function() {
  return this.code[Symbol.iterator]();
};

/**
 * Convert the script to an array of
 * Buffers (pushdatas) and Numbers
 * (opcodes).
 * @returns {Array}
 */

Script.prototype.toArray = function toArray() {
  return this.code.slice();
};

/**
 * Inject properties from an array of
 * of buffers and numbers.
 * @private
 * @param {Array} code
 * @returns {Script}
 */

Script.prototype.fromArray = function fromArray(code) {
  assert(Array.isArray(code));

  this.clear();

  for (const op of code)
    this.push(op);

  return this.compile();
};

/**
 * Instantiate script from an array
 * of buffers and numbers.
 * @param {Array} code
 * @returns {Script}
 */

Script.fromArray = function fromArray(code) {
  return new Script().fromArray(code);
};

/**
 * Convert script to stack items.
 * @returns {Buffer[]}
 */

Script.prototype.toItems = function toItems() {
  const items = [];

  for (const op of this.code) {
    const data = op.toPush();

    if (!data)
      throw new Error('Non-push opcode in script.');

    items.push(data);
  }

  return items;
};

/**
 * Inject data from stack items.
 * @private
 * @param {Buffer[]} items
 * @returns {Script}
 */

Script.prototype.fromItems = function fromItems(items) {
  assert(Array.isArray(items));

  this.clear();

  for (const item of items)
    this.pushData(item);

  return this.compile();
};

/**
 * Instantiate script from stack items.
 * @param {Buffer[]} items
 * @returns {Script}
 */

Script.fromItems = function fromItems(items) {
  return new Script().fromItems(items);
};

/**
 * Convert script to stack.
 * @returns {Stack}
 */

Script.prototype.toStack = function toStack() {
  return new Stack(this.toItems());
};

/**
 * Inject data from stack.
 * @private
 * @param {Stack} stack
 * @returns {Script}
 */

Script.prototype.fromStack = function fromStack(stack) {
  return this.fromItems(stack.items);
};

/**
 * Instantiate script from stack.
 * @param {Stack} stack
 * @returns {Script}
 */

Script.fromStack = function fromStack(stack) {
  return new Script().fromStack(stack);
};

/**
 * Clone the script.
 * @returns {Script} Cloned script.
 */

Script.prototype.clone = function clone() {
  return new Script().inject(this);
};

/**
 * Inject properties from script.
 * Used for cloning.
 * @private
 * @param {Script} script
 * @returns {Script}
 */

Script.prototype.inject = function inject(script) {
  this.raw = script.raw;
  this.code = script.code.slice();
  return this;
};

/**
 * Test equality against script.
 * @param {Script} script
 * @returns {Boolean}
 */

Script.prototype.equals = function equals(script) {
  assert(Script.isScript(script));
  return this.raw.equals(script.raw);
};

/**
 * Compare against another script.
 * @param {Script} script
 * @returns {Number}
 */

Script.prototype.compare = function compare(script) {
  assert(Script.isScript(script));
  return this.raw.compare(script.raw);
};

/**
 * Clear the script.
 * @returns {Script}
 */

Script.prototype.clear = function clear() {
  this.raw = EMPTY_BUFFER;
  this.code.length = 0;
  return this;
};

/**
 * Inspect the script.
 * @returns {String} Human-readable script code.
 */

Script.prototype.inspect = function inspect() {
  return `<Script: ${this.toString()}>`;
};

/**
 * Convert the script to a wmccd test string.
 * @returns {String} Human-readable script code.
 */

Script.prototype.toString = function toString() {
  const out = [];

  for (const op of this.code)
    out.push(op.toFormat());

  return out.join(' ');
};

/**
 * Format the script as wmccd asm.
 * @param {Boolean?} decode - Attempt to decode hash types.
 * @returns {String} Human-readable script.
 */

Script.prototype.toASM = function toASM(decode) {
  if (this.isNulldata())
    decode = false;

  const out = [];

  for (const op of this.code)
    out.push(op.toASM(decode));

  return out.join(' ');
};

/**
 * Re-encode the script internally. Useful if you
 * changed something manually in the `code` array.
 * @returns {Script}
 */

Script.prototype.compile = function compile() {
  if (this.code.length === 0)
    return this.clear();

  let size = 0;

  for (const op of this.code)
    size += op.getSize();

  const bw = new StaticWriter(size);

  for (const op of this.code)
    op.toWriter(bw);

  this.raw = bw.render();

  return this;
};

/**
 * Write the script to a buffer writer.
 * @param {BufferWriter} bw
 */

Script.prototype.toWriter = function toWriter(bw) {
  bw.writeVarBytes(this.raw);
  return bw;
};

/**
 * Encode the script to a Buffer. See {@link Script#encode}.
 * @param {String} enc - Encoding, either `'hex'` or `null`.
 * @returns {Buffer|String} Serialized script.
 */

Script.prototype.toRaw = function toRaw() {
  return this.raw;
};

/**
 * Convert script to a hex string.
 * @returns {String}
 */

Script.prototype.toJSON = function toJSON() {
  return this.toRaw().toString('hex');
};

/**
 * Inject properties from json object.
 * @private
 * @param {String} json
 */

Script.prototype.fromJSON = function fromJSON(json) {
  assert(typeof json === 'string', 'Code must be a string.');
  return this.fromRaw(Buffer.from(json, 'hex'));
};

/**
 * Instantiate script from a hex string.
 * @params {String} json
 * @returns {Script}
 */

Script.fromJSON = function fromJSON(json) {
  return new Script().fromJSON(json);
};

/**
 * Get the script's "subscript" starting at a separator.
 * @param {Number} index - The last separator to sign/verify beyond.
 * @returns {Script} Subscript.
 */

Script.prototype.getSubscript = function getSubscript(index) {
  if (index === 0)
    return this.clone();

  const script = new Script();

  for (let i = index; i < this.code.length; i++) {
    const op = this.code[i];

    if (op.value === -1)
      break;

    script.code.push(op);
  }

  return script.compile();
};

/**
 * Get the script's "subscript" starting at a separator.
 * Remove all OP_CODESEPARATORs if present. This bizarre
 * behavior is necessary for signing and verification when
 * code separators are present.
 * @returns {Script} Subscript.
 */

Script.prototype.removeSeparators = function removeSeparators() {
  let found = false;

  // Optimizing for the common case:
  // Check for any separators first.
  for (const op of this.code) {
    if (op.value === -1)
      break;

    if (op.value === opcodes.OP_CODESEPARATOR) {
      found = true;
      break;
    }
  }

  if (!found)
    return this;

  // Uncommon case: someone actually
  // has a code separator. Go through
  // and remove them all.
  const script = new Script();

  for (const op of this.code) {
    if (op.value === -1)
      break;

    if (op.value !== opcodes.OP_CODESEPARATOR)
      script.code.push(op);
  }

  return script.compile();
};

/**
 * Execute and interpret the script.
 * @param {Stack} stack - Script execution stack.
 * @param {Number?} flags - Script standard flags.
 * @param {TX?} tx - Transaction being verified.
 * @param {Number?} index - Index of input being verified.
 * @param {Amount?} value - Previous output value.
 * @param {Number?} version - Signature hash version (0=legacy, 1=segwit).
 * @throws {ScriptError} Will be thrown on VERIFY failures, among other things.
 */

Script.prototype.execute = function execute(stack, flags, tx, index, value, version) {
  if (flags == null)
    flags = Script.flags.STANDARD_VERIFY_FLAGS;

  if (version == null)
    version = 0;

  if (this.raw.length > consensus.MAX_SCRIPT_SIZE)
    throw new ScriptError('SCRIPT_SIZE');

  const state = [];
  const alt = [];

  let lastSep = 0;
  let opCount = 0;
  let negate = 0;
  let minimal = false;

  if (flags & Script.flags.VERIFY_MINIMALDATA)
    minimal = true;

  for (let ip = 0; ip < this.code.length; ip++) {
    const op = this.code[ip];

    if (op.value === -1)
      throw new ScriptError('BAD_OPCODE', op, ip);

    if (op.data && op.data.length > consensus.MAX_SCRIPT_PUSH)
      throw new ScriptError('PUSH_SIZE', op, ip);

    if (op.value > opcodes.OP_16 && ++opCount > consensus.MAX_SCRIPT_OPS)
      throw new ScriptError('OP_COUNT', op, ip);

    if (op.isDisabled())
      throw new ScriptError('DISABLED_OPCODE', op, ip);

    if (negate && !op.isBranch()) {
      if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK)
        throw new ScriptError('STACK_SIZE', op, ip);
      continue;
    }

    if (op.data) {
      if (minimal && !op.isMinimal())
        throw new ScriptError('MINIMALDATA', op, ip);

      stack.push(op.data);

      if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK)
        throw new ScriptError('STACK_SIZE', op, ip);

      continue;
    }

    switch (op.value) {
      case opcodes.OP_0: {
        stack.pushInt(0);
        break;
      }
      case opcodes.OP_1NEGATE: {
        stack.pushInt(-1);
        break;
      }
      case opcodes.OP_1:
      case opcodes.OP_2:
      case opcodes.OP_3:
      case opcodes.OP_4:
      case opcodes.OP_5:
      case opcodes.OP_6:
      case opcodes.OP_7:
      case opcodes.OP_8:
      case opcodes.OP_9:
      case opcodes.OP_10:
      case opcodes.OP_11:
      case opcodes.OP_12:
      case opcodes.OP_13:
      case opcodes.OP_14:
      case opcodes.OP_15:
      case opcodes.OP_16: {
        stack.pushInt(op.value - 0x50);
        break;
      }
      case opcodes.OP_NOP: {
        break;
      }
      case opcodes.OP_CHECKLOCKTIMEVERIFY: {
        // OP_CHECKLOCKTIMEVERIFY = OP_NOP2
        if (!(flags & Script.flags.VERIFY_CHECKLOCKTIMEVERIFY)) {
          if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
            throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);
          break;
        }

        if (!tx)
          throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');

        if (stack.length === 0)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        const num = stack.getNum(-1, minimal, 5);

        if (num.isNeg())
          throw new ScriptError('NEGATIVE_LOCKTIME', op, ip);

        const locktime = num.toDouble();

        if (!tx.verifyLocktime(index, locktime))
          throw new ScriptError('UNSATISFIED_LOCKTIME', op, ip);

        break;
      }
      case opcodes.OP_CHECKSEQUENCEVERIFY: {
        // OP_CHECKSEQUENCEVERIFY = OP_NOP3
        if (!(flags & Script.flags.VERIFY_CHECKSEQUENCEVERIFY)) {
          if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
            throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);
          break;
        }

        if (!tx)
          throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');

        if (stack.length === 0)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        const num = stack.getNum(-1, minimal, 5);

        if (num.isNeg())
          throw new ScriptError('NEGATIVE_LOCKTIME', op, ip);

        const locktime = num.toDouble();

        if (!tx.verifySequence(index, locktime))
          throw new ScriptError('UNSATISFIED_LOCKTIME', op, ip);

        break;
      }
      case opcodes.OP_NOP1:
      case opcodes.OP_NOP4:
      case opcodes.OP_NOP5:
      case opcodes.OP_NOP6:
      case opcodes.OP_NOP7:
      case opcodes.OP_NOP8:
      case opcodes.OP_NOP9:
      case opcodes.OP_NOP10: {
        if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
          throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);
        break;
      }
      case opcodes.OP_IF:
      case opcodes.OP_NOTIF: {
        let val = false;

        if (!negate) {
          if (stack.length < 1)
            throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);

          if (version === 1 && (flags & Script.flags.VERIFY_MINIMALIF)) {
            const item = stack.get(-1);

            if (item.length > 1)
              throw new ScriptError('MINIMALIF');

            if (item.length === 1 && item[0] !== 1)
              throw new ScriptError('MINIMALIF');
          }

          val = stack.getBool(-1);

          if (op.value === opcodes.OP_NOTIF)
            val = !val;

          stack.pop();
        }

        state.push(val);

        if (!val)
          negate += 1;

        break;
      }
      case opcodes.OP_ELSE: {
        if (state.length === 0)
          throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);

        state[state.length - 1] = !state[state.length - 1];

        if (!state[state.length - 1])
          negate += 1;
        else
          negate -= 1;

        break;
      }
      case opcodes.OP_ENDIF: {
        if (state.length === 0)
          throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);

        if (!state.pop())
          negate -= 1;

        break;
      }
      case opcodes.OP_VERIFY: {
        if (stack.length === 0)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        if (!stack.getBool(-1))
          throw new ScriptError('VERIFY', op, ip);

        stack.pop();

        break;
      }
      case opcodes.OP_RETURN: {
        throw new ScriptError('OP_RETURN', op, ip);
      }
      case opcodes.OP_TOALTSTACK: {
        if (stack.length === 0)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        alt.push(stack.pop());
        break;
      }
      case opcodes.OP_FROMALTSTACK: {
        if (alt.length === 0)
          throw new ScriptError('INVALID_ALTSTACK_OPERATION', op, ip);

        stack.push(alt.pop());
        break;
      }
      case opcodes.OP_2DROP: {
        if (stack.length < 2)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        stack.pop();
        stack.pop();
        break;
      }
      case opcodes.OP_2DUP: {
        if (stack.length < 2)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        const v1 = stack.get(-2);
        const v2 = stack.get(-1);

        stack.push(v1);
        stack.push(v2);
        break;
      }
      case opcodes.OP_3DUP: {
        if (stack.length < 3)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        const v1 = stack.get(-3);
        const v2 = stack.get(-2);
        const v3 = stack.get(-1);

        stack.push(v1);
        stack.push(v2);
        stack.push(v3);
        break;
      }
      case opcodes.OP_2OVER: {
        if (stack.length < 4)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        const v1 = stack.get(-4);
        const v2 = stack.get(-3);

        stack.push(v1);
        stack.push(v2);
        break;
      }
      case opcodes.OP_2ROT: {
        if (stack.length < 6)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        const v1 = stack.get(-6);
        const v2 = stack.get(-5);

        stack.erase(-6, -4);
        stack.push(v1);
        stack.push(v2);
        break;
      }
      case opcodes.OP_2SWAP: {
        if (stack.length < 4)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        stack.swap(-4, -2);
        stack.swap(-3, -1);
        break;
      }
      case opcodes.OP_IFDUP: {
        if (stack.length === 0)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        if (stack.getBool(-1)) {
          const val = stack.get(-1);
          stack.push(val);
        }

        break;
      }
      case opcodes.OP_DEPTH: {
        stack.pushInt(stack.length);
        break;
      }
      case opcodes.OP_DROP: {
        if (stack.length === 0)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        stack.pop();
        break;
      }
      case opcodes.OP_DUP: {
        if (stack.length === 0)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        stack.push(stack.get(-1));
        break;
      }
      case opcodes.OP_NIP: {
        if (stack.length < 2)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        stack.remove(-2);
        break;
      }
      case opcodes.OP_OVER: {
        if (stack.length < 2)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        stack.push(stack.get(-2));
        break;
      }
      case opcodes.OP_PICK:
      case opcodes.OP_ROLL: {
        if (stack.length < 2)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        const num = stack.getInt(-1, minimal, 4);
        stack.pop();

        if (num < 0 || num >= stack.length)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        const val = stack.get(-num - 1);

        if (op.value === opcodes.OP_ROLL)
          stack.remove(-num - 1);

        stack.push(val);
        break;
      }
      case opcodes.OP_ROT: {
        if (stack.length < 3)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        stack.swap(-3, -2);
        stack.swap(-2, -1);
        break;
      }
      case opcodes.OP_SWAP: {
        if (stack.length < 2)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        stack.swap(-2, -1);
        break;
      }
      case opcodes.OP_TUCK: {
        if (stack.length < 2)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        stack.insert(-2, stack.get(-1));
        break;
      }
      case opcodes.OP_SIZE: {
        if (stack.length < 1)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        stack.pushInt(stack.get(-1).length);
        break;
      }
      case opcodes.OP_EQUAL:
      case opcodes.OP_EQUALVERIFY: {
        if (stack.length < 2)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        const v1 = stack.get(-2);
        const v2 = stack.get(-1);

        const res = v1.equals(v2);

        stack.pop();
        stack.pop();

        stack.pushBool(res);

        if (op.value === opcodes.OP_EQUALVERIFY) {
          if (!res)
            throw new ScriptError('EQUALVERIFY', op, ip);
          stack.pop();
        }

        break;
      }
      case opcodes.OP_1ADD:
      case opcodes.OP_1SUB:
      case opcodes.OP_NEGATE:
      case opcodes.OP_ABS:
      case opcodes.OP_NOT:
      case opcodes.OP_0NOTEQUAL: {
        if (stack.length < 1)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        let num = stack.getNum(-1, minimal, 4);
        let cmp;

        switch (op.value) {
          case opcodes.OP_1ADD:
            num.iaddn(1);
            break;
          case opcodes.OP_1SUB:
            num.isubn(1);
            break;
          case opcodes.OP_NEGATE:
            num.ineg();
            break;
          case opcodes.OP_ABS:
            num.iabs();
            break;
          case opcodes.OP_NOT:
            cmp = num.isZero();
            num = ScriptNum.fromBool(cmp);
            break;
          case opcodes.OP_0NOTEQUAL:
            cmp = !num.isZero();
            num = ScriptNum.fromBool(cmp);
            break;
          default:
            assert(false, 'Fatal script error.');
            break;
        }

        stack.pop();
        stack.pushNum(num);

        break;
      }
      case opcodes.OP_ADD:
      case opcodes.OP_SUB:
      case opcodes.OP_BOOLAND:
      case opcodes.OP_BOOLOR:
      case opcodes.OP_NUMEQUAL:
      case opcodes.OP_NUMEQUALVERIFY:
      case opcodes.OP_NUMNOTEQUAL:
      case opcodes.OP_LESSTHAN:
      case opcodes.OP_GREATERTHAN:
      case opcodes.OP_LESSTHANOREQUAL:
      case opcodes.OP_GREATERTHANOREQUAL:
      case opcodes.OP_MIN:
      case opcodes.OP_MAX: {
        if (stack.length < 2)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        const n1 = stack.getNum(-2, minimal, 4);
        const n2 = stack.getNum(-1, minimal, 4);
        let num, cmp;

        switch (op.value) {
          case opcodes.OP_ADD:
            num = n1.iadd(n2);
            break;
          case opcodes.OP_SUB:
            num = n1.isub(n2);
            break;
          case opcodes.OP_BOOLAND:
            cmp = n1.toBool() && n2.toBool();
            num = ScriptNum.fromBool(cmp);
            break;
          case opcodes.OP_BOOLOR:
            cmp = n1.toBool() || n2.toBool();
            num = ScriptNum.fromBool(cmp);
            break;
          case opcodes.OP_NUMEQUAL:
            cmp = n1.eq(n2);
            num = ScriptNum.fromBool(cmp);
            break;
          case opcodes.OP_NUMEQUALVERIFY:
            cmp = n1.eq(n2);
            num = ScriptNum.fromBool(cmp);
            break;
          case opcodes.OP_NUMNOTEQUAL:
            cmp = !n1.eq(n2);
            num = ScriptNum.fromBool(cmp);
            break;
          case opcodes.OP_LESSTHAN:
            cmp = n1.lt(n2);
            num = ScriptNum.fromBool(cmp);
            break;
          case opcodes.OP_GREATERTHAN:
            cmp = n1.gt(n2);
            num = ScriptNum.fromBool(cmp);
            break;
          case opcodes.OP_LESSTHANOREQUAL:
            cmp = n1.lte(n2);
            num = ScriptNum.fromBool(cmp);
            break;
          case opcodes.OP_GREATERTHANOREQUAL:
            cmp = n1.gte(n2);
            num = ScriptNum.fromBool(cmp);
            break;
          case opcodes.OP_MIN:
            num = ScriptNum.min(n1, n2);
            break;
          case opcodes.OP_MAX:
            num = ScriptNum.max(n1, n2);
            break;
          default:
            assert(false, 'Fatal script error.');
            break;
        }

        stack.pop();
        stack.pop();
        stack.pushNum(num);

        if (op.value === opcodes.OP_NUMEQUALVERIFY) {
          if (!stack.getBool(-1))
            throw new ScriptError('NUMEQUALVERIFY', op, ip);
          stack.pop();
        }

        break;
      }
      case opcodes.OP_WITHIN: {
        if (stack.length < 3)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        const n1 = stack.getNum(-3, minimal, 4);
        const n2 = stack.getNum(-2, minimal, 4);
        const n3 = stack.getNum(-1, minimal, 4);

        const val = n2.lte(n1) && n1.lt(n3);

        stack.pop();
        stack.pop();
        stack.pop();

        stack.pushBool(val);
        break;
      }
      case opcodes.OP_RIPEMD160: {
        if (stack.length === 0)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        stack.push(digest.ripemd160(stack.pop()));
        break;
      }
      case opcodes.OP_SHA1: {
        if (stack.length === 0)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        stack.push(digest.sha1(stack.pop()));
        break;
      }
      case opcodes.OP_SHA256: {
        if (stack.length === 0)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        stack.push(digest.sha256(stack.pop()));
        break;
      }
      case opcodes.OP_HASH160: {
        if (stack.length === 0)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        stack.push(digest.hash160(stack.pop()));
        break;
      }
      case opcodes.OP_HASH256: {
        if (stack.length === 0)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        stack.push(digest.hash256(stack.pop()));
        break;
      }
      case opcodes.OP_CODESEPARATOR: {
        lastSep = ip + 1;
        break;
      }
      case opcodes.OP_CHECKSIG:
      case opcodes.OP_CHECKSIGVERIFY: {
        if (!tx)
          throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');

        if (stack.length < 2)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        const sig = stack.get(-2);
        const key = stack.get(-1);

        const subscript = this.getSubscript(lastSep);

        if (version === 0)
          subscript.findAndDelete(sig);

        validateSignature(sig, flags);
        validateKey(key, flags, version);

        let res = false;

        if (sig.length > 0) {
          const type = sig[sig.length - 1];
          const hash = tx.signatureHash(index, subscript, value, type, version);
          res = checksig(hash, sig, key);
        }

        if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {
          if (sig.length !== 0)
            throw new ScriptError('NULLFAIL', op, ip);
        }

        stack.pop();
        stack.pop();

        stack.pushBool(res);

        if (op.value === opcodes.OP_CHECKSIGVERIFY) {
          if (!res)
            throw new ScriptError('CHECKSIGVERIFY', op, ip);
          stack.pop();
        }

        break;
      }
      case opcodes.OP_CHECKMULTISIG:
      case opcodes.OP_CHECKMULTISIGVERIFY: {
        if (!tx)
          throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');

        let i = 1;
        if (stack.length < i)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        let n = stack.getInt(-i, minimal, 4);
        let okey = n + 2;
        let ikey, isig;

        if (n < 0 || n > consensus.MAX_MULTISIG_PUBKEYS)
          throw new ScriptError('PUBKEY_COUNT', op, ip);

        opCount += n;

        if (opCount > consensus.MAX_SCRIPT_OPS)
          throw new ScriptError('OP_COUNT', op, ip);

        i += 1;
        ikey = i;
        i += n;

        if (stack.length < i)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        let m = stack.getInt(-i, minimal, 4);

        if (m < 0 || m > n)
          throw new ScriptError('SIG_COUNT', op, ip);

        i += 1;
        isig = i;
        i += m;

        if (stack.length < i)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        const subscript = this.getSubscript(lastSep);

        for (let j = 0; j < m; j++) {
          const sig = stack.get(-isig - j);
          if (version === 0)
            subscript.findAndDelete(sig);
        }

        let res = true;
        while (res && m > 0) {
          const sig = stack.get(-isig);
          const key = stack.get(-ikey);

          validateSignature(sig, flags);
          validateKey(key, flags, version);

          if (sig.length > 0) {
            const type = sig[sig.length - 1];
            const hash = tx.signatureHash(
              index,
              subscript,
              value,
              type,
              version
            );

            if (checksig(hash, sig, key)) {
              isig += 1;
              m -= 1;
            }
          }

          ikey += 1;
          n -= 1;

          if (m > n)
            res = false;
        }

        while (i > 1) {
          if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {
            if (okey === 0 && stack.get(-1).length !== 0)
              throw new ScriptError('NULLFAIL', op, ip);
          }

          if (okey > 0)
            okey -= 1;

          stack.pop();

          i -= 1;
        }

        if (stack.length < 1)
          throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

        if (flags & Script.flags.VERIFY_NULLDUMMY) {
          if (stack.get(-1).length !== 0)
            throw new ScriptError('SIG_NULLDUMMY', op, ip);
        }

        stack.pop();

        stack.pushBool(res);

        if (op.value === opcodes.OP_CHECKMULTISIGVERIFY) {
          if (!res)
            throw new ScriptError('CHECKMULTISIGVERIFY', op, ip);
          stack.pop();
        }

        break;
      }
      default: {
        throw new ScriptError('BAD_OPCODE', op, ip);
      }
    }

    if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK)
      throw new ScriptError('STACK_SIZE', op, ip);
  }

  if (state.length !== 0)
    throw new ScriptError('UNBALANCED_CONDITIONAL');
};

/**
 * Remove all matched data elements from
 * a script's code (used to remove signatures
 * before verification). Note that this
 * compares and removes data on the _byte level_.
 * It also reserializes the data to a single
 * script with minimaldata encoding beforehand.
 * A signature will _not_ be removed if it is
 * not minimaldata.
 * @see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-November/006878.html
 * @see https://test.webbtc.com/tx/19aa42fee0fa57c45d3b16488198b27caaacc4ff5794510d0c17f173f05587ff
 * @param {Buffer} data - Data element to match against.
 * @returns {Number} Total.
 */

Script.prototype.findAndDelete = function findAndDelete(data) {
  const target = Opcode.fromPush(data);

  if (this.raw.length < target.getSize())
    return 0;

  let found = false;

  for (const op of this.code) {
    if (op.value === -1)
      break;

    if (op.equals(target)) {
      found = true;
      break;
    }
  }

  if (!found)
    return 0;

  const code = [];

  let total = 0;

  for (const op of this.code) {
    if (op.value === -1)
      break;

    if (op.equals(target)) {
      total += 1;
      continue;
    }

    code.push(op);
  }

  this.code = code;
  this.compile();

  return total;
};

/**
 * Find a data element in a script.
 * @param {Buffer} data - Data element to match against.
 * @returns {Number} Index (`-1` if not present).
 */

Script.prototype.indexOf = function indexOf(data) {
  for (let i = 0; i < this.code.length; i++) {
    const op = this.code[i];

    if (op.value === -1)
      break;

    if (!op.data)
      continue;

    if (op.data.equals(data))
      return i;
  }

  return -1;
};

/**
 * Test a script to see if it is likely
 * to be script code (no weird opcodes).
 * @returns {Boolean}
 */

Script.prototype.isCode = function isCode() {
  for (const op of this.code) {
    if (op.value === -1)
      return false;

    if (op.isDisabled())
      return false;

    switch (op.value) {
      case opcodes.OP_RESERVED:
      case opcodes.OP_NOP:
      case opcodes.OP_VER:
      case opcodes.OP_VERIF:
      case opcodes.OP_VERNOTIF:
      case opcodes.OP_RESERVED1:
      case opcodes.OP_RESERVED2:
      case opcodes.OP_NOP1:
        return false;
    }

    if (op.value > opcodes.OP_CHECKSEQUENCEVERIFY)
      return false;
  }

  return true;
};

/**
 * Inject properties from a pay-to-pubkey script.
 * @private
 * @param {Buffer} key
 */

Script.prototype.fromPubkey = function fromPubkey(key) {
  assert(Buffer.isBuffer(key) && (key.length === 33 || key.length === 65));

  this.raw = Buffer.allocUnsafe(1 + key.length + 1);
  this.raw[0] = key.length;
  key.copy(this.raw, 1);
  this.raw[1 + key.length] = opcodes.OP_CHECKSIG;

  key = this.raw.slice(1, 1 + key.length);

  this.code.length = 0;
  this.code.push(Opcode.fromPush(key));
  this.code.push(Opcode.fromOp(opcodes.OP_CHECKSIG));

  return this;
};

/**
 * Create a pay-to-pubkey script.
 * @param {Buffer} key
 * @returns {Script}
 */

Script.fromPubkey = function fromPubkey(key) {
  return new Script().fromPubkey(key);
};

/**
 * Inject properties from a pay-to-pubkeyhash script.
 * @private
 * @param {Buffer} hash
 */

Script.prototype.fromPubkeyhash = function fromPubkeyhash(hash) {
  assert(Buffer.isBuffer(hash) && hash.length === 20);

  this.raw = Buffer.allocUnsafe(25);
  this.raw[0] = opcodes.OP_DUP;
  this.raw[1] = opcodes.OP_HASH160;
  this.raw[2] = 0x14;
  hash.copy(this.raw, 3);
  this.raw[23] = opcodes.OP_EQUALVERIFY;
  this.raw[24] = opcodes.OP_CHECKSIG;

  hash = this.raw.slice(3, 23);

  this.code.length = 0;
  this.code.push(Opcode.fromOp(opcodes.OP_DUP));
  this.code.push(Opcode.fromOp(opcodes.OP_HASH160));
  this.code.push(Opcode.fromPush(hash));
  this.code.push(Opcode.fromOp(opcodes.OP_EQUALVERIFY));
  this.code.push(Opcode.fromOp(opcodes.OP_CHECKSIG));

  return this;
};

/**
 * Create a pay-to-pubkeyhash script.
 * @param {Buffer} hash
 * @returns {Script}
 */

Script.fromPubkeyhash = function fromPubkeyhash(hash) {
  return new Script().fromPubkeyhash(hash);
};

/**
 * Inject properties from pay-to-multisig script.
 * @private
 * @param {Number} m
 * @param {Number} n
 * @param {Buffer[]} keys
 */

Script.prototype.fromMultisig = function fromMultisig(m, n, keys) {
  assert(util.isU8(m) && util.isU8(n));
  assert(Array.isArray(keys));
  assert(keys.length === n, '`n` keys are required for multisig.');
  assert(m >= 1 && m <= n);
  assert(n >= 1 && n <= 15);

  this.clear();

  this.pushSmall(m);

  for (const key of sortKeys(keys))
    this.pushData(key);

  this.pushSmall(n);
  this.pushOp(opcodes.OP_CHECKMULTISIG);

  return this.compile();
};

/**
 * Create a pay-to-multisig script.
 * @param {Number} m
 * @param {Number} n
 * @param {Buffer[]} keys
 * @returns {Script}
 */

Script.fromMultisig = function fromMultisig(m, n, keys) {
  return new Script().fromMultisig(m, n, keys);
};

/**
 * Inject properties from a pay-to-scripthash script.
 * @private
 * @param {Buffer} hash
 */

Script.prototype.fromScripthash = function fromScripthash(hash) {
  assert(Buffer.isBuffer(hash) && hash.length === 20);

  this.raw = Buffer.allocUnsafe(23);
  this.raw[0] = opcodes.OP_HASH160;
  this.raw[1] = 0x14;
  hash.copy(this.raw, 2);
  this.raw[22] = opcodes.OP_EQUAL;

  hash = this.raw.slice(2, 22);

  this.code.length = 0;
  this.code.push(Opcode.fromOp(opcodes.OP_HASH160));
  this.code.push(Opcode.fromPush(hash));
  this.code.push(Opcode.fromOp(opcodes.OP_EQUAL));

  return this;
};

/**
 * Create a pay-to-scripthash script.
 * @param {Buffer} hash
 * @returns {Script}
 */

Script.fromScripthash = function fromScripthash(hash) {
  return new Script().fromScripthash(hash);
};

/**
 * Inject properties from a nulldata/opreturn script.
 * @private
 * @param {Buffer} flags
 */

Script.prototype.fromNulldata = function fromNulldata(flags) {
  assert(Buffer.isBuffer(flags));
  assert(flags.length <= policy.MAX_OP_RETURN, 'Nulldata too large.');

  this.clear();
  this.pushOp(opcodes.OP_RETURN);
  this.pushData(flags);

  return this.compile();
};

/**
 * Create a nulldata/opreturn script.
 * @param {Buffer} flags
 * @returns {Script}
 */

Script.fromNulldata = function fromNulldata(flags) {
  return new Script().fromNulldata(flags);
};

/**
 * Inject properties from a witness program.
 * @private
 * @param {Number} version
 * @param {Buffer} data
 */

Script.prototype.fromProgram = function fromProgram(version, data) {
  assert(util.isU8(version) && version >= 0 && version <= 16);
  assert(Buffer.isBuffer(data) && data.length >= 2 && data.length <= 40);

  this.raw = Buffer.allocUnsafe(2 + data.length);
  this.raw[0] = version === 0 ? 0 : version + 0x50;
  this.raw[1] = data.length;
  data.copy(this.raw, 2);

  data = this.raw.slice(2, 2 + data.length);

  this.code.length = 0;
  this.code.push(Opcode.fromSmall(version));
  this.code.push(Opcode.fromPush(data));

  return this;
};

/**
 * Create a witness program.
 * @param {Number} version
 * @param {Buffer} data
 * @returns {Script}
 */

Script.fromProgram = function fromProgram(version, data) {
  return new Script().fromProgram(version, data);
};

/**
 * Inject properties from an address.
 * @private
 * @param {Address|Base58Address} address
 */

Script.prototype.fromAddress = function fromAddress(address) {
  if (typeof address === 'string')
    address = Address.fromString(address);

  assert(address instanceof Address, 'Not an address.');

  if (address.isPubkeyhash())
    return this.fromPubkeyhash(address.hash);

  if (address.isScripthash())
    return this.fromScripthash(address.hash);

  if (address.isProgram())
    return this.fromProgram(address.version, address.hash);

  throw new Error('Unknown address type.');
};

/**
 * Create an output script from an address.
 * @param {Address|Base58Address} address
 * @returns {Script}
 */

Script.fromAddress = function fromAddress(address) {
  return new Script().fromAddress(address);
};

/**
 * Inject properties from a witness block commitment.
 * @private
 * @param {Buffer} hash
 * @param {String|Buffer} flags
 */

Script.prototype.fromCommitment = function fromCommitment(hash, flags) {
  const bw = new StaticWriter(36);

  bw.writeU32BE(0xaa21a9ed);
  bw.writeHash(hash);

  this.clear();
  this.pushOp(opcodes.OP_RETURN);
  this.pushData(bw.render());

  if (flags)
    this.pushData(flags);

  return this.compile();
};

/**
 * Create a witness block commitment.
 * @param {Buffer} hash
 * @param {String|Buffer} flags
 * @returns {Script}
 */

Script.fromCommitment = function fromCommitment(hash, flags) {
  return new Script().fromCommitment(hash, flags);
};

/**
 * Grab and deserialize the redeem script.
 * @returns {Script|null} Redeem script.
 */

Script.prototype.getRedeem = function getRedeem() {
  let data = null;

  for (const op of this.code) {
    if (op.value === -1)
      return null;

    if (op.value > opcodes.OP_16)
      return null;

    data = op.data;
  }

  if (!data)
    return null;

  return Script.fromRaw(data);
};

/**
 * Get the standard script type.
 * @returns {ScriptType}
 */

Script.prototype.getType = function getType() {
  if (this.isPubkey())
    return scriptTypes.PUBKEY;

  if (this.isPubkeyhash())
    return scriptTypes.PUBKEYHASH;

  if (this.isScripthash())
    return scriptTypes.SCRIPTHASH;

  if (this.isWitnessPubkeyhash())
    return scriptTypes.WITNESSPUBKEYHASH;

  if (this.isWitnessScripthash())
    return scriptTypes.WITNESSSCRIPTHASH;

  if (this.isWitnessMasthash())
    return scriptTypes.WITNESSMASTHASH;

  if (this.isMultisig())
    return scriptTypes.MULTISIG;

  if (this.isNulldata())
    return scriptTypes.NULLDATA;

  return scriptTypes.NONSTANDARD;
};

/**
 * Test whether a script is of an unknown/non-standard type.
 * @returns {Boolean}
 */

Script.prototype.isUnknown = function isUnknown() {
  return this.getType() === scriptTypes.NONSTANDARD;
};

/**
 * Test whether the script is standard by policy standards.
 * @returns {Boolean}
 */

Script.prototype.isStandard = function isStandard() {
  const [m, n] = this.getMultisig();

  if (m !== -1) {
    if (n < 1 || n > 3)
      return false;

    if (m < 1 || m > n)
      return false;

    return true;
  }

  if (this.isNulldata())
    return this.raw.length <= policy.MAX_OP_RETURN_BYTES;

  return this.getType() !== scriptTypes.NONSTANDARD;
};

/**
 * Calculate the size of the script
 * excluding the varint size bytes.
 * @returns {Number}
 */

Script.prototype.getSize = function getSize() {
  return this.raw.length;
};

/**
 * Calculate the size of the script
 * including the varint size bytes.
 * @returns {Number}
 */

Script.prototype.getVarSize = function getVarSize() {
  return encoding.sizeVarBytes(this.raw);
};

/**
 * "Guess" the address of the input script.
 * This method is not 100% reliable.
 * @returns {Address|null}
 */

Script.prototype.getInputAddress = function getInputAddress() {
  return Address.fromInputScript(this);
};

/**
 * Get the address of the script if present. Note that
 * pubkey and multisig scripts will be treated as though
 * they are pubkeyhash and scripthashes respectively.
 * @returns {Address|null}
 */

Script.prototype.getAddress = function getAddress() {
  return Address.fromScript(this);
};

/**
 * Get the hash160 of the raw script.
 * @param {String?} enc
 * @returns {Hash}
 */

Script.prototype.hash160 = function hash160(enc) {
  let hash = digest.hash160(this.toRaw());
  if (enc === 'hex')
    hash = hash.toString('hex');
  return hash;
};

/**
 * Get the sha256 of the raw script.
 * @param {String?} enc
 * @returns {Hash}
 */

Script.prototype.sha256 = function sha256(enc) {
  let hash = digest.sha256(this.toRaw());
  if (enc === 'hex')
    hash = hash.toString('hex');
  return hash;
};

/**
 * Test whether the output script is pay-to-pubkey.
 * @param {Boolean} [minimal=false] - Minimaldata only.
 * @returns {Boolean}
 */

Script.prototype.isPubkey = function isPubkey(minimal) {
  if (minimal) {
    return this.raw.length >= 35
      && (this.raw[0] === 33 || this.raw[0] === 65)
      && this.raw[0] + 2 === this.raw.length
      && this.raw[this.raw.length - 1] === opcodes.OP_CHECKSIG;
  }

  if (this.code.length !== 2)
    return false;

  const size = this.getLength(0);

  return (size === 33 || size === 65)
    && this.getOp(1) === opcodes.OP_CHECKSIG;
};

/**
 * Get P2PK key if present.
 * @param {Boolean} [minimal=false] - Minimaldata only.
 * @returns {Buffer|null}
 */

Script.prototype.getPubkey = function getPubkey(minimal) {
  if (!this.isPubkey(minimal))
    return null;

  if (minimal)
    return this.raw.slice(1, 1 + this.raw[0]);

  return this.getData(0);
};

/**
 * Test whether the output script is pay-to-pubkeyhash.
 * @param {Boolean} [minimal=false] - Minimaldata only.
 * @returns {Boolean}
 */

Script.prototype.isPubkeyhash = function isPubkeyhash(minimal) {
  if (minimal || this.raw.length === 25) {
    return this.raw.length === 25
      && this.raw[0] === opcodes.OP_DUP
      && this.raw[1] === opcodes.OP_HASH160
      && this.raw[2] === 0x14
      && this.raw[23] === opcodes.OP_EQUALVERIFY
      && this.raw[24] === opcodes.OP_CHECKSIG;
  }

  if (this.code.length !== 5)
    return false;

  return this.getOp(0) === opcodes.OP_DUP
    && this.getOp(1) === opcodes.OP_HASH160
    && this.getLength(2) === 20
    && this.getOp(3) === opcodes.OP_EQUALVERIFY
    && this.getOp(4) === opcodes.OP_CHECKSIG;
};

/**
 * Get P2PKH hash if present.
 * @param {Boolean} [minimal=false] - Minimaldata only.
 * @returns {Buffer|null}
 */

Script.prototype.getPubkeyhash = function getPubkeyhash(minimal) {
  if (!this.isPubkeyhash(minimal))
    return null;

  if (minimal)
    return this.raw.slice(3, 23);

  return this.getData(2);
};

/**
 * Test whether the output script is pay-to-multisig.
 * @param {Boolean} [minimal=false] - Minimaldata only.
 * @returns {Boolean}
 */

Script.prototype.isMultisig = function isMultisig(minimal) {
  if (this.code.length < 4 || this.code.length > 19)
    return false;

  if (this.getOp(-1) !== opcodes.OP_CHECKMULTISIG)
    return false;

  const m = this.getSmall(0);

  if (m < 1)
    return false;

  const n = this.getSmall(-2);

  if (n < 1 || m > n)
    return false;

  if (this.code.length !== n + 3)
    return false;

  for (let i = 1; i < n + 1; i++) {
    const op = this.code[i];
    const size = op.toLength();

    if (size !== 33 && size !== 65)
      return false;

    if (minimal && !op.isMinimal())
      return false;
  }

  return true;
};

/**
 * Get multisig m and n values if present.
 * @param {Boolean} [minimal=false] - Minimaldata only.
 * @returns {Array} [m, n]
 */

Script.prototype.getMultisig = function getMultisig(minimal) {
  if (!this.isMultisig(minimal))
    return [-1, -1];

  return [this.getSmall(0), this.getSmall(-2)];
};

/**
 * Test whether the output script is pay-to-scripthash. Note that
 * bitcoin itself requires scripthashes to be in strict minimaldata
 * encoding. Using `OP_HASH160 OP_PUSHDATA1 [hash] OP_EQUAL` will
 * _not_ be recognized as a scripthash.
 * @returns {Boolean}
 */

Script.prototype.isScripthash = function isScripthash() {
  return this.raw.length === 23
    && this.raw[0] === opcodes.OP_HASH160
    && this.raw[1] === 0x14
    && this.raw[22] === opcodes.OP_EQUAL;
};

/**
 * Get P2SH hash if present.
 * @returns {Buffer|null}
 */

Script.prototype.getScripthash = function getScripthash() {
  if (!this.isScripthash())
    return null;

  return this.getData(1);
};

/**
 * Test whether the output script is nulldata/opreturn.
 * @param {Boolean} [minimal=false] - Minimaldata only.
 * @returns {Boolean}
 */

Script.prototype.isNulldata = function isNulldata(minimal) {
  if (this.code.length === 0)
    return false;

  if (this.getOp(0) !== opcodes.OP_RETURN)
    return false;

  if (this.code.length === 1)
    return true;

  if (minimal) {
    if (this.raw.length > policy.MAX_OP_RETURN_BYTES)
      return false;
  }

  for (let i = 1; i < this.code.length; i++) {
    const op = this.code[i];

    if (op.value === -1)
      return false;

    if (op.value > opcodes.OP_16)
      return false;

    if (minimal && !op.isMinimal())
      return false;
  }

  return true;
};

/**
 * Get OP_RETURN data if present.
 * @param {Boolean} [minimal=false] - Minimaldata only.
 * @returns {Buffer|null}
 */

Script.prototype.getNulldata = function getNulldata(minimal) {
  if (!this.isNulldata(minimal))
    return null;

  for (let i = 1; i < this.code.length; i++) {
    const op = this.code[i];
    const data = op.toPush();
    if (data)
      return data;
  }

  return EMPTY_BUFFER;
};

/**
 * Test whether the output script is a segregated witness
 * commitment.
 * @returns {Boolean}
 */

Script.prototype.isCommitment = function isCommitment() {
  return this.raw.length >= 38
    && this.raw[0] === opcodes.OP_RETURN
    && this.raw[1] === 0x24
    && this.raw.readUInt32BE(2, true) === 0xaa21a9ed;
};

/**
 * Get the commitment hash if present.
 * @returns {Buffer|null}
 */

Script.prototype.getCommitment = function getCommitment() {
  if (!this.isCommitment())
    return null;

  return this.raw.slice(6, 38);
};

/**
 * Test whether the output script is a witness program.
 * Note that this will return true even for malformed
 * witness v0 programs.
 * @return {Boolean}
 */

Script.prototype.isProgram = function isProgram() {
  if (this.raw.length < 4 || this.raw.length > 42)
    return false;

  if (this.raw[0] !== opcodes.OP_0
      && (this.raw[0] < opcodes.OP_1 || this.raw[0] > opcodes.OP_16)) {
    return false;
  }

  if (this.raw[1] + 2 !== this.raw.length)
    return false;

  return true;
};

/**
 * Get the witness program if present.
 * @returns {Program|null}
 */

Script.prototype.getProgram = function getProgram() {
  if (!this.isProgram())
    return null;

  const version = this.getSmall(0);
  const data = this.getData(1);

  return new Program(version, data);
};

/**
 * Get the script to the equivalent witness
 * program (mimics wmccd's scriptForWitness).
 * @returns {Script|null}
 */

Script.prototype.forWitness = function forWitness() {
  if (this.isProgram())
    return this.clone();

  const pk = this.getPubkey();
  if (pk) {
    const hash = digest.hash160(pk);
    return Script.fromProgram(0, hash);
  }

  const pkh = this.getPubkeyhash();
  if (pkh)
    return Script.fromProgram(0, pkh);

  return Script.fromProgram(0, this.sha256());
};

/**
 * Test whether the output script is
 * a pay-to-witness-pubkeyhash program.
 * @returns {Boolean}
 */

Script.prototype.isWitnessPubkeyhash = function isWitnessPubkeyhash() {
  return this.raw.length === 22
    && this.raw[0] === opcodes.OP_0
    && this.raw[1] === 0x14;
};

/**
 * Get P2WPKH hash if present.
 * @returns {Buffer|null}
 */

Script.prototype.getWitnessPubkeyhash = function getWitnessPubkeyhash() {
  if (!this.isWitnessPubkeyhash())
    return null;

  return this.getData(1);
};

/**
 * Test whether the output script is
 * a pay-to-witness-scripthash program.
 * @returns {Boolean}
 */

Script.prototype.isWitnessScripthash = function isWitnessScripthash() {
  return this.raw.length === 34
    && this.raw[0] === opcodes.OP_0
    && this.raw[1] === 0x20;
};

/**
 * Get P2WSH hash if present.
 * @returns {Buffer|null}
 */

Script.prototype.getWitnessScripthash = function getWitnessScripthash() {
  if (!this.isWitnessScripthash())
    return null;

  return this.getData(1);
};

/**
 * Test whether the output script
 * is a pay-to-mast program.
 * @returns {Boolean}
 */

Script.prototype.isWitnessMasthash = function isWitnessMasthash() {
  return this.raw.length === 34
    && this.raw[0] === opcodes.OP_1
    && this.raw[1] === 0x20;
};

/**
 * Get P2WMH hash if present.
 * @returns {Buffer|null}
 */

Script.prototype.getWitnessMasthash = function getWitnessMasthash() {
  if (!this.isWitnessMasthash())
    return null;

  return this.getData(1);
};

/**
 * Test whether the output script is unspendable.
 * @returns {Boolean}
 */

Script.prototype.isUnspendable = function isUnspendable() {
  if (this.raw.length > consensus.MAX_SCRIPT_SIZE)
    return true;

  return this.raw.length > 0 && this.raw[0] === opcodes.OP_RETURN;
};

/**
 * "Guess" the type of the input script.
 * This method is not 100% reliable.
 * @returns {ScriptType}
 */

Script.prototype.getInputType = function getInputType() {
  if (this.isPubkeyInput())
    return scriptTypes.PUBKEY;

  if (this.isPubkeyhashInput())
    return scriptTypes.PUBKEYHASH;

  if (this.isScripthashInput())
    return scriptTypes.SCRIPTHASH;

  if (this.isMultisigInput())
    return scriptTypes.MULTISIG;

  return scriptTypes.NONSTANDARD;
};

/**
 * "Guess" the type of the input script.
 * This method is not 100% reliable.
 * @returns {ScriptType}
 */

Script.prototype.getInputTypeVal = function getInputTypeVal() {
  if (this.isPubkeyInput())
    return scriptTypesByVal[scriptTypes.PUBKEY];

  if (this.isPubkeyhashInput())
    return scriptTypesByVal[scriptTypes.PUBKEYHASH];

  if (this.isScripthashInput())
    return scriptTypesByVal[scriptTypes.SCRIPTHASH];

  if (this.isMultisigInput())
    return scriptTypesByVal[scriptTypes.MULTISIG];

  return scriptTypesByVal[scriptTypes.NONSTANDARD];
};

/**
 * "Guess" whether the input script is an unknown/non-standard type.
 * This method is not 100% reliable.
 * @returns {Boolean}
 */

Script.prototype.isUnknownInput = function isUnknownInput() {
  return this.getInputType() === scriptTypes.NONSTANDARD;
};

/**
 * "Guess" whether the input script is pay-to-pubkey.
 * This method is not 100% reliable.
 * @returns {Boolean}
 */

Script.prototype.isPubkeyInput = function isPubkeyInput() {
  if (this.code.length !== 1)
    return false;

  const size = this.getLength(0);

  return size >= 9 && size <= 73;
};

/**
 * Get P2PK signature if present.
 * @returns {Buffer|null}
 */

Script.prototype.getPubkeyInput = function getPubkeyInput() {
  if (!this.isPubkeyInput())
    return null;

  return this.getData(0);
};

/**
 * "Guess" whether the input script is pay-to-pubkeyhash.
 * This method is not 100% reliable.
 * @returns {Boolean}
 */

Script.prototype.isPubkeyhashInput = function isPubkeyhashInput() {
  if (this.code.length !== 2)
    return false;

  const sig = this.getLength(0);
  const key = this.getLength(1);

  return sig >= 9 && sig <= 73
    && (key === 33 || key === 65);
};

/**
 * Get P2PKH signature and key if present.
 * @returns {Array} [sig, key]
 */

Script.prototype.getPubkeyhashInput = function getPubkeyhashInput() {
  if (!this.isPubkeyhashInput())
    return [null, null];

  return [this.getData(0), this.getData(1)];
};

/**
 * "Guess" whether the input script is pay-to-multisig.
 * This method is not 100% reliable.
 * @returns {Boolean}
 */

Script.prototype.isMultisigInput = function isMultisigInput() {
  if (this.code.length < 2)
    return false;

  if (this.getOp(0) !== opcodes.OP_0)
    return false;

  if (this.getOp(1) > opcodes.OP_PUSHDATA4)
    return false;

  // We need to rule out scripthash
  // because it may look like multisig.
  if (this.isScripthashInput())
    return false;

  for (let i = 1; i < this.code.length; i++) {
    const size = this.getLength(i);
    if (size < 9 || size > 73)
      return false;
  }

  return true;
};

/**
 * Get multisig signatures if present.
 * @returns {Buffer[]|null}
 */

Script.prototype.getMultisigInput = function getMultisigInput() {
  if (!this.isMultisigInput())
    return null;

  const sigs = [];

  for (let i = 1; i < this.code.length; i++)
    sigs.push(this.getData(i));

  return sigs;
};

/**
 * "Guess" whether the input script is pay-to-scripthash.
 * This method is not 100% reliable.
 * @returns {Boolean}
 */

Script.prototype.isScripthashInput = function isScripthashInput() {
  if (this.code.length < 2)
    return false;

  // Grab the raw redeem script.
  const raw = this.getData(-1);

  // Last data element should be an array
  // for the redeem script.
  if (!raw)
    return false;

  // Testing for scripthash inputs requires
  // some evil magic to work. We do it by
  // ruling things _out_. This test will not
  // be correct 100% of the time. We rule
  // out that the last data element is: a
  // null dummy, a valid signature, a valid
  // key, and we ensure that it is at least
  // a script that does not use undefined
  // opcodes.
  if (raw.length === 0)
    return false;

  if (common.isSignatureEncoding(raw))
    return false;

  if (common.isKeyEncoding(raw))
    return false;

  const redeem = Script.fromRaw(raw);

  if (!redeem.isCode())
    return false;

  if (redeem.isUnspendable())
    return false;

  if (!this.isPushOnly())
    return false;

  return true;
};

/**
 * Get P2SH redeem script if present.
 * @returns {Buffer|null}
 */

Script.prototype.getScripthashInput = function getScripthashInput() {
  if (!this.isScripthashInput())
    return null;

  return this.getData(-1);
};

/**
 * Get coinbase height.
 * @returns {Number} `-1` if not present.
 */

Script.prototype.getCoinbaseHeight = function getCoinbaseHeight() {
  return Script.getCoinbaseHeight(this.raw);
};

/**
 * Get coinbase height.
 * @param {Buffer} raw - Raw script.
 * @returns {Number} `-1` if not present.
 */

Script.getCoinbaseHeight = function getCoinbaseHeight(raw) {
  if (raw.length === 0)
    return -1;

  if (raw[0] >= opcodes.OP_1 && raw[0] <= opcodes.OP_16)
    return raw[0] - 0x50;

  if (raw[0] > 0x06)
    return -1;

  const op = Opcode.fromRaw(raw);
  const num = op.toNum();

  if (!num)
    return 1;

  if (num.isNeg())
    return -1;

  if (!op.equals(Opcode.fromNum(num)))
    return -1;

  return num.toDouble();
};

/**
 * Test the script against a bloom filter.
 * @param {Bloom} filter
 * @returns {Boolean}
 */

Script.prototype.test = function test(filter) {
  for (const op of this.code) {
    if (op.value === -1)
      break;

    if (!op.data || op.data.length === 0)
      continue;

    if (filter.test(op.data))
      return true;
  }

  return false;
};

/**
 * Test the script to see if it contains only push ops.
 * Push ops are: OP_1NEGATE, OP_0-OP_16 and all PUSHDATAs.
 * @returns {Boolean}
 */

Script.prototype.isPushOnly = function isPushOnly() {
  for (const op of this.code) {
    if (op.value === -1)
      return false;

    if (op.value > opcodes.OP_16)
      return false;
  }

  return true;
};

/**
 * Count the sigops in the script.
 * @param {Boolean} accurate - Whether to enable accurate counting. This will
 * take into account the `n` value for OP_CHECKMULTISIG(VERIFY).
 * @returns {Number} sigop count
 */

Script.prototype.getSigops = function getSigops(accurate) {
  let total = 0;
  let lastOp = -1;

  for (const op of this.code) {
    if (op.value === -1)
      break;

    switch (op.value) {
      case opcodes.OP_CHECKSIG:
      case opcodes.OP_CHECKSIGVERIFY:
        total += 1;
        break;
      case opcodes.OP_CHECKMULTISIG:
      case opcodes.OP_CHECKMULTISIGVERIFY:
        if (accurate && lastOp >= opcodes.OP_1 && lastOp <= opcodes.OP_16)
          total += lastOp - 0x50;
        else
          total += consensus.MAX_MULTISIG_PUBKEYS;
        break;
    }

    lastOp = op.value;
  }

  return total;
};

/**
 * Count the sigops in the script, taking into account redeem scripts.
 * @param {Script} input - Input script, needed for access to redeem script.
 * @returns {Number} sigop count
 */

Script.prototype.getScripthashSigops = function getScripthashSigops(input) {
  if (!this.isScripthash())
    return this.getSigops(true);

  const redeem = input.getRedeem();

  if (!redeem)
    return 0;

  return redeem.getSigops(true);
};

/**
 * Count the sigops in a script, taking into account witness programs.
 * @param {Script} input
 * @param {Witness} witness
 * @returns {Number} sigop count
 */

Script.prototype.getWitnessSigops = function getWitnessSigops(input, witness) {
  let program = this.getProgram();

  if (!program) {
    if (this.isScripthash()) {
      const redeem = input.getRedeem();
      if (redeem)
        program = redeem.getProgram();
    }
  }

  if (!program)
    return 0;

  if (program.version === 0) {
    if (program.data.length === 20)
      return 1;

    if (program.data.length === 32 && witness.items.length > 0) {
      const redeem = witness.getRedeem();
      return redeem.getSigops(true);
    }
  }

  return 0;
};

/*
 * Mutation
 */

Script.prototype.get = function get(index) {
  if (index < 0)
    index += this.code.length;

  if (index < 0 || index >= this.code.length)
    return null;

  return this.code[index];
};

Script.prototype.pop = function pop() {
  const op = this.code.pop();
  return op || null;
};

Script.prototype.shift = function shift() {
  const op = this.code.shift();
  return op || null;
};

Script.prototype.remove = function remove(index) {
  if (index < 0)
    index += this.code.length;

  if (index < 0 || index >= this.code.length)
    return null;

  const items = this.code.splice(index, 1);

  if (items.length === 0)
    return null;

  return items[0];
};

Script.prototype.set = function set(index, op) {
  if (index < 0)
    index += this.code.length;

  assert(Opcode.isOpcode(op));
  assert(index >= 0 && index <= this.code.length);

  this.code[index] = op;

  return this;
};

Script.prototype.push = function push(op) {
  assert(Opcode.isOpcode(op));
  this.code.push(op);
  return this;
};

Script.prototype.unshift = function unshift(op) {
  assert(Opcode.isOpcode(op));
  this.code.unshift(op);
  return this;
};

Script.prototype.insert = function insert(index, op) {
  if (index < 0)
    index += this.code.length;

  assert(Opcode.isOpcode(op));
  assert(index >= 0 && index <= this.code.length);

  this.code.splice(index, 0, op);

  return this;
};

/*
 * Op
 */

Script.prototype.getOp = function getOp(index) {
  const op = this.get(index);
  return op ? op.value : -1;
};

Script.prototype.popOp = function popOp() {
  const op = this.pop();
  return op ? op.value : -1;
};

Script.prototype.shiftOp = function shiftOp() {
  const op = this.shift();
  return op ? op.value : -1;
};

Script.prototype.removeOp = function removeOp(index) {
  const op = this.remove(index);
  return op ? op.value : -1;
};

Script.prototype.setOp = function setOp(index, value) {
  return this.set(index, Opcode.fromOp(value));
};

Script.prototype.pushOp = function pushOp(value) {
  return this.push(Opcode.fromOp(value));
};

Script.prototype.unshiftOp = function unshiftOp(value) {
  return this.unshift(Opcode.fromOp(value));
};

Script.prototype.insertOp = function insertOp(index, value) {
  return this.insert(index, Opcode.fromOp(value));
};

/*
 * Data
 */

Script.prototype.getData = function getData(index) {
  const op = this.get(index);
  return op ? op.data : null;
};

Script.prototype.popData = function popData() {
  const op = this.pop();
  return op ? op.data : null;
};

Script.prototype.shiftData = function shiftData() {
  const op = this.shift();
  return op ? op.data : null;
};

Script.prototype.removeData = function removeData(index) {
  const op = this.remove(index);
  return op ? op.data : null;
};

Script.prototype.setData = function setData(index, data) {
  return this.set(index, Opcode.fromData(data));
};

Script.prototype.pushData = function pushData(data) {
  return this.push(Opcode.fromData(data));
};

Script.prototype.unshiftData = function unshiftData(data) {
  return this.unshift(Opcode.fromData(data));
};

Script.prototype.insertData = function insertData(index, data) {
  return this.insert(index, Opcode.fromData(data));
};

/*
 * Length
 */

Script.prototype.getLength = function getLength(index) {
  const op = this.get(index);
  return op ? op.toLength() : -1;
};

/*
 * Push
 */

Script.prototype.getPush = function getPush(index) {
  const op = this.get(index);
  return op ? op.toPush() : null;
};

Script.prototype.popPush = function popPush() {
  const op = this.pop();
  return op ? op.toPush() : null;
};

Script.prototype.shiftPush = function shiftPush() {
  const op = this.shift();
  return op ? op.toPush() : null;
};

Script.prototype.removePush = function removePush(index) {
  const op = this.remove(index);
  return op ? op.toPush() : null;
};

Script.prototype.setPush = function setPush(index, data) {
  return this.set(index, Opcode.fromPush(data));
};

Script.prototype.pushPush = function pushPush(data) {
  return this.push(Opcode.fromPush(data));
};

Script.prototype.unshiftPush = function unshiftPush(data) {
  return this.unshift(Opcode.fromPush(data));
};

Script.prototype.insertPush = function insertPush(index, data) {
  return this.insert(index, Opcode.fromPush(data));
};

/*
 * String
 */

Script.prototype.getString = function getString(index, enc) {
  const op = this.get(index);
  return op ? op.toString(enc) : null;
};

Script.prototype.popString = function popString(enc) {
  const op = this.pop();
  return op ? op.toString(enc) : null;
};

Script.prototype.shiftString = function shiftString(enc) {
  const op = this.shift();
  return op ? op.toString(enc) : null;
};

Script.prototype.removeString = function removeString(index, enc) {
  const op = this.remove(index);
  return op ? op.toString(enc) : null;
};

Script.prototype.setString = function setString(index, str, enc) {
  return this.set(index, Opcode.fromString(str, enc));
};

Script.prototype.pushString = function pushString(str, enc) {
  return this.push(Opcode.fromString(str, enc));
};

Script.prototype.unshiftString = function unshiftString(str, enc) {
  return this.unshift(Opcode.fromString(str, enc));
};

Script.prototype.insertString = function insertString(index, str, enc) {
  return this.insert(index, Opcode.fromString(str, enc));
};

/*
 * Small
 */

Script.prototype.getSmall = function getSmall(index) {
  const op = this.get(index);
  return op ? op.toSmall() : -1;
};

Script.prototype.popSmall = function popSmall() {
  const op = this.pop();
  return op ? op.toSmall() : -1;
};

Script.prototype.shiftSmall = function shiftSmall() {
  const op = this.shift();
  return op ? op.toSmall() : -1;
};

Script.prototype.removeSmall = function removeSmall(index) {
  const op = this.remove(index);
  return op ? op.toSmall() : -1;
};

Script.prototype.setSmall = function setSmall(index, num) {
  return this.set(index, Opcode.fromSmall(num));
};

Script.prototype.pushSmall = function pushSmall(num) {
  return this.push(Opcode.fromSmall(num));
};

Script.prototype.unshiftSmall = function unshiftSmall(num) {
  return this.unshift(Opcode.fromSmall(num));
};

Script.prototype.insertSmall = function insertSmall(index, num) {
  return this.insert(index, Opcode.fromSmall(num));
};

/*
 * Num
 */

Script.prototype.getNum = function getNum(index, minimal, limit) {
  const op = this.get(index);
  return op ? op.toNum(minimal, limit) : null;
};

Script.prototype.popNum = function popNum(minimal, limit) {
  const op = this.pop();
  return op ? op.toNum(minimal, limit) : null;
};

Script.prototype.shiftNum = function shiftNum(minimal, limit) {
  const op = this.shift();
  return op ? op.toNum(minimal, limit) : null;
};

Script.prototype.removeNum = function removeNum(index, minimal, limit) {
  const op = this.remove(index);
  return op ? op.toNum(minimal, limit) : null;
};

Script.prototype.setNum = function setNum(index, num) {
  return this.set(index, Opcode.fromNum(num));
};

Script.prototype.pushNum = function pushNum(num) {
  return this.push(Opcode.fromNum(num));
};

Script.prototype.unshiftNum = function unshiftNum(num) {
  return this.unshift(Opcode.fromNum(num));
};

Script.prototype.insertNum = function insertNum(index, num) {
  return this.insert(index, Opcode.fromNum(num));
};

/*
 * Int
 */

Script.prototype.getInt = function getInt(index, minimal, limit) {
  const op = this.get(index);
  return op ? op.toInt(minimal, limit) : -1;
};

Script.prototype.popInt = function popInt(minimal, limit) {
  const op = this.pop();
  return op ? op.toInt(minimal, limit) : -1;
};

Script.prototype.shiftInt = function shiftInt(minimal, limit) {
  const op = this.shift();
  return op ? op.toInt(minimal, limit) : -1;
};

Script.prototype.removeInt = function removeInt(index, minimal, limit) {
  const op = this.remove(index);
  return op ? op.toInt(minimal, limit) : -1;
};

Script.prototype.setInt = function setInt(index, num) {
  return this.set(index, Opcode.fromInt(num));
};

Script.prototype.pushInt = function pushInt(num) {
  return this.push(Opcode.fromInt(num));
};

Script.prototype.unshiftInt = function unshiftInt(num) {
  return this.unshift(Opcode.fromInt(num));
};

Script.prototype.insertInt = function insertInt(index, num) {
  return this.insert(index, Opcode.fromInt(num));
};

/*
 * Bool
 */

Script.prototype.getBool = function getBool(index) {
  const op = this.get(index);
  return op ? op.toBool() : false;
};

Script.prototype.popBool = function popBool() {
  const op = this.pop();
  return op ? op.toBool() : false;
};

Script.prototype.shiftBool = function shiftBool() {
  const op = this.shift();
  return op ? op.toBool() : false;
};

Script.prototype.removeBool = function removeBool(index) {
  const op = this.remove(index);
  return op ? op.toBool() : false;
};

Script.prototype.setBool = function setBool(index, value) {
  return this.set(index, Opcode.fromBool(value));
};

Script.prototype.pushBool = function pushBool(value) {
  return this.push(Opcode.fromBool(value));
};

Script.prototype.unshiftBool = function unshiftBool(value) {
  return this.unshift(Opcode.fromBool(value));
};

Script.prototype.insertBool = function insertBool(index, value) {
  return this.insert(index, Opcode.fromBool(value));
};

/*
 * Symbol
 */

Script.prototype.getSym = function getSym(index) {
  const op = this.get(index);
  return op ? op.toSymbol() : null;
};

Script.prototype.popSym = function popSym() {
  const op = this.pop();
  return op ? op.toSymbol() : null;
};

Script.prototype.shiftSym = function shiftSym() {
  const op = this.shift();
  return op ? op.toSymbol() : null;
};

Script.prototype.removeSym = function removeSym(index) {
  const op = this.remove(index);
  return op ? op.toSymbol() : null;
};

Script.prototype.setSym = function setSym(index, symbol) {
  return this.set(index, Opcode.fromSymbol(symbol));
};

Script.prototype.pushSym = function pushSym(symbol) {
  return this.push(Opcode.fromSymbol(symbol));
};

Script.prototype.unshiftSym = function unshiftSym(symbol) {
  return this.unshift(Opcode.fromSymbol(symbol));
};

Script.prototype.insertSym = function insertSym(index, symbol) {
  return this.insert(index, Opcode.fromSymbol(symbol));
};

/**
 * Inject properties from wmccd test string.
 * @private
 * @param {String} items - Script string.
 * @throws Parse error.
 */

Script.prototype.fromString = function fromString(code) {
  assert(typeof code === 'string');

  code = code.trim();

  if (code.length === 0)
    return this;

  const items = code.split(/\s+/);
  const bw = new BufferWriter();

  for (const item of items) {
    let symbol = item;

    if (!util.isUpperCase(symbol))
      symbol = symbol.toUpperCase();

    if (!util.startsWith(symbol, 'OP_'))
      symbol = `OP_${symbol}`;

    const value = opcodes[symbol];

    if (value == null) {
      if (item[0] === '\'') {
        assert(item[item.length - 1] === '\'', 'Invalid string.');
        const str = item.slice(1, -1);
        const op = Opcode.fromString(str);
        bw.writeBytes(op.toRaw());
        continue;
      }

      if (/^-?\d+$/.test(item)) {
        const num = ScriptNum.fromString(item, 10);
        const op = Opcode.fromNum(num);
        bw.writeBytes(op.toRaw());
        continue;
      }

      assert(item.indexOf('0x') === 0, 'Unknown opcode.');

      const hex = item.substring(2);
      const data = Buffer.from(hex, 'hex');

      assert(data.length === hex.length / 2, 'Invalid hex string.');

      bw.writeBytes(data);

      continue;
    }

    bw.writeU8(value);
  }

  return this.fromRaw(bw.render());
};

/**
 * Parse a wmccd test script
 * string into a script object.
 * @param {String} items - Script string.
 * @returns {Script}
 * @throws Parse error.
 */

Script.fromString = function fromString(code) {
  return new Script().fromString(code);
};

/**
 * Verify an input and output script, and a witness if present.
 * @param {Script} input
 * @param {Witness} witness
 * @param {Script} output
 * @param {TX} tx
 * @param {Number} index
 * @param {Amount} value
 * @param {VerifyFlags} flags
 * @throws {ScriptError}
 */

Script.verify = function verify(input, witness, output, tx, index, value, flags) {
  if (flags == null)
    flags = Script.flags.STANDARD_VERIFY_FLAGS;

  if (flags & Script.flags.VERIFY_SIGPUSHONLY) {
    if (!input.isPushOnly())
      throw new ScriptError('SIG_PUSHONLY');
  }

  // Setup a stack.
  let stack = new Stack();

  // Execute the input script
  input.execute(stack, flags, tx, index, value, 0);

  // Copy the stack for P2SH
  let copy;
  if (flags & Script.flags.VERIFY_P2SH)
    copy = stack.clone();

  // Execute the previous output script.
  output.execute(stack, flags, tx, index, value, 0);

  // Verify the stack values.
  if (stack.length === 0 || !stack.getBool(-1))
    throw new ScriptError('EVAL_FALSE');

  let hadWitness = false;

  if ((flags & Script.flags.VERIFY_WITNESS) && output.isProgram()) {
    hadWitness = true;

    // Input script must be empty.
    if (input.raw.length !== 0)
      throw new ScriptError('WITNESS_MALLEATED');

    // Verify the program in the output script.
    Script.verifyProgram(witness, output, flags, tx, index, value);

    // Force a cleanstack
    stack.length = 1;
  }

  // If the script is P2SH, execute the real output script
  if ((flags & Script.flags.VERIFY_P2SH) && output.isScripthash()) {
    // P2SH can only have push ops in the scriptSig
    if (!input.isPushOnly())
      throw new ScriptError('SIG_PUSHONLY');

    // Reset the stack
    stack = copy;

    // Stack should not be empty at this point
    if (stack.length === 0)
      throw new ScriptError('EVAL_FALSE');

    // Grab the real redeem script
    const raw = stack.pop();
    const redeem = Script.fromRaw(raw);

    // Execute the redeem script.
    redeem.execute(stack, flags, tx, index, value, 0);

    // Verify the the stack values.
    if (stack.length === 0 || !stack.getBool(-1))
      throw new ScriptError('EVAL_FALSE');

    if ((flags & Script.flags.VERIFY_WITNESS) && redeem.isProgram()) {
      hadWitness = true;

      // Input script must be exactly one push of the redeem script.
      if (!input.raw.equals(Opcode.fromPush(raw).toRaw()))
        throw new ScriptError('WITNESS_MALLEATED_P2SH');

      // Verify the program in the redeem script.
      Script.verifyProgram(witness, redeem, flags, tx, index, value);

      // Force a cleanstack.
      stack.length = 1;
    }
  }

  // Ensure there is nothing left on the stack.
  if (flags & Script.flags.VERIFY_CLEANSTACK) {
    assert((flags & Script.flags.VERIFY_P2SH) !== 0);
    if (stack.length !== 1)
      throw new ScriptError('CLEANSTACK');
  }

  // If we had a witness but no witness program, fail.
  if (flags & Script.flags.VERIFY_WITNESS) {
    assert((flags & Script.flags.VERIFY_P2SH) !== 0);
    if (!hadWitness && witness.items.length > 0)
      throw new ScriptError('WITNESS_UNEXPECTED');
  }
};

/**
 * Verify a witness program. This runs after regular script
 * execution if a witness program is present. It will convert
 * the witness to a stack and execute the program.
 * @param {Witness} witness
 * @param {Script} output
 * @param {VerifyFlags} flags
 * @param {TX} tx
 * @param {Number} index
 * @param {Amount} value
 * @throws {ScriptError}
 */

Script.verifyProgram = function verifyProgram(witness, output, flags, tx, index, value) {
  const program = output.getProgram();

  assert(program, 'verifyProgram called on non-witness-program.');
  assert((flags & Script.flags.VERIFY_WITNESS) !== 0);

  const stack = witness.toStack();
  let redeem;

  if (program.version === 0) {
    if (program.data.length === 32) {
      if (stack.length === 0)
        throw new ScriptError('WITNESS_PROGRAM_WITNESS_EMPTY');

      const witnessScript = stack.pop();

      if (!digest.sha256(witnessScript).equals(program.data))
        throw new ScriptError('WITNESS_PROGRAM_MISMATCH');

      redeem = Script.fromRaw(witnessScript);
    } else if (program.data.length === 20) {
      if (stack.length !== 2)
        throw new ScriptError('WITNESS_PROGRAM_MISMATCH');

      redeem = Script.fromPubkeyhash(program.data);
    } else {
      // Failure on version=0 (bad program data length).
      throw new ScriptError('WITNESS_PROGRAM_WRONG_LENGTH');
    }
  } else if ((flags & Script.flags.VERIFY_MAST) && program.version === 1) {
    Script.verifyMast(program, stack, output, flags, tx, index);
    return;
  } else {
    // Anyone can spend (we can return true here
    // if we want to always relay these transactions).
    // Otherwise, if we want to act like an "old"
    // implementation and only accept them in blocks,
    // we can use the regular output script which will
    // succeed in a block, but fail in the mempool
    // due to VERIFY_CLEANSTACK.
    if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)
      throw new ScriptError('DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM');
    return;
  }

  // Witnesses still have push limits.
  for (let j = 0; j < stack.length; j++) {
    if (stack.get(j).length > consensus.MAX_SCRIPT_PUSH)
      throw new ScriptError('PUSH_SIZE');
  }

  // Verify the redeem script.
  redeem.execute(stack, flags, tx, index, value, 1);

  // Verify the stack values.
  if (stack.length !== 1 || !stack.getBool(-1))
    throw new ScriptError('EVAL_FALSE');
};

/**
 * Verify a MAST witness program.
 * @param {Program} program
 * @param {Stack} stack
 * @param {Script} output
 * @param {VerifyFlags} flags
 * @param {TX} tx
 * @param {Number} index
 * @param {Amount} value
 * @throws {ScriptError}
 */

Script.verifyMast = function verifyMast(program, stack, output, flags, tx, index, value) {
  assert(program.version === 1);
  assert((flags & Script.flags.VERIFY_MAST) !== 0);

  if (stack.length < 4)
    throw new ScriptError('INVALID_MAST_STACK');

  const metadata = stack.get(-1);
  if (metadata.length < 1 || metadata.length > 5)
    throw new ScriptError('INVALID_MAST_STACK');

  const subscripts = metadata[0];
  if (subscripts === 0 || stack.length < subscripts + 3)
    throw new ScriptError('INVALID_MAST_STACK');

  let ops = subscripts;
  let scriptRoot = new BufferWriter();
  scriptRoot.writeU8(subscripts);

  if (metadata[metadata.length - 1] === 0x00)
    throw new ScriptError('INVALID_MAST_STACK');

  let version = 0;

  for (let j = 1; j < metadata.length; j++)
    version |= metadata[j] << 8 * (j - 1);

  if (version < 0)
    version += 0x100000000;

  if (version > 0) {
    if (flags & Script.flags.DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)
      throw new ScriptError('DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM');
  }

  let mastRoot = new BufferWriter();
  mastRoot.writeU32(version);

  const pathdata = stack.get(-2);

  if (pathdata.length & 0x1f)
    throw new ScriptError('INVALID_MAST_STACK');

  const depth = pathdata.length >>> 5;

  if (depth > 32)
    throw new ScriptError('INVALID_MAST_STACK');

  ops += depth;
  if (version === 0) {
    if (ops > consensus.MAX_SCRIPT_OPS)
      throw new ScriptError('OP_COUNT');
  }

  const path = [];

  for (let j = 0; j < depth; j++)
    path.push(pathdata.slice(j * 32, j * 32 + 32));

  const posdata = stack.get(-3);

  if (posdata.length > 4)
    throw new ScriptError('INVALID_MAST_STACK');

  let pos = 0;
  if (posdata.length > 0) {
    if (posdata[posdata.length - 1] === 0x00)
      throw new ScriptError('INVALID_MAST_STACK');

    for (let j = 0; j < posdata.length; j++)
      pos |= posdata[j] << 8 * j;

    if (pos < 0)
      pos += 0x100000000;
  }

  if (depth < 32) {
    if (pos >= ((1 << depth) >>> 0))
      throw new ScriptError('INVALID_MAST_STACK');
  }

  let scripts = new BufferWriter();
  scripts.writeBytes(output.raw);

  for (let j = 0; j < subscripts; j++) {
    const script = stack.get(-(4 + j));
    if (version === 0) {
      if ((scripts.offset + script.length) > consensus.MAX_SCRIPT_SIZE)
        throw new ScriptError('SCRIPT_SIZE');
    }
    scriptRoot.writeBytes(digest.hash256(script));
    scripts.writeBytes(script);
  }

  scriptRoot = digest.hash256(scriptRoot.render());
  scriptRoot = merkle.verifyBranch(scriptRoot, path, pos);

  mastRoot.writeBytes(scriptRoot);
  mastRoot = digest.hash256(mastRoot.render());

  if (!mastRoot.equals(program.data))
    throw new ScriptError('WITNESS_PROGRAM_MISMATCH');

  if (version === 0) {
    stack.length -= 3 + subscripts;

    for (let j = 0; j < stack.length; j++) {
      if (stack.get(j).length > consensus.MAX_SCRIPT_PUSH)
        throw new ScriptError('PUSH_SIZE');
    }

    scripts = scripts.render();
    output = Script.fromRaw(scripts);
    output.execute(stack, flags, tx, index, value, 1);

    if (stack.length !== 0)
      throw new ScriptError('EVAL_FALSE');
  }
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

Script.prototype.fromReader = function fromReader(br) {
  return this.fromRaw(br.readVarBytes());
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer}
 */

Script.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);

  this.raw = data;

  while (br.left())
    this.code.push(Opcode.fromReader(br));

  return this;
};

/**
 * Create a script from buffer reader.
 * @param {BufferReader} br
 * @param {String?} enc - Either `"hex"` or `null`.
 * @returns {Script}
 */

Script.fromReader = function fromReader(br) {
  return new Script().fromReader(br);
};

/**
 * Create a script from a serialized buffer.
 * @param {Buffer|String} data - Serialized script.
 * @param {String?} enc - Either `"hex"` or `null`.
 * @returns {Script}
 */

Script.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new Script().fromRaw(data);
};

/**
 * Test whether an object a Script.
 * @param {Object} obj
 * @returns {Boolean}
 */

Script.isScript = function isScript(obj) {
  return obj instanceof Script;
};

/*
 * Helpers
 */

function sortKeys(keys) {
  return keys.slice().sort((a, b) => {
    return a.compare(b);
  });
}

/**
 * Test whether the data element is a valid key if VERIFY_STRICTENC is enabled.
 * @param {Buffer} key
 * @param {VerifyFlags?} flags
 * @returns {Boolean}
 * @throws {ScriptError}
 */

function validateKey(key, flags, version) {
  assert(Buffer.isBuffer(key));
  assert(typeof flags === 'number');
  assert(typeof version === 'number');

  if (flags & Script.flags.VERIFY_STRICTENC) {
    if (!common.isKeyEncoding(key))
      throw new ScriptError('PUBKEYTYPE');
  }

  if (version === 1) {
    if (flags & Script.flags.VERIFY_WITNESS_PUBKEYTYPE) {
      if (!common.isCompressedEncoding(key))
        throw new ScriptError('WITNESS_PUBKEYTYPE');
    }
  }

  return true;
}

/**
 * Test whether the data element is a valid signature based
 * on the encoding, S value, and sighash type. Requires
 * VERIFY_DERSIG|VERIFY_LOW_S|VERIFY_STRICTENC, VERIFY_LOW_S
 * and VERIFY_STRING_ENC to be enabled respectively. Note that
 * this will allow zero-length signatures.
 * @param {Buffer} sig
 * @param {VerifyFlags?} flags
 * @returns {Boolean}
 * @throws {ScriptError}
 */

function validateSignature(sig, flags) {
  assert(Buffer.isBuffer(sig));
  assert(typeof flags === 'number');

  // Allow empty sigs
  if (sig.length === 0)
    return true;

  if ((flags & Script.flags.VERIFY_DERSIG)
      || (flags & Script.flags.VERIFY_LOW_S)
      || (flags & Script.flags.VERIFY_STRICTENC)) {
    if (!common.isSignatureEncoding(sig))
      throw new ScriptError('SIG_DER');
  }

  if (flags & Script.flags.VERIFY_LOW_S) {
    if (!common.isLowDER(sig))
      throw new ScriptError('SIG_HIGH_S');
  }

  if (flags & Script.flags.VERIFY_STRICTENC) {
    if (!common.isHashType(sig))
      throw new ScriptError('SIG_HASHTYPE');
  }

  return true;
}

/**
 * Verify a signature, taking into account sighash type.
 * @param {Buffer} msg - Signature hash.
 * @param {Buffer} sig
 * @param {Buffer} key
 * @returns {Boolean}
 */

function checksig(msg, sig, key) {
  return secp256k1.verify(msg, sig.slice(0, -1), key);
}

/*
 * Expose
 */

module.exports = Script;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = exports;

elliptic.version = __webpack_require__(140).version;
elliptic.utils = __webpack_require__(141);
elliptic.rand = __webpack_require__(142);
elliptic.curve = __webpack_require__(39);
elliptic.curves = __webpack_require__(148);

// Protocols
elliptic.ec = __webpack_require__(156);
elliptic.eddsa = __webpack_require__(159);


/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * address.js - address object for wmcc_core.
 */



const assert = __webpack_require__(0);
const Network = __webpack_require__(6);
const encoding = __webpack_require__(3);
const util = __webpack_require__(1);
const digest = __webpack_require__(5);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const base58 = __webpack_require__(26);
const bech32 = __webpack_require__(99);

/**
 * Represents an address.
 * @alias module:primitives.Address
 * @constructor
 * @param {Object?} options
 * @property {Buffer} hash
 * @property {AddressPrefix} type
 * @property {Number} version
 * @property {Network} network
 */

function Address(options) {
  if (!(this instanceof Address))
    return new Address(options);

  this.hash = encoding.ZERO_HASH160;
  this.type = Address.types.PUBKEYHASH;
  this.version = -1;
  this.network = Network.primary;

  if (options)
    this.fromOptions(options);
}

/**
 * Address types.
 * @enum {Number}
 */

Address.types = {
  PUBKEYHASH: 2,
  SCRIPTHASH: 3,
  WITNESS: 4
};

/**
 * Address types by value.
 * @const {RevMap}
 */

Address.typesByVal = util.reverse(Address.types);

/**
 * Address scriptTypes.
 * @enum {Number}
 */

Address.scriptTypes = {
  NONSTANDARD: 0,
  //PUBKEY: 1,
  PUBKEYHASH: 2,
  SCRIPTHASH: 3,
  //MULTISIG: 4,
  //NULLDATA: 5,
  //WITNESSMALFORMED: 0x80 | 0,
  WITNESSSCRIPTHASH: 0x80 | 1,
  WITNESSPUBKEYHASH: 0x80 | 2,
  WITNESSMASTHASH: 0x80 | 3
};

/**
 * Address scriptTypes by value.
 * @const {RevMap}
 */

Address.scriptTypesByVal = util.reverse(Address.scriptTypes);

/**
 * Inject properties from options object.
 * @private
 * @param {Object} options
 */

Address.prototype.fromOptions = function fromOptions(options) {
  if (typeof options === 'string')
    return this.fromString(options);

  return this.fromHash(
    options.hash,
    options.type,
    options.version,
    options.network
  );
};

/**
 * Insantiate address from options.
 * @param {Object} options
 * @returns {Address}
 */

Address.fromOptions = function fromOptions(options) {
  return new Address().fromOptions(options);
};

/**
 * Get the address hash.
 * @param {String?} enc - Can be `"hex"` or `null`.
 * @returns {Hash|Buffer}
 */

Address.prototype.getHash = function getHash(enc) {
  if (enc === 'hex')
    return this.hash.toString(enc);
  return this.hash;
};

/**
 * Test whether the address is null.
 * @returns {Boolean}
 */

Address.prototype.isNull = function isNull() {
  if (this.hash.length === 20)
    return this.hash.equals(encoding.ZERO_HASH160);

  if (this.hash.length === 32)
    return this.hash.equals(encoding.ZERO_HASH);

  for (let i = 0; i < this.hash.length; i++) {
    if (this.hash[i] !== 0)
      return false;
  }

  return true;
};

/**
 * Test equality against another address.
 * @param {Address} addr
 * @returns {Boolean}
 */

Address.prototype.equals = function equals(addr) {
  assert(addr instanceof Address);

  return this.network === addr.network
    && this.type === addr.type
    && this.version === addr.version
    && this.hash.equals(addr.hash);
};

/**
 * Get the address type as a string.
 * @returns {String}
 */

Address.prototype.getType = function getType() {
  return Address.typesByVal[this.type].toLowerCase();
};

/**
 * Get the standard script type.
 * @returns {ScriptType}
 */

Address.prototype.getScriptType = function getScriptType() {
  //if (this.isPubkey())
  //  return scriptTypes.PUBKEY;

  if (this.isPubkeyhash())
    return Address.scriptTypes.PUBKEYHASH;

  if (this.isScripthash())
    return Address.scriptTypes.SCRIPTHASH;

  if (this.isWitnessPubkeyhash())
    return Address.scriptTypes.WITNESSPUBKEYHASH;

  if (this.isWitnessScripthash())
    return Address.scriptTypes.WITNESSSCRIPTHASH;

  if (this.isWitnessMasthash())
    return Address.scriptTypes.WITNESSMASTHASH;

  //if (this.isMultisig())
  //  return scriptTypes.MULTISIG;

  //if (this.isNulldata())
  //  return scriptTypes.NULLDATA;

  return Address.scriptTypes.NONSTANDARD;
};

/**
 * Get a network address prefix for the address.
 * @param {Network?} network
 * @returns {Number}
 */

Address.prototype.getPrefix = function getPrefix(network) {
  if (!network)
    network = this.network;

  network = Network.get(network);

  const prefixes = network.addressPrefix;

  switch (this.type) {
    case Address.types.PUBKEYHASH:
      return prefixes.pubkeyhash;
    case Address.types.SCRIPTHASH:
      return prefixes.scripthash;
    case Address.types.WITNESS:
      if (this.hash.length === 20)
        return prefixes.witnesspubkeyhash;

      if (this.hash.length === 32)
        return prefixes.witnessscripthash;

      break;
  }

  return -1;
};

/**
 * Calculate size of serialized address.
 * @returns {Number}
 */

Address.prototype.getSize = function getSize() {
  let size = 5 + this.hash.length;

  if (this.version !== -1)
    size += 2;

  return size;
};

/**
 * Compile the address object to its raw serialization.
 * @param {{NetworkType|Network)?} network
 * @returns {Buffer}
 * @throws Error on bad hash/prefix.
 */

Address.prototype.toRaw = function toRaw(network) {
  const size = this.getSize();
  const bw = new StaticWriter(size);
  const prefix = this.getPrefix(network);

  assert(prefix !== -1, 'Not a valid address prefix.');

  bw.writeU8(prefix);

  if (this.version !== -1) {
    bw.writeU8(this.version);
    bw.writeU8(0);
  }

  bw.writeBytes(this.hash);
  bw.writeChecksum();

  return bw.render();
};

/**
 * Compile the address object to a base58 address.
 * @param {{NetworkType|Network)?} network
 * @returns {Base58Address}
 * @throws Error on bad hash/prefix.
 */

Address.prototype.toBase58 = function toBase58(network) {
  return base58.encode(this.toRaw(network));
};

/**
 * Compile the address object to a bech32 address.
 * @param {{NetworkType|Network)?} network
 * @returns {String}
 * @throws Error on bad hash/prefix.
 */

Address.prototype.toBech32 = function toBech32(network) {
  const version = this.version;
  const hash = this.hash;

  assert(version !== -1,
    'Cannot convert non-program address to bech32.');

  if (!network)
    network = this.network;

  network = Network.get(network);

  const hrp = network.addressPrefix.bech32;

  return bech32.encode(hrp, version, hash);
};

/**
 * Inject properties from string.
 * @private
 * @param {String} addr
 * @param {(Network|NetworkType)?} network
 * @returns {Address}
 */

Address.prototype.fromString = function fromString(addr, network) {
  assert(typeof addr === 'string');
  assert(addr.length > 0);
  assert(addr.length <= 100);

  // If the address is mixed case,
  // it can only ever be base58.
  if (isMixedCase(addr))
    return this.fromBase58(addr, network);

  // Otherwise, it's most likely bech32.
  try {
    return this.fromBech32(addr, network);
  } catch (e) {
    return this.fromBase58(addr, network);
  }
};

/**
 * Instantiate address from string.
 * @param {String} addr
 * @param {(Network|NetworkType)?} network
 * @returns {Address}
 */

Address.fromString = function fromString(addr, network) {
  return new Address().fromString(addr, network);
};

/**
 * Convert the Address to a string.
 * @param {(Network|NetworkType)?} network
 * @returns {Base58Address}
 */

Address.prototype.toString = function toString(network) {
  if (this.version !== -1)
    return this.toBech32(network);
  return this.toBase58(network);
};

/**
 * Inspect the Address.
 * @returns {Object}
 */

Address.prototype.inspect = function inspect() {
  return '<Address:'
    + ` type=${this.getType()}`
    + ` version=${this.version}`
    + ` str=${this.toString()}`
    + '>';
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 * @throws Parse error
 */

Address.prototype.fromRaw = function fromRaw(data, network) {
  const br = new BufferReader(data, true);

  if (data.length > 40)
    throw new Error('Address is too long.');

  const prefix = br.readU8();

  network = Network.fromAddress(prefix, network);

  const type = Address.getType(prefix, network);

  let version = -1;
  if (data.length > 25) {
    version = br.readU8();

    if (br.readU8() !== 0)
      throw new Error('Address version padding is non-zero.');
  }

  const hash = br.readBytes(br.left() - 4);

  br.verifyChecksum();

  return this.fromHash(hash, type, version, network);
};

/**
 * Create an address object from a serialized address.
 * @param {Buffer} data
 * @returns {Address}
 * @throws Parse error.
 */

Address.fromRaw = function fromRaw(data, network) {
  return new Address().fromRaw(data, network);
};

/**
 * Inject properties from base58 address.
 * @private
 * @param {Base58Address} data
 * @param {Network?} network
 * @throws Parse error
 */

Address.prototype.fromBase58 = function fromBase58(data, network) {
  assert(typeof data === 'string');

  if (data.length > 55)
    throw new Error('Address is too long.');

  return this.fromRaw(base58.decode(data), network);
};

/**
 * Create an address object from a base58 address.
 * @param {Base58Address} data
 * @param {Network?} network
 * @returns {Address}
 * @throws Parse error.
 */

Address.fromBase58 = function fromBase58(data, network) {
  return new Address().fromBase58(data, network);
};

/**
 * Inject properties from bech32 address.
 * @private
 * @param {String} data
 * @param {Network?} network
 * @throws Parse error
 */

Address.prototype.fromBech32 = function fromBech32(data, network) {
  const type = Address.types.WITNESS;

  assert(typeof data === 'string');

  const addr = bech32.decode(data);

  network = Network.fromBech32(addr.hrp, network);

  return this.fromHash(addr.hash, type, addr.version, network);
};

/**
 * Create an address object from a bech32 address.
 * @param {String} data
 * @param {Network?} network
 * @returns {Address}
 * @throws Parse error.
 */

Address.fromBech32 = function fromBech32(data, network) {
  return new Address().fromBech32(data, network);
};

/**
 * Inject properties from output script.
 * @private
 * @param {Script} script
 */

Address.prototype.fromScript = function fromScript(script) {
  const pk = script.getPubkey();

  if (pk) {
    this.hash = digest.hash160(pk);
    this.type = Address.types.PUBKEYHASH;
    this.version = -1;
    return this;
  }

  const pkh = script.getPubkeyhash();

  if (pkh) {
    this.hash = pkh;
    this.type = Address.types.PUBKEYHASH;
    this.version = -1;
    return this;
  }

  const sh = script.getScripthash();

  if (sh) {
    this.hash = sh;
    this.type = Address.types.SCRIPTHASH;
    this.version = -1;
    return this;
  }

  const program = script.getProgram();

  if (program && !program.isMalformed()) {
    this.hash = program.data;
    this.type = Address.types.WITNESS;
    this.version = program.version;
    return this;
  }

  // Put this last: it's the slowest to check.
  if (script.isMultisig()) {
    this.hash = script.hash160();
    this.type = Address.types.SCRIPTHASH;
    this.version = -1;
    return this;
  }

  return null;
};

/**
 * Inject properties from witness.
 * @private
 * @param {Witness} witness
 */

Address.prototype.fromWitness = function fromWitness(witness) {
  const [, pk] = witness.getPubkeyhashInput();

  // We're pretty much screwed here
  // since we can't get the version.
  if (pk) {
    this.hash = digest.hash160(pk);
    this.type = Address.types.WITNESS;
    this.version = 0;
    return this;
  }

  const redeem = witness.getScripthashInput();

  if (redeem) {
    this.hash = digest.sha256(redeem);
    this.type = Address.types.WITNESS;
    this.version = 0;
    return this;
  }

  return null;
};

/**
 * Inject properties from input script.
 * @private
 * @param {Script} script
 */

Address.prototype.fromInputScript = function fromInputScript(script) {
  const [, pk] = script.getPubkeyhashInput();

  if (pk) {
    this.hash = digest.hash160(pk);
    this.type = Address.types.PUBKEYHASH;
    this.version = -1;
    return this;
  }

  const redeem = script.getScripthashInput();

  if (redeem) {
    this.hash = digest.hash160(redeem);
    this.type = Address.types.SCRIPTHASH;
    this.version = -1;
    return this;
  }

  return null;
};

/**
 * Create an Address from a witness.
 * Attempt to extract address
 * properties from a witness.
 * @param {Witness}
 * @returns {Address|null}
 */

Address.fromWitness = function fromWitness(witness) {
  return new Address().fromWitness(witness);
};

/**
 * Create an Address from an input script.
 * Attempt to extract address
 * properties from an input script.
 * @param {Script}
 * @returns {Address|null}
 */

Address.fromInputScript = function fromInputScript(script) {
  return new Address().fromInputScript(script);
};

/**
 * Create an Address from an output script.
 * Parse an output script and extract address
 * properties. Converts pubkey and multisig
 * scripts to pubkeyhash and scripthash addresses.
 * @param {Script}
 * @returns {Address|null}
 */

Address.fromScript = function fromScript(script) {
  return new Address().fromScript(script);
};

/**
 * Inject properties from a hash.
 * @private
 * @param {Buffer|Hash} hash
 * @param {AddressPrefix} type
 * @param {Number} [version=-1]
 * @param {(Network|NetworkType)?} network
 * @throws on bad hash size
 */

Address.prototype.fromHash = function fromHash(hash, type, version, network) {
  if (typeof hash === 'string')
    hash = Buffer.from(hash, 'hex');

  if (typeof type === 'string') {
    type = Address.types[type.toUpperCase()];
    assert(type != null, 'Not a valid address type.');
  }

  if (type == null)
    type = Address.types.PUBKEYHASH;

  if (version == null)
    version = -1;

  network = Network.get(network);

  assert(Buffer.isBuffer(hash));
  assert(util.isU8(type));
  assert(util.isI8(version));

  assert(type >= Address.types.PUBKEYHASH && type <= Address.types.WITNESS,
    'Not a valid address type.');

  if (version === -1) {
    assert(type !== Address.types.WITNESS, 'Wrong version (witness)');
    assert(hash.length === 20, 'Hash is the wrong size.');
  } else {
    assert(type === Address.types.WITNESS, 'Wrong version (non-witness).');
    assert(version >= 0 && version <= 16, 'Bad program version.');
    if (version === 0 && type === Address.types.WITNESS) {
      assert(hash.length === 20 || hash.length === 32,
        'Witness program hash is the wrong size.');
    }
    assert(hash.length >= 2 && hash.length <= 40, 'Hash is the wrong size.');
  }

  this.hash = hash;
  this.type = type;
  this.version = version;
  this.network = network;

  return this;
};

/**
 * Create a naked address from hash/type/version.
 * @param {Hash} hash
 * @param {AddressPrefix} type
 * @param {Number} [version=-1]
 * @param {(Network|NetworkType)?} network
 * @returns {Address}
 * @throws on bad hash size
 */

Address.fromHash = function fromHash(hash, type, version, network) {
  return new Address().fromHash(hash, type, version, network);
};

/**
 * Inject properties from pubkeyhash.
 * @private
 * @param {Buffer} hash
 * @param {Network?} network
 * @returns {Address}
 */

Address.prototype.fromPubkeyhash = function fromPubkeyhash(hash, network) {
  const type = Address.types.PUBKEYHASH;
  assert(hash.length === 20, 'P2PKH must be 20 bytes.');
  return this.fromHash(hash, type, -1, network);
};

/**
 * Instantiate address from pubkeyhash.
 * @param {Buffer} hash
 * @param {Network?} network
 * @returns {Address}
 */

Address.fromPubkeyhash = function fromPubkeyhash(hash, network) {
  return new Address().fromPubkeyhash(hash, network);
};

/**
 * Inject properties from scripthash.
 * @private
 * @param {Buffer} hash
 * @param {Network?} network
 * @returns {Address}
 */

Address.prototype.fromScripthash = function fromScripthash(hash, network) {
  const type = Address.types.SCRIPTHASH;
  assert(hash && hash.length === 20, 'P2SH must be 20 bytes.');
  return this.fromHash(hash, type, -1, network);
};

/**
 * Instantiate address from scripthash.
 * @param {Buffer} hash
 * @param {Network?} network
 * @returns {Address}
 */

Address.fromScripthash = function fromScripthash(hash, network) {
  return new Address().fromScripthash(hash, network);
};

/**
 * Inject properties from witness pubkeyhash.
 * @private
 * @param {Buffer} hash
 * @param {Network?} network
 * @returns {Address}
 */

Address.prototype.fromWitnessPubkeyhash = function fromWitnessPubkeyhash(hash, network) {
  const type = Address.types.WITNESS;
  assert(hash && hash.length === 20, 'P2WPKH must be 20 bytes.');
  return this.fromHash(hash, type, 0, network);
};

/**
 * Instantiate address from witness pubkeyhash.
 * @param {Buffer} hash
 * @param {Network?} network
 * @returns {Address}
 */

Address.fromWitnessPubkeyhash = function fromWitnessPubkeyhash(hash, network) {
  return new Address().fromWitnessPubkeyhash(hash, network);
};

/**
 * Inject properties from witness scripthash.
 * @private
 * @param {Buffer} hash
 * @param {Network?} network
 * @returns {Address}
 */

Address.prototype.fromWitnessScripthash = function fromWitnessScripthash(hash, network) {
  const type = Address.types.WITNESS;
  assert(hash && hash.length === 32, 'P2WPKH must be 32 bytes.');
  return this.fromHash(hash, type, 0, network);
};

/**
 * Instantiate address from witness scripthash.
 * @param {Buffer} hash
 * @param {Network?} network
 * @returns {Address}
 */

Address.fromWitnessScripthash = function fromWitnessScripthash(hash, network) {
  return new Address().fromWitnessScripthash(hash, network);
};

/**
 * Inject properties from witness program.
 * @private
 * @param {Number} version
 * @param {Buffer} hash
 * @param {Network?} network
 * @returns {Address}
 */

Address.prototype.fromProgram = function fromProgram(version, hash, network) {
  const type = Address.types.WITNESS;

  assert(version >= 0, 'Bad version for witness program.');

  if (typeof hash === 'string')
    hash = Buffer.from(hash, 'hex');

  return this.fromHash(hash, type, version, network);
};

/**
 * Instantiate address from witness program.
 * @param {Number} version
 * @param {Buffer} hash
 * @param {Network?} network
 * @returns {Address}
 */

Address.fromProgram = function fromProgram(version, hash, network) {
  return new Address().fromProgram(version, hash, network);
};

/**
 * Test whether the address is pubkeyhash.
 * @returns {Boolean}
 */

Address.prototype.isPubkeyhash = function isPubkeyhash() {
  return this.type === Address.types.PUBKEYHASH;
};

/**
 * Test whether the address is scripthash.
 * @returns {Boolean}
 */

Address.prototype.isScripthash = function isScripthash() {
  return this.type === Address.types.SCRIPTHASH;
};

/**
 * Test whether the address is witness pubkeyhash.
 * @returns {Boolean}
 */

Address.prototype.isWitnessPubkeyhash = function isWitnessPubkeyhash() {
  return this.version === 0 && this.hash.length === 20;
};

/**
 * Test whether the address is witness scripthash.
 * @returns {Boolean}
 */

Address.prototype.isWitnessScripthash = function isWitnessScripthash() {
  return this.version === 0 && this.hash.length === 32;
};

/**
 * Test whether the address is witness masthash.
 * @returns {Boolean}
 */

Address.prototype.isWitnessMasthash = function isWitnessMasthash() {
  return this.version === 1 && this.hash.length === 32;
};

/**
 * Test whether the address is a witness program.
 * @returns {Boolean}
 */

Address.prototype.isProgram = function isProgram() {
  return this.version !== -1;
};

/**
 * Test whether the address is an unknown witness program.
 * @returns {Boolean}
 */

Address.prototype.isUnknown = function isUnknown() {
  if (this.version === -1)
    return false;

  if (this.version > 0)
    return true;

  return this.hash.length !== 20 && this.hash.length !== 32;
};

/**
 * Get the hash of a base58 address or address-related object.
 * @param {String|Address|Hash} data
 * @param {String?} enc
 * @param {Network?} network
 * @returns {Hash}
 */

Address.getHash = function getHash(data, enc, network) {
  if (!data)
    throw new Error('Object is not an address.');

  let hash;

  if (typeof data === 'string') {
    if (data.length === 40 || data.length === 64)
      return enc === 'hex' ? data : Buffer.from(data, 'hex');

    hash = Address.fromString(data, network).hash;
  } else if (Buffer.isBuffer(data)) {
    if (data.length !== 20 && data.length !== 32)
      throw new Error('Object is not an address.');
    hash = data;
  } else if (data instanceof Address) {
    hash = data.hash;
    if (network) {
      network = Network.get(network);
      if (data.network !== network)
        throw new Error('Network mismatch for address.');
    }
  } else {
    throw new Error('Object is not an address.');
  }

  return enc === 'hex'
    ? hash.toString('hex')
    : hash;
};

/**
 * Get an address type for a specified network address prefix.
 * @param {Number} prefix
 * @param {Network} network
 * @returns {AddressType}
 */

Address.getType = function getType(prefix, network) {
  const prefixes = network.addressPrefix;
  switch (prefix) {
    case prefixes.pubkeyhash:
      return Address.types.PUBKEYHASH;
    case prefixes.scripthash:
      return Address.types.SCRIPTHASH;
    case prefixes.witnesspubkeyhash:
    case prefixes.witnessscripthash:
      return Address.types.WITNESS;
    default:
      throw new Error('Unknown address prefix.');
  }
};

/*
 * Helpers
 */

function isMixedCase(str) {
  let lower = false;
  let upper = false;

  for (let i = 0; i < str.length; i++) {
    const ch = str.charCodeAt(i);

    if (ch >= 0x30 && ch <= 0x39)
      continue;

    if (ch & 32) {
      assert(ch >= 0x61 && ch <= 0x7a);
      lower = true;
    } else {
      assert(ch >= 0x41 && ch <= 0x5a);
      upper = true;
    }

    if (lower && upper)
      return true;
  }

  return false;
}

/*
 * Expose
 */

module.exports = Address;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * secp256k1.js - ecdsa wrapper for secp256k1 and elliptic.
 */



let native;

if (Number(process.env.WMCC_NO_SECP256K1) !== 1) {
  try {
    native = __webpack_require__(135);
  } catch (e) {
    ;
  }
}

module.exports = native
  ? __webpack_require__(137)
  : __webpack_require__(139);


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * output.js - output object for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const Amount = __webpack_require__(20);
const Network = __webpack_require__(6);
const Address = __webpack_require__(11);
const Script = __webpack_require__(8);
const StaticWriter = __webpack_require__(4);
const BufferReader = __webpack_require__(2);
const consensus = __webpack_require__(7);
const policy = __webpack_require__(19);

/**
 * Represents a transaction output.
 * @alias module:primitives.Output
 * @constructor
 * @param {NakedOutput} options
 * @property {Amount} value - Value in wmcoins.
 * @property {Script} script
 */

function Output(options) {
  if (!(this instanceof Output))
    return new Output(options);

  this.value = 0;
  this.script = new Script();

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from options object.
 * @private
 * @param {NakedOutput} options
 */

Output.prototype.fromOptions = function fromOptions(options) {
  assert(options, 'Output data is required.');

  if (options.value) {
    assert(util.isU64(options.value), 'Value must be a uint64.');
    this.value = options.value;
  }

  if (options.script)
    this.script.fromOptions(options.script);

  if (options.address)
    this.script.fromAddress(options.address);

  return this;
};

/**
 * Instantiate output from options object.
 * @param {NakedOutput} options
 * @returns {Output}
 */

Output.fromOptions = function fromOptions(options) {
  return new Output().fromOptions(options);
};

/**
 * Inject properties from script/value pair.
 * @private
 * @param {Script|Address} script
 * @param {Amount} value
 * @returns {Output}
 */

Output.prototype.fromScript = function fromScript(script, value) {
  if (typeof script === 'string')
    script = Address.fromString(script);

  if (script instanceof Address)
    script = Script.fromAddress(script);

  assert(script instanceof Script, 'Script must be a Script.');
  assert(util.isU64(value), 'Value must be a uint64.');

  this.script = script;
  this.value = value;

  return this;
};

/**
 * Instantiate output from script/value pair.
 * @param {Script|Address} script
 * @param {Amount} value
 * @returns {Output}
 */

Output.fromScript = function fromScript(script, value) {
  return new Output().fromScript(script, value);
};

/**
 * Clone the output.
 * @returns {Output}
 */

Output.prototype.clone = function clone() {
  const output = new Output();
  output.value = this.value;
  output.script.inject(this.script);
  return output;
};

/**
 * Test equality against another output.
 * @param {Output} output
 * @returns {Boolean}
 */

Output.prototype.equals = function equals(output) {
  assert(Output.isOutput(output));
  return this.value === output.value
    && this.script.equals(output.script);
};

/**
 * Compare against another output (BIP69).
 * @param {Output} output
 * @returns {Number}
 */

Output.prototype.compare = function compare(output) {
  assert(Output.isOutput(output));

  const cmp = this.value - output.value;

  if (cmp !== 0)
    return cmp;

  return this.script.compare(output.script);
};

/**
 * Get the script type as a string.
 * @returns {ScriptType} type
 */

Output.prototype.getType = function getType() {
  return Script.typesByVal[this.script.getType()].toLowerCase();
};

/**
 * Get the address.
 * @returns {Address} address
 */

Output.prototype.getAddress = function getAddress() {
  return this.script.getAddress();
};

/**
 * Get the address hash.
 * @param {String?} enc
 * @returns {Hash} hash
 */

Output.prototype.getHash = function getHash(enc) {
  const addr = this.getAddress();

  if (!addr)
    return null;

  return addr.getHash(enc);
};

/**
 * Convert the input to a more user-friendly object.
 * @returns {Object}
 */

Output.prototype.inspect = function inspect() {
  return {
    type: this.getType(),
    value: Amount.wmcc(this.value),
    script: this.script,
    address: this.getAddress()
  };
};

/**
 * Convert the output to an object suitable
 * for JSON serialization.
 * @returns {Object}
 */

Output.prototype.toJSON = function toJSON() {
  return this.getJSON();
};

/**
 * Convert the output to an object suitable
 * for JSON serialization.
 * @param {Network} network
 * @returns {Object}
 */

Output.prototype.getJSON = function getJSON(network) {
  let addr = this.getAddress();

  network = Network.get(network);

  if (addr)
    addr = addr.toString(network);

  return {
    value: this.value,
    script: this.script.toJSON(),
    address: addr
  };
};

/**
 * Calculate the dust threshold for this
 * output, based on serialize size and rate.
 * @param {Rate?} rate
 * @returns {Amount}
 */

Output.prototype.getDustThreshold = function getDustThreshold(rate) {
  const scale = consensus.WITNESS_SCALE_FACTOR;

  if (this.script.isUnspendable())
    return 0;

  let size = this.getSize();

  if (this.script.isProgram()) {
    // 75% segwit discount applied to script size.
    size += 32 + 4 + 1 + (107 / scale | 0) + 4;
  } else {
    size += 32 + 4 + 1 + 107 + 4;
  }

  return 3 * policy.getMinFee(size, rate);
};

/**
 * Calculate size of serialized output.
 * @returns {Number}
 */

Output.prototype.getSize = function getSize() {
  return 8 + this.script.getVarSize();
};

/**
 * Test whether the output should be considered dust.
 * @param {Rate?} rate
 * @returns {Boolean}
 */

Output.prototype.isDust = function isDust(rate) {
  return this.value < this.getDustThreshold(rate);
};

/**
 * Inject properties from a JSON object.
 * @private
 * @param {Object} json
 */

Output.prototype.fromJSON = function fromJSON(json) {
  assert(json, 'Output data is required.');
  assert(util.isU64(json.value), 'Value must be a uint64.');
  this.value = json.value;
  this.script.fromJSON(json.script);
  return this;
};

/**
 * Instantiate an Output from a jsonified output object.
 * @param {Object} json - The jsonified output object.
 * @returns {Output}
 */

Output.fromJSON = function fromJSON(json) {
  return new Output().fromJSON(json);
};

/**
 * Write the output to a buffer writer.
 * @param {BufferWriter} bw
 */

Output.prototype.toWriter = function toWriter(bw) {
  bw.writeI64(this.value);
  bw.writeVarBytes(this.script.toRaw());
  return bw;
};

/**
 * Serialize the output.
 * @param {String?} enc - Encoding, can be `'hex'` or null.
 * @returns {Buffer|String}
 */

Output.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

Output.prototype.fromReader = function fromReader(br) {
  this.value = br.readI64();
  this.script.fromRaw(br.readVarBytes());
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

Output.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate an output from a buffer reader.
 * @param {BufferReader} br
 * @returns {Output}
 */

Output.fromReader = function fromReader(br) {
  return new Output().fromReader(br);
};

/**
 * Instantiate an output from a serialized Buffer.
 * @param {Buffer} data
 * @param {String?} enc - Encoding, can be `'hex'` or null.
 * @returns {Output}
 */

Output.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new Output().fromRaw(data);
};

/**
 * Test an object to see if it is an Output.
 * @param {Object} obj
 * @returns {Boolean}
 */

Output.isOutput = function isOutput(obj) {
  return obj instanceof Output;
};

/*
 * Expose
 */

module.exports = Output;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = __webpack_require__(134).Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      r.strip();
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(133)(module)))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(22);
var inherits = __webpack_require__(40);

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * tx.js - transaction object for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const encoding = __webpack_require__(3);
const digest = __webpack_require__(5);
const secp256k1 = __webpack_require__(12);
const Amount = __webpack_require__(20);
const Network = __webpack_require__(6);
const Script = __webpack_require__(8);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const Input = __webpack_require__(42);
const Output = __webpack_require__(13);
const Outpoint = __webpack_require__(21);
const InvItem = __webpack_require__(36);
const Bloom = __webpack_require__(43);
const consensus = __webpack_require__(7);
const policy = __webpack_require__(19);
const ScriptError = __webpack_require__(35);
const hashType = Script.hashType;

/**
 * A static transaction object.
 * @alias module:primitives.TX
 * @constructor
 * @param {Object} options - Transaction fields.
 * @property {Number} version - Transaction version. Note that WMCC_Core reads
 * versions as unsigned even though they are signed at the protocol level.
 * This value will never be negative.
 * @property {Number} flag - Flag field for segregated witness.
 * Always non-zero (1 if not present).
 * @property {Input[]} inputs
 * @property {Output[]} outputs
 * @property {Number} locktime - nLockTime
 */

function TX(options) {
  if (!(this instanceof TX))
    return new TX(options);

  this.version = 1;
  this.inputs = [];
  this.outputs = [];
  this.locktime = 0;

  this.mutable = false;

  this._hash = null;
  this._hhash = null;
  this._whash = null;

  this._raw = null;
  this._size = -1;
  this._witness = -1;
  this._sigops = -1;

  this._hashPrevouts = null;
  this._hashSequence = null;
  this._hashOutputs = null;

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from options object.
 * @private
 * @param {NakedTX} options
 */

TX.prototype.fromOptions = function fromOptions(options) {
  assert(options, 'TX data is required.');

  if (options.version != null) {
    assert(util.isU32(options.version), 'Version must be a uint32.');
    this.version = options.version;
  }

  if (options.inputs) {
    assert(Array.isArray(options.inputs), 'Inputs must be an array.');
    for (const input of options.inputs)
      this.inputs.push(new Input(input));
  }

  if (options.outputs) {
    assert(Array.isArray(options.outputs), 'Outputs must be an array.');
    for (const output of options.outputs)
      this.outputs.push(new Output(output));
  }

  if (options.locktime != null) {
    assert(util.isU32(options.locktime), 'Locktime must be a uint32.');
    this.locktime = options.locktime;
  }

  return this;
};

/**
 * Instantiate TX from options object.
 * @param {NakedTX} options
 * @returns {TX}
 */

TX.fromOptions = function fromOptions(options) {
  return new TX().fromOptions(options);
};

/**
 * Clone the transaction.
 * @returns {TX}
 */

TX.prototype.clone = function clone() {
  return new TX().inject(this);
};

/**
 * Inject properties from tx.
 * Used for cloning.
 * @private
 * @param {TX} tx
 * @returns {TX}
 */

TX.prototype.inject = function inject(tx) {
  this.version = tx.version;

  for (const input of tx.inputs)
    this.inputs.push(input.clone());

  for (const output of tx.outputs)
    this.outputs.push(output.clone());

  this.locktime = tx.locktime;

  return this;
};

/**
 * Clear any cached values.
 */

TX.prototype.refresh = function refresh() {
  this._hash = null;
  this._hhash = null;
  this._whash = null;

  this._raw = null;
  this._size = -1;
  this._witness = -1;
  this._sigops = -1;

  this._hashPrevouts = null;
  this._hashSequence = null;
  this._hashOutputs = null;
};

/**
 * Hash the transaction with the non-witness serialization.
 * @param {String?} enc - Can be `'hex'` or `null`.
 * @returns {Hash|Buffer} hash
 */

TX.prototype.hash = function hash(enc) {
  let h = this._hash;

  if (!h) {
    h = digest.hash256(this.toNormal());
    if (!this.mutable)
      this._hash = h;
  }

  if (enc === 'hex') {
    let hex = this._hhash;
    if (!hex) {
      hex = h.toString('hex');
      if (!this.mutable)
        this._hhash = hex;
    }
    h = hex;
  }

  return h;
};

/**
 * Hash the transaction with the witness
 * serialization, return the wtxid (normal
 * hash if no witness is present, all zeroes
 * if coinbase).
 * @param {String?} enc - Can be `'hex'` or `null`.
 * @returns {Hash|Buffer} hash
 */

TX.prototype.witnessHash = function witnessHash(enc) {
  if (!this.hasWitness())
    return this.hash(enc);

  let hash = this._whash;

  if (!hash) {
    hash = digest.hash256(this.toRaw());
    if (!this.mutable)
      this._whash = hash;
  }

  return enc === 'hex' ? hash.toString('hex') : hash;
};

/**
 * Serialize the transaction. Note
 * that this is cached. This will use
 * the witness serialization if a
 * witness is present.
 * @returns {Buffer} Serialized transaction.
 */

TX.prototype.toRaw = function toRaw() {
  return this.frame().data;
};

/**
 * Serialize the transaction without the
 * witness vector, regardless of whether it
 * is a witness transaction or not.
 * @returns {Buffer} Serialized transaction.
 */

TX.prototype.toNormal = function toNormal() {
  if (this.hasWitness())
    return this.frameNormal().data;
  return this.toRaw();
};

/**
 * Write the transaction to a buffer writer.
 * @param {BufferWriter} bw
 */

TX.prototype.toWriter = function toWriter(bw) {
  if (this.mutable) {
    if (this.hasWitness())
      return this.writeWitness(bw);
    return this.writeNormal(bw);
  }

  bw.writeBytes(this.toRaw());

  return bw;
};

/**
 * Write the transaction to a buffer writer.
 * Uses non-witness serialization.
 * @param {BufferWriter} bw
 */

TX.prototype.toNormalWriter = function toNormalWriter(bw) {
  if (this.hasWitness()) {
    this.writeNormal(bw);
    return bw;
  }
  return this.toWriter(bw);
};

/**
 * Serialize the transaction. Note
 * that this is cached. This will use
 * the witness serialization if a
 * witness is present.
 * @private
 * @returns {RawTX}
 */

TX.prototype.frame = function frame() {
  if (this.mutable) {
    assert(!this._raw);
    if (this.hasWitness())
      return this.frameWitness();
    return this.frameNormal();
  }

  if (this._raw) {
    assert(this._size >= 0);
    assert(this._witness >= 0);
    const raw = new RawTX(this._size, this._witness);
    raw.data = this._raw;
    return raw;
  }

  let raw;
  if (this.hasWitness())
    raw = this.frameWitness();
  else
    raw = this.frameNormal();

  this._raw = raw.data;
  this._size = raw.size;
  this._witness = raw.witness;

  return raw;
};

/**
 * Calculate total size and size of the witness bytes.
 * @returns {Object} Contains `size` and `witness`.
 */

TX.prototype.getSizes = function getSizes() {
  if (this.mutable) {
    if (this.hasWitness())
      return this.getWitnessSizes();
    return this.getNormalSizes();
  }
  return this.frame();
};

/**
 * Calculate the virtual size of the transaction.
 * Note that this is cached.
 * @returns {Number} vsize
 */

TX.prototype.getVirtualSize = function getVirtualSize() {
  const scale = consensus.WITNESS_SCALE_FACTOR;
  return (this.getWeight() + scale - 1) / scale | 0;
};

/**
 * Calculate the virtual size of the transaction
 * (weighted against bytes per sigop cost).
 * @param {Number} sigops - Sigops cost.
 * @returns {Number} vsize
 */

TX.prototype.getSigopsSize = function getSigopsSize(sigops) {
  const scale = consensus.WITNESS_SCALE_FACTOR;
  const bytes = policy.BYTES_PER_SIGOP;
  const weight = Math.max(this.getWeight(), sigops * bytes);
  return (weight + scale - 1) / scale | 0;
};

/**
 * Calculate the weight of the transaction.
 * Note that this is cached.
 * @returns {Number} weight
 */

TX.prototype.getWeight = function getWeight() {
  const raw = this.getSizes();
  const base = raw.size - raw.witness;
  return base * (consensus.WITNESS_SCALE_FACTOR - 1) + raw.size;
};

/**
 * Calculate the real size of the transaction
 * with the witness included.
 * @returns {Number} size
 */

TX.prototype.getSize = function getSize() {
  return this.getSizes().size;
};

/**
 * Calculate the size of the transaction
 * without the witness.
 * with the witness included.
 * @returns {Number} size
 */

TX.prototype.getBaseSize = function getBaseSize() {
  const raw = this.getSizes();
  return raw.size - raw.witness;
};

/**
 * Test whether the transaction has a non-empty witness.
 * @returns {Boolean}
 */

TX.prototype.hasWitness = function hasWitness() {
  if (this._witness !== -1)
    return this._witness !== 0;

  for (const input of this.inputs) {
    if (input.witness.items.length > 0)
      return true;
  }

  return false;
};

/**
 * Get the signature hash of the transaction for signing verifying.
 * @param {Number} index - Index of input being signed/verified.
 * @param {Script} prev - Previous output script or redeem script
 * (in the case of witnesspubkeyhash, this should be the generated
 * p2pkh script).
 * @param {Amount} value - Previous output value.
 * @param {SighashType} type - Sighash type.
 * @param {Number} version - Sighash version (0=legacy, 1=segwit).
 * @returns {Buffer} Signature hash.
 */

TX.prototype.signatureHash = function signatureHash(index, prev, value, type, version) {
  assert(index >= 0 && index < this.inputs.length);
  assert(prev instanceof Script);
  assert(typeof value === 'number');
  assert(typeof type === 'number');

  // Traditional sighashing
  if (version === 0)
    return this.signatureHashV0(index, prev, type);

  // Segwit sighashing
  if (version === 1)
    return this.signatureHashV1(index, prev, value, type);

  throw new Error('Unknown sighash version.');
};

/**
 * Legacy sighashing -- O(n^2).
 * @private
 * @param {Number} index
 * @param {Script} prev
 * @param {SighashType} type
 * @returns {Buffer}
 */

TX.prototype.signatureHashV0 = function signatureHashV0(index, prev, type) {
  if ((type & 0x1f) === hashType.SINGLE) {
    // wmccd used to return 1 as an error code:
    // it ended up being treated like a hash.
    if (index >= this.outputs.length)
      return Buffer.from(encoding.ONE_HASH);
  }

  // Remove all code separators.
  prev = prev.removeSeparators();

  // Calculate buffer size.
  const size = this.hashSize(index, prev, type);
  const bw = StaticWriter.pool(size);

  bw.writeU32(this.version);

  // Serialize inputs.
  if (type & hashType.ANYONECANPAY) {
    // Serialize only the current
    // input if ANYONECANPAY.
    const input = this.inputs[index];

    // Count.
    bw.writeVarint(1);

    // Outpoint.
    input.prevout.toWriter(bw);

    // Replace script with previous
    // output script if current index.
    bw.writeVarBytes(prev.toRaw());
    bw.writeU32(input.sequence);
  } else {
    bw.writeVarint(this.inputs.length);
    for (let i = 0; i < this.inputs.length; i++) {
      const input = this.inputs[i];

      // Outpoint.
      input.prevout.toWriter(bw);

      // Replace script with previous
      // output script if current index.
      if (i === index) {
        bw.writeVarBytes(prev.toRaw());
        bw.writeU32(input.sequence);
        continue;
      }

      // Script is null.
      bw.writeVarint(0);

      // Sequences are 0 if NONE or SINGLE.
      switch (type & 0x1f) {
        case hashType.NONE:
        case hashType.SINGLE:
          bw.writeU32(0);
          break;
        default:
          bw.writeU32(input.sequence);
          break;
      }
    }
  }

  // Serialize outputs.
  switch (type & 0x1f) {
    case hashType.NONE: {
      // No outputs if NONE.
      bw.writeVarint(0);
      break;
    }
    case hashType.SINGLE: {
      const output = this.outputs[index];

      // Drop all outputs after the
      // current input index if SINGLE.
      bw.writeVarint(index + 1);

      for (let i = 0; i < index; i++) {
        // Null all outputs not at
        // current input index.
        bw.writeI64(-1);
        bw.writeVarint(0);
      }

      // Regular serialization
      // at current input index.
      output.toWriter(bw);

      break;
    }
    default: {
      // Regular output serialization if ALL.
      bw.writeVarint(this.outputs.length);
      for (const output of this.outputs)
        output.toWriter(bw);
      break;
    }
  }

  bw.writeU32(this.locktime);

  // Append the hash type.
  bw.writeU32(type);

  return digest.hash256(bw.render());
};

/**
 * Calculate sighash size.
 * @private
 * @param {Number} index
 * @param {Script} prev
 * @param {Number} type
 * @returns {Number}
 */

TX.prototype.hashSize = function hashSize(index, prev, type) {
  let size = 0;

  size += 4;

  if (type & hashType.ANYONECANPAY) {
    size += 1;
    size += 36;
    size += prev.getVarSize();
    size += 4;
  } else {
    size += encoding.sizeVarint(this.inputs.length);
    size += 41 * (this.inputs.length - 1);
    size += 36;
    size += prev.getVarSize();
    size += 4;
  }

  switch (type & 0x1f) {
    case hashType.NONE:
      size += 1;
      break;
    case hashType.SINGLE:
      size += encoding.sizeVarint(index + 1);
      size += 9 * index;
      size += this.outputs[index].getSize();
      break;
    default:
      size += encoding.sizeVarint(this.outputs.length);
      for (const output of this.outputs)
        size += output.getSize();
      break;
  }

  size += 8;

  return size;
};

/**
 * Witness sighashing -- O(n).
 * @private
 * @param {Number} index
 * @param {Script} prev
 * @param {Amount} value
 * @param {SighashType} type
 * @returns {Buffer}
 */

TX.prototype.signatureHashV1 = function signatureHashV1(index, prev, value, type) {
  const input = this.inputs[index];
  let prevouts = encoding.ZERO_HASH;
  let sequences = encoding.ZERO_HASH;
  let outputs = encoding.ZERO_HASH;

  if (!(type & hashType.ANYONECANPAY)) {
    if (this._hashPrevouts) {
      prevouts = this._hashPrevouts;
    } else {
      const bw = StaticWriter.pool(this.inputs.length * 36);

      for (const input of this.inputs)
        input.prevout.toWriter(bw);

      prevouts = digest.hash256(bw.render());

      if (!this.mutable)
        this._hashPrevouts = prevouts;
    }
  }

  if (!(type & hashType.ANYONECANPAY)
      && (type & 0x1f) !== hashType.SINGLE
      && (type & 0x1f) !== hashType.NONE) {
    if (this._hashSequence) {
      sequences = this._hashSequence;
    } else {
      const bw = StaticWriter.pool(this.inputs.length * 4);

      for (const input of this.inputs)
        bw.writeU32(input.sequence);

      sequences = digest.hash256(bw.render());

      if (!this.mutable)
        this._hashSequence = sequences;
    }
  }

  if ((type & 0x1f) !== hashType.SINGLE
      && (type & 0x1f) !== hashType.NONE) {
    if (this._hashOutputs) {
      outputs = this._hashOutputs;
    } else {
      let size = 0;

      for (const output of this.outputs)
        size += output.getSize();

      const bw = StaticWriter.pool(size);

      for (const output of this.outputs)
        output.toWriter(bw);

      outputs = digest.hash256(bw.render());

      if (!this.mutable)
        this._hashOutputs = outputs;
    }
  } else if ((type & 0x1f) === hashType.SINGLE) {
    if (index < this.outputs.length) {
      const output = this.outputs[index];
      outputs = digest.hash256(output.toRaw());
    }
  }

  const size = 156 + prev.getVarSize();
  const bw = StaticWriter.pool(size);

  bw.writeU32(this.version);
  bw.writeBytes(prevouts);
  bw.writeBytes(sequences);
  bw.writeHash(input.prevout.hash);
  bw.writeU32(input.prevout.index);
  bw.writeVarBytes(prev.toRaw());
  bw.writeI64(value);
  bw.writeU32(input.sequence);
  bw.writeBytes(outputs);
  bw.writeU32(this.locktime);
  bw.writeU32(type);

  return digest.hash256(bw.render());
};

/**
 * Verify signature.
 * @param {Number} index
 * @param {Script} prev
 * @param {Amount} value
 * @param {Buffer} sig
 * @param {Buffer} key
 * @param {Number} version
 * @returns {Boolean}
 */

TX.prototype.checksig = function checksig(index, prev, value, sig, key, version) {
  if (sig.length === 0)
    return false;

  const type = sig[sig.length - 1];
  const hash = this.signatureHash(index, prev, value, type, version);

  return secp256k1.verify(hash, sig.slice(0, -1), key);
};

/**
 * Create a signature suitable for inserting into scriptSigs/witnesses.
 * @param {Number} index - Index of input being signed.
 * @param {Script} prev - Previous output script or redeem script
 * (in the case of witnesspubkeyhash, this should be the generated
 * p2pkh script).
 * @param {Amount} value - Previous output value.
 * @param {Buffer} key
 * @param {SighashType} type
 * @param {Number} version - Sighash version (0=legacy, 1=segwit).
 * @returns {Buffer} Signature in DER format.
 */

TX.prototype.signature = function signature(index, prev, value, key, type, version) {
  if (type == null)
    type = hashType.ALL;

  if (version == null)
    version = 0;

  const hash = this.signatureHash(index, prev, value, type, version);
  const sig = secp256k1.sign(hash, key);
  const bw = new StaticWriter(sig.length + 1);

  bw.writeBytes(sig);
  bw.writeU8(type);

  return bw.render();
};

/**
 * Verify all transaction inputs.
 * @param {CoinView} view
 * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
 * @throws {ScriptError} on invalid inputs
 */

TX.prototype.check = function check(view, flags) {
  if (this.inputs.length === 0)
    throw new ScriptError('UNKNOWN_ERROR', 'No inputs.');

  if (this.isCoinbase())
    return;

  for (let i = 0; i < this.inputs.length; i++) {
    const {prevout} = this.inputs[i];
    const coin = view.getOutput(prevout);

    if (!coin)
      throw new ScriptError('UNKNOWN_ERROR', 'No coin available.');

    this.checkInput(i, coin, flags);
  }
};

/**
 * Verify a transaction input.
 * @param {Number} index - Index of output being
 * verified.
 * @param {Coin|Output} coin - Previous output.
 * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
 * @throws {ScriptError} on invalid input
 */

TX.prototype.checkInput = function checkInput(index, coin, flags) {
  const input = this.inputs[index];

  assert(input, 'Input does not exist.');
  assert(coin, 'No coin passed.');

  Script.verify(
    input.script,
    input.witness,
    coin.script,
    this,
    index,
    coin.value,
    flags
  );
};

/**
 * Verify the transaction inputs on the worker pool
 * (if workers are enabled).
 * @param {CoinView} view
 * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
 * @param {WorkerPool?} pool
 * @returns {Promise}
 */

TX.prototype.checkAsync = async function checkAsync(view, flags, pool) {
  if (this.inputs.length === 0)
    throw new ScriptError('UNKNOWN_ERROR', 'No inputs.');

  if (this.isCoinbase())
    return;

  if (!pool) {
    this.check(view, flags);
    return;
  }

  await pool.check(this, view, flags);
};

/**
 * Verify a transaction input asynchronously.
 * @param {Number} index - Index of output being
 * verified.
 * @param {Coin|Output} coin - Previous output.
 * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
 * @param {WorkerPool?} pool
 * @returns {Promise}
 */

TX.prototype.checkInputAsync = async function checkInputAsync(index, coin, flags, pool) {
  const input = this.inputs[index];

  assert(input, 'Input does not exist.');
  assert(coin, 'No coin passed.');

  if (!pool) {
    this.checkInput(index, coin, flags);
    return;
  }

  await pool.checkInput(this, index, coin, flags);
};

/**
 * Verify all transaction inputs.
 * @param {CoinView} view
 * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
 * @returns {Boolean} Whether the inputs are valid.
 */

TX.prototype.verify = function verify(view, flags) {
  try {
    this.check(view, flags);
  } catch (e) {
    if (e.type === 'ScriptError')
      return false;
    throw e;
  }
  return true;
};

/**
 * Verify a transaction input.
 * @param {Number} index - Index of output being
 * verified.
 * @param {Coin|Output} coin - Previous output.
 * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
 * @returns {Boolean} Whether the input is valid.
 */

TX.prototype.verifyInput = function verifyInput(index, coin, flags) {
  try {
    this.checkInput(index, coin, flags);
  } catch (e) {
    if (e.type === 'ScriptError')
      return false;
    throw e;
  }
  return true;
};

/**
 * Verify the transaction inputs on the worker pool
 * (if workers are enabled).
 * @param {CoinView} view
 * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
 * @param {WorkerPool?} pool
 * @returns {Promise}
 */

TX.prototype.verifyAsync = async function verifyAsync(view, flags, pool) {
  try {
    await this.checkAsync(view, flags, pool);
  } catch (e) {
    if (e.type === 'ScriptError')
      return false;
    throw e;
  }
  return true;
};

/**
 * Verify a transaction input asynchronously.
 * @param {Number} index - Index of output being
 * verified.
 * @param {Coin|Output} coin - Previous output.
 * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
 * @param {WorkerPool?} pool
 * @returns {Promise}
 */

TX.prototype.verifyInputAsync = async function verifyInputAsync(index, coin, flags, pool) {
  try {
    await this.checkInput(index, coin, flags, pool);
  } catch (e) {
    if (e.type === 'ScriptError')
      return false;
    throw e;
  }
  return true;
};

/**
 * Test whether the transaction is a coinbase
 * by examining the inputs.
 * @returns {Boolean}
 */

TX.prototype.isCoinbase = function isCoinbase() {
  return this.inputs.length === 1 && this.inputs[0].prevout.isNull();
};

/**
 * Test whether the transaction is replaceable.
 * @returns {Boolean}
 */

TX.prototype.isRBF = function isRBF() {
  // Core doesn't do this, but it should:
  if (this.version === 2)
    return false;

  for (const input of this.inputs) {
    if (input.isRBF())
      return true;
  }

  return false;
};

/**
 * Calculate the fee for the transaction.
 * @param {CoinView} view
 * @returns {Amount} fee (zero if not all coins are available).
 */

TX.prototype.getFee = function getFee(view) {
  if (!this.hasCoins(view))
    return 0;

  return this.getInputValue(view) - this.getOutputValue();
};

/**
 * Calculate the total input value.
 * @param {CoinView} view
 * @returns {Amount} value
 */

TX.prototype.getInputValue = function getInputValue(view) {
  let total = 0;

  for (const {prevout} of this.inputs) {
    const coin = view.getOutput(prevout);

    if (!coin)
      return 0;

    total += coin.value;
  }

  return total;
};

/**
 * Calculate the total output value.
 * @returns {Amount} value
 */

TX.prototype.getOutputValue = function getOutputValue() {
  let total = 0;

  for (const output of this.outputs)
    total += output.value;

  return total;
};

/**
 * Get all input addresses.
 * @private
 * @param {CoinView} view
 * @returns {Array} [addrs, table]
 */

TX.prototype._getInputAddresses = function _getInputAddresses(view) {
  const table = Object.create(null);
  const addrs = [];

  if (this.isCoinbase())
    return [addrs, table];

  for (const input of this.inputs) {
    const coin = view ? view.getOutputFor(input) : null;
    const addr = input.getAddress(coin);

    if (!addr)
      continue;

    const hash = addr.getHash('hex');

    if (!table[hash]) {
      table[hash] = true;
      addrs.push(addr);
    }
  }

  return [addrs, table];
};

/**
 * Get all output addresses.
 * @private
 * @returns {Array} [addrs, table]
 */

TX.prototype._getOutputAddresses = function _getOutputAddresses() {
  const table = Object.create(null);
  const addrs = [];

  for (const output of this.outputs) {
    const addr = output.getAddress();

    if (!addr)
      continue;

    const hash = addr.getHash('hex');

    if (!table[hash]) {
      table[hash] = true;
      addrs.push(addr);
    }
  }

  return [addrs, table];
};

/**
 * Get all addresses.
 * @private
 * @param {CoinView} view
 * @returns {Array} [addrs, table]
 */

TX.prototype._getAddresses = function _getAddresses(view) {
  const [addrs, table] = this._getInputAddresses(view);
  const output = this.getOutputAddresses();

  for (const addr of output) {
    const hash = addr.getHash('hex');

    if (!table[hash]) {
      table[hash] = true;
      addrs.push(addr);
    }
  }

  return [addrs, table];
};

/**
 * Get all input addresses.
 * @param {CoinView|null} view
 * @returns {Address[]} addresses
 */

TX.prototype.getInputAddresses = function getInputAddresses(view) {
  const [addrs] = this._getInputAddresses(view);
  return addrs;
};

/**
 * Get all output addresses.
 * @returns {Address[]} addresses
 */

TX.prototype.getOutputAddresses = function getOutputAddresses() {
  const [addrs] = this._getOutputAddresses();
  return addrs;
};

/**
 * Get all addresses.
 * @param {CoinView|null} view
 * @returns {Address[]} addresses
 */

TX.prototype.getAddresses = function getAddresses(view) {
  const [addrs] = this._getAddresses(view);
  return addrs;
};

/**
 * Get all input address hashes.
 * @param {CoinView|null} view
 * @returns {Hash[]} hashes
 */

TX.prototype.getInputHashes = function getInputHashes(view, enc) {
  if (enc === 'hex') {
    const [, table] = this._getInputAddresses(view);
    return Object.keys(table);
  }

  const addrs = this.getInputAddresses(view);
  const hashes = [];

  for (const addr of addrs)
    hashes.push(addr.getHash());

  return hashes;
};

/**
 * Get all output address hashes.
 * @returns {Hash[]} hashes
 */

TX.prototype.getOutputHashes = function getOutputHashes(enc) {
  if (enc === 'hex') {
    const [, table] = this._getOutputAddresses();
    return Object.keys(table);
  }

  const addrs = this.getOutputAddresses();
  const hashes = [];

  for (const addr of addrs)
    hashes.push(addr.getHash());

  return hashes;
};

/**
 * Get all address hashes.
 * @param {CoinView|null} view
 * @returns {Hash[]} hashes
 */

TX.prototype.getHashes = function getHashes(view, enc) {
  if (enc === 'hex') {
    const [, table] = this._getAddresses(view);
    return Object.keys(table);
  }

  const addrs = this.getAddresses(view);
  const hashes = [];

  for (const addr of addrs)
    hashes.push(addr.getHash());

  return hashes;
};

/**
 * Test whether the transaction has
 * all coins available.
 * @param {CoinView} view
 * @returns {Boolean}
 */

TX.prototype.hasCoins = function hasCoins(view) {
  if (this.inputs.length === 0)
    return false;

  for (const {prevout} of this.inputs) {
    if (!view.hasEntry(prevout))
      return false;
  }

  return true;
};

/**
 * Check finality of transaction by examining
 * nLocktime and nSequence values.
 * @example
 * tx.isFinal(chain.height + 1, network.now());
 * @param {Number} height - Height at which to test. This
 * is usually the chain height, or the chain height + 1
 * when the transaction entered the mempool.
 * @param {Number} time - Time at which to test. This is
 * usually the chain tip's parent's median time, or the
 * time at which the transaction entered the mempool. If
 * MEDIAN_TIME_PAST is enabled this will be the median
 * time of the chain tip's previous entry's median time.
 * @returns {Boolean}
 */

TX.prototype.isFinal = function isFinal(height, time) {
  const THRESHOLD = consensus.LOCKTIME_THRESHOLD;

  if (this.locktime === 0)
    return true;

  if (this.locktime < (this.locktime < THRESHOLD ? height : time))
    return true;

  for (const input of this.inputs) {
    if (input.sequence !== 0xffffffff)
      return false;
  }

  return true;
};

/**
 * Verify the absolute locktime of a transaction.
 * Called by OP_CHECKLOCKTIMEVERIFY.
 * @param {Number} index - Index of input being verified.
 * @param {Number} predicate - Locktime to verify against.
 * @returns {Boolean}
 */

TX.prototype.verifyLocktime = function verifyLocktime(index, predicate) {
  const THRESHOLD = consensus.LOCKTIME_THRESHOLD;
  const input = this.inputs[index];

  assert(input, 'Input does not exist.');
  assert(predicate >= 0, 'Locktime must be non-negative.');

  // Locktimes must be of the same type (blocks or seconds).
  if ((this.locktime < THRESHOLD) !== (predicate < THRESHOLD))
    return false;

  if (predicate > this.locktime)
    return false;

  if (input.sequence === 0xffffffff)
    return false;

  return true;
};

/**
 * Verify the relative locktime of an input.
 * Called by OP_CHECKSEQUENCEVERIFY.
 * @param {Number} index - Index of input being verified.
 * @param {Number} predicate - Relative locktime to verify against.
 * @returns {Boolean}
 */

TX.prototype.verifySequence = function verifySequence(index, predicate) {
  const DISABLE_FLAG = consensus.SEQUENCE_DISABLE_FLAG;
  const TYPE_FLAG = consensus.SEQUENCE_TYPE_FLAG;
  const MASK = consensus.SEQUENCE_MASK;
  const input = this.inputs[index];

  assert(input, 'Input does not exist.');
  assert(predicate >= 0, 'Locktime must be non-negative.');

  // For future softfork capability.
  if (predicate & DISABLE_FLAG)
    return true;

  // Version must be >=2.
  if (this.version < 2)
    return false;

  // Cannot use the disable flag without
  // the predicate also having the disable
  // flag (for future softfork capability).
  if (input.sequence & DISABLE_FLAG)
    return false;

  // Locktimes must be of the same type (blocks or seconds).
  if ((input.sequence & TYPE_FLAG) !== (predicate & TYPE_FLAG))
    return false;

  if ((predicate & MASK) > (input.sequence & MASK))
    return false;

  return true;
};

/**
 * Calculate legacy (inaccurate) sigop count.
 * @returns {Number} sigop count
 */

TX.prototype.getLegacySigops = function getLegacySigops() {
  if (this._sigops !== -1)
    return this._sigops;

  let total = 0;

  for (const input of this.inputs)
    total += input.script.getSigops(false);

  for (const output of this.outputs)
    total += output.script.getSigops(false);

  if (!this.mutable)
    this._sigops = total;

  return total;
};

/**
 * Calculate accurate sigop count, taking into account redeem scripts.
 * @param {CoinView} view
 * @returns {Number} sigop count
 */

TX.prototype.getScripthashSigops = function getScripthashSigops(view) {
  if (this.isCoinbase())
    return 0;

  let total = 0;

  for (const input of this.inputs) {
    const coin = view.getOutputFor(input);

    if (!coin)
      continue;

    if (!coin.script.isScripthash())
      continue;

    total += coin.script.getScripthashSigops(input.script);
  }

  return total;
};

/**
 * Calculate accurate sigop count, taking into account redeem scripts.
 * @param {CoinView} view
 * @returns {Number} sigop count
 */

TX.prototype.getWitnessSigops = function getWitnessSigops(view) {
  if (this.isCoinbase())
    return 0;

  let total = 0;

  for (const input of this.inputs) {
    const coin = view.getOutputFor(input);

    if (!coin)
      continue;

    total += coin.script.getWitnessSigops(input.script, input.witness);
  }

  return total;
};

/**
 * Calculate sigops cost, taking into account witness programs.
 * @param {CoinView} view
 * @param {VerifyFlags?} flags
 * @returns {Number} sigop weight
 */

TX.prototype.getSigopsCost = function getSigopsCost(view, flags) {
  if (flags == null)
    flags = Script.flags.STANDARD_VERIFY_FLAGS;

  const scale = consensus.WITNESS_SCALE_FACTOR;

  let cost = this.getLegacySigops() * scale;

  if (flags & Script.flags.VERIFY_P2SH)
    cost += this.getScripthashSigops(view) * scale;

  if (flags & Script.flags.VERIFY_WITNESS)
    cost += this.getWitnessSigops(view);

  return cost;
};

/**
 * Calculate virtual sigop count.
 * @param {CoinView} view
 * @param {VerifyFlags?} flags
 * @returns {Number} sigop count
 */

TX.prototype.getSigops = function getSigops(view, flags) {
  const scale = consensus.WITNESS_SCALE_FACTOR;
  return (this.getSigopsCost(view, flags) + scale - 1) / scale | 0;
};

/**
 * Non-contextual sanity checks for the transaction.
 * Will mostly verify coin and output values.
 * @see CheckTransaction()
 * @returns {Array} [result, reason, score]
 */

TX.prototype.isSane = function isSane(height) {
  const [valid] = this.checkSanity(height); // check this 
  return valid;
};

/**
 * Non-contextual sanity checks for the transaction.
 * Will mostly verify coin and output values.
 * @see CheckTransaction()
 * @returns {Array} [valid, reason, score]
 */

TX.prototype.checkSanity = function checkSanity(height) {
  assert(typeof height === 'number');
  if (this.inputs.length === 0)
    return [false, 'bad-txns-vin-empty', 100];

  if (this.outputs.length === 0)
    return [false, 'bad-txns-vout-empty', 100];

  if (this.getBaseSize() > consensus.MAX_BLOCK_SIZE)
    return [false, 'bad-txns-oversize', 100];

  let total = 0;

  for (const output of this.outputs) {
    if (output.value < 0)
      return [false, 'bad-txns-vout-negative', 100];

    if (output.value > consensus.getMaxMoney(height))
      return [false, 'bad-txns-vout-toolarge', 100];

    if (!util.isSafeAddition(total, output.value)) // ctl
      return [false, 'bad-txns-txouttotal-toolarge', 100]; // ctl

    total += output.value;

    if (total < 0 || total > consensus.getMaxMoney(height))
      return [false, 'bad-txns-txouttotal-toolarge', 100];
  }

  const prevout = new Set();

  for (const input of this.inputs) {
    const key = input.prevout.toKey();

    if (prevout.has(key))
      return [false, 'bad-txns-inputs-duplicate', 100];

    prevout.add(key);
  }

  if (this.isCoinbase()) {
    const size = this.inputs[0].script.getSize();
    if (size < 2 || size > 100)
      return [false, 'bad-cb-length', 100];
  } else {
    for (const input of this.inputs) {
      if (input.prevout.isNull())
        return [false, 'bad-txns-prevout-null', 10];
    }
  }

  return [true, 'valid', 0];
};

/**
 * Non-contextual checks to determine whether the
 * transaction has all standard output script
 * types and standard input script size with only
 * pushdatas in the code.
 * Will mostly verify coin and output values.
 * @see IsStandardTx()
 * @returns {Array} [valid, reason, score]
 */

TX.prototype.isStandard = function isStandard() {
  const [valid] = this.checkStandard();
  return valid;
};

/**
 * Non-contextual checks to determine whether the
 * transaction has all standard output script
 * types and standard input script size with only
 * pushdatas in the code.
 * Will mostly verify coin and output values.
 * @see IsStandardTx()
 * @returns {Array} [valid, reason, score]
 */

TX.prototype.checkStandard = function checkStandard() {
  if (this.version < 1 || this.version > policy.MAX_TX_VERSION)
    return [false, 'version', 0];

  if (this.getWeight() >= policy.MAX_TX_WEIGHT)
    return [false, 'tx-size', 0];

  for (const input of this.inputs) {
    if (input.script.getSize() > 1650)
      return [false, 'scriptsig-size', 0];

    if (!input.script.isPushOnly())
      return [false, 'scriptsig-not-pushonly', 0];
  }

  let nulldata = 0;

  for (const output of this.outputs) {
    if (!output.script.isStandard())
      return [false, 'scriptpubkey', 0];

    if (output.script.isNulldata()) {
      nulldata++;
      continue;
    }

    if (output.script.isMultisig() && !policy.BARE_MULTISIG)
      return [false, 'bare-multisig', 0];

    if (output.isDust(policy.MIN_RELAY))
      return [false, 'dust', 0];
  }

  if (nulldata > 1)
    return [false, 'multi-op-return', 0];

  return [true, 'valid', 0];
};

/**
 * Perform contextual checks to verify coin and input
 * script standardness (including the redeem script).
 * @see AreInputsStandard()
 * @param {CoinView} view
 * @param {VerifyFlags?} flags
 * @returns {Boolean}
 */

TX.prototype.hasStandardInputs = function hasStandardInputs(view) {
  if (this.isCoinbase())
    return true;

  for (const input of this.inputs) {
    const coin = view.getOutputFor(input);

    if (!coin)
      return false;

    if (coin.script.isPubkeyhash())
      continue;

    if (coin.script.isScripthash()) {
      const redeem = input.script.getRedeem();

      if (!redeem)
        return false;

      if (redeem.getSigops(true) > policy.MAX_P2SH_SIGOPS)
        return false;

      continue;
    }

    if (coin.script.isUnknown())
      return false;
  }

  return true;
};

/**
 * Perform contextual checks to verify coin and witness standardness.
 * @see IsBadWitness()
 * @param {CoinView} view
 * @returns {Boolean}
 */

TX.prototype.hasStandardWitness = function hasStandardWitness(view) {
  if (this.isCoinbase())
    return true;

  for (const input of this.inputs) {
    const witness = input.witness;
    const coin = view.getOutputFor(input);

    if (!coin)
      continue;

    if (witness.items.length === 0)
      continue;

    let prev = coin.script;

    if (prev.isScripthash()) {
      prev = input.script.getRedeem();
      if (!prev)
        return false;
    }

    if (!prev.isProgram())
      return false;

    if (prev.isWitnessPubkeyhash()) {
      if (witness.items.length !== 2)
        return false;

      if (witness.items[0].length > 73)
        return false;

      if (witness.items[1].length > 65)
        return false;

      continue;
    }

    if (prev.isWitnessScripthash()) {
      if (witness.items.length - 1 > policy.MAX_P2WSH_STACK)
        return false;

      for (let i = 0; i < witness.items.length - 1; i++) {
        const item = witness.items[i];
        if (item.length > policy.MAX_P2WSH_PUSH)
          return false;
      }

      const raw = witness.items[witness.items.length - 1];

      if (raw.length > policy.MAX_P2WSH_SIZE)
        return false;

      const redeem = Script.fromRaw(raw);

      if (redeem.isPubkey()) {
        if (witness.items.length - 1 !== 1)
          return false;

        if (witness.items[0].length > 73)
          return false;

        continue;
      }

      if (redeem.isPubkeyhash()) {
        if (input.witness.items.length - 1 !== 2)
          return false;

        if (witness.items[0].length > 73)
          return false;

        if (witness.items[1].length > 65)
          return false;

        continue;
      }

      const [m] = redeem.getMultisig();

      if (m !== -1) {
        if (witness.items.length - 1 !== m + 1)
          return false;

        if (witness.items[0].length !== 0)
          return false;

        for (let i = 1; i < witness.items.length - 1; i++) {
          const item = witness.items[i];
          if (item.length > 73)
            return false;
        }
      }

      continue;
    }

    if (witness.items.length > policy.MAX_P2WSH_STACK)
      return false;

    for (const item of witness.items) {
      if (item.length > policy.MAX_P2WSH_PUSH)
        return false;
    }
  }

  return true;
};

/**
 * Perform contextual checks to verify input, output,
 * and fee values, as well as coinbase spend maturity
 * (coinbases can only be spent 100 blocks or more
 * after they're created). Note that this function is
 * consensus critical.
 * @param {CoinView} view
 * @param {Number} height - Height at which the
 * transaction is being spent. In the mempool this is
 * the chain height plus one at the time it entered the pool.
 * @returns {Boolean}
 */

TX.prototype.verifyInputs = function verifyInputs(view, height) {
  const [fee] = this.checkInputs(view, height);
  return fee !== -1;
};

/**
 * Perform contextual checks to verify input, output,
 * and fee values, as well as coinbase spend maturity
 * (coinbases can only be spent 100 blocks or more
 * after they're created). Note that this function is
 * consensus critical.
 * @param {CoinView} view
 * @param {Number} height - Height at which the
 * transaction is being spent. In the mempool this is
 * the chain height plus one at the time it entered the pool.
 * @returns {Array} [fee, reason, score]
 */

TX.prototype.checkInputs = function checkInputs(view, height) {
  assert(typeof height === 'number');

  let total = 0;

  for (const {prevout} of this.inputs) {
    const entry = view.getEntry(prevout);

    if (!entry)
      return [-1, 'bad-txns-inputs-missingorspent', 0];

    if (entry.coinbase) {
      if (height - entry.height < consensus.COINBASE_MATURITY)
        return [-1, 'bad-txns-premature-spend-of-coinbase', 0];
    }

    const coin = view.getOutput(prevout);
    assert(coin);

    if (coin.value < 0 || coin.value > consensus.getMaxMoney(height))
      return [-1, 'bad-txns-inputvalues-outofrange', 100];

    if (!util.isSafeAddition(total, coin.value)) // ctl
      return [-1, 'bad-txns-inputvalues-outofrange', 100]; // ctl

    total += coin.value;

    if (total < 0 || total > consensus.getMaxMoney(height))
      return [-1, 'bad-txns-inputvalues-outofrange', 100];
  }

  // Overflows already checked in `isSane()`.
  const value = this.getOutputValue();

  if (total < value)
    return [-1, 'bad-txns-in-belowout', 100];

  const fee = total - value;

  if (fee < 0)
    return [-1, 'bad-txns-fee-negative', 100];

  if (fee > consensus.getMaxMoney(height))
    return [-1, 'bad-txns-fee-outofrange', 100];

  return [fee, 'valid', 0];
};

/**
 * Calculate the modified size of the transaction. This
 * is used in the mempool for calculating priority.
 * @param {Number?} size - The size to modify. If not present,
 * virtual size will be used.
 * @returns {Number} Modified size.
 */

TX.prototype.getModifiedSize = function getModifiedSize(size) {
  if (size == null)
    size = this.getVirtualSize();

  for (const input of this.inputs) {
    const offset = 41 + Math.min(110, input.script.getSize());
    if (size > offset)
      size -= offset;
  }

  return size;
};

/**
 * Calculate the transaction priority.
 * @param {CoinView} view
 * @param {Number} height
 * @param {Number?} size - Size to calculate priority
 * based on. If not present, virtual size will be used.
 * @returns {Number}
 */

TX.prototype.getPriority = function getPriority(view, height, size) {
  assert(typeof height === 'number', 'Must pass in height.');

  if (this.isCoinbase())
    return 0;

  if (size == null)
    size = this.getVirtualSize();

  let sum = 0;

  for (const {prevout} of this.inputs) {
    const coin = view.getOutput(prevout);

    if (!coin)
      continue;

    const coinHeight = view.getHeight(prevout);

    if (coinHeight === -1)
      continue;

    if (coinHeight <= height) {
      const age = height - coinHeight;
      sum += coin.value * age;
    }
  }

  return Math.floor(sum / size);
};

/**
 * Calculate the transaction's on-chain value.
 * @param {CoinView} view
 * @returns {Number}
 */

TX.prototype.getChainValue = function getChainValue(view) {
  if (this.isCoinbase())
    return 0;

  let value = 0;

  for (const {prevout} of this.inputs) {
    const coin = view.getOutput(prevout);

    if (!coin)
      continue;

    const height = view.getHeight(prevout);

    if (height === -1)
      continue;

    value += coin.value;
  }

  return value;
};

/**
 * Determine whether the transaction is above the
 * free threshold in priority. A transaction which
 * passed this test is most likely relayable
 * without a fee.
 * @param {CoinView} view
 * @param {Number?} height - If not present, tx
 * height or network height will be used.
 * @param {Number?} size - If not present, modified
 * size will be calculated and used.
 * @returns {Boolean}
 */

TX.prototype.isFree = function isFree(view, height, size) {
  const priority = this.getPriority(view, height, size);
  return priority > policy.FREE_THRESHOLD;
};

/**
 * Calculate minimum fee in order for the transaction
 * to be relayable (not the constant min relay fee).
 * @param {Number?} size - If not present, max size
 * estimation will be calculated and used.
 * @param {Rate?} rate - Rate of wmcoin per kB.
 * @returns {Amount} fee
 */

TX.prototype.getMinFee = function getMinFee(size, rate) {
  if (size == null)
    size = this.getVirtualSize();

  return policy.getMinFee(size, rate);
};

/**
 * Calculate the minimum fee in order for the transaction
 * to be relayable, but _round to the nearest kilobyte
 * when taking into account size.
 * @param {Number?} size - If not present, max size
 * estimation will be calculated and used.
 * @param {Rate?} rate - Rate of wmcoin per kB.
 * @returns {Amount} fee
 */

TX.prototype.getRoundFee = function getRoundFee(size, rate) {
  if (size == null)
    size = this.getVirtualSize();

  return policy.getRoundFee(size, rate);
};

/**
 * Calculate the transaction's rate based on size
 * and fees. Size will be calculated if not present.
 * @param {CoinView} view
 * @param {Number?} size
 * @returns {Rate}
 */

TX.prototype.getRate = function getRate(view, size) {
  const fee = this.getFee(view);

  if (fee < 0)
    return 0;

  if (size == null)
    size = this.getVirtualSize();

  return policy.getRate(size, fee);
};

/**
 * Get all unique outpoint hashes.
 * @returns {Hash[]} Outpoint hashes.
 */

TX.prototype.getPrevout = function getPrevout() {
  if (this.isCoinbase())
    return [];

  const prevout = Object.create(null);

  for (const input of this.inputs)
    prevout[input.prevout.hash] = true;

  return Object.keys(prevout);
};

/**
 * Test a transaction against a bloom filter using
 * the BIP37 matching algorithm. Note that this may
 * update the filter depending on what the `update`
 * value is.
 * @see "Filter matching algorithm":
 * @see https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki
 * @param {Bloom} filter
 * @returns {Boolean} True if the transaction matched.
 */

TX.prototype.isWatched = function isWatched(filter) {
  let found = false;

  // 1. Test the tx hash
  if (filter.test(this.hash()))
    found = true;

  // 2. Test data elements in output scripts
  //    (may need to update filter on match)
  for (let i = 0; i < this.outputs.length; i++) {
    const output = this.outputs[i];
    // Test the output script
    if (output.script.test(filter)) {
      if (filter.update === Bloom.flags.ALL) {
        const prevout = Outpoint.fromTX(this, i);
        filter.add(prevout.toRaw());
      } else if (filter.update === Bloom.flags.PUBKEY_ONLY) {
        if (output.script.isPubkey() || output.script.isMultisig()) {
          const prevout = Outpoint.fromTX(this, i);
          filter.add(prevout.toRaw());
        }
      }
      found = true;
    }
  }

  if (found)
    return found;

  // 3. Test prev_out structure
  // 4. Test data elements in input scripts
  for (const input of this.inputs) {
    const prevout = input.prevout;

    // Test the COutPoint structure
    if (filter.test(prevout.toRaw()))
      return true;

    // Test the input script
    if (input.script.test(filter))
      return true;
  }

  // 5. No match
  return false;
};

/**
 * Get little-endian tx hash.
 * @returns {Hash}
 */

TX.prototype.rhash = function rhash() {
  return util.revHex(this.hash('hex'));
};

/**
 * Get little-endian wtx hash.
 * @returns {Hash}
 */

TX.prototype.rwhash = function rwhash() {
  return util.revHex(this.witnessHash('hex'));
};

/**
 * Get little-endian tx hash.
 * @returns {Hash}
 */

TX.prototype.txid = function txid() {
  return this.rhash();
};

/**
 * Get little-endian wtx hash.
 * @returns {Hash}
 */

TX.prototype.wtxid = function wtxid() {
  return this.rwhash();
};

/**
 * Convert the tx to an inv item.
 * @returns {InvItem}
 */

TX.prototype.toInv = function toInv() {
  return new InvItem(InvItem.types.TX, this.hash('hex'));
};

/**
 * Inspect the transaction and return a more
 * user-friendly representation of the data.
 * @returns {Object}
 */

TX.prototype.inspect = function inspect() {
  return this.format();
};

/**
 * Inspect the transaction and return a more
 * user-friendly representation of the data.
 * @param {CoinView} view
 * @param {ChainEntry} entry
 * @param {Number} index
 * @returns {Object}
 */

TX.prototype.format = function format(view, entry, index) {
  let rate = 0;
  let fee = 0;
  let height = -1;
  let block = null;
  let time = 0;
  let date = null;

  if (view) {
    fee = this.getFee(view);
    rate = this.getRate(view);

    // Rate can exceed 53 bits in testing.
    if (!Number.isSafeInteger(rate))
      rate = 0;
  }

  if (entry) {
    height = entry.height;
    block = util.revHex(entry.hash);
    time = entry.time;
    date = util.date(time);
  }

  if (index == null)
    index = -1;

  return {
    hash: this.txid(),
    witnessHash: this.wtxid(),
    size: this.getSize(),
    virtualSize: this.getVirtualSize(),
    value: Amount.wmcc(this.getOutputValue()),
    fee: Amount.wmcc(fee),
    rate: Amount.wmcc(rate),
    minFee: Amount.wmcc(this.getMinFee()),
    height: height,
    block: block,
    time: time,
    date: date,
    index: index,
    version: this.version,
    inputs: this.inputs.map((input) => {
      const coin = view ? view.getOutputFor(input) : null;
      return input.format(coin);
    }),
    outputs: this.outputs,
    locktime: this.locktime
  };
};

/**
 * Convert the transaction to an object suitable
 * for JSON serialization.
 * @returns {Object}
 */

TX.prototype.toJSON = function toJSON() {
  return this.getJSON();
};

/**
 * Convert the transaction to an object suitable
 * for JSON serialization. Note that the hashes
 * will be reversed to abide by wmccd's legacy
 * of little-endian uint256s.
 * @param {Network} network
 * @param {CoinView} view
 * @param {ChainEntry} entry
 * @param {Number} index
 * @returns {Object}
 */

TX.prototype.getJSON = function getJSON(network, view, entry, index) {
  let rate, fee, height, block, time, date;

  if (view) {
    fee = this.getFee(view);
    rate = this.getRate(view);

    // Rate can exceed 53 bits in testing.
    if (!Number.isSafeInteger(rate))
      rate = 0;
  }

  if (entry) {
    height = entry.height;
    block = util.revHex(entry.hash);
    time = entry.time;
    date = util.date(time);
  }

  network = Network.get(network);

  return {
    hash: this.txid(),
    witnessHash: this.wtxid(),
    fee: fee,
    rate: rate,
    mtime: util.now(),
    height: height,
    block: block,
    time: time,
    date: date,
    index: index,
    version: this.version,
    inputs: this.inputs.map((input) => {
      const coin = view ? view.getCoinFor(input) : null;
      return input.getJSON(network, coin);
    }),
    outputs: this.outputs.map((output) => {
      return output.getJSON(network);
    }),
    locktime: this.locktime,
    hex: this.toRaw().toString('hex')
  };
};

/**
 * Inject properties from a json object.
 * @private
 * @param {Object} json
 */

TX.prototype.fromJSON = function fromJSON(json) {
  assert(json, 'TX data is required.');
  assert(util.isU32(json.version), 'Version must be a uint32.');
  assert(Array.isArray(json.inputs), 'Inputs must be an array.');
  assert(Array.isArray(json.outputs), 'Outputs must be an array.');
  assert(util.isU32(json.locktime), 'Locktime must be a uint32.');

  this.version = json.version;

  for (const input of json.inputs)
    this.inputs.push(Input.fromJSON(input));

  for (const output of json.outputs)
    this.outputs.push(Output.fromJSON(output));

  this.locktime = json.locktime;

  return this;
};

/**
 * Instantiate a transaction from a
 * jsonified transaction object.
 * @param {Object} json - The jsonified transaction object.
 * @returns {TX}
 */

TX.fromJSON = function fromJSON(json) {
  return new TX().fromJSON(json);
};

/**
 * Instantiate a transaction from a serialized Buffer.
 * @param {Buffer} data
 * @param {String?} enc - Encoding, can be `'hex'` or null.
 * @returns {TX}
 */

TX.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new TX().fromRaw(data);
};

/**
 * Instantiate a transaction from a buffer reader.
 * @param {BufferReader} br
 * @returns {TX}
 */

TX.fromReader = function fromReader(br) {
  return new TX().fromReader(br);
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

TX.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

TX.prototype.fromReader = function fromReader(br) {
  if (hasWitnessBytes(br))
    return this.fromWitnessReader(br);

  br.start();

  this.version = br.readU32();

  const inCount = br.readVarint();

  for (let i = 0; i < inCount; i++)
    this.inputs.push(Input.fromReader(br));

  const outCount = br.readVarint();

  for (let i = 0; i < outCount; i++)
    this.outputs.push(Output.fromReader(br));

  this.locktime = br.readU32();

  if (!this.mutable) {
    this._raw = br.endData();
    this._size = this._raw.length;
    this._witness = 0;
  } else {
    br.end();
  }

  return this;
};

/**
 * Inject properties from serialized
 * buffer reader (witness serialization).
 * @private
 * @param {BufferReader} br
 */

TX.prototype.fromWitnessReader = function fromWitnessReader(br) {
  br.start();

  this.version = br.readU32();

  assert(br.readU8() === 0, 'Non-zero marker.');

  let flags = br.readU8();

  assert(flags !== 0, 'Flags byte is zero.');

  const inCount = br.readVarint();

  for (let i = 0; i < inCount; i++)
    this.inputs.push(Input.fromReader(br));

  const outCount = br.readVarint();

  for (let i = 0; i < outCount; i++)
    this.outputs.push(Output.fromReader(br));

  let witness = 0;
  let hasWitness = false;

  if (flags & 1) {
    flags ^= 1;

    witness = br.offset;

    for (const input of this.inputs) {
      input.witness.fromReader(br);
      if (input.witness.items.length > 0)
        hasWitness = true;
    }

    witness = (br.offset - witness) + 2;
  }

  if (flags !== 0)
    throw new Error('Unknown witness flag.');

  // We'll never be able to reserialize
  // this to get the regular txid, and
  // there's no way it's valid anyway.
  if (this.inputs.length === 0 && this.outputs.length !== 0)
    throw new Error('Zero input witness tx.');

  this.locktime = br.readU32();

  if (!this.mutable && hasWitness) {
    this._raw = br.endData();
    this._size = this._raw.length;
    this._witness = witness;
  } else {
    br.end();
  }

  return this;
};

/**
 * Serialize transaction without witness.
 * @private
 * @returns {RawTX}
 */

TX.prototype.frameNormal = function frameNormal() {
  const raw = this.getNormalSizes();
  const bw = new StaticWriter(raw.size);
  this.writeNormal(bw);
  raw.data = bw.render();
  return raw;
};

/**
 * Serialize transaction with witness. Calculates the witness
 * size as it is framing (exposed on return value as `witness`).
 * @private
 * @returns {RawTX}
 */

TX.prototype.frameWitness = function frameWitness() {
  const raw = this.getWitnessSizes();
  const bw = new StaticWriter(raw.size);
  this.writeWitness(bw);
  raw.data = bw.render();
  return raw;
};

/**
 * Serialize transaction without witness.
 * @private
 * @param {BufferWriter} bw
 * @returns {RawTX}
 */

TX.prototype.writeNormal = function writeNormal(bw) {
  if (this.inputs.length === 0 && this.outputs.length !== 0)
    throw new Error('Cannot serialize zero-input tx.');

  bw.writeU32(this.version);

  bw.writeVarint(this.inputs.length);

  for (const input of this.inputs)
    input.toWriter(bw);

  bw.writeVarint(this.outputs.length);

  for (const output of this.outputs)
    output.toWriter(bw);

  bw.writeU32(this.locktime);

  return bw;
};

/**
 * Serialize transaction with witness. Calculates the witness
 * size as it is framing (exposed on return value as `witness`).
 * @private
 * @param {BufferWriter} bw
 * @returns {RawTX}
 */

TX.prototype.writeWitness = function writeWitness(bw) {
  if (this.inputs.length === 0 && this.outputs.length !== 0)
    throw new Error('Cannot serialize zero-input tx.');

  bw.writeU32(this.version);
  bw.writeU8(0);
  bw.writeU8(1);

  bw.writeVarint(this.inputs.length);

  for (const input of this.inputs)
    input.toWriter(bw);

  bw.writeVarint(this.outputs.length);

  for (const output of this.outputs)
    output.toWriter(bw);

  const start = bw.offset;

  for (const input of this.inputs)
    input.witness.toWriter(bw);

  const witness = bw.offset - start;

  bw.writeU32(this.locktime);

  if (witness === this.inputs.length)
    throw new Error('Cannot serialize empty-witness tx.');

  return bw;
};

/**
 * Calculate the real size of the transaction
 * without the witness vector.
 * @returns {RawTX}
 */

TX.prototype.getNormalSizes = function getNormalSizes() {
  let base = 0;

  base += 4;

  base += encoding.sizeVarint(this.inputs.length);

  for (const input of this.inputs)
    base += input.getSize();

  base += encoding.sizeVarint(this.outputs.length);

  for (const output of this.outputs)
    base += output.getSize();

  base += 4;

  return new RawTX(base, 0);
};

/**
 * Calculate the real size of the transaction
 * with the witness included.
 * @returns {RawTX}
 */

TX.prototype.getWitnessSizes = function getWitnessSizes() {
  let base = 0;
  let witness = 0;

  base += 4;
  witness += 2;

  base += encoding.sizeVarint(this.inputs.length);

  for (const input of this.inputs) {
    base += input.getSize();
    witness += input.witness.getVarSize();
  }

  base += encoding.sizeVarint(this.outputs.length);

  for (const output of this.outputs)
    base += output.getSize();

  base += 4;

  return new RawTX(base + witness, witness);
};

/**
 * Test whether an object is a TX.
 * @param {Object} obj
 * @returns {Boolean}
 */

TX.isTX = function isTX(obj) {
  return obj instanceof TX;
};

/*
 * Helpers
 */

function hasWitnessBytes(br) {
  if (br.left() < 6)
    return false;

  return br.data[br.offset + 4] === 0
    && br.data[br.offset + 5] !== 0;
}

function RawTX(size, witness) {
  this.data = null;
  this.size = size;
  this.witness = witness;
}

/*
 * Expose
 */

module.exports = TX;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * co.js - promise and generator control flow for wmcc_core.
 * Originally based on yoursnetwork's "asink" module.
 */



/**
 * @module utils/co
 */

const assert = __webpack_require__(0);

/**
 * Execute an instantiated generator.
 * @param {Generator} gen
 * @returns {Promise}
 */

function exec(gen) {
  return new Promise((resolve, reject) => {
    const step = (value, rejection) => {
      let next;

      try {
        if (rejection)
          next = gen.throw(value);
        else
          next = gen.next(value);
      } catch (e) {
        reject(e);
        return;
      }

      if (next.done) {
        resolve(next.value);
        return;
      }

      if (!isPromise(next.value)) {
        step(next.value, false);
        return;
      }

      // eslint-disable-next-line no-use-before-define
      next.value.then(succeed, fail);
    };

    const succeed = (value) => {
      step(value, false);
    };

    const fail = (value) => {
      step(value, true);
    };

    step(undefined, false);
  });
}

/**
 * Execute generator function
 * with a context and execute.
 * @param {GeneratorFunction} generator
 * @param {Object?} self
 * @returns {Promise}
 */

function spawn(generator, self) {
  const gen = generator.call(self);
  return exec(gen);
}

/**
 * Wrap a generator function to be
 * executed into a function that
 * returns a promise.
 * @param {GeneratorFunction}
 * @returns {Function}
 */

function co(generator) {
  return function() {
    const gen = generator.apply(this, arguments);
    return exec(gen);
  };
}

/**
 * Test whether an object is a promise.
 * @param {Object} obj
 * @returns {Boolean}
 */

function isPromise(obj) {
  return obj && typeof obj.then === 'function';
}

/**
 * Wait for a nextTick with a promise.
 * @returns {Promise}
 */

function wait() {
  return new Promise(resolve => setImmediate(resolve));
};

/**
 * Wait for a timeout with a promise.
 * @param {Number} time
 * @returns {Promise}
 */

function timeout(time) {
  return new Promise(resolve => setTimeout(resolve, time));
}

/**
 * Wrap `resolve` and `reject` into
 * a node.js style callback.
 * @param {Function} resolve
 * @param {Function} reject
 * @returns {Function}
 */

function wrap(resolve, reject) {
  return function(err, result) {
    if (err) {
      reject(err);
      return;
    }
    resolve(result);
  };
}

/**
 * Wrap a function that accepts node.js
 * style callbacks into a function that
 * returns a promise.
 * @param {Function} func
 * @returns {AsyncFunction}
 */

function promisify(func) {
  return function(...args) {
    return new Promise((resolve, reject) => {
      args.push(wrap(resolve, reject));
      func.call(this, ...args);
    });
  };
}

/**
 * Wrap a promise-returning function
 * into a function that accepts a
 * node.js style callback.
 * @param {AsyncFunction} func
 * @returns {Function}
 */

function callbackify(func) {
  return function(...args) {
    if (args.length === 0
        || typeof args[args.length - 1] !== 'function') {
      throw new Error(`${func.name || 'Function'} requires a callback.`);
    }

    const callback = args.pop();

    func.call(this, ...args).then((value) => {
      setImmediate(() => callback(null, value));
    }, (err) => {
      setImmediate(() => callback(err));
    });
  };
}

/**
 * Execute each promise and
 * have them pass a truth test.
 * @method
 * @param {Promise[]} jobs
 * @returns {Promise}
 */

async function every(jobs) {
  const result = await Promise.all(jobs);

  for (const item of result) {
    if (!item)
      return false;
  }

  return true;
}

/**
 * Start an interval. Wait for promise
 * to resolve on each iteration.
 * @param {Function} func
 * @param {Number?} time
 * @param {Object?} self
 * @returns {Object}
 */

function startInterval(func, time, self) {
  const ctx = {
    timer: null,
    stopped: false
  };

  const cb = async () => {
    assert(ctx.timer != null);
    ctx.timer = null;

    try {
      await func.call(self);
    } finally {
      if (!ctx.stopped)
        ctx.timer = setTimeout(cb, time);
    }
  };

  ctx.timer = setTimeout(cb, time);

  return ctx;
}

/**
 * Clear an interval.
 * @param {Object} ctx
 */

function stopInterval(ctx) {
  assert(ctx);
  if (ctx.timer != null) {
    clearTimeout(ctx.timer);
    ctx.timer = null;
  }
  ctx.stopped = true;
}

/**
 * Start a timeout.
 * @param {Function} func
 * @param {Number?} time
 * @param {Object?} self
 * @returns {Object}
 */

function startTimeout(func, time, self) {
  return {
    timer: setTimeout(func.bind(self), time),
    stopped: false
  };
}

/**
 * Clear a timeout.
 * @param {Object} ctx
 */

function stopTimeout(ctx) {
  assert(ctx);
  if (ctx.timer != null) {
    clearTimeout(ctx.timer);
    ctx.timer = null;
  }
  ctx.stopped = true;
}

/**
 * Create a job object.
 * @returns {Job}
 */

function job(resolve, reject) {
  return new Job(resolve, reject);
}

/**
 * Job
 * @constructor
 * @ignore
 * @param {Function} resolve
 * @param {Function} reject
 * @property {Function} resolve
 * @property {Function} reject
 */

function Job(resolve, reject) {
  this.resolve = resolve;
  this.reject = reject;
}

/*
 * Expose
 */

exports = co;
exports.exec = exec;
exports.spawn = spawn;
exports.co = co;
exports.wait = wait;
exports.timeout = timeout;
exports.wrap = wrap;
exports.promisify = promisify;
exports.callbackify = callbackify;
exports.every = every;
exports.setInterval = startInterval;
exports.clearInterval = stopInterval;
exports.setTimeout = startTimeout;
exports.clearTimeout = stopTimeout;
exports.job = job;

module.exports = exports;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * native.js - Native bindings for wmcc_core.
 */
 


exports.binding = null;

if (Number(process.env.WMCC_NO_NATIVE) !== 1) {
  try {
    exports.binding = __webpack_require__(132);
  } catch (e) {
    ;
  }
}


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * policy.js - WMCC constants for wmcc_core.
 */



/**
 * @module protocol/policy
 */

const assert = __webpack_require__(0);
const consensus = __webpack_require__(7);

/**
 * Maximum transaction version (policy).
 * @const {Number}
 * @default
 */

exports.MAX_TX_VERSION = 2;

/**
 * Maximum transaction base size (policy).
 * @const {Number}
 * @default
 */

exports.MAX_TX_SIZE = consensus.MAX_BLOCK_SIZE / 10;

/**
 * Maximum transaction weight (policy).
 * @const {Number}
 * @default
 */

exports.MAX_TX_WEIGHT = consensus.MAX_BLOCK_WEIGHT / 10;

/**
 * Maximum number of transaction sigops (policy).
 * @const {Number}
 * @default
 */

exports.MAX_TX_SIGOPS = consensus.MAX_BLOCK_SIGOPS / 5;

/**
 * Maximum cost of transaction sigops (policy).
 * @const {Number}
 * @default
 */

exports.MAX_TX_SIGOPS_COST = consensus.MAX_BLOCK_SIGOPS_COST / 5;

/**
 * How much weight a sigop should
 * add to virtual size (policy).
 * @const {Number}
 * @default
 */

exports.BYTES_PER_SIGOP = 20;

/**
 * Minimum relay fee rate (policy).
 * @const {Rate}
 */

exports.MIN_RELAY = 1000;

/**
 * Whether bare multisig outputs
 * should be relayed (policy).
 * @const {Boolean}
 * @default
 */

exports.BARE_MULTISIG = true;

/**
 * Priority threshold for
 * free transactions (policy).
 * @const {Number}
 * @default
 */

exports.FREE_THRESHOLD = consensus.COIN * 144 / 250;

/**
 * Max sigops per redeem script (policy).
 * @const {Number}
 * @default
 */

exports.MAX_P2SH_SIGOPS = 15;

/**
 * Max serialized nulldata size (policy).
 * @const {Number}
 * @default
 */

exports.MAX_OP_RETURN_BYTES = 83;

/**
 * Max pushdata size in nulldata (policy).
 * @const {Number}
 * @default
 */

exports.MAX_OP_RETURN = 80;

/**
 * Max p2wsh stack size. Used for
 * witness malleation checks (policy).
 * @const {Number}
 * @default
 */

exports.MAX_P2WSH_STACK = 100;

/**
 * Max p2wsh push size. Used for
 * witness malleation checks (policy).
 * @const {Number}
 * @default
 */

exports.MAX_P2WSH_PUSH = 80;

/**
 * Max serialized p2wsh size. Used for
 * witness malleation checks (policy).
 * @const {Number}
 * @default
 */

exports.MAX_P2WSH_SIZE = 3600;

/**
 * Default ancestor limit.
 * @const {Number}
 * @default
 */

exports.MEMPOOL_MAX_ANCESTORS = 25;

/**
 * Default maximum mempool size in bytes.
 * @const {Number}
 * @default
 */

exports.MEMPOOL_MAX_SIZE = 100 * 1000000;

/**
 * Time at which transactions
 * fall out of the mempool.
 * @const {Number}
 * @default
 */

exports.MEMPOOL_EXPIRY_TIME = 72 * 60 * 60;

/**
 * Maximum number of orphan transactions.
 * @const {Number}
 * @default
 */

exports.MEMPOOL_MAX_ORPHANS = 100;

/**
 * Minimum block size to create. Block will be
 * filled with free transactions until block
 * reaches this weight.
 * @const {Number}
 * @default
 */

exports.MIN_BLOCK_WEIGHT = 0;

/**
 * Maximum block weight to be mined.
 * @const {Number}
 * @default
 */

exports.MAX_BLOCK_WEIGHT = 1000000 * consensus.WITNESS_SCALE_FACTOR;

/**
 * How much of the block should be dedicated to
 * high-priority transactions (included regardless
 * of fee rate).
 * @const {Number}
 * @default
 */

exports.BLOCK_PRIORITY_WEIGHT = 0;

/**
 * Priority threshold to be reached before
 * switching to fee rate comparison.
 * @const {Number}
 * @default
 */

exports.BLOCK_PRIORITY_THRESHOLD = exports.FREE_THRESHOLD;

/**
 * Calculate minimum fee based on rate and size.
 * @param {Number?} size
 * @param {Rate?} rate - Rate of wmcoin per kB.
 * @returns {Amount} fee
 */

exports.getMinFee = function getMinFee(size, rate) {
  if (rate == null)
    rate = exports.MIN_RELAY;

  assert(size >= 0);
  assert(rate >= 0);

  if (size === 0)
    return 0;

  let fee = Math.floor(rate * size / 1000);

  if (fee === 0 && rate > 0)
    fee = rate;

  return fee;
};

/**
 * Calculate the minimum fee in order for the transaction
 * to be relayable, but _round to the nearest kilobyte
 * when taking into account size.
 * @param {Number?} size
 * @param {Rate?} rate - Rate of wmcoin per kB.
 * @returns {Amount} fee
 */

exports.getRoundFee = function getRoundFee(size, rate) {
  if (rate == null)
    rate = exports.MIN_RELAY;

  assert(size >= 0);
  assert(rate >= 0);

  if (size === 0)
    return 0;

  let fee = rate * Math.ceil(size / 1000);

  if (fee === 0 && rate > 0)
    fee = rate;

  return fee;
};

/**
 * Calculate a fee rate based on size and fees.
 * @param {Number} size
 * @param {Amount} fee
 * @returns {Rate}
 */

exports.getRate = function getRate(size, fee) {
  assert(size >= 0);
  assert(fee >= 0);

  if (size === 0)
    return 0;

  return Math.floor(fee * 1000 / size);
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * amount.js - amount object for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);

/**
 * Represents a wmcc amount (wmcoins internally).
 * @alias module:wmcc.Amount
 * @constructor
 * @param {(String|Number)?} value
 * @param {String?} unit
 * @property {Amount} value
 */

function Amount(value, unit) {
  if (!(this instanceof Amount))
    return new Amount(value, unit);

  this.value = 0;
  this.unit = null;

  if (value != null)
    this.fromOptions(value, unit);
}

/**
 * Inject properties from options.
 * @private
 * @param {(String|Number)?} value
 * @param {String?} unit
 * @returns {Amount}
 */

Amount.prototype.fromOptions = function fromOptions(value, unit) {
  if (typeof unit === 'string')
    return this.from(unit, value);

  if (typeof value === 'number')
    return this.fromValue(value);

  return this.fromWMCC(value);
};

/**
 * Get wmcoin value.
 * @returns {Amount}
 */

Amount.prototype.toValue = function toValue() {
  return this.value;
};

/**
 * Get wmcoin string or value.
 * @param {Boolean?} num
 * @returns {String|Amount}
 */

Amount.prototype.toWMCoin = function toWMCoin(num) {
  if (num)
    return this.value;

  return this.value.toString(10);
};

/**
 * Get bits string or value.
 * @param {Boolean?} num
 * @returns {String|Amount}
 */

Amount.prototype.toBits = function toBits(num) {
  return Amount.encode(this.value, 2, num);
};

/**
 * Get mwmcc string or value.
 * @param {Boolean?} num
 * @returns {String|Amount}
 */

Amount.prototype.toMWMCC = function toMWMCC(num) {
  return Amount.encode(this.value, 5, num);
};

/**
 * Get wmcc string or value.
 * @param {Boolean?} num
 * @returns {String|Amount}
 */

Amount.prototype.toWMCC = function toWMCC(num) {
  return Amount.encode(this.value, 8, num);
};

/**
 * Get unit string or value.
 * @param {String} unit - Can be `sat`,
 * `uwmcc`, `bits`, `mwmcc`, or `wmcc`.
 * @param {Boolean?} num
 * @returns {String|Amount}
 */

Amount.prototype.to = function to(unit, num) {
  switch (unit) {
    case 'wmcoin':
      return this.toWMCoin(num);
    case 'uwmcc':
    case 'bits':
      return this.toBits(num);
    case 'mwmcc':
      return this.toMWMCC(num);
    case 'wmcc':
      return this.toWMCC(num);
  }
  throw new Error(`Unknown unit "${unit}".`);
};

/**
 * Convert amount to wmcc string.
 * @returns {String}
 */

Amount.prototype.toString = function toString() {
  return this.toWMCC();
};

/**
 * Convert amount to wmcc string with unit.
 * @param {String} unit
 * @returns {String}
 */

Amount.prototype.toText = function toText(unit, num) {
  return `${this.to(unit, num)} ${unit}`;
};

/**
 * Inject properties from value.
 * @private
 * @param {Amount} value
 * @returns {Amount}
 */

Amount.prototype.fromValue = function fromValue(value) {
  assert(util.isI64(value), 'Value must be an int64.');
  this.unit = 'wmcc';
  this.value = value;
  return this;
};

/**
 * Inject properties from wmcoins.
 * @private
 * @param {Number|String} value
 * @returns {Amount}
 */

Amount.prototype.fromWMCoin = function fromWMCoin(value) {
  this.unit = 'wmcoin';
  this.value = Amount.decode(value, 0);
  return this;
};

/**
 * Inject properties from bits.
 * @private
 * @param {Number|String} value
 * @returns {Amount}
 */

Amount.prototype.fromBits = function fromBits(value) {
  this.unit = 'bits';
  this.value = Amount.decode(value, 2);
  return this;
};

/**
 * Inject properties from mwmcc.
 * @private
 * @param {Number|String} value
 * @returns {Amount}
 */

Amount.prototype.fromMWMCC = function fromMWMCC(value) {
  this.unit = 'mwmcc';
  this.value = Amount.decode(value, 5);
  return this;
};

/**
 * Inject properties from wmcc.
 * @private
 * @param {Number|String} value
 * @returns {Amount}
 */

Amount.prototype.fromWMCC = function fromWMCC(value) {
  this.unit = 'wmcc';
  this.value = Amount.decode(value, 8);
  return this;
};

/**
 * Inject properties from unit.
 * @private
 * @param {String} unit
 * @param {Number|String} value
 * @returns {Amount}
 */

Amount.prototype.from = function from(unit, value) {
  switch (unit) {
    case 'wmcoin':
      return this.fromWMCoin(value);
    case 'uwmcc':
    case 'bits':
      return this.fromBits(value);
    case 'mwmcc':
      return this.fromMWMCC(value);
    case 'wmcc':
      return this.fromWMCC(value);
  }
  throw new Error(`Unknown unit "${unit}".`);
};

/**
 * Instantiate amount from options.
 * @param {(String|Number)?} value
 * @param {String?} unit
 * @returns {Amount}
 */

Amount.fromOptions = function fromOptions(value, unit) {
  return new Amount().fromOptions(value, unit);
};

/**
 * Instantiate amount from value.
 * @private
 * @param {Amount} value
 * @returns {Amount}
 */

Amount.fromValue = function fromValue(value) {
  return new Amount().fromValue(value);
};

/**
 * Instantiate amount from wmcoins.
 * @param {Number|String} value
 * @returns {Amount}
 */

Amount.fromWMCoin = function fromWMCoin(value) {
  return new Amount().fromWMCoin(value);
};

/**
 * Instantiate amount from bits.
 * @param {Number|String} value
 * @returns {Amount}
 */

Amount.fromBits = function fromBits(value) {
  return new Amount().fromBits(value);
};

/**
 * Instantiate amount from mwmcc.
 * @param {Number|String} value
 * @returns {Amount}
 */

Amount.fromMWMCC = function fromMWMCC(value) {
  return new Amount().fromMWMCC(value);
};

/**
 * Instantiate amount from wmcc.
 * @param {Number|String} value
 * @returns {Amount}
 */

Amount.fromWMCC = function fromWMCC(value) {
  return new Amount().fromWMCC(value);
};

/**
 * Instantiate amount from unit.
 * @param {String} unit
 * @param {Number|String} value
 * @returns {Amount}
 */

Amount.from = function from(unit, value) {
  return new Amount().from(unit, value);
};

/**
 * Inspect amount.
 * @returns {String}
 */

Amount.prototype.inspect = function inspect() {
  return `<Amount: ${this.toString()}>`;
};

/**
 * Convert WMCC string to a WMCoin.
 * @param {String} value - WMCC.
 * @returns {Amount} WMCoin.
 */

Amount.wmcoin = function wmcoin(value) {
  return Amount.fromWMCC(value).toWMCoin(true);
};

/**
 * Safely convert wmcoins to a WMCC string.
 * This function explicitly avoids any
 * floating point arithmetic.
 * @param {Amount} value - WMCoin.
 * @returns {String} WMCC string.
 */

Amount.wmcc = function wmcc(value, num) {
  if (typeof value === 'string')
    return value;

  return Amount.encode(value, 8, num);
};

/**
 * Safely convert wmcoins to a WMCC string with unit.
 * This function explicitly avoids any
 * floating point arithmetic.
 * @param {Amount} value - WMCoin.
 * @returns {String} WMCC string.
 */

Amount.text = function text(value, num) {
  return `${Amount.wmcc(value, num)} wmcc`;
};

/**
 * Safely convert a WMCC string to wmcoins.
 * @param {String} str - WMCC
 * @returns {Amount} WMCoin.
 * @throws on parse error
 */

Amount.value = function value(str) {
  if (typeof str === 'number')
    return str;

  return Amount.decode(str, 8);
};

/**
 * Safely convert wmcoins to a WMCC string.
 * @param {Amount} value
 * @param {Number} exp - Exponent.
 * @param {Boolean} num - Return a number.
 * @returns {String|Number}
 */

Amount.encode = function encode(value, exp, num) {
  if (num)
    return util.toFloat(value, exp);
  return util.toFixed(value, exp);
};

/**
 * Safely convert a WMCC string to wmcoins.
 * @param {String|Number} value - WMCC
 * @param {Number} exp - Exponent.
 * @returns {Amount} WMCoin.
 * @throws on parse error
 */

Amount.decode = function decode(value, exp) {
  if (typeof value === 'number')
    return util.fromFloat(value, exp);
  return util.fromFixed(value, exp);
};

/*
 * Expose
 */

module.exports = Amount;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * outpoint.js - outpoint object for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const StaticWriter = __webpack_require__(4);
const BufferReader = __webpack_require__(2);
const encoding = __webpack_require__(3);

/**
 * Represents a COutPoint.
 * @alias module:primitives.Outpoint
 * @constructor
 * @param {Hash?} hash
 * @param {Number?} index
 * @property {Hash} hash
 * @property {Number} index
 */

function Outpoint(hash, index) {
  if (!(this instanceof Outpoint))
    return new Outpoint(hash, index);

  this.hash = encoding.NULL_HASH;
  this.index = 0xffffffff;

  if (hash != null) {
    assert(typeof hash === 'string', 'Hash must be a string.');
    assert(util.isU32(index), 'Index must be a uint32.');
    this.hash = hash;
    this.index = index;
  }
}

/**
 * Inject properties from options object.
 * @private
 * @param {Object} options
 */

Outpoint.prototype.fromOptions = function fromOptions(options) {
  assert(options, 'Outpoint data is required.');
  assert(typeof options.hash === 'string', 'Hash must be a string.');
  assert(util.isU32(options.index), 'Index must be a uint32.');
  this.hash = options.hash;
  this.index = options.index;
  return this;
};

/**
 * Instantate outpoint from options object.
 * @param {Object} options
 * @returns {Outpoint}
 */

Outpoint.fromOptions = function fromOptions(options) {
  return new Outpoint().fromOptions(options);
};

/**
 * Clone the outpoint.
 * @returns {Outpoint}
 */

Outpoint.prototype.clone = function clone() {
  const outpoint = new Outpoint();
  outpoint.hash = this.value;
  outpoint.index = this.index;
  return outpoint;
};

/**
 * Test equality against another outpoint.
 * @param {Outpoint} prevout
 * @returns {Boolean}
 */

Outpoint.prototype.equals = function equals(prevout) {
  assert(Outpoint.isOutpoint(prevout));
  return this.hash === prevout.hash
    && this.index === prevout.index;
};

/**
 * Compare against another outpoint (BIP69).
 * @param {Outpoint} prevout
 * @returns {Number}
 */

Outpoint.prototype.compare = function compare(prevout) {
  assert(Outpoint.isOutpoint(prevout));

  const cmp = util.strcmp(this.txid(), prevout.txid());

  if (cmp !== 0)
    return cmp;

  return this.index - prevout.index;
};

/**
 * Test whether the outpoint is null (hash of zeroes
 * with max-u32 index). Used to detect coinbases.
 * @returns {Boolean}
 */

Outpoint.prototype.isNull = function isNull() {
  return this.index === 0xffffffff && this.hash === encoding.NULL_HASH;
};

/**
 * Get little-endian hash.
 * @returns {Hash}
 */

Outpoint.prototype.rhash = function rhash() {
  return util.revHex(this.hash);
};

/**
 * Get little-endian hash.
 * @returns {Hash}
 */

Outpoint.prototype.txid = function txid() {
  return this.rhash();
};

/**
 * Serialize outpoint to a key
 * suitable for a hash table.
 * @returns {String}
 */

Outpoint.prototype.toKey = function toKey() {
  return Outpoint.toKey(this.hash, this.index);
};

/**
 * Inject properties from hash table key.
 * @private
 * @param {String} key
 * @returns {Outpoint}
 */

Outpoint.prototype.fromKey = function fromKey(key) {
  assert(key.length > 64);
  this.hash = key.slice(0, 64);
  this.index = parseInt(key.slice(64), 10);
  return this;
};

/**
 * Instantiate outpoint from hash table key.
 * @param {String} key
 * @returns {Outpoint}
 */

Outpoint.fromKey = function fromKey(key) {
  return new Outpoint().fromKey(key);
};

/**
 * Write outpoint to a buffer writer.
 * @param {BufferWriter} bw
 */

Outpoint.prototype.toWriter = function toWriter(bw) {
  bw.writeHash(this.hash);
  bw.writeU32(this.index);
  return bw;
};

/**
 * Calculate size of outpoint.
 * @returns {Number}
 */

Outpoint.prototype.getSize = function getSize() {
  return 36;
};

/**
 * Serialize outpoint.
 * @returns {Buffer}
 */

Outpoint.prototype.toRaw = function toRaw() {
  return this.toWriter(new StaticWriter(36)).render();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

Outpoint.prototype.fromReader = function fromReader(br) {
  this.hash = br.readHash('hex');
  this.index = br.readU32();
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

Outpoint.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate outpoint from a buffer reader.
 * @param {BufferReader} br
 * @returns {Outpoint}
 */

Outpoint.fromReader = function fromReader(br) {
  return new Outpoint().fromReader(br);
};

/**
 * Instantiate outpoint from serialized data.
 * @param {Buffer} data
 * @returns {Outpoint}
 */

Outpoint.fromRaw = function fromRaw(data) {
  return new Outpoint().fromRaw(data);
};

/**
 * Inject properties from json object.
 * @private
 * @params {Object} json
 */

Outpoint.prototype.fromJSON = function fromJSON(json) {
  assert(json, 'Outpoint data is required.');
  assert(typeof json.hash === 'string', 'Hash must be a string.');
  assert(util.isU32(json.index), 'Index must be a uint32.');
  this.hash = util.revHex(json.hash);
  this.index = json.index;
  return this;
};

/**
 * Convert the outpoint to an object suitable
 * for JSON serialization. Note that the hash
 * will be reversed to abide by wmccd's legacy
 * of little-endian uint256s.
 * @returns {Object}
 */

Outpoint.prototype.toJSON = function toJSON() {
  return {
    hash: util.revHex(this.hash),
    index: this.index
  };
};

/**
 * Instantiate outpoint from json object.
 * @param {Object} json
 * @returns {Outpoint}
 */

Outpoint.fromJSON = function fromJSON(json) {
  return new Outpoint().fromJSON(json);
};

/**
 * Inject properties from tx.
 * @private
 * @param {TX} tx
 * @param {Number} index
 */

Outpoint.prototype.fromTX = function fromTX(tx, index) {
  assert(tx);
  assert(typeof index === 'number');
  assert(index >= 0);
  this.hash = tx.hash('hex');
  this.index = index;
  return this;
};

/**
 * Instantiate outpoint from tx.
 * @param {TX} tx
 * @param {Number} index
 * @returns {Outpoint}
 */

Outpoint.fromTX = function fromTX(tx, index) {
  return new Outpoint().fromTX(tx, index);
};

/**
 * Serialize outpoint to a key
 * suitable for a hash table.
 * @param {Hash} hash
 * @param {Number} index
 * @returns {String}
 */

Outpoint.toKey = function toKey(hash, index) {
  assert(typeof hash === 'string');
  assert(hash.length === 64);
  assert(index >= 0);
  return hash + index;
};

/**
 * Convert the outpoint to a user-friendly string.
 * @returns {String}
 */

Outpoint.prototype.inspect = function inspect() {
  return `<Outpoint: ${this.rhash()}/${this.index}>`;
};

/**
 * Test an object to see if it is an outpoint.
 * @param {Object} obj
 * @returns {Boolean}
 */

Outpoint.isOutpoint = function isOutpoint(obj) {
  return obj instanceof Outpoint;
};

/*
 * Expose
 */

module.exports = Outpoint;


/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * lock.js - lock and queue for wmcc_core.
 */



const assert = __webpack_require__(0);

/**
 * Represents a mutex lock for locking asynchronous object methods.
 * @alias module:utils.Lock
 * @constructor
 * @param {Boolean?} named - Whether to
 * maintain a map of queued jobs by job name.
 */

function Lock(named) {
  if (!(this instanceof Lock))
    return Lock.create(named);

  this.named = named === true;

  this.jobs = [];
  this.busy = false;
  this.destroyed = false;

  this.map = new Map();
  this.current = null;

  this.unlocker = this.unlock.bind(this);
}

/**
 * Create a closure scoped lock.
 * @param {Boolean?} named
 * @returns {Function} Lock method.
 */

Lock.create = function create(named) {
  const lock = new Lock(named);
  return function _lock(arg1, arg2) {
    return lock.lock(arg1, arg2);
  };
};

/**
 * Test whether the lock has a pending
 * job or a job in progress (by name).
 * @param {String} name
 * @returns {Boolean}
 */

Lock.prototype.has = function has(name) {
  assert(this.named, 'Must use named jobs.');

  if (this.current === name)
    return true;

  const count = this.map.get(name);

  if (count == null)
    return false;

  return count > 0;
};

/**
 * Test whether the lock has
 * a pending job by name.
 * @param {String} name
 * @returns {Boolean}
 */

Lock.prototype.hasPending = function hasPending(name) {
  assert(this.named, 'Must use named jobs.');

  const count = this.map.get(name);

  if (count == null)
    return false;

  return count > 0;
};

/**
 * Lock the parent object and all its methods
 * which use the lock. Begin to queue calls.
 * @param {String?} name - Job name.
 * @param {Boolean?} force - Bypass the lock.
 * @returns {Promise} - Returns {Function}, must be
 * called once the method finishes executing in order
 * to resolve the queue.
 */

Lock.prototype.lock = function lock(arg1, arg2) {
  let name, force;

  if (this.named) {
    name = arg1 || null;
    force = arg2;
  } else {
    name = null;
    force = arg1;
  }

  if (this.destroyed)
    return Promise.reject(new Error('Lock is destroyed.'));

  if (force) {
    assert(this.busy);
    return Promise.resolve(nop);
  }

  if (this.busy) {
    if (name) {
      let count = this.map.get(name);
      if (!count)
        count = 0;
      this.map.set(name, count + 1);
    }
    return new Promise((resolve, reject) => {
      this.jobs.push(new Job(resolve, reject, name));
    });
  }

  this.busy = true;
  this.current = name;

  return Promise.resolve(this.unlocker);
};

/**
 * The actual unlock callback.
 * @private
 */

Lock.prototype.unlock = function unlock() {
  assert(this.destroyed || this.busy);

  this.busy = false;
  this.current = null;

  if (this.jobs.length === 0)
    return;

  assert(!this.destroyed);

  const job = this.jobs.shift();

  if (job.name) {
    let count = this.map.get(job.name);
    assert(count > 0);
    if (--count === 0)
      this.map.delete(job.name);
    else
      this.map.set(job.name, count);
  }

  this.busy = true;
  this.current = job.name;

  job.resolve(this.unlocker);
};

/**
 * Destroy the lock. Purge all pending calls.
 */

Lock.prototype.destroy = function destroy() {
  assert(!this.destroyed, 'Lock is already destroyed.');

  this.destroyed = true;

  const jobs = this.jobs;

  this.busy = false;
  this.jobs = [];
  this.map.clear();
  this.current = null;

  for (const job of jobs)
    job.reject(new Error('Lock was destroyed.'));
};

/**
 * Lock Job
 * @constructor
 * @ignore
 * @param {Function} resolve
 * @param {Function} reject
 * @param {String?} name
 */

function Job(resolve, reject, name) {
  this.resolve = resolve;
  this.reject = reject;
  this.name = name || null;
}

/*
 * Helpers
 */

function nop() {}

/*
 * Expose
 */

module.exports = Lock;


/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),
/* 25 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * base58.js - base58 for wmcc_core.
 */



/**
 * @module utils/base58
 */

const assert = __webpack_require__(0);
const native = __webpack_require__(18).binding;

/*
 * Base58
 */

const base58 = ''
  + '123456789'
  + 'ABCDEFGHJKLMNPQRSTUVWXYZ'
  + 'abcdefghijkmnopqrstuvwxyz';

const unbase58 = {};

for (let i = 0; i < base58.length; i++)
  unbase58[base58[i]] = i;

/**
 * Encode a base58 string.
 * @see https://github.com/bitcoin/bitcoin/blob/master/src/base58.cpp
 * @param {Buffer} data
 * @returns {Base58String}
 */

exports.encode = function encode(data) {
  let zeroes = 0;
  let i = 0;

  for (; i < data.length; i++) {
    if (data[i] !== 0)
      break;
    zeroes++;
  }

  const b58 = Buffer.allocUnsafe(((data.length * 138 / 100) | 0) + 1);
  b58.fill(0);

  let length = 0;

  for (; i < data.length; i++) {
    let carry = data[i];
    let j = 0;

    for (let k = b58.length - 1; k >= 0; k--, j++) {
      if (carry === 0 && j >= length)
        break;
      carry += 256 * b58[k];
      b58[k] = carry % 58;
      carry = carry / 58 | 0;
    }

    assert(carry === 0);
    length = j;
  }

  i = b58.length - length;
  while (i < b58.length && b58[i] === 0)
    i++;

  let str = '';

  for (let j = 0; j < zeroes; j++)
    str += '1';

  for (; i < b58.length; i++)
    str += base58[b58[i]];

  return str;
};

if (native)
  exports.encode = native.toBase58;

/**
 * Decode a base58 string.
 * @see https://github.com/bitcoin/bitcoin/blob/master/src/base58.cpp
 * @param {Base58String} str
 * @returns {Buffer}
 * @throws on non-base58 character.
 */

exports.decode = function decode(str) {
  let zeroes = 0;
  let i = 0;

  for (; i < str.length; i++) {
    if (str[i] !== '1')
      break;
    zeroes++;
  }

  const b256 = Buffer.allocUnsafe(((str.length * 733) / 1000 | 0) + 1);
  b256.fill(0);

  let length = 0;

  for (; i < str.length; i++) {
    const ch = unbase58[str[i]];

    if (ch == null)
      throw new Error('Non-base58 character.');

    let carry = ch;
    let j = 0;

    for (let k = b256.length - 1; k >= 0; k--, j++) {
      if (carry === 0 && j >= length)
        break;
      carry += 58 * b256[k];
      b256[k] = carry % 256;
      carry = carry / 256 | 0;
    }

    assert(carry === 0);
    length = j;
  }

  i = 0;
  while (i < b256.length && b256[i] === 0)
    i++;

  const out = Buffer.allocUnsafe(zeroes + (b256.length - i));

  let j;
  for (j = 0; j < zeroes; j++)
    out[j] = 0;

  while (i < b256.length)
    out[j++] = b256[i++];

  return out;
};

if (native)
  exports.decode = native.fromBase58;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * bn.js - big numbers for wmcc_core.
 */



/**
 * @module crypto.BN
 */

/**
 * bn.js
 * @constructor
 * @see https://github.com/indutny/bn.js
 */

module.exports = __webpack_require__(14);


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * common.js - common script functions for wmcc_core.
 */



/**
 * @module script/common
 */

const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const secp256k1 = __webpack_require__(12);
const ScriptNum = __webpack_require__(33);

/**
 * Script opcodes.
 * @enum {Number}
 * @default
 */

exports.opcodes = {
  // Push
  OP_0: 0x00,

  OP_PUSHDATA1: 0x4c,
  OP_PUSHDATA2: 0x4d,
  OP_PUSHDATA4: 0x4e,

  OP_1NEGATE: 0x4f,

  OP_RESERVED: 0x50,

  OP_1: 0x51,
  OP_2: 0x52,
  OP_3: 0x53,
  OP_4: 0x54,
  OP_5: 0x55,
  OP_6: 0x56,
  OP_7: 0x57,
  OP_8: 0x58,
  OP_9: 0x59,
  OP_10: 0x5a,
  OP_11: 0x5b,
  OP_12: 0x5c,
  OP_13: 0x5d,
  OP_14: 0x5e,
  OP_15: 0x5f,
  OP_16: 0x60,

  // Control
  OP_NOP: 0x61,
  OP_VER: 0x62,
  OP_IF: 0x63,
  OP_NOTIF: 0x64,
  OP_VERIF: 0x65,
  OP_VERNOTIF: 0x66,
  OP_ELSE: 0x67,
  OP_ENDIF: 0x68,
  OP_VERIFY: 0x69,
  OP_RETURN: 0x6a,

  // Stack
  OP_TOALTSTACK: 0x6b,
  OP_FROMALTSTACK: 0x6c,
  OP_2DROP: 0x6d,
  OP_2DUP: 0x6e,
  OP_3DUP: 0x6f,
  OP_2OVER: 0x70,
  OP_2ROT: 0x71,
  OP_2SWAP: 0x72,
  OP_IFDUP: 0x73,
  OP_DEPTH: 0x74,
  OP_DROP: 0x75,
  OP_DUP: 0x76,
  OP_NIP: 0x77,
  OP_OVER: 0x78,
  OP_PICK: 0x79,
  OP_ROLL: 0x7a,
  OP_ROT: 0x7b,
  OP_SWAP: 0x7c,
  OP_TUCK: 0x7d,

  // Splice
  OP_CAT: 0x7e,
  OP_SUBSTR: 0x7f,
  OP_LEFT: 0x80,
  OP_RIGHT: 0x81,
  OP_SIZE: 0x82,

  // Bit
  OP_INVERT: 0x83,
  OP_AND: 0x84,
  OP_OR: 0x85,
  OP_XOR: 0x86,
  OP_EQUAL: 0x87,
  OP_EQUALVERIFY: 0x88,
  OP_RESERVED1: 0x89,
  OP_RESERVED2: 0x8a,

  // Numeric
  OP_1ADD: 0x8b,
  OP_1SUB: 0x8c,
  OP_2MUL: 0x8d,
  OP_2DIV: 0x8e,
  OP_NEGATE: 0x8f,
  OP_ABS: 0x90,
  OP_NOT: 0x91,
  OP_0NOTEQUAL: 0x92,
  OP_ADD: 0x93,
  OP_SUB: 0x94,
  OP_MUL: 0x95,
  OP_DIV: 0x96,
  OP_MOD: 0x97,
  OP_LSHIFT: 0x98,
  OP_RSHIFT: 0x99,
  OP_BOOLAND: 0x9a,
  OP_BOOLOR: 0x9b,
  OP_NUMEQUAL: 0x9c,
  OP_NUMEQUALVERIFY: 0x9d,
  OP_NUMNOTEQUAL: 0x9e,
  OP_LESSTHAN: 0x9f,
  OP_GREATERTHAN: 0xa0,
  OP_LESSTHANOREQUAL: 0xa1,
  OP_GREATERTHANOREQUAL: 0xa2,
  OP_MIN: 0xa3,
  OP_MAX: 0xa4,
  OP_WITHIN: 0xa5,

  // Crypto
  OP_RIPEMD160: 0xa6,
  OP_SHA1: 0xa7,
  OP_SHA256: 0xa8,
  OP_HASH160: 0xa9,
  OP_HASH256: 0xaa,
  OP_CODESEPARATOR: 0xab,
  OP_CHECKSIG: 0xac,
  OP_CHECKSIGVERIFY: 0xad,
  OP_CHECKMULTISIG: 0xae,
  OP_CHECKMULTISIGVERIFY: 0xaf,

  // Expansion
  OP_NOP1: 0xb0,
  OP_CHECKLOCKTIMEVERIFY: 0xb1,
  OP_CHECKSEQUENCEVERIFY: 0xb2,
  OP_NOP4: 0xb3,
  OP_NOP5: 0xb4,
  OP_NOP6: 0xb5,
  OP_NOP7: 0xb6,
  OP_NOP8: 0xb7,
  OP_NOP9: 0xb8,
  OP_NOP10: 0xb9,

  // Custom
  OP_INVALIDOPCODE: 0xff
};

/**
 * Opcodes by value.
 * @const {RevMap}
 */

exports.opcodesByVal = util.reverse(exports.opcodes);

/**
 * Small ints (1 indexed, 1==0).
 * @const {Buffer[]}
 */

exports.small = [
  Buffer.from([0x81]),
  Buffer.from([]),
  Buffer.from([0x01]),
  Buffer.from([0x02]),
  Buffer.from([0x03]),
  Buffer.from([0x04]),
  Buffer.from([0x05]),
  Buffer.from([0x06]),
  Buffer.from([0x07]),
  Buffer.from([0x08]),
  Buffer.from([0x09]),
  Buffer.from([0x0a]),
  Buffer.from([0x0b]),
  Buffer.from([0x0c]),
  Buffer.from([0x0d]),
  Buffer.from([0x0e]),
  Buffer.from([0x0f]),
  Buffer.from([0x10])
];

/**
 * Script and locktime flags. See {@link VerifyFlags}.
 * @enum {Number}
 */

exports.flags = {
  VERIFY_NONE: 0,
  VERIFY_P2SH: 1 << 0,
  VERIFY_STRICTENC: 1 << 1,
  VERIFY_DERSIG: 1 << 2,
  VERIFY_LOW_S: 1 << 3,
  VERIFY_NULLDUMMY: 1 << 4,
  VERIFY_SIGPUSHONLY: 1 << 5,
  VERIFY_MINIMALDATA: 1 << 6,
  VERIFY_DISCOURAGE_UPGRADABLE_NOPS: 1 << 7,
  VERIFY_CLEANSTACK: 1 << 8,
  VERIFY_CHECKLOCKTIMEVERIFY: 1 << 9,
  VERIFY_CHECKSEQUENCEVERIFY: 1 << 10,
  VERIFY_WITNESS: 1 << 11,
  VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM: 1 << 12,
  VERIFY_MINIMALIF: 1 << 13,
  VERIFY_NULLFAIL: 1 << 14,
  VERIFY_WITNESS_PUBKEYTYPE: 1 << 15,
  VERIFY_MAST: 1 << 16
};

/**
 * Consensus verify flags (used for block validation).
 * @const {VerifyFlags}
 * @default
 */

exports.flags.MANDATORY_VERIFY_FLAGS = exports.flags.VERIFY_P2SH;

/**
 * Standard verify flags (used for mempool validation).
 * @const {VerifyFlags}
 * @default
 */

exports.flags.STANDARD_VERIFY_FLAGS = 0
  | exports.flags.MANDATORY_VERIFY_FLAGS
  | exports.flags.VERIFY_DERSIG
  | exports.flags.VERIFY_STRICTENC
  | exports.flags.VERIFY_MINIMALDATA
  | exports.flags.VERIFY_NULLDUMMY
  | exports.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS
  | exports.flags.VERIFY_CLEANSTACK
  | exports.flags.VERIFY_MINIMALIF
  | exports.flags.VERIFY_NULLFAIL
  | exports.flags.VERIFY_CHECKLOCKTIMEVERIFY
  | exports.flags.VERIFY_CHECKSEQUENCEVERIFY
  | exports.flags.VERIFY_LOW_S
  | exports.flags.VERIFY_WITNESS
  | exports.flags.VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM
  | exports.flags.VERIFY_WITNESS_PUBKEYTYPE;

/**
 * Standard flags without mandatory bits.
 * @const {VerifyFlags}
 * @default
 */

exports.flags.ONLY_STANDARD_VERIFY_FLAGS =
  exports.flags.STANDARD_VERIFY_FLAGS & ~exports.flags.MANDATORY_VERIFY_FLAGS;

/**
 * Sighash Types.
 * @enum {SighashType}
 * @default
 */

exports.hashType = {
  /*
   * Sign all outputs.
   */

  ALL: 1,

  /*
   * Do not sign outputs (zero sequences).
   */

  NONE: 2,

  /*
   * Sign output at the same index (zero sequences).
   */

  SINGLE: 3,

  /*
   * Sign only the current input (mask).
   */

  ANYONECANPAY: 0x80
};

/**
 * Sighash types by value.
 * @const {RevMap}
 */

exports.hashTypeByVal = util.reverse(exports.hashType);

/**
 * Output script types.
 * @enum {Number}
 */

exports.types = {
  NONSTANDARD: 0,
  PUBKEY: 1,
  PUBKEYHASH: 2,
  SCRIPTHASH: 3,
  MULTISIG: 4,
  NULLDATA: 5,
  WITNESSMALFORMED: 0x80 | 0,
  WITNESSSCRIPTHASH: 0x80 | 1,
  WITNESSPUBKEYHASH: 0x80 | 2,
  WITNESSMASTHASH: 0x80 | 3
};

/**
 * Output script types by value.
 * @const {RevMap}
 */

exports.typesByVal = util.reverse(exports.types);

/**
 * Test a signature to see whether it contains a valid sighash type.
 * @param {Buffer} sig
 * @returns {Boolean}
 */

exports.isHashType = function isHashType(sig) {
  assert(Buffer.isBuffer(sig));

  if (sig.length === 0)
    return false;

  const type = sig[sig.length - 1] & ~exports.hashType.ANYONECANPAY;

  if (!(type >= exports.hashType.ALL && type <= exports.hashType.SINGLE))
    return false;

  return true;
};

/**
 * Test a signature to see whether it contains a low S value.
 * @param {Buffer} sig
 * @returns {Boolean}
 */

exports.isLowDER = function isLowDER(sig) {
  if (!exports.isSignatureEncoding(sig))
    return false;

  return secp256k1.isLowS(sig.slice(0, -1));
};

/**
 * Test whether the data element is a valid key.
 * @param {Buffer} key
 * @returns {Boolean}
 */

exports.isKeyEncoding = function isKeyEncoding(key) {
  assert(Buffer.isBuffer(key));

  if (key.length < 33)
    return false;

  if (key[0] === 0x04) {
    if (key.length !== 65)
      return false;
  } else if (key[0] === 0x02 || key[0] === 0x03) {
    if (key.length !== 33)
      return false;
  } else {
    return false;
  }

  return true;
};

/**
 * Test whether the data element is a compressed key.
 * @param {Buffer} key
 * @returns {Boolean}
 */

exports.isCompressedEncoding = function isCompressedEncoding(key) {
  assert(Buffer.isBuffer(key));

  if (key.length !== 33)
    return false;

  if (key[0] !== 0x02 && key[0] !== 0x03)
    return false;

  return true;
};

/**
 * Test a signature to see if it abides by BIP66.
 * @see https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki
 * @param {Buffer} sig
 * @returns {Boolean}
 */

exports.isSignatureEncoding = function isSignatureEncoding(sig) {
  assert(Buffer.isBuffer(sig));

  // Format:
  //   0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S] [sighash]
  // * total-length: 1-byte length descriptor of everything that follows,
  //   excluding the sighash byte.
  // * R-length: 1-byte length descriptor of the R value that follows.
  // * R: arbitrary-length big-endian encoded R value. It must use the shortest
  //   possible encoding for a positive integers (which means no null bytes at
  //   the start, except a single one when the next byte has its highest bit
  //   set).
  // * S-length: 1-byte length descriptor of the S value that follows.
  // * S: arbitrary-length big-endian encoded S value. The same rules apply.
  // * sighash: 1-byte value indicating what data is hashed (not part of the DER
  //   signature)

  // Minimum and maximum size constraints.
  if (sig.length < 9)
    return false;

  if (sig.length > 73)
    return false;

  // A signature is of type 0x30 (compound).
  if (sig[0] !== 0x30)
    return false;

  // Make sure the length covers the entire signature.
  if (sig[1] !== sig.length - 3)
    return false;

  // Extract the length of the R element.
  const lenR = sig[3];

  // Make sure the length of the S element is still inside the signature.
  if (5 + lenR >= sig.length)
    return false;

  // Extract the length of the S element.
  const lenS = sig[5 + lenR];

  // Verify that the length of the signature matches the sum of the length
  // of the elements.
  if (lenR + lenS + 7 !== sig.length)
    return false;

  // Check whether the R element is an integer.
  if (sig[2] !== 0x02)
    return false;

  // Zero-length integers are not allowed for R.
  if (lenR === 0)
    return false;

  // Negative numbers are not allowed for R.
  if (sig[4] & 0x80)
    return false;

  // Null bytes at the start of R are not allowed, unless R would
  // otherwise be interpreted as a negative number.
  if (lenR > 1 && (sig[4] === 0x00) && !(sig[5] & 0x80))
    return false;

  // Check whether the S element is an integer.
  if (sig[lenR + 4] !== 0x02)
    return false;

  // Zero-length integers are not allowed for S.
  if (lenS === 0)
    return false;

  // Negative numbers are not allowed for S.
  if (sig[lenR + 6] & 0x80)
    return false;

  // Null bytes at the start of S are not allowed, unless S would otherwise be
  // interpreted as a negative number.
  if (lenS > 1 && (sig[lenR + 6] === 0x00) && !(sig[lenR + 7] & 0x80))
    return false;

  return true;
};

/**
 * Format stack item into wmccd asm format.
 * @param {Buffer} item
 * @param {Boolean?} decode - Attempt to decode hash types.
 * @returns {String} Human-readable string.
 */

exports.toASM = function toASM(item, decode) {
  if (item.length <= 4) {
    const num = ScriptNum.decode(item);
    return num.toString(10);
  }

  if (decode && exports.isSignatureEncoding(item)) {
    const type = item[item.length - 1];

    let symbol = exports.hashTypeByVal[type & 0x1f] || '';

    if (symbol) {
      if (type & exports.hashType.ANYONECANPAY)
        symbol += '|ANYONECANPAY';
      symbol = `[${symbol}]`;
    }

    return item.slice(0, -1).toString('hex') + symbol;
  }

  return item.toString('hex');
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * random.js - randomness for wmcc_core.
 */



/**
 * @module crypto.random
 */

const crypto = __webpack_require__(24);

/**
 * Generate pseudo-random bytes.
 * @function
 * @param {Number} size
 * @returns {Buffer}
 */

exports.randomBytes = crypto.randomBytes;

/**
 * Generate a random uint32.
 * Probably more cryptographically sound than
 * `Math.random()`.
 * @returns {Number}
 */

exports.randomInt = function randomInt() {
  return exports.randomBytes(4).readUInt32LE(0, true);
};

/**
 * Generate a random number within a range.
 * Probably more cryptographically sound than
 * `Math.random()`.
 * @param {Number} min - Inclusive.
 * @param {Number} max - Exclusive.
 * @returns {Number}
 */

exports.randomRange = function randomRange(min, max) {
  const num = exports.randomInt();
  return Math.floor((num / 0x100000000) * (max - min) + min);
};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * coinview.js - coin viewpoint object for wmcc_core.
 */



const Coins = __webpack_require__(101);
const UndoCoins = __webpack_require__(87);
const CoinEntry = __webpack_require__(50);

/**
 * Represents a coin viewpoint:
 * a snapshot of {@link Coins} objects.
 * @alias module:coins.CoinView
 * @constructor
 * @property {Object} map
 * @property {UndoCoins} undo
 */

function CoinView() {
  if (!(this instanceof CoinView))
    return new CoinView();

  this.map = new Map();
  this.undo = new UndoCoins();
}

/**
 * Get coins.
 * @param {Hash} hash
 * @returns {Coins} coins
 */

CoinView.prototype.get = function get(hash) {
  return this.map.get(hash);
};

/**
 * Test whether the view has an entry.
 * @param {Hash} hash
 * @returns {Boolean}
 */

CoinView.prototype.has = function has(hash) {
  return this.map.has(hash);
};

/**
 * Add coins to the collection.
 * @param {Hash} hash
 * @param {Coins} coins
 * @returns {Coins}
 */

CoinView.prototype.add = function add(hash, coins) {
  this.map.set(hash, coins);
  return coins;
};

/**
 * Ensure existence of coins object in the collection.
 * @param {Hash} hash
 * @returns {Coins}
 */

CoinView.prototype.ensure = function ensure(hash) {
  const coins = this.map.get(hash);

  if (coins)
    return coins;

  return this.add(hash, new Coins());
};

/**
 * Remove coins from the collection.
 * @param {Coins} coins
 * @returns {Coins|null}
 */

CoinView.prototype.remove = function remove(hash) {
  const coins = this.map.get(hash);

  if (!coins)
    return null;

  this.map.delete(hash);

  return coins;
};

/**
 * Add a tx to the collection.
 * @param {TX} tx
 * @param {Number} height
 * @returns {Coins}
 */

CoinView.prototype.addTX = function addTX(tx, height) {
  const hash = tx.hash('hex');
  const coins = Coins.fromTX(tx, height);
  return this.add(hash, coins);
};

/**
 * Remove a tx from the collection.
 * @param {TX} tx
 * @param {Number} height
 * @returns {Coins}
 */

CoinView.prototype.removeTX = function removeTX(tx, height) {
  const hash = tx.hash('hex');
  const coins = Coins.fromTX(tx, height);

  for (const coin of coins.outputs.values())
    coin.spent = true;

  return this.add(hash, coins);
};

/**
 * Add an entry to the collection.
 * @param {Outpoint} prevout
 * @param {CoinEntry} coin
 * @returns {CoinEntry|null}
 */

CoinView.prototype.addEntry = function addEntry(prevout, coin) {
  const {hash, index} = prevout;
  /*let coins = this.get(hash);

  if (!coins) {
    coins = new Coins();
    this.add(hash, coins);
  }

  if (coin.output.script.isUnspendable())
    return null;

  if (coins.has(index))
    return null;*/
  const coins = this.ensure(hash);
  return coins.add(index, coin);
};

/**
 * Add a coin to the collection.
 * @param {Coin} coin
 * @returns {CoinEntry|null}
 */

CoinView.prototype.addCoin = function addCoin(coin) {
  /*const {hash, index} = coin;
  let coins = this.get(hash);

  if (!coins) {
    coins = new Coins();
    this.add(hash, coins);
  }

  if (coin.script.isUnspendable())
    return null;

  if (coins.has(index))
    return null;*/
  const coins = this.ensure(coin.hash);
  return coins.addCoin(coin);
};

/**
 * Add an output to the collection.
 * @param {Outpoint} prevout
 * @param {Output} output
 * @returns {CoinEntry|null}
 */

CoinView.prototype.addOutput = function addOutput(prevout, output) {
  const {hash, index} = prevout;
  /*let coins = this.get(hash);

  if (!coins) {
    coins = new Coins();
    this.add(hash, coins);
  }

  if (output.script.isUnspendable())
    return null;

  if (coins.has(index))
    return null;*/
  const coins = this.ensure(hash);
  return coins.addOutput(index, output);
};

/**
 * Add an output to the collection by output index.
 * @param {TX} tx
 * @param {Number} index
 * @param {Number} height
 * @returns {CoinEntry|null}
 */

CoinView.prototype.addIndex = function addIndex(tx, index, height) {
  const hash = tx.hash('hex');
  const coins = this.ensure(hash);
  return coins.addIndex(tx, index, height);
};

/**
 * Spend an output.
 * @param {Outpoint} prevout
 * @returns {CoinEntry|null}
 */

CoinView.prototype.spendEntry = function spendEntry(prevout) {
  const {hash, index} = prevout;
  const coins = this.get(hash);

  if (!coins)
    return null;

  const coin = coins.spend(index);

  if (!coin)
    return null;

  this.undo.push(coin);

  return coin;
};

/**
 * Remove an output.
 * @param {Outpoint} prevout
 * @returns {CoinEntry|null}
 */

CoinView.prototype.removeEntry = function removeEntry(prevout) {
  const {hash, index} = prevout;
  const coins = this.get(hash);

  if (!coins)
    return null;

  return coins.remove(index);
};

/**
 * Test whether the view has an entry by prevout.
 * @param {Outpoint} prevout
 * @returns {Boolean}
 */

CoinView.prototype.hasEntry = function hasEntry(prevout) {
  const {hash, index} = prevout;
  const coins = this.get(hash);

  if (!coins)
    return false;

  return coins.has(index);
};

/**
 * Get a single entry by prevout.
 * @param {Outpoint} prevout
 * @returns {CoinEntry|null}
 */

CoinView.prototype.getEntry = function getEntry(prevout) {
  const {hash, index} = prevout;
  const coins = this.get(hash);

  if (!coins)
    return null;

  return coins.get(index);
};

/**
 * Test whether an entry has been spent by prevout.
 * @param {Outpoint} prevout
 * @returns {Boolean}
 */

CoinView.prototype.isUnspent = function isUnspent(prevout) {
  const {hash, index} = prevout;
  const coins = this.get(hash);

  if (!coins)
    return false;

  return coins.isUnspent(index);
};

/**
 * Get a single coin by prevout.
 * @param {Outpoint} prevout
 * @returns {Coin|null}
 */

CoinView.prototype.getCoin = function getCoin(prevout) {
  const coins = this.get(prevout.hash);

  if (!coins)
    return null;

  return coins.getCoin(prevout);
};

/**
 * Get a single output by prevout.
 * @param {Outpoint} prevout
 * @returns {Output|null}
 */

CoinView.prototype.getOutput = function getOutput(prevout) {
  const {hash, index} = prevout;
  const coins = this.get(hash);

  if (!coins)
    return null;

  return coins.getOutput(index);
};

/**
 * Get coins height by prevout.
 * @param {Outpoint} prevout
 * @returns {Number}
 */

CoinView.prototype.getHeight = function getHeight(prevout) {
  const coin = this.getEntry(prevout);

  if (!coin)
    return -1;

  return coin.height;
};

/**
 * Get coins coinbase flag by prevout.
 * @param {Outpoint} prevout
 * @returns {Boolean}
 */

CoinView.prototype.isCoinbase = function isCoinbase(prevout) {
  const coin = this.getEntry(prevout);

  if (!coin)
    return false;

  return coin.coinbase;
};

/**
 * Test whether the view has an entry by input.
 * @param {Input} input
 * @returns {Boolean}
 */

CoinView.prototype.hasEntryFor = function hasEntryFor(input) {
  return this.hasEntry(input.prevout);
};

/**
 * Get a single entry by input.
 * @param {Input} input
 * @returns {CoinEntry|null}
 */

CoinView.prototype.getEntryFor = function getEntryFor(input) {
  return this.getEntry(input.prevout);
};

/**
 * Test whether an entry has been spent by input.
 * @param {Input} input
 * @returns {Boolean}
 */

CoinView.prototype.isUnspentFor = function isUnspentFor(input) {
  return this.isUnspent(input.prevout);
};

/**
 * Get a single coin by input.
 * @param {Input} input
 * @returns {Coin|null}
 */

CoinView.prototype.getCoinFor = function getCoinFor(input) {
  return this.getCoin(input.prevout);
};

/**
 * Get a single output by input.
 * @param {Input} input
 * @returns {Output|null}
 */

CoinView.prototype.getOutputFor = function getOutputFor(input) {
  return this.getOutput(input.prevout);
};

/**
 * Get coins height by input.
 * @param {Input} input
 * @returns {Number}
 */

CoinView.prototype.getHeightFor = function getHeightFor(input) {
  return this.getHeight(input.prevout);
};

/**
 * Get coins coinbase flag by input.
 * @param {Input} input
 * @returns {Boolean}
 */

CoinView.prototype.isCoinbaseFor = function isCoinbaseFor(input) {
  return this.isCoinbase(input.prevout);
};

/**
 * Retrieve coins from database.
 * @method
 * @param {ChainDB} db
 * @param {Outpoint} prevout
 * @returns {Promise} - Returns {@link CoinEntry}.
 */

CoinView.prototype.readCoin = async function readCoin(db, prevout) {
  const cache = this.getEntry(prevout);

  if (cache)
    return cache;

  const coin = await db.readCoin(prevout);

  if (!coin)
    return null;

  return this.addEntry(prevout, coin);
};

/**
 * Read all input coins into unspent map.
 * @method
 * @param {ChainDB} db
 * @param {TX} tx
 * @returns {Promise} - Returns {Boolean}.
 */

CoinView.prototype.readInputs = async function readInputs(db, tx) {
  let found = true;

  for (const {prevout} of tx.inputs) {
    if (!await this.readCoin(db, prevout))
      found = false;
  }

  return found;
};

/**
 * Spend coins for transaction.
 * @method
 * @param {ChainDB} db
 * @param {TX} tx
 * @returns {Promise} - Returns {Boolean}.
 */

CoinView.prototype.spendInputs = async function spendInputs(db, tx) {
  //if (tx.inputs.length < 4) {
  let i = 0;
  while (i < tx.inputs.length) {
    const len = Math.min(i + 4, tx.inputs.length);
    const jobs = [];

    //for (const {prevout} of tx.inputs)
    for (; i < len; i++) {
      const {prevout} = tx.inputs[i];
      jobs.push(this.readCoin(db, prevout));
    }

    const coins = await Promise.all(jobs);

    for (const coin of coins) {
      if (!coin || coin.spent)
        return false;

      coin.spent = true;
      this.undo.push(coin);
    }/*

    return true;
  }

  for (const {prevout} of tx.inputs) {
    const coin = await this.readCoin(db, prevout);

    if (!coin || coin.spent)
      return false;

    coin.spent = true;
    this.undo.push(coin);*/
  }

  return true;
};

/**
 * Calculate serialization size.
 * @returns {Number}
 */

CoinView.prototype.getSize = function getSize(tx) {
  let size = 0;

  size += tx.inputs.length;

  for (const {prevout} of tx.inputs) {
    const coin = this.getEntry(prevout);

    if (!coin)
      continue;

    size += coin.getSize();
  }

  return size;
};

/**
 * Write coin data to buffer writer
 * as it pertains to a transaction.
 * @param {BufferWriter} bw
 * @param {TX} tx
 */

CoinView.prototype.toWriter = function toWriter(bw, tx) {
  for (const {prevout} of tx.inputs) {
    const coin = this.getEntry(prevout);

    if (!coin) {
      bw.writeU8(0);
      continue;
    }

    bw.writeU8(1);
    coin.toWriter(bw);
  }

  return bw;
};

/**
 * Read serialized view data from a buffer
 * reader as it pertains to a transaction.
 * @private
 * @param {BufferReader} br
 * @param {TX} tx
 */

CoinView.prototype.fromReader = function fromReader(br, tx) {
  for (const {prevout} of tx.inputs) {
    if (br.readU8() === 0)
      continue;

    const coin = CoinEntry.fromReader(br);

    this.addEntry(prevout, coin);
  }

  return this;
};

/**
 * Read serialized view data from a buffer
 * reader as it pertains to a transaction.
 * @param {BufferReader} br
 * @param {TX} tx
 * @returns {CoinView}
 */

CoinView.fromReader = function fromReader(br, tx) {
  return new CoinView().fromReader(br, tx);
};

/*
 * Expose
 */

module.exports = CoinView;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * asyncobject.js - async object class for wmcc_core.
 */



const assert = __webpack_require__(0);
const EventEmitter = __webpack_require__(10);
const Lock = __webpack_require__(23);

/**
 * An abstract object that handles state and
 * provides recallable open and close methods.
 * @alias module:utils.AsyncObject
 * @constructor
 * @property {Boolean} loading
 * @property {Boolean} closing
 * @property {Boolean} loaded
 */

function AsyncObject() {
  assert(this instanceof AsyncObject);

  EventEmitter.call(this);

  this._asyncLock = new Lock();
  this._hooks = Object.create(null);

  this.loading = false;
  this.closing = false;
  this.loaded = false;
}

Object.setPrototypeOf(AsyncObject.prototype, EventEmitter.prototype);

/**
 * Open the object (recallable).
 * @method
 * @returns {Promise}
 */

AsyncObject.prototype.open = async function open() {
  const unlock = await this._asyncLock.lock();
  try {
    return await this.__open();
  } finally {
    unlock();
  }
};

/**
 * Open the object (without a lock).
 * @method
 * @private
 * @returns {Promise}
 */

AsyncObject.prototype.__open = async function __open() {
  if (this.loaded)
    return;

  await this.fire('preopen');

  this.loading = true;

  try {
    await this._open();
  } catch (e) {
    this.loading = false;
    this.emit('error', e);
    throw e;
  }

  this.loading = false;
  this.loaded = true;

  await this.fire('open');
};

/**
 * Close the object (recallable).
 * @method
 * @returns {Promise}
 */

AsyncObject.prototype.close = async function close() {
  const unlock = await this._asyncLock.lock();
  try {
    return await this.__close();
  } finally {
    unlock();
  }
};

/**
 * Close the object (without a lock).
 * @method
 * @private
 * @returns {Promise}
 */

AsyncObject.prototype.__close = async function __close() {
  if (!this.loaded)
    return;

  await this.fire('preclose');

  this.closing = true;

  try {
    await this._close();
  } catch (e) {
    this.closing = false;
    this.emit('error', e);
    throw e;
  }

  this.closing = false;
  this.loaded = false;

  await this.fire('close');
};

/**
 * Close the object (recallable).
 * @method
 * @returns {Promise}
 */

AsyncObject.prototype.destroy = AsyncObject.prototype.close;

/**
 * Initialize the object.
 * @private
 * @returns {Promise}
 */

AsyncObject.prototype._open = function _open(callback) {
  throw new Error('Abstract method.');
};

/**
 * Close the object.
 * @private
 * @returns {Promise}
 */

AsyncObject.prototype._close = function _close(callback) {
  throw new Error('Abstract method.');
};

/**
 * Add a hook listener.
 * @param {String} type
 * @param {Function} handler
 */

AsyncObject.prototype.hook = function hook(type, handler) {
  assert(typeof type === 'string', '`type` must be a string.');

  if (!this._hooks[type])
    this._hooks[type] = [];

  this._hooks[type].push(handler);
};

/**
 * Remove a hook listener.
 * @param {String} type
 * @param {Function} handler
 */

AsyncObject.prototype.unhook = function unhook(type) {
  assert(typeof type === 'string', '`type` must be a string.');

  if (this._hooks[type])
    delete this._hooks[type];
};

/**
 * Emit events and hooks for type.
 * @method
 * @param {String} type
 * @param {...Object} args
 * @returns {Promise}
 */

AsyncObject.prototype.fire = async function fire() {
  await this.fireHook.apply(this, arguments);
  this.emit.apply(this, arguments);
};

/**
 * Emit an asynchronous event (hook).
 * Wait for promises to resolve.
 * @method
 * @param {String} type
 * @param {...Object} args
 * @returns {Promise}
 */

AsyncObject.prototype.fireHook = async function fireHook(type) {
  assert(typeof type === 'string', '`type` must be a string.');

  const listeners = this._hooks[type];

  if (!listeners || listeners.length === 0)
    return;

  let args;

  for (const handler of listeners) {
    switch (arguments.length) {
      case 1:
        await handler();
        break;
      case 2:
        await handler(arguments[1]);
        break;
      case 3:
        await handler(arguments[1], arguments[2]);
        break;
      case 4:
        await handler(arguments[1], arguments[2], arguments[3]);
        break;
      default:
        if (!args) {
          args = new Array(arguments.length - 1);
          for (let i = 1; i < arguments.length; i++)
            args[i - 1] = arguments[i];
        }
        await handler.apply(null, args);
        break;
    }
  }
};

/*
 * Expose
 */

module.exports = AsyncObject;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(15);
var assert = __webpack_require__(22);

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * scriptnum.js - script number object for wmcc_core.
 */



const assert = __webpack_require__(0);
const {I64} = __webpack_require__(49);
const ScriptError = __webpack_require__(35);

/*
 * Constants
 */

const EMPTY_ARRAY = Buffer.alloc(0);

/**
 * Script Number
 * @see https://github.com/chjj/n64
 * @alias module:script.ScriptNum
 * @constructor
 * @param {(Number|String|Buffer|Object)?} num
 * @param {(String|Number)?} base
 * @property {Number} hi
 * @property {Number} lo
 * @property {Number} sign
 */

function ScriptNum(num, base) {
  if (!(this instanceof ScriptNum))
    return new ScriptNum(num, base);

  I64.call(this, num, base);
}

Object.setPrototypeOf(ScriptNum, I64);
Object.setPrototypeOf(ScriptNum.prototype, I64.prototype);

/**
 * Cast to int32.
 * @returns {Number}
 */

ScriptNum.prototype.getInt = function getInt() {
  if (this.lt(I64.INT32_MIN))
    return I64.LONG_MIN;

  if (this.gt(I64.INT32_MAX))
    return I64.LONG_MAX;

  return this.toInt();
};

/**
 * Serialize script number.
 * @returns {Buffer}
 */

ScriptNum.prototype.toRaw = function toRaw() {
  let num = this;

  // Zeroes are always empty arrays.
  if (num.isZero())
    return EMPTY_ARRAY;

  // Need to append sign bit.
  let neg = false;
  if (num.isNeg()) {
    num = num.neg();
    neg = true;
  }

  // Calculate size.
  const size = num.byteLength();

  let offset = 0;

  if (num.testn((size * 8) - 1))
    offset = 1;

  // Write number.
  const data = Buffer.allocUnsafe(size + offset);

  switch (size) {
    case 8:
      data[7] = (num.hi >>> 24) & 0xff;
    case 7:
      data[6] = (num.hi >> 16) & 0xff;
    case 6:
      data[5] = (num.hi >> 8) & 0xff;
    case 5:
      data[4] = num.hi & 0xff;
    case 4:
      data[3] = (num.lo >>> 24) & 0xff;
    case 3:
      data[2] = (num.lo >> 16) & 0xff;
    case 2:
      data[1] = (num.lo >> 8) & 0xff;
    case 1:
      data[0] = num.lo & 0xff;
  }

  // Append sign bit.
  if (data[size - 1] & 0x80) {
    assert(offset === 1);
    assert(data.length === size + offset);
    data[size] = neg ? 0x80 : 0;
  } else if (neg) {
    assert(offset === 0);
    assert(data.length === size);
    data[size - 1] |= 0x80;
  } else {
    assert(offset === 0);
    assert(data.length === size);
  }

  return data;
};

/**
 * Instantiate script number from serialized data.
 * @private
 * @param {Buffer} data
 * @returns {ScriptNum}
 */

ScriptNum.prototype.fromRaw = function fromRaw(data) {
  assert(Buffer.isBuffer(data));

  // Empty arrays are always zero.
  if (data.length === 0)
    return this;

  // Read number (9 bytes max).
  switch (data.length) {
    case 8:
      this.hi |= data[7] << 24;
    case 7:
      this.hi |= data[6] << 16;
    case 6:
      this.hi |= data[5] << 8;
    case 5:
      this.hi |= data[4];
    case 4:
      this.lo |= data[3] << 24;
    case 3:
      this.lo |= data[2] << 16;
    case 2:
      this.lo |= data[1] << 8;
    case 1:
      this.lo |= data[0];
      break;
    default:
      for (let i = 0; i < data.length; i++)
        this.orb(i, data[i]);
      break;
  }

  // Remove high bit and flip sign.
  if (data[data.length - 1] & 0x80) {
    this.setn((data.length * 8) - 1, 0);
    this.ineg();
  }

  return this;
};

/**
 * Serialize script number.
 * @returns {Buffer}
 */

ScriptNum.prototype.encode = function encode() {
  return this.toRaw();
};

/**
 * Decode and verify script number.
 * @private
 * @param {Buffer} data
 * @param {Boolean?} minimal - Require minimal encoding.
 * @param {Number?} limit - Size limit.
 * @returns {ScriptNum}
 */

ScriptNum.prototype.decode = function decode(data, minimal, limit) {
  assert(Buffer.isBuffer(data));

  if (limit != null && data.length > limit)
    throw new ScriptError('UNKNOWN_ERROR', 'Script number overflow.');

  if (minimal && !ScriptNum.isMinimal(data))
    throw new ScriptError('UNKNOWN_ERROR', 'Non-minimal script number.');

  return this.fromRaw(data);
};

/**
 * Inspect script number.
 * @returns {String}
 */

ScriptNum.prototype.inspect = function inspect() {
  return `<ScriptNum: ${this.toString(10)}>`;
};

/**
 * Test wether a serialized script
 * number is in its most minimal form.
 * @param {Buffer} data
 * @returns {Boolean}
 */

ScriptNum.isMinimal = function isMinimal(data) {
  assert(Buffer.isBuffer(data));

  if (data.length === 0)
    return true;

  if ((data[data.length - 1] & 0x7f) === 0) {
    if (data.length === 1)
      return false;

    if ((data[data.length - 2] & 0x80) === 0)
      return false;
  }

  return true;
};

/**
 * Decode and verify script number.
 * @param {Buffer} data
 * @param {Boolean?} minimal - Require minimal encoding.
 * @param {Number?} limit - Size limit.
 * @returns {ScriptNum}
 */

ScriptNum.decode = function decode(data, minimal, limit) {
  return new ScriptNum().decode(data, minimal, limit);
};

/**
 * Test whether object is a script number.
 * @param {Object} obj
 * @returns {Boolean}
 */

ScriptNum.isScriptNum = function isScriptNum(obj) {
  return obj instanceof ScriptNum;
};

/*
 * Expose
 */

module.exports = ScriptNum;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * logger.js - basic logger for wmcc_core.
 */



const assert = __webpack_require__(0);
const fs = __webpack_require__(58);
const util = __webpack_require__(1);
const co = __webpack_require__(17);
const Lock = __webpack_require__(23);

/**
 * Basic stdout and file logger.
 * @alias module:node.Logger
 * @constructor
 * @param {(String|Object)?} options/level
 * @param {String?} options.level
 * @param {Boolean} [options.colors=true]
 */

function Logger(options) {
  if (!(this instanceof Logger))
    return new Logger(options);

  this.level = Logger.levels.NONE;
  this.colors = Logger.HAS_TTY;
  this.console = true;
  this.shrink = true;
  this.closed = true;
  this.closing = false;
  this.filename = null;
  this.stream = null;
  this.contexts = Object.create(null);
  this.locker = new Lock();

  if (options)
    this.set(options);
}

/**
 * Whether stdout is a tty FD.
 * @const {Boolean}
 */

Logger.HAS_TTY = Boolean(process.stdout && process.stdout.isTTY);

/**
 * Maximum file size.
 * @const {Number}
 * @default
 */

Logger.MAX_FILE_SIZE = 20 << 20;

/**
 * Available log levels.
 * @enum {Number}
 */

Logger.levels = {
  NONE: 0,
  ERROR: 1,
  WARNING: 2,
  INFO: 3,
  DEBUG: 4,
  SPAM: 5
};

/**
 * Available log levels.
 * @const {String[]}
 * @default
 */

Logger.levelsByVal = [
  'none',
  'error',
  'warning',
  'info',
  'debug',
  'spam'
];

/**
 * Available log levels.
 * @const {String[]}
 * @default
 */

Logger.prefixByVal = [
  'N',
  'E',
  'W',
  'I',
  'D',
  'S'
];

/**
 * Default CSI colors.
 * @const {String[]}
 * @default
 */

Logger.styles = [
  '0',
  '1;31',
  '1;33',
  '94',
  '90',
  '90'
];

/**
 * Set logger options.
 * @param {Object} options
 */

Logger.prototype.set = function set(options) {
  assert(options);
  assert(this.closed);

  if (typeof options === 'string') {
    this.setLevel(options);
    return;
  }

  if (options.level != null) {
    assert(typeof options.level === 'string');
    this.setLevel(options.level);
  }

  if (options.colors != null && Logger.HAS_TTY) {
    assert(typeof options.colors === 'boolean');
    this.colors = options.colors;
  }

  if (options.console != null) {
    assert(typeof options.console === 'boolean');
    this.console = options.console;
  }

  if (options.shrink != null) {
    assert(typeof options.shrink === 'boolean');
    this.shrink = options.shrink;
  }

  if (options.filename != null) {
    assert(typeof options.filename === 'string', 'Bad file.');
    this.filename = options.filename;
  }
};

/**
 * Open the logger.
 * @method
 * @returns {Promise}
 */

Logger.prototype.open = async function open() {
  const unlock = await this.locker.lock();
  try {
    return await this._open();
  } finally {
    unlock();
  }
};

/**
 * Open the logger (no lock).
 * @method
 * @returns {Promise}
 */

Logger.prototype._open = async function _open() {
  if (!this.filename) {
    this.closed = false;
    return;
  }

  if (this.stream) {
    this.closed = false;
    return;
  }

  if (fs.unsupported) {
    this.closed = false;
    return;
  }

  if (this.shrink)
    await this.truncate();

  this.stream = await openStream(this.filename);
  this.stream.once('error', this.handleError.bind(this));
  this.closed = false;
};

/**
 * Destroy the write stream.
 * @method
 * @returns {Promise}
 */

Logger.prototype.close = async function close() {
  const unlock = await this.locker.lock();
  try {
    return await this._close();
  } finally {
    unlock();
  }
};

/**
 * Destroy the write stream (no lock).
 * @method
 * @returns {Promise}
 */

Logger.prototype._close = async function _close() {
  if (this.timer != null) {
    co.clearTimeout(this.timer);
    this.timer = null;
  }

  if (fs.unsupported) {
    this.closed = true;
    this.stream = null;
    return;
  }

  if (this.stream) {
    try {
      this.closing = true;
      await closeStream(this.stream);
    } finally {
      this.closing = false;
    }
    this.stream = null;
  }

  this.closed = true;
};

/**
 * Truncate the log file to the last 20mb.
 * @method
 * @private
 * @returns {Promise}
 */

Logger.prototype.truncate = async function truncate() {
  if (!this.filename)
    return;

  if (fs.unsupported)
    return;

  assert(!this.stream);

  let stat;
  try {
    stat = await fs.stat(this.filename);
  } catch (e) {
    if (e.code === 'ENOENT')
      return;
    throw e;
  }

  const maxSize = Logger.MAX_FILE_SIZE;

  if (stat.size <= maxSize + (maxSize / 10))
    return;

  this.debug('Truncating log file to %d bytes.', maxSize);

  const fd = await fs.open(this.filename, 'r+');
  const data = Buffer.allocUnsafe(maxSize);

  await fs.read(fd, data, 0, maxSize, stat.size - maxSize);
  await fs.ftruncate(fd, maxSize);
  await fs.write(fd, data, 0, maxSize, 0);
  await fs.close(fd);
};

/**
 * Handle write stream error.
 * @param {Error} err
 */

Logger.prototype.handleError = function handleError(err) {
  try {
    this.stream.close();
  } catch (e) {
    ;
  }

  this.stream = null;
  this.retry();
};

/**
 * Try to reopen the logger.
 * @method
 * @private
 * @returns {Promise}
 */

Logger.prototype.reopen = async function reopen() {
  const unlock = await this.locker.lock();
  try {
    return await this._reopen();
  } finally {
    unlock();
  }
};

/**
 * Try to reopen the logger (no lock).
 * @method
 * @private
 * @returns {Promise}
 */

Logger.prototype._reopen = async function _reopen() {
  if (this.stream)
    return;

  if (this.closed)
    return;

  if (fs.unsupported)
    return;

  try {
    this.stream = await openStream(this.filename);
  } catch (e) {
    this.retry();
    return;
  }

  this.stream.once('error', this.handleError.bind(this));
};

/**
 * Try to reopen the logger after a timeout.
 * @method
 * @private
 * @returns {Promise}
 */

Logger.prototype.retry = function retry() {
  assert(this.timer == null);
  this.timer = co.setTimeout(() => {
    this.timer = null;
    this.reopen();
  }, 10000, this);
};

/**
 * Set the log file location.
 * @param {String} filename
 */

Logger.prototype.setFile = function setFile(filename) {
  assert(typeof filename === 'string');
  assert(!this.stream, 'Log stream has already been created.');
  this.filename = filename;
};

/**
 * Set or reset the log level.
 * @param {String} level
 */

Logger.prototype.setLevel = function setLevel(name) {
  const level = Logger.levels[name.toUpperCase()];
  assert(level != null, 'Invalid log level.');
  this.level = level;
};

/**
 * Output a log to the `error` log level.
 * @param {String|Object|Error} err
 * @param {...Object} args
 */

Logger.prototype.error = function error(...args) {
  if (this.level < Logger.levels.ERROR)
    return;

  const err = args[0];

  if (err instanceof Error) {
    this.logError(Logger.levels.ERROR, null, err);
    return;
  }

  this.log(Logger.levels.ERROR, null, args);
};

/**
 * Output a log to the `warning` log level.
 * @param {String|Object} obj
 * @param {...Object} args
 */

Logger.prototype.warning = function warning(...args) {
  if (this.level < Logger.levels.WARNING)
    return;

  const err = args[0];

  if (err instanceof Error) {
    this.logError(Logger.levels.WARNING, null, err);
    return;
  }

  this.log(Logger.levels.WARNING, null, args);
};

/**
 * Output a log to the `info` log level.
 * @param {String|Object} obj
 * @param {...Object} args
 */

Logger.prototype.info = function info(...args) {
  if (this.level < Logger.levels.INFO)
    return;

  const err = args[0];

  if (err instanceof Error) {
    this.logError(Logger.levels.INFO, null, err);
    return;
  }

  this.log(Logger.levels.INFO, null, args);
};

/**
 * Output a log to the `debug` log level.
 * @param {String|Object} obj
 * @param {...Object} args
 */

Logger.prototype.debug = function debug(...args) {
  if (this.level < Logger.levels.DEBUG)
    return;

  const err = args[0];

  if (err instanceof Error) {
    this.logError(Logger.levels.DEBUG, null, err);
    return;
  }

  this.log(Logger.levels.DEBUG, null, args);
};

/**
 * Output a log to the `spam` log level.
 * @param {String|Object} obj
 * @param {...Object} args
 */

Logger.prototype.spam = function spam(...args) {
  if (this.level < Logger.levels.SPAM)
    return;

  const err = args[0];

  if (err instanceof Error) {
    this.logError(Logger.levels.SPAM, null, err);
    return;
  }

  this.log(Logger.levels.SPAM, null, args);
};

/**
 * Output a log to the desired log level.
 * Note that this bypasses the level check.
 * @param {String} level
 * @param {String|null} module
 * @param {Object[]} args
 */

Logger.prototype.log = function log(level, module, args) {
  if (this.closed)
    return;

  if (this.level < level)
    return;

  this.writeConsole(level, module, args);
  this.writeStream(level, module, args);
};

/**
 * Create logger context.
 * @param {String} module
 * @returns {LoggerContext}
 */

Logger.prototype.context = function context(module) {
  let ctx = this.contexts[module];

  if (!ctx) {
    ctx = new LoggerContext(this, module);
    this.contexts[module] = ctx;
  }

  return ctx;
};

/**
 * Write log to the console.
 * @param {String} level
 * @param {String|null} module
 * @param {Object[]} args
 */

Logger.prototype.writeConsole = function writeConsole(level, module, args) {
  const name = Logger.levelsByVal[level];

  assert(name, 'Invalid log level.');

  if (!this.console)
    return false;

  if (!process.stdout) {
    let msg = `[${name}] `;

    if (module)
      msg += `(${module}) `;

    if (typeof args[0] === 'object') {
      return level === Logger.levels.ERROR
        ? console.error(msg, args[0])
        : console.log(msg, args[0]);
    }

    msg += util.format(args, false);

    if (level === Logger.levels.ERROR) {
      console.error(msg);
      return true;
    }

    console.log(msg);

    return true;
  }

  let msg;
  if (this.colors) {
    const color = Logger.styles[level];
    assert(color);

    msg = `\x1b[${color}m[${name}]\x1b[m `;
  } else {
    msg = `[${name}] `;
  }

  if (module)
    msg += `(${module}) `;

  msg += util.format(args, this.colors);
  msg += '\n';

  return level === Logger.levels.ERROR
    ? process.stderr.write(msg)
    : process.stdout.write(msg);
};

/**
 * Write a string to the output stream (usually a file).
 * @param {String} level
 * @param {String|null} module
 * @param {Object[]} args
 */

Logger.prototype.writeStream = function writeStream(level, module, args) {
  const name = Logger.prefixByVal[level];

  assert(name, 'Invalid log level.');

  if (!this.stream)
    return;

  if (this.closing)
    return;

  let msg = `[${name}:${util.date()}] `;

  if (module)
    msg += `(${module}) `;

  msg += util.format(args, false);
  msg += '\n';

  this.stream.write(msg);
};

/**
 * Helper to parse an error into a nicer
 * format. Call's `log` internally.
 * @private
 * @param {Number} level
 * @param {String|null} module
 * @param {Error} err
 */

Logger.prototype.logError = function logError(level, module, err) {
  if (this.closed)
    return;

  if (fs.unsupported && this.console) {
    if (level <= Logger.levels.WARNING)
      console.error(err);
  }

  let msg = String(err.message).replace(/^ *Error: */, '');

  if (level !== Logger.levels.ERROR)
    msg = `Error: ${msg}`;

  this.log(level, module, [msg]);

  if (level <= Logger.levels.WARNING) {
    if (this.stream)
      this.stream.write(err.stack + '\n');
  }
};

/**
 * Log the current memory usage.
 * @param {String|null} module
 */

Logger.prototype.memory = function memory(module) {
  const mem = util.memoryUsage();

  this.log(Logger.levels.DEBUG, module, [
    'Memory: rss=%dmb, js-heap=%d/%dmb native-heap=%dmb',
    mem.total,
    mem.jsHeap,
    mem.jsHeapTotal,
    mem.nativeHeap
  ]);
};

/**
 * Basic stdout and file logger.
 * @constructor
 * @ignore
 * @param {Logger} logger
 * @param {String} module
 */

function LoggerContext(logger, module) {
  if (!(this instanceof LoggerContext))
    return new LoggerContext(logger, module);

  assert(typeof module === 'string');

  this.logger = logger;
  this.module = module;
}

/**
 * Open the logger.
 * @returns {Promise}
 */

LoggerContext.prototype.open = function open() {
  return this.logger.open();
};

/**
 * Destroy the write stream.
 * @returns {Promise}
 */

LoggerContext.prototype.close = function close() {
  return this.logger.close();
};

/**
 * Set the log file location.
 * @param {String} filename
 */

LoggerContext.prototype.setFile = function setFile(filename) {
  this.logger.setFile(filename);
};

/**
 * Set or reset the log level.
 * @param {String} level
 */

LoggerContext.prototype.setLevel = function setLevel(name) {
  this.logger.setLevel(name);
};

/**
 * Output a log to the `error` log level.
 * @param {String|Object|Error} err
 * @param {...Object} args
 */

LoggerContext.prototype.error = function error(...args) {
  if (this.logger.level < Logger.levels.ERROR)
    return;

  const err = args[0];

  if (err instanceof Error) {
    this.logError(Logger.levels.ERROR, err);
    return;
  }

  this.log(Logger.levels.ERROR, args);
};

/**
 * Output a log to the `warning` log level.
 * @param {String|Object} obj
 * @param {...Object} args
 */

LoggerContext.prototype.warning = function warning(...args) {
  if (this.logger.level < Logger.levels.WARNING)
    return;

  const err = args[0];

  if (err instanceof Error) {
    this.logError(Logger.levels.WARNING, err);
    return;
  }

  this.log(Logger.levels.WARNING, args);
};

/**
 * Output a log to the `info` log level.
 * @param {String|Object} obj
 * @param {...Object} args
 */

LoggerContext.prototype.info = function info(...args) {
  if (this.logger.level < Logger.levels.INFO)
    return;

  const err = args[0];

  if (err instanceof Error) {
    this.logError(Logger.levels.INFO, err);
    return;
  }

  this.log(Logger.levels.INFO, args);
};

/**
 * Output a log to the `debug` log level.
 * @param {String|Object} obj
 * @param {...Object} args
 */

LoggerContext.prototype.debug = function debug(...args) {
  if (this.logger.level < Logger.levels.DEBUG)
    return;

  const err = args[0];

  if (err instanceof Error) {
    this.logError(Logger.levels.DEBUG, err);
    return;
  }

  this.log(Logger.levels.DEBUG, args);
};

/**
 * Output a log to the `spam` log level.
 * @param {String|Object} obj
 * @param {...Object} args
 */

LoggerContext.prototype.spam = function spam(...args) {
  if (this.logger.level < Logger.levels.SPAM)
    return;

  const err = args[0];

  if (err instanceof Error) {
    this.logError(Logger.levels.SPAM, err);
    return;
  }

  this.log(Logger.levels.SPAM, args);
};

/**
 * Output a log to the desired log level.
 * Note that this bypasses the level check.
 * @param {String} level
 * @param {Object[]} args
 */

LoggerContext.prototype.log = function log(level, args) {
  this.logger.log(level, this.module, args);
};

/**
 * Create logger context.
 * @param {String} module
 * @returns {LoggerContext}
 */

LoggerContext.prototype.context = function context(module) {
  return new LoggerContext(this.logger, module);
};

/**
 * Helper to parse an error into a nicer
 * format. Call's `log` internally.
 * @private
 * @param {Number} level
 * @param {Error} err
 */

LoggerContext.prototype.logError = function logError(level, err) {
  this.logger.logError(level, this.module, err);
};

/**
 * Log the current memory usage.
 */

LoggerContext.prototype.memory = function memory() {
  this.logger.memory(this.module);
};

/*
 * Default
 */

Logger.global = new Logger();

/*
 * Helpers
 */

function openStream(filename) {
  return new Promise((resolve, reject) => {
    const stream = fs.createWriteStream(filename, { flags: 'a' });

    const cleanup = () => {
      /* eslint-disable */
      stream.removeListener('error', onError);
      stream.removeListener('open', onOpen);
      /* eslint-enable */
    };

    const onError = (err) => {
      try {
        stream.close();
      } catch (e) {
        ;
      }
      cleanup();
      reject(err);
    };

    const onOpen = () => {
      cleanup();
      resolve(stream);
    };

    stream.once('error', onError);
    stream.once('open', onOpen);
  });
}

function closeStream(stream) {
  return new Promise((resolve, reject) => {
    const cleanup = () => {
      /* eslint-disable */
      stream.removeListener('error', onError);
      stream.removeListener('close', onClose);
      /* eslint-enable */
    };

    const onError = (err) => {
      cleanup();
      reject(err);
    };

    const onClose = () => {
      cleanup();
      resolve(stream);
    };

    stream.removeAllListeners('error');
    stream.removeAllListeners('close');
    stream.once('error', onError);
    stream.once('close', onClose);

    stream.close();
  });
}

/*
 * Expose
 */

module.exports = Logger;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * scripterror.js - script error for wmcc_core.
 */



/**
 * An error thrown from the scripting system,
 * potentially pertaining to Script execution.
 * @alias module:script.ScriptError
 * @constructor
 * @extends Error
 * @param {String} code - Error code.
 * @param {Opcode} op - Opcode.
 * @param {Number?} ip - Instruction pointer.
 * @property {String} message - Error message.
 * @property {String} code - Original code passed in.
 * @property {Number} op - Opcode.
 * @property {Number} ip - Instruction pointer.
 */

function ScriptError(code, op, ip) {
  if (!(this instanceof ScriptError))
    return new ScriptError(code, op, ip);

  Error.call(this);

  this.type = 'ScriptError';
  this.code = code;
  this.message = code;
  this.op = -1;
  this.ip = -1;

  if (typeof op === 'string') {
    this.message = op;
  } else if (op) {
    this.message = `${code} (op=${op.toSymbol()}, ip=${ip})`;
    this.op = op.value;
    this.ip = ip;
  }

  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ScriptError);
};

Object.setPrototypeOf(ScriptError.prototype, Error.prototype);

module.exports = ScriptError;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * invitem.js - inv item object for wmcc_core.
 */



const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const util = __webpack_require__(1);

/**
 * Inv Item
 * @alias module:primitives.InvItem
 * @constructor
 * @param {Number} type
 * @param {Hash} hash
 * @property {InvType} type
 * @property {Hash} hash
 */

function InvItem(type, hash) {
  if (!(this instanceof InvItem))
    return new InvItem(type, hash);

  this.type = type;
  this.hash = hash;
}

/**
 * Inv types.
 * @enum {Number}
 * @default
 */

InvItem.types = {
  ERROR: 0,
  TX: 1,
  BLOCK: 2,
  FILTERED_BLOCK: 3,
  WITNESS_TX: 1 | (1 << 30),
  WITNESS_BLOCK: 2 | (1 << 30),
  WITNESS_FILTERED_BLOCK: 3 | (1 << 30),
  CMPCT_BLOCK: 4
};

/**
 * Inv types by value.
 * @const {RevMap}
 */

InvItem.typesByVal = util.reverse(InvItem.types);

/**
 * Witness bit for inv types.
 * @const {Number}
 * @default
 */

InvItem.WITNESS_FLAG = 1 << 30;

/**
 * Write inv item to buffer writer.
 * @param {BufferWriter} bw
 */

InvItem.prototype.getSize = function getSize() {
  return 36;
};

/**
 * Write inv item to buffer writer.
 * @param {BufferWriter} bw
 */

InvItem.prototype.toWriter = function toWriter(bw) {
  bw.writeU32(this.type);
  bw.writeHash(this.hash);
  return bw;
};

/**
 * Serialize inv item.
 * @returns {Buffer}
 */

InvItem.prototype.toRaw = function toRaw() {
  return this.toWriter(new StaticWriter(36)).render();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

InvItem.prototype.fromReader = function fromReader(br) {
  this.type = br.readU32();
  this.hash = br.readHash('hex');
  return this;
};

/**
 * Inject properties from serialized data.
 * @param {Buffer} data
 */

InvItem.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate inv item from buffer reader.
 * @param {BufferReader} br
 * @returns {InvItem}
 */

InvItem.fromReader = function fromReader(br) {
  return new InvItem().fromReader(br);
};

/**
 * Instantiate inv item from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {InvItem}
 */

InvItem.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new InvItem().fromRaw(data);
};

/**
 * Test whether the inv item is a block.
 * @returns {Boolean}
 */

InvItem.prototype.isBlock = function isBlock() {
  switch (this.type) {
    case InvItem.types.BLOCK:
    case InvItem.types.WITNESS_BLOCK:
    case InvItem.types.FILTERED_BLOCK:
    case InvItem.types.WITNESS_FILTERED_BLOCK:
    case InvItem.types.CMPCT_BLOCK:
      return true;
    default:
      return false;
  }
};

/**
 * Test whether the inv item is a tx.
 * @returns {Boolean}
 */

InvItem.prototype.isTX = function isTX() {
  switch (this.type) {
    case InvItem.types.TX:
    case InvItem.types.WITNESS_TX:
      return true;
    default:
      return false;
  }
};

/**
 * Test whether the inv item has the witness bit set.
 * @returns {Boolean}
 */

InvItem.prototype.hasWitness = function hasWitness() {
  return (this.type & InvItem.WITNESS_FLAG) !== 0;
};

/**
 * Get little-endian hash.
 * @returns {Hash}
 */

InvItem.prototype.rhash = function rhash() {
  return util.revHex(this.hash);
};

/*
 * Expose
 */

module.exports = InvItem;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * headers.js - headers object for wmcc_core.
 */



const util = __webpack_require__(1);
const AbstractBlock = __webpack_require__(67);
const StaticWriter = __webpack_require__(4);
const BufferReader = __webpack_require__(2);

/**
 * Represents block headers obtained from the network via `headers`.
 * @alias module:primitives.Headers
 * @constructor
 * @extends AbstractBlock
 * @param {NakedBlock} options
 */

function Headers(options) {
  if (!(this instanceof Headers))
    return new Headers(options);

  AbstractBlock.call(this);

  if (options)
    this.parseOptions(options);
}

Object.setPrototypeOf(Headers.prototype, AbstractBlock.prototype);

/**
 * Do non-contextual verification on the headers.
 * @param {Object?} ret - Return object, may be
 * set with properties `reason` and `score`.
 * @returns {Boolean}
 */

Headers.prototype.verifyBody = function verifyBody(ret) {
  return true;
};

/**
 * Get size of the headers.
 * @returns {Number}
 */

Headers.prototype.getSize = function getSize() {
  return 81;
};

/**
 * Serialize the headers to a buffer writer.
 * @param {BufferWriter} bw
 */

Headers.prototype.toWriter = function toWriter(bw) {
  this.writeHead(bw);
  bw.writeVarint(0);
  return bw;
};

/**
 * Serialize the headers.
 * @returns {Buffer|String}
 */

Headers.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {Buffer} data
 */

Headers.prototype.fromReader = function fromReader(br) {
  this.readHead(br);
  br.readVarint();
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

Headers.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate headers from buffer reader.
 * @param {BufferReader} br
 * @returns {Headers}
 */

Headers.fromReader = function fromReader(br) {
  return new Headers().fromReader(br);
};

/**
 * Instantiate headers from serialized data.
 * @param {Buffer} data
 * @param {String?} enc - Encoding, can be `'hex'` or null.
 * @returns {Headers}
 */

Headers.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new Headers().fromRaw(data);
};

/**
 * Instantiate headers from serialized data.
 * @param {Buffer} data
 * @param {String?} enc - Encoding, can be `'hex'` or null.
 * @returns {Headers}
 */

Headers.fromHead = function fromHead(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new Headers().fromHead(data);
};

/**
 * Instantiate headers from a chain entry.
 * @param {ChainEntry} entry
 * @returns {Headers}
 */

Headers.fromEntry = function fromEntry(entry) {
  const headers = new Headers();
  headers.version = entry.version;
  headers.prevBlock = entry.prevBlock;
  headers.merkleRoot = entry.merkleRoot;
  headers.time = entry.time;
  headers.bits = entry.bits;
  headers.nonce = entry.nonce;
  headers._hash = Buffer.from(entry.hash, 'hex');
  headers._hhash = entry.hash;
  return headers;
};

/**
 * Convert the block to a headers object.
 * @returns {Headers}
 */

Headers.prototype.toHeaders = function toHeaders() {
  return this;
};

/**
 * Convert the block to a headers object.
 * @param {Block|MerkleBlock} block
 * @returns {Headers}
 */

Headers.fromBlock = function fromBlock(block) {
  const headers = new Headers(block);
  headers._hash = block._hash;
  headers._hhash = block._hhash;
  return headers;
};

/**
 * Convert the block to an object suitable
 * for JSON serialization.
 * @returns {Object}
 */

Headers.prototype.toJSON = function toJSON() {
  return this.getJSON();
};

/**
 * Convert the block to an object suitable
 * for JSON serialization. Note that the hashes
 * will be reversed to abide by wmccd's legacy
 * of little-endian uint256s.
 * @param {Network} network
 * @param {CoinView} view
 * @param {Number} height
 * @returns {Object}
 */

Headers.prototype.getJSON = function getJSON(network, view, height) {
  return {
    hash: this.rhash(),
    height: height,
    version: this.version,
    prevBlock: util.revHex(this.prevBlock),
    merkleRoot: util.revHex(this.merkleRoot),
    time: this.time,
    bits: this.bits,
    nonce: this.nonce
  };
};

/**
 * Inject properties from json object.
 * @private
 * @param {Object} json
 */

Headers.prototype.fromJSON = function fromJSON(json) {
  this.parseJSON(json);
  return this;
};

/**
 * Instantiate a merkle block from a jsonified block object.
 * @param {Object} json - The jsonified block object.
 * @returns {Headers}
 */

Headers.fromJSON = function fromJSON(json) {
  return new Headers().fromJSON(json);
};

/**
 * Inspect the headers and return a more
 * user-friendly representation of the data.
 * @returns {Object}
 */

Headers.prototype.inspect = function inspect() {
  return this.format();
};

/**
 * Inspect the headers and return a more
 * user-friendly representation of the data.
 * @param {CoinView} view
 * @param {Number} height
 * @returns {Object}
 */

Headers.prototype.format = function format(view, height) {
  return {
    hash: this.rhash(),
    height: height != null ? height : -1,
    date: util.date(this.time),
    version: util.hex32(this.version),
    prevBlock: util.revHex(this.prevBlock),
    merkleRoot: util.revHex(this.merkleRoot),
    time: this.time,
    bits: this.bits,
    nonce: this.nonce
  };
};

/**
 * Test an object to see if it is a Headers object.
 * @param {Object} obj
 * @returns {Boolean}
 */

Headers.isHeaders = function isHeaders(obj) {
  return obj instanceof Headers;
};

/*
 * Expose
 */

module.exports = Headers;


/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = exports;

curve.base = __webpack_require__(143);
curve.short = __webpack_require__(144);
curve.mont = __webpack_require__(146);
curve.edwards = __webpack_require__(147);


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

try {
  var util = __webpack_require__(38);
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  module.exports = __webpack_require__(145);
}


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * stack.js - stack object for wmcc_core.
 */



const assert = __webpack_require__(0);
const common = __webpack_require__(28);
const ScriptNum = __webpack_require__(33);

/**
 * Represents the stack of a Script during execution.
 * @alias module:script.Stack
 * @constructor
 * @param {Buffer[]?} items - Stack items.
 * @property {Buffer[]} items - Stack items.
 * @property {Number} length - Size of stack.
 */

function Stack(items) {
  if (!(this instanceof Stack))
    return new Stack(items);

  this.items = items || [];
}

/*
 * Expose length setter and getter.
 */

Object.defineProperty(Stack.prototype, 'length', {
  get() {
    return this.items.length;
  },
  set(length) {
    this.items.length = length;
    return this.items.length;
  }
});

/**
 * Instantiate a key and value iterator.
 * @returns {StackIterator}
 */

Stack.prototype[Symbol.iterator] = function iterator() {
  return this.items[Symbol.iterator]();
};

/**
 * Instantiate a value-only iterator.
 * @returns {StackIterator}
 */

Stack.prototype.values = function values() {
  return this.items.values();
};

/**
 * Instantiate a key and value iterator.
 * @returns {StackIterator}
 */

Stack.prototype.entries = function entries() {
  return this.items.entries();
};

/**
 * Inspect the stack.
 * @returns {String} Human-readable stack.
 */

Stack.prototype.inspect = function inspect() {
  return `<Stack: ${this.toString()}>`;
};

/**
 * Convert the stack to a string.
 * @returns {String} Human-readable stack.
 */

Stack.prototype.toString = function toString() {
  const out = [];

  for (const item of this.items)
    out.push(item.toString('hex'));

  return out.join(' ');
};

/**
 * Format the stack as wmccd asm.
 * @param {Boolean?} decode - Attempt to decode hash types.
 * @returns {String} Human-readable script.
 */

Stack.prototype.toASM = function toASM(decode) {
  const out = [];

  for (const item of this.items)
    out.push(common.toASM(item, decode));

  return out.join(' ');
};

/**
 * Clone the stack.
 * @returns {Stack} Cloned stack.
 */

Stack.prototype.clone = function clone() {
  return new Stack(this.items.slice());
};

/**
 * Clear the stack.
 * @returns {Stack}
 */

Stack.prototype.clear = function clear() {
  this.items.length = 0;
  return this;
};

/**
 * Get a stack item by index.
 * @param {Number} index
 * @returns {Buffer|null}
 */

Stack.prototype.get = function get(index) {
  if (index < 0)
    index += this.items.length;

  if (index < 0 || index >= this.items.length)
    return null;

  return this.items[index];
};

/**
 * Pop a stack item.
 * @see Array#pop
 * @returns {Buffer|null}
 */

Stack.prototype.pop = function pop() {
  const item = this.items.pop();
  return item || null;
};

/**
 * Shift a stack item.
 * @see Array#shift
 * @returns {Buffer|null}
 */

Stack.prototype.shift = function shift() {
  const item = this.items.shift();
  return item || null;
};

/**
 * Remove an item.
 * @param {Number} index
 * @returns {Buffer}
 */

Stack.prototype.remove = function remove(index) {
  if (index < 0)
    index += this.items.length;

  if (index < 0 || index >= this.items.length)
    return null;

  const items = this.items.splice(index, 1);

  if (items.length === 0)
    return null;

  return items[0];
};

/**
 * Set stack item at index.
 * @param {Number} index
 * @param {Buffer} value
 * @returns {Buffer}
 */

Stack.prototype.set = function set(index, item) {
  if (index < 0)
    index += this.items.length;

  assert(Buffer.isBuffer(item));
  assert(index >= 0 && index <= this.items.length);

  this.items[index] = item;

  return this;
};

/**
 * Push item onto stack.
 * @see Array#push
 * @param {Buffer} item
 * @returns {Number} Stack size.
 */

Stack.prototype.push = function push(item) {
  assert(Buffer.isBuffer(item));
  this.items.push(item);
  return this;
};

/**
 * Unshift item from stack.
 * @see Array#unshift
 * @param {Buffer} item
 * @returns {Number}
 */

Stack.prototype.unshift = function unshift(item) {
  assert(Buffer.isBuffer(item));
  this.items.unshift(item);
  return this;
};

/**
 * Insert an item.
 * @param {Number} index
 * @param {Buffer} item
 * @returns {Buffer}
 */

Stack.prototype.insert = function insert(index, item) {
  if (index < 0)
    index += this.items.length;

  assert(Buffer.isBuffer(item));
  assert(index >= 0 && index <= this.items.length);

  this.items.splice(index, 0, item);

  return this;
};

/**
 * Erase stack items.
 * @param {Number} start
 * @param {Number} end
 * @returns {Buffer[]}
 */

Stack.prototype.erase = function erase(start, end) {
  if (start < 0)
    start = this.items.length + start;

  if (end < 0)
    end = this.items.length + end;

  this.items.splice(start, end - start);
};

/**
 * Swap stack values.
 * @param {Number} i1 - Index 1.
 * @param {Number} i2 - Index 2.
 */

Stack.prototype.swap = function swap(i1, i2) {
  if (i1 < 0)
    i1 = this.items.length + i1;

  if (i2 < 0)
    i2 = this.items.length + i2;

  const v1 = this.items[i1];
  const v2 = this.items[i2];

  this.items[i1] = v2;
  this.items[i2] = v1;
};

/*
 * Data
 */

Stack.prototype.getData = function getData(index) {
  return this.get(index);
};

Stack.prototype.popData = function popData() {
  return this.pop();
};

Stack.prototype.shiftData = function shiftData() {
  return this.shift();
};

Stack.prototype.removeData = function removeData(index) {
  return this.remove(index);
};

Stack.prototype.setData = function setData(index, data) {
  return this.set(index, data);
};

Stack.prototype.pushData = function pushData(data) {
  return this.push(data);
};

Stack.prototype.unshiftData = function unshiftData(data) {
  return this.unshift(data);
};

Stack.prototype.insertData = function insertData(index, data) {
  return this.insert(index, data);
};

/*
 * Length
 */

Stack.prototype.getLength = function getLength(index) {
  const item = this.get(index);
  return item ? item.length : -1;
};

/*
 * String
 */

Stack.prototype.getString = function getString(index, enc) {
  const item = this.get(index);
  return item ? Stack.toString(item, enc) : null;
};

Stack.prototype.popString = function popString(enc) {
  const item = this.pop();
  return item ? Stack.toString(item, enc) : null;
};

Stack.prototype.shiftString = function shiftString(enc) {
  const item = this.shift();
  return item ? Stack.toString(item, enc) : null;
};

Stack.prototype.removeString = function removeString(index, enc) {
  const item = this.remove(index);
  return item ? Stack.toString(item, enc) : null;
};

Stack.prototype.setString = function setString(index, str, enc) {
  return this.set(index, Stack.fromString(str, enc));
};

Stack.prototype.pushString = function pushString(str, enc) {
  return this.push(Stack.fromString(str, enc));
};

Stack.prototype.unshiftString = function unshiftString(str, enc) {
  return this.unshift(Stack.fromString(str, enc));
};

Stack.prototype.insertString = function insertString(index, str, enc) {
  return this.insert(index, Stack.fromString(str, enc));
};

/*
 * Num
 */

Stack.prototype.getNum = function getNum(index, minimal, limit) {
  const item = this.get(index);
  return item ? Stack.toNum(item, minimal, limit) : null;
};

Stack.prototype.popNum = function popNum(minimal, limit) {
  const item = this.pop();
  return item ? Stack.toNum(item, minimal, limit) : null;
};

Stack.prototype.shiftNum = function shiftNum(minimal, limit) {
  const item = this.shift();
  return item ? Stack.toNum(item, minimal, limit) : null;
};

Stack.prototype.removeNum = function removeNum(index, minimal, limit) {
  const item = this.remove(index);
  return item ? Stack.toNum(item, minimal, limit) : null;
};

Stack.prototype.setNum = function setNum(index, num) {
  return this.set(index, Stack.fromNum(num));
};

Stack.prototype.pushNum = function pushNum(num) {
  return this.push(Stack.fromNum(num));
};

Stack.prototype.unshiftNum = function unshiftNum(num) {
  return this.unshift(Stack.fromNum(num));
};

Stack.prototype.insertNum = function insertNum(index, num) {
  return this.insert(index, Stack.fromNum(num));
};

/*
 * Int
 */

Stack.prototype.getInt = function getInt(index, minimal, limit) {
  const item = this.get(index);
  return item ? Stack.toInt(item, minimal, limit) : -1;
};

Stack.prototype.popInt = function popInt(minimal, limit) {
  const item = this.pop();
  return item ? Stack.toInt(item, minimal, limit) : -1;
};

Stack.prototype.shiftInt = function shiftInt(minimal, limit) {
  const item = this.shift();
  return item ? Stack.toInt(item, minimal, limit) : -1;
};

Stack.prototype.removeInt = function removeInt(index, minimal, limit) {
  const item = this.remove(index);
  return item ? Stack.toInt(item, minimal, limit) : -1;
};

Stack.prototype.setInt = function setInt(index, num) {
  return this.set(index, Stack.fromInt(num));
};

Stack.prototype.pushInt = function pushInt(num) {
  return this.push(Stack.fromInt(num));
};

Stack.prototype.unshiftInt = function unshiftInt(num) {
  return this.unshift(Stack.fromInt(num));
};

Stack.prototype.insertInt = function insertInt(index, num) {
  return this.insert(index, Stack.fromInt(num));
};

/*
 * Bool
 */

Stack.prototype.getBool = function getBool(index) {
  const item = this.get(index);
  return item ? Stack.toBool(item) : false;
};

Stack.prototype.popBool = function popBool() {
  const item = this.pop();
  return item ? Stack.toBool(item) : false;
};

Stack.prototype.shiftBool = function shiftBool() {
  const item = this.shift();
  return item ? Stack.toBool(item) : false;
};

Stack.prototype.removeBool = function removeBool(index) {
  const item = this.remove(index);
  return item ? Stack.toBool(item) : false;
};

Stack.prototype.setBool = function setBool(index, value) {
  return this.set(index, Stack.fromBool(value));
};

Stack.prototype.pushBool = function pushBool(value) {
  return this.push(Stack.fromBool(value));
};

Stack.prototype.unshiftBool = function unshiftBool(value) {
  return this.unshift(Stack.fromBool(value));
};

Stack.prototype.insertBool = function insertBool(index, value) {
  return this.insert(index, Stack.fromBool(value));
};

/**
 * Test an object to see if it is a Stack.
 * @param {Object} obj
 * @returns {Boolean}
 */

Stack.isStack = function isStack(obj) {
  return obj instanceof Stack;
};

/*
 * Encoding
 */

Stack.toString = function toString(item, enc) {
  assert(Buffer.isBuffer(item));
  return item.toString(enc || 'utf8');
};

Stack.fromString = function fromString(str, enc) {
  assert(typeof str === 'string');
  return Buffer.from(str, enc || 'utf8');
};

Stack.toNum = function toNum(item, minimal, limit) {
  return ScriptNum.decode(item, minimal, limit);
};

Stack.fromNum = function fromNum(num) {
  assert(ScriptNum.isScriptNum(num));
  return num.encode();
};

Stack.toInt = function toInt(item, minimal, limit) {
  const num = Stack.toNum(item, minimal, limit);
  return num.getInt();
};

Stack.fromInt = function fromInt(int) {
  assert(typeof int === 'number');

  if (int >= -1 && int <= 16)
    return common.small[int + 1];

  const num = ScriptNum.fromNumber(int);

  return Stack.fromNum(num);
};

Stack.toBool = function toBool(item) {
  assert(Buffer.isBuffer(item));

  for (let i = 0; i < item.length; i++) {
    if (item[i] !== 0) {
      // Cannot be negative zero
      if (i === item.length - 1 && item[i] === 0x80)
        return false;
      return true;
    }
  }

  return false;
};

Stack.fromBool = function fromBool(value) {
  assert(typeof value === 'boolean');
  return Stack.fromInt(value ? 1 : 0);
};

/*
 * Expose
 */

module.exports = Stack;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * input.js - input object for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const Network = __webpack_require__(6);
const Script = __webpack_require__(8);
const Witness = __webpack_require__(55);
const Outpoint = __webpack_require__(21);
const StaticWriter = __webpack_require__(4);
const BufferReader = __webpack_require__(2);

/**
 * Represents a transaction input.
 * @alias module:primitives.Input
 * @constructor
 * @param {NakedInput} options
 * @property {Outpoint} prevout - Outpoint.
 * @property {Script} script - Input script / scriptSig.
 * @property {Number} sequence - nSequence.
 * @property {Witness} witness - Witness (empty if not present).
 */

function Input(options) {
  if (!(this instanceof Input))
    return new Input(options);

  this.prevout = new Outpoint();
  this.script = new Script();
  this.sequence = 0xffffffff;
  this.witness = new Witness();

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from options object.
 * @private
 * @param {Object} options
 */

Input.prototype.fromOptions = function fromOptions(options) {
  assert(options, 'Input data is required.');

  this.prevout.fromOptions(options.prevout);

  if (options.script)
    this.script.fromOptions(options.script);

  if (options.sequence != null) {
    assert(util.isU32(options.sequence), 'Sequence must be a uint32.');
    this.sequence = options.sequence;
  }

  if (options.witness)
    this.witness.fromOptions(options.witness);

  return this;
};

/**
 * Instantiate an Input from options object.
 * @param {NakedInput} options
 * @returns {Input}
 */

Input.fromOptions = function fromOptions(options) {
  return new Input().fromOptions(options);
};

/**
 * Clone the input.
 * @returns {Input}
 */

Input.prototype.clone = function clone() {
  const input = new Input();
  input.prevout = this.prevout;
  input.script.inject(this.script);
  input.sequence = this.sequence;
  input.witness.inject(this.witness);
  return input;
};

/**
 * Test equality against another input.
 * @param {Input} input
 * @returns {Boolean}
 */

Input.prototype.equals = function equals(input) {
  assert(Input.isInput(input));
  return this.prevout.equals(input.prevout);
};

/**
 * Compare against another input (BIP69).
 * @param {Input} input
 * @returns {Number}
 */

Input.prototype.compare = function compare(input) {
  assert(Input.isInput(input));
  return this.prevout.compare(input.prevout);
};

/**
 * Get the previous output script type as a string.
 * Will "guess" based on the input script and/or
 * witness if coin is not available.
 * @param {Coin?} coin
 * @returns {ScriptType} type
 */

Input.prototype.getType = function getType(coin) {
  if (this.isCoinbase())
    return 'coinbase';

  if (coin)
    return coin.getType();

  let type;

  if (this.witness.items.length > 0)
    type = this.witness.getInputType();
  else
    type = this.script.getInputType();

  return Script.typesByVal[type].toLowerCase();
};

/**
 * Get the redeem script. Will attempt to resolve nested
 * redeem scripts if witnessscripthash is behind a scripthash.
 * @param {Coin?} coin
 * @returns {Script?} Redeem script.
 */

Input.prototype.getRedeem = function getRedeem(coin) {
  if (this.isCoinbase())
    return null;

  if (!coin) {
    if (this.witness.isScripthashInput())
      return this.witness.getRedeem();

    if (this.script.isScripthashInput())
      return this.script.getRedeem();

    return null;
  }

  let prev = coin.script;
  let redeem = null;

  if (prev.isScripthash()) {
    prev = this.script.getRedeem();
    redeem = prev;
  }

  if (prev && prev.isWitnessScripthash()) {
    prev = this.witness.getRedeem();
    redeem = prev;
  }

  return redeem;
};

/**
 * Get the redeem script type.
 * @param {Coin?} coin
 * @returns {String} subtype
 */

Input.prototype.getSubtype = function getSubtype(coin) {
  if (this.isCoinbase())
    return null;

  const redeem = this.getRedeem(coin);

  if (!redeem)
    return null;

  const type = redeem.getType();

  return Script.typesByVal[type].toLowerCase();
};

/**
 * Get the previous output script's address. Will "guess"
 * based on the input script and/or witness if coin
 * is not available.
 * @param {Coin?} coin
 * @returns {Address?} addr
 */

Input.prototype.getAddress = function getAddress(coin) {
  if (this.isCoinbase())
    return null;

  if (coin)
    return coin.getAddress();

  if (this.witness.items.length > 0)
    return this.witness.getInputAddress();

  return this.script.getInputAddress();
};

/**
 * Get the address hash.
 * @param {String?} enc
 * @returns {Hash} hash
 */

Input.prototype.getHash = function getHash(enc) {
  const addr = this.getAddress();

  if (!addr)
    return null;

  return addr.getHash(enc);
};

/**
 * Test to see if nSequence is equal to uint32max.
 * @returns {Boolean}
 */

Input.prototype.isFinal = function isFinal() {
  return this.sequence === 0xffffffff;
};

/**
 * Test to see if nSequence is less than 0xfffffffe.
 * @returns {Boolean}
 */

Input.prototype.isRBF = function isRBF() {
  return this.sequence < 0xfffffffe;
};

/**
 * Test to see if outpoint is null.
 * @returns {Boolean}
 */

Input.prototype.isCoinbase = function isCoinbase() {
  return this.prevout.isNull();
};

/**
 * Convert the input to a more user-friendly object.
 * @returns {Object}
 */

Input.prototype.inspect = function inspect() {
  return this.format();
};

/**
 * Convert the input to a more user-friendly object.
 * @param {Coin?} coin
 * @returns {Object}
 */

Input.prototype.format = function format(coin) {
  return {
    type: this.getType(coin),
    subtype: this.getSubtype(coin),
    address: this.getAddress(coin),
    script: this.script,
    witness: this.witness,
    redeem: this.getRedeem(coin),
    sequence: this.sequence,
    prevout: this.prevout,
    coin: coin || null
  };
};

/**
 * Convert the input to an object suitable
 * for JSON serialization.
 * @returns {Object}
 */

Input.prototype.toJSON = function toJSON(network, coin) {
  return this.getJSON();
};

/**
 * Convert the input to an object suitable
 * for JSON serialization. Note that the hashes
 * will be reversed to abide by wmccd's legacy
 * of little-endian uint256s.
 * @param {Network} network
 * @param {Coin} coin
 * @returns {Object}
 */

Input.prototype.getJSON = function getJSON(network, coin) {
  network = Network.get(network);

  let addr;
  if (!coin) {
    addr = this.getAddress();
    if (addr)
      addr = addr.toString(network);
  }

  return {
    prevout: this.prevout.toJSON(),
    script: this.script.toJSON(),
    witness: this.witness.toJSON(),
    sequence: this.sequence,
    address: addr,
    coin: coin ? coin.getJSON(network, true) : undefined
  };
};

/**
 * Inject properties from a JSON object.
 * @private
 * @param {Object} json
 */

Input.prototype.fromJSON = function fromJSON(json) {
  assert(json, 'Input data is required.');
  assert(util.isU32(json.sequence), 'Sequence must be a uint32.');
  this.prevout.fromJSON(json.prevout);
  this.script.fromJSON(json.script);
  this.witness.fromJSON(json.witness);
  this.sequence = json.sequence;
  return this;
};

/**
 * Instantiate an Input from a jsonified input object.
 * @param {Object} json - The jsonified input object.
 * @returns {Input}
 */

Input.fromJSON = function fromJSON(json) {
  return new Input().fromJSON(json);
};

/**
 * Calculate size of serialized input.
 * @returns {Number}
 */

Input.prototype.getSize = function getSize() {
  return 40 + this.script.getVarSize();
};

/**
 * Serialize the input.
 * @param {String?} enc - Encoding, can be `'hex'` or null.
 * @returns {Buffer|String}
 */

Input.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

/**
 * Write the input to a buffer writer.
 * @param {BufferWriter} bw
 */

Input.prototype.toWriter = function toWriter(bw) {
  this.prevout.toWriter(bw);
  bw.writeVarBytes(this.script.toRaw());
  bw.writeU32(this.sequence);
  return bw;
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

Input.prototype.fromReader = function fromReader(br) {
  this.prevout.fromReader(br);
  this.script.fromRaw(br.readVarBytes());
  this.sequence = br.readU32();
  return this;
};

/**
 * Inject properties from serialized data.
 * @param {Buffer} data
 */

Input.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate an input from a buffer reader.
 * @param {BufferReader} br
 * @returns {Input}
 */

Input.fromReader = function fromReader(br) {
  return new Input().fromReader(br);
};

/**
 * Instantiate an input from a serialized Buffer.
 * @param {Buffer} data
 * @param {String?} enc - Encoding, can be `'hex'` or null.
 * @returns {Input}
 */

Input.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new Input().fromRaw(data);
};

/**
 * Inject properties from outpoint.
 * @private
 * @param {Outpoint} outpoint
 */

Input.prototype.fromOutpoint = function fromOutpoint(outpoint) {
  assert(typeof outpoint.hash === 'string');
  assert(typeof outpoint.index === 'number');
  this.prevout.hash = outpoint.hash;
  this.prevout.index = outpoint.index;
  return this;
};

/**
 * Instantiate input from outpoint.
 * @param {Outpoint}
 * @returns {Input}
 */

Input.fromOutpoint = function fromOutpoint(outpoint) {
  return new Input().fromOutpoint(outpoint);
};

/**
 * Inject properties from coin.
 * @private
 * @param {Coin} coin
 */

Input.prototype.fromCoin = function fromCoin(coin) {
  assert(typeof coin.hash === 'string');
  assert(typeof coin.index === 'number');
  this.prevout.hash = coin.hash;
  this.prevout.index = coin.index;
  return this;
};

/**
 * Instantiate input from coin.
 * @param {Coin}
 * @returns {Input}
 */

Input.fromCoin = function fromCoin(coin) {
  return new Input().fromCoin(coin);
};

/**
 * Inject properties from transaction.
 * @private
 * @param {TX} tx
 * @param {Number} index
 */

Input.prototype.fromTX = function fromTX(tx, index) {
  assert(tx);
  assert(typeof index === 'number');
  assert(index >= 0 && index < tx.outputs.length);
  this.prevout.hash = tx.hash('hex');
  this.prevout.index = index;
  return this;
};

/**
 * Instantiate input from tx.
 * @param {TX} tx
 * @param {Number} index
 * @returns {Input}
 */

Input.fromTX = function fromTX(tx, index) {
  return new Input().fromTX(tx, index);
};

/**
 * Test an object to see if it is an Input.
 * @param {Object} obj
 * @returns {Boolean}
 */

Input.isInput = function isInput(obj) {
  return obj instanceof Input;
};

/*
 * Expose
 */

module.exports = Input;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * bloom.js - bloom filter for wmcc_core.
 */



const assert = __webpack_require__(0);
const murmur3 = __webpack_require__(66);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const encoding = __webpack_require__(3);
const sum32 = murmur3.sum32;
const mul32 = murmur3.mul32;
const DUMMY = Buffer.alloc(0);

/*
 * Constants
 */

const LN2SQUARED = 0.4804530139182014246671025263266649717305529515945455;
const LN2 = 0.6931471805599453094172321214581765680755001343602552;

/**
 * Bloom Filter
 * @alias module:utils.Bloom
 * @constructor
 * @param {Number} size - Filter size in bits.
 * @param {Number} n - Number of hash functions.
 * @param {Number} tweak - Seed value.
 * @param {Number|String} - Update type.
 * @property {Buffer} filter
 * @property {Number} size
 * @property {Number} n
 * @property {Number} tweak
 * @property {Number} update - Update flag (see {@link Bloom.flags}).
 */

function Bloom(size, n, tweak, update) {
  if (!(this instanceof Bloom))
    return new Bloom(size, n, tweak, update);

  this.filter = DUMMY;
  this.size = 0;
  this.n = 0;
  this.tweak = 0;
  this.update = Bloom.flags.NONE;

  if (size != null)
    this.fromOptions(size, n, tweak, update);
}

/**
 * Max bloom filter size.
 * @const {Number}
 * @default
 */

Bloom.MAX_BLOOM_FILTER_SIZE = 36000;

/**
 * Max number of hash functions.
 * @const {Number}
 * @default
 */

Bloom.MAX_HASH_FUNCS = 50;

/**
 * Bloom filter update flags.
 * @enum {Number}
 * @default
 */

Bloom.flags = {
  /**
   * Never update the filter with outpoints.
   */

  NONE: 0,

  /**
   * Always update the filter with outpoints.
   */

  ALL: 1,

  /**
   * Only update the filter with outpoints if it is
   * "asymmetric" in terms of addresses (pubkey/multisig).
   */

  PUBKEY_ONLY: 2
};

/**
 * Bloom filter update flags by value.
 * @const {RevMap}
 */

Bloom.flagsByVal = {
  0: 'NONE',
  1: 'ALL',
  2: 'PUBKEY_ONLY'
};

/**
 * Inject properties from options.
 * @private
 * @param {Number} size - Filter size in bits.
 * @param {Number} n - Number of hash functions.
 * @param {Number} tweak - Seed value.
 * @param {Number|String} - Update type.
 * @returns {Bloom}
 */

Bloom.prototype.fromOptions = function fromOptions(size, n, tweak, update) {
  assert(typeof size === 'number', '`size` must be a number.');
  assert(size > 0, '`size` must be greater than zero.');
  assert(Number.isSafeInteger(size), '`size` must be an integer.');

  size -= size % 8;

  const filter = Buffer.allocUnsafe(size / 8);
  filter.fill(0);

  if (tweak == null || tweak === -1)
    tweak = (Math.random() * 0x100000000) >>> 0;

  if (update == null || update === -1)
    update = Bloom.flags.NONE;

  if (typeof update === 'string') {
    update = Bloom.flags[update.toUpperCase()];
    assert(update != null, 'Unknown update flag.');
  }

  assert(size > 0, '`size` must be greater than zero.');
  assert(n > 0, '`n` must be greater than zero.');
  assert(Number.isSafeInteger(n), '`n` must be an integer.');
  assert(typeof tweak === 'number', '`tweak` must be a number.');
  assert(Number.isSafeInteger(tweak), '`tweak` must be an integer.');
  assert(Bloom.flagsByVal[update], 'Unknown update flag.');

  this.filter = filter;
  this.size = size;
  this.n = n;
  this.tweak = tweak;
  this.update = update;

  return this;
};

/**
 * Instantiate bloom filter from options.
 * @param {Number} size - Filter size in bits.
 * @param {Number} n - Number of hash functions.
 * @param {Number} tweak - Seed value.
 * @param {Number|String} - Update type.
 * @returns {Bloom}
 */

Bloom.fromOptions = function fromOptions(size, n, tweak, update) {
  return new Bloom().fromOptions(size, n, tweak, update);
};

/**
 * Perform the mumur3 hash on data.
 * @param {Buffer} val
 * @param {Number} n
 * @returns {Number}
 */

Bloom.prototype.hash = function hash(val, n) {
  return murmur3(val, sum32(mul32(n, 0xfba4c795), this.tweak)) % this.size;
};

/**
 * Reset the filter.
 */

Bloom.prototype.reset = function reset() {
  this.filter.fill(0);
};

/**
 * Add data to the filter.
 * @param {Buffer|String}
 * @param {String?} enc - Can be any of the Buffer object's encodings.
 */

Bloom.prototype.add = function add(val, enc) {
  if (typeof val === 'string')
    val = Buffer.from(val, enc);

  for (let i = 0; i < this.n; i++) {
    const index = this.hash(val, i);
    this.filter[index >>> 3] |= 1 << (7 & index);
  }
};

/**
 * Test whether data is present in the filter.
 * @param {Buffer|String} val
 * @param {String?} enc - Can be any of the Buffer object's encodings.
 * @returns {Boolean}
 */

Bloom.prototype.test = function test(val, enc) {
  if (typeof val === 'string')
    val = Buffer.from(val, enc);

  for (let i = 0; i < this.n; i++) {
    const index = this.hash(val, i);
    if ((this.filter[index >>> 3] & (1 << (7 & index))) === 0)
      return false;
  }

  return true;
};

/**
 * Test whether data is present in the
 * filter and potentially add data.
 * @param {Buffer|String} val
 * @param {String?} enc - Can be any of the Buffer object's encodings.
 * @returns {Boolean} Whether data was added.
 */

Bloom.prototype.added = function added(val, enc) {
  let ret = false;

  if (typeof val === 'string')
    val = Buffer.from(val, enc);

  for (let i = 0; i < this.n; i++) {
    const index = this.hash(val, i);
    if (!ret && (this.filter[index >>> 3] & (1 << (7 & index))) === 0)
      ret = true;
    this.filter[index >>> 3] |= 1 << (7 & index);
  }

  return ret;
};

/**
 * Create a filter from a false positive rate.
 * @param {Number} items - Expected number of items.
 * @param {Number} rate - False positive rate (0.0-1.0).
 * @param {Number|String} update
 * @example
 * Bloom.fromRate(800000, 0.0001, 'none');
 * @returns {Boolean}
 */

Bloom.fromRate = function fromRate(items, rate, update) {
  assert(typeof items === 'number', '`items` must be a number.');
  assert(items > 0, '`items` must be greater than zero.');
  assert(Number.isSafeInteger(items), '`items` must be an integer.');
  assert(typeof rate === 'number', '`rate` must be a number.');
  assert(rate >= 0 && rate <= 1, '`rate` must be between 0.0 and 1.0.');

  const bits = (-1 / LN2SQUARED * items * Math.log(rate)) | 0;
  const size = Math.max(8, bits);

  if (update !== -1) {
    assert(size <= Bloom.MAX_BLOOM_FILTER_SIZE * 8,
      'Bloom filter size violates policy limits!');
  }

  const n = Math.max(1, (size / items * LN2) | 0);

  if (update !== -1) {
    assert(n <= Bloom.MAX_HASH_FUNCS,
      'Bloom filter size violates policy limits!');
  }

  return new Bloom(size, n, -1, update);
};

/**
 * Ensure the filter is within the size limits.
 * @returns {Boolean}
 */

Bloom.prototype.isWithinConstraints = function isWithinConstraints() {
  if (this.size > Bloom.MAX_BLOOM_FILTER_SIZE * 8)
    return false;

  if (this.n > Bloom.MAX_HASH_FUNCS)
    return false;

  return true;
};

/**
 * Get serialization size.
 * @returns {Number}
 */

Bloom.prototype.getSize = function getSize() {
  return encoding.sizeVarBytes(this.filter) + 9;
};

/**
 * Write filter to buffer writer.
 * @param {BufferWriter} bw
 */

Bloom.prototype.toWriter = function toWriter(bw) {
  bw.writeVarBytes(this.filter);
  bw.writeU32(this.n);
  bw.writeU32(this.tweak);
  bw.writeU8(this.update);
  return bw;
};

/**
 * Serialize bloom filter.
 * @returns {Buffer}
 */

Bloom.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

Bloom.prototype.fromReader = function fromReader(br) {
  this.filter = br.readVarBytes();
  this.n = br.readU32();
  this.tweak = br.readU32();
  this.update = br.readU8();
  assert(Bloom.flagsByVal[this.update] != null, 'Unknown update flag.');
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

Bloom.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate bloom filter from buffer reader.
 * @param {BufferReader} br
 * @returns {Bloom}
 */

Bloom.fromReader = function fromReader(br) {
  return new Bloom().fromReader(br);
};

/**
 * Instantiate bloom filter from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {Bloom}
 */

Bloom.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new Bloom().fromRaw(data);
};

/*
 * Expose
 */

module.exports = Bloom;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * coin.js - coin object for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const Amount = __webpack_require__(20);
const Output = __webpack_require__(13);
const Script = __webpack_require__(8);
const Network = __webpack_require__(6);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const encoding = __webpack_require__(3);

/**
 * Represents an unspent output.
 * @alias module:primitives.Coin
 * @constructor
 * @extends Output
 * @param {NakedCoin|Coin} options
 * @property {Number} version - Transaction version.
 * @property {Number} height - Transaction height (-1 if unconfirmed).
 * @property {Amount} value - Output value in wmcoins.
 * @property {Script} script - Output script.
 * @property {Boolean} coinbase - Whether the containing
 * transaction is a coinbase.
 * @property {Hash} hash - Transaction hash.
 * @property {Number} index - Output index.
 */

function Coin(options) {
  if (!(this instanceof Coin))
    return new Coin(options);

  this.version = 1;
  this.height = -1;
  this.value = 0;
  this.script = new Script();
  this.coinbase = false;
  this.hash = encoding.NULL_HASH;
  this.index = 0;

  if (options)
    this.fromOptions(options);
}

Object.setPrototypeOf(Coin.prototype, Output.prototype);

/**
 * Inject options into coin.
 * @private
 * @param {Object} options
 */

Coin.prototype.fromOptions = function fromOptions(options) {
  assert(options, 'Coin data is required.');

  if (options.version != null) {
    assert(util.isU32(options.version), 'Version must be a uint32.');
    this.version = options.version;
  }

  if (options.height != null) {
    if (options.height !== -1) {
      assert(util.isU32(options.height), 'Height must be a uint32.');
      this.height = options.height;
    } else {
      this.height = -1;
    }
  }

  if (options.value != null) {
    assert(util.isU64(options.value), 'Value must be a uint64.');
    this.value = options.value;
  }

  if (options.script)
    this.script.fromOptions(options.script);

  if (options.coinbase != null) {
    assert(typeof options.coinbase === 'boolean',
      'Coinbase must be a boolean.');
    this.coinbase = options.coinbase;
  }

  if (options.hash != null) {
    assert(typeof options.hash === 'string', 'Hash must be a string.');
    this.hash = options.hash;
  }

  if (options.index != null) {
    assert(util.isU32(options.index), 'Index must be a uint32.');
    this.index = options.index;
  }

  return this;
};

/**
 * Instantiate Coin from options object.
 * @private
 * @param {Object} options
 */

Coin.fromOptions = function fromOptions(options) {
  return new Coin().fromOptions(options);
};

/**
 * Clone the coin.
 * @private
 * @returns {Coin}
 */

Coin.prototype.clone = function clone() {
  assert(false, 'Coins are not cloneable.');
};

/**
 * Calculate number of confirmations since coin was created.
 * @param {Number?} height - Current chain height. Network
 * height is used if not passed in.
 * @return {Number}
 */

Coin.prototype.getDepth = function getDepth(height) {
  assert(typeof height === 'number', 'Must pass a height.');

  if (this.height === -1)
    return 0;

  if (height === -1)
    return 0;

  if (height < this.height)
    return 0;

  return height - this.height + 1;
};

/**
 * Serialize coin to a key
 * suitable for a hash table.
 * @returns {String}
 */

Coin.prototype.toKey = function toKey() {
  return this.hash + this.index;
};

/**
 * Inject properties from hash table key.
 * @private
 * @param {String} key
 * @returns {Coin}
 */

Coin.prototype.fromKey = function fromKey(key) {
  assert(key.length > 64);
  this.hash = key.slice(0, 64);
  this.index = parseInt(key.slice(64), 10);
  return this;
};

/**
 * Instantiate coin from hash table key.
 * @param {String} key
 * @returns {Coin}
 */

Coin.fromKey = function fromKey(key) {
  return new Coin().fromKey(key);
};

/**
 * Get little-endian hash.
 * @returns {Hash}
 */

Coin.prototype.rhash = function rhash() {
  return util.revHex(this.hash);
};

/**
 * Get little-endian hash.
 * @returns {Hash}
 */

Coin.prototype.txid = function txid() {
  return this.rhash();
};

/**
 * Convert the coin to a more user-friendly object.
 * @returns {Object}
 */

Coin.prototype.inspect = function inspect() {
  return {
    type: this.getType(),
    version: this.version,
    height: this.height,
    value: Amount.wmcc(this.value),
    script: this.script,
    coinbase: this.coinbase,
    hash: this.hash ? util.revHex(this.hash) : null,
    index: this.index,
    address: this.getAddress()
  };
};

/**
 * Convert the coin to an object suitable
 * for JSON serialization.
 * @returns {Object}
 */

Coin.prototype.toJSON = function toJSON() {
  return this.getJSON();
};

/**
 * Convert the coin to an object suitable
 * for JSON serialization. Note that the hash
 * will be reversed to abide by wmccd's legacy
 * of little-endian uint256s.
 * @param {Network} network
 * @param {Boolean} minimal
 * @returns {Object}
 */

Coin.prototype.getJSON = function getJSON(network, minimal) {
  let addr = this.getAddress();

  network = Network.get(network);

  if (addr)
    addr = addr.toString(network);

  return {
    version: this.version,
    height: this.height,
    value: this.value,
    script: this.script.toJSON(),
    address: addr,
    coinbase: this.coinbase,
    hash: !minimal ? this.rhash() : undefined,
    index: !minimal ? this.index : undefined
  };
};

/**
 * Inject JSON properties into coin.
 * @private
 * @param {Object} json
 */

Coin.prototype.fromJSON = function fromJSON(json) {
  assert(json, 'Coin data required.');
  assert(util.isU32(json.version), 'Version must be a uint32.');
  assert(json.height === -1 || util.isU32(json.height),
    'Height must be a uint32.');
  assert(util.isU64(json.value), 'Value must be a uint64.');
  assert(typeof json.coinbase === 'boolean', 'Coinbase must be a boolean.');

  this.version = json.version;
  this.height = json.height;
  this.value = json.value;
  this.script.fromJSON(json.script);
  this.coinbase = json.coinbase;

  if (json.hash != null) {
    assert(typeof json.hash === 'string', 'Hash must be a string.');
    assert(json.hash.length === 64, 'Hash must be a string.');
    assert(util.isU32(json.index), 'Index must be a uint32.');
    this.hash = util.revHex(json.hash);
    this.index = json.index;
  }

  return this;
};

/**
 * Instantiate an Coin from a jsonified coin object.
 * @param {Object} json - The jsonified coin object.
 * @returns {Coin}
 */

Coin.fromJSON = function fromJSON(json) {
  return new Coin().fromJSON(json);
};

/**
 * Calculate size of coin.
 * @returns {Number}
 */

Coin.prototype.getSize = function getSize() {
  return 17 + this.script.getVarSize();
};

/**
 * Write the coin to a buffer writer.
 * @param {BufferWriter} bw
 */

Coin.prototype.toWriter = function toWriter(bw) {
  let height = this.height;

  if (height === -1)
    height = 0x7fffffff;

  bw.writeU32(this.version);
  bw.writeU32(height);
  bw.writeI64(this.value);
  bw.writeVarBytes(this.script.toRaw());
  bw.writeU8(this.coinbase ? 1 : 0);

  return bw;
};

/**
 * Serialize the coin.
 * @returns {Buffer|String}
 */

Coin.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

/**
 * Inject properties from serialized buffer writer.
 * @private
 * @param {BufferReader} br
 */

Coin.prototype.fromReader = function fromReader(br) {
  this.version = br.readU32();
  this.height = br.readU32();
  this.value = br.readI64();
  this.script.fromRaw(br.readVarBytes());
  this.coinbase = br.readU8() === 1;

  if (this.height === 0x7fffffff)
    this.height = -1;

  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

Coin.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate a coin from a buffer reader.
 * @param {BufferReader} br
 * @returns {Coin}
 */

Coin.fromReader = function fromReader(br) {
  return new Coin().fromReader(br);
};

/**
 * Instantiate a coin from a serialized Buffer.
 * @param {Buffer} data
 * @param {String?} enc - Encoding, can be `'hex'` or null.
 * @returns {Coin}
 */

Coin.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new Coin().fromRaw(data);
};

/**
 * Inject properties from TX.
 * @param {TX} tx
 * @param {Number} index
 */

Coin.prototype.fromTX = function fromTX(tx, index, height) {
  assert(typeof index === 'number');
  assert(typeof height === 'number');
  assert(index >= 0 && index < tx.outputs.length);
  this.version = tx.version;
  this.height = height;
  this.value = tx.outputs[index].value;
  this.script = tx.outputs[index].script;
  this.coinbase = tx.isCoinbase();
  this.hash = tx.hash('hex');
  this.index = index;
  return this;
};

/**
 * Instantiate a coin from a TX
 * @param {TX} tx
 * @param {Number} index - Output index.
 * @returns {Coin}
 */

Coin.fromTX = function fromTX(tx, index, height) {
  return new Coin().fromTX(tx, index, height);
};

/**
 * Test an object to see if it is a Coin.
 * @param {Object} obj
 * @returns {Boolean}
 */

Coin.isCoin = function isCoin(obj) {
  return obj instanceof Coin;
};

/*
 * Expose
 */

module.exports = Coin;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * scrypt.js - scrypt for wmcc_core.
 *
 * Ported from:
 * https://github.com/Tarsnap/scrypt/blob/master/lib/crypto/crypto_scrypt-ref.c
 *
 * Copyright 2009 Colin Percival
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* eslint camelcase: "off" */



/**
 * @module crypto/scrypt
 */

const co = __webpack_require__(17);
const pbkdf2 = __webpack_require__(68);
const native = __webpack_require__(18).binding;

/**
 * Javascript scrypt implementation. Scrypt is
 * used in bip38. WMCC_Core doesn't support bip38
 * yet, but here it is, just in case.
 * @alias module:crypto/scrypt.derive
 * @param {Buffer} passwd
 * @param {Buffer} salt
 * @param {Number} N
 * @param {Number} r
 * @param {Number} p
 * @param {Number} len
 * @returns {Buffer}
 */

function derive(passwd, salt, N, r, p, len) {
  if (r * p >= (1 << 30))
    throw new Error('EFBIG');

  if ((N & (N - 1)) !== 0 || N === 0)
    throw new Error('EINVAL');

  if (N > 0xffffffff)
    throw new Error('EINVAL');

  const XY = Buffer.allocUnsafe(256 * r);
  const V = Buffer.allocUnsafe(128 * r * N);

  const B = pbkdf2.derive(passwd, salt, 1, p * 128 * r, 'sha256');

  for (let i = 0; i < p; i++)
    smix(B, i * 128 * r, r, N, V, XY);

  return pbkdf2.derive(passwd, B, 1, len, 'sha256');
}

if (native)
  derive = native.scrypt;

/**
 * Asynchronous scrypt implementation.
 * @alias module:crypto/scrypt.deriveAsync
 * @function
 * @param {Buffer} passwd
 * @param {Buffer} salt
 * @param {Number} N
 * @param {Number} r
 * @param {Number} p
 * @param {Number} len
 * @returns {Promise}
 */

async function deriveAsync(passwd, salt, N, r, p, len) {
  if (r * p >= (1 << 30))
    throw new Error('EFBIG');

  if ((N & (N - 1)) !== 0 || N === 0)
    throw new Error('EINVAL');

  if (N > 0xffffffff)
    throw new Error('EINVAL');

  const XY = Buffer.allocUnsafe(256 * r);
  const V = Buffer.allocUnsafe(128 * r * N);

  const B = await pbkdf2.deriveAsync(passwd, salt, 1, p * 128 * r, 'sha256');

  for (let i = 0; i < p; i++)
    await smixAsync(B, i * 128 * r, r, N, V, XY);

  return await pbkdf2.deriveAsync(passwd, B, 1, len, 'sha256');
}

if (native)
  deriveAsync = native.scryptAsync;

/*
 * Helpers
 */

function salsa20_8(B) {
  const B32 = new Uint32Array(16);
  const x = new Uint32Array(16);

  for (let i = 0; i < 16; i++)
    B32[i] = B.readUInt32LE(i * 4, true);

  for (let i = 0; i < 16; i++)
    x[i] = B32[i];

  for (let i = 0; i < 8; i += 2) {
    x[4] ^= R(x[0] + x[12], 7);
    x[8] ^= R(x[4] + x[0], 9);
    x[12] ^= R(x[8] + x[4], 13);
    x[0] ^= R(x[12] + x[8], 18);

    x[9] ^= R(x[5] + x[1], 7);
    x[13] ^= R(x[9] + x[5], 9);
    x[1] ^= R(x[13] + x[9], 13);
    x[5] ^= R(x[1] + x[13], 18);

    x[14] ^= R(x[10] + x[6], 7);
    x[2] ^= R(x[14] + x[10], 9);
    x[6] ^= R(x[2] + x[14], 13);
    x[10] ^= R(x[6] + x[2], 18);

    x[3] ^= R(x[15] + x[11], 7);
    x[7] ^= R(x[3] + x[15], 9);
    x[11] ^= R(x[7] + x[3], 13);
    x[15] ^= R(x[11] + x[7], 18);

    x[1] ^= R(x[0] + x[3], 7);
    x[2] ^= R(x[1] + x[0], 9);
    x[3] ^= R(x[2] + x[1], 13);
    x[0] ^= R(x[3] + x[2], 18);

    x[6] ^= R(x[5] + x[4], 7);
    x[7] ^= R(x[6] + x[5], 9);
    x[4] ^= R(x[7] + x[6], 13);
    x[5] ^= R(x[4] + x[7], 18);

    x[11] ^= R(x[10] + x[9], 7);
    x[8] ^= R(x[11] + x[10], 9);
    x[9] ^= R(x[8] + x[11], 13);
    x[10] ^= R(x[9] + x[8], 18);

    x[12] ^= R(x[15] + x[14], 7);
    x[13] ^= R(x[12] + x[15], 9);
    x[14] ^= R(x[13] + x[12], 13);
    x[15] ^= R(x[14] + x[13], 18);
  }

  for (let i = 0; i < 16; i++)
    B32[i] += x[i];

  for (let i = 0; i < 16; i++)
    B.writeUInt32LE(B32[i], 4 * i, true);
}

function R(a, b) {
  return (a << b) | (a >>> (32 - b));
}

function blockmix_salsa8(B, Y, Yo, r) {
  const X = Buffer.allocUnsafe(64);

  blkcpy(X, B, 0, (2 * r - 1) * 64, 64);

  for (let i = 0; i < 2 * r; i++) {
    blkxor(X, B, 0, i * 64, 64);
    salsa20_8(X);
    blkcpy(Y, X, Yo + i * 64, 0, 64);
  }

  for (let i = 0; i < r; i++)
    blkcpy(B, Y, i * 64, Yo + (i * 2) * 64, 64);

  for (let i = 0; i < r; i++)
    blkcpy(B, Y, (i + r) * 64, Yo + (i * 2 + 1) * 64, 64);
}

function integerify(B, r) {
  return B.readUInt32LE((2 * r - 1) * 64, true);
}

function smix(B, Bo, r, N, V, XY) {
  const X = XY;
  const Y = XY;

  blkcpy(X, B, 0, Bo, 128 * r);

  for (let i = 0; i < N; i++) {
    blkcpy(V, X, i * (128 * r), 0, 128 * r);
    blockmix_salsa8(X, Y, 128 * r, r);
  }

  for (let i = 0; i < N; i++) {
    const j = integerify(X, r) & (N - 1);
    blkxor(X, V, 0, j * (128 * r), 128 * r);
    blockmix_salsa8(X, Y, 128 * r, r);
  }

  blkcpy(B, X, Bo, 0, 128 * r);
}

async function smixAsync(B, Bo, r, N, V, XY) {
  const X = XY;
  const Y = XY;

  blkcpy(X, B, 0, Bo, 128 * r);

  for (let i = 0; i < N; i++) {
    blkcpy(V, X, i * (128 * r), 0, 128 * r);
    blockmix_salsa8(X, Y, 128 * r, r);
    await co.wait();
  }

  for (let i = 0; i < N; i++) {
    const j = integerify(X, r) & (N - 1);
    blkxor(X, V, 0, j * (128 * r), 128 * r);
    blockmix_salsa8(X, Y, 128 * r, r);
    await co.wait();
  }

  blkcpy(B, X, Bo, 0, 128 * r);
}

function blkcpy(dest, src, s1, s2, len) {
  src.copy(dest, s1, s2, s2 + len);
}

function blkxor(dest, src, s1, s2, len) {
  for (let i = 0; i < len; i++)
    dest[s1 + i] ^= src[s2 + i];
}

/*
 * Expose
 */

exports.derive = derive;
exports.deriveAsync = deriveAsync;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * ip.js - ip utils for wmcc_core.
 *
 * Parts of this software are based on node-ip.
 * https://github.com/indutny/node-ip
 * Copyright (c) 2012, Fedor Indutny (MIT License).
 */

/* eslint no-unreachable: "off" */



const assert = __webpack_require__(0);
const os = __webpack_require__(116);
const base32 = __webpack_require__(179);

/**
 * @exports utils/ip
 */

const IP = exports;

/*
 * Constants
 */

const ZERO_IP = Buffer.from('00000000000000000000000000000000', 'hex');
const LOCAL_IP = Buffer.from('00000000000000000000000000000001', 'hex');
const RFC6052 = Buffer.from('0064ff9b0000000000000000', 'hex');
const RFC4862 = Buffer.from('fe80000000000000', 'hex');
const RFC6145 = Buffer.from('0000000000000000ffff0000', 'hex');
const TOR_ONION = Buffer.from('fd87d87eeb43', 'hex');
const SHIFTED = Buffer.from('00000000000000ffff', 'hex');

const IPV4_REGEX = /^(\d{1,3}\.){3}\d{1,3}$/;
const IPV6_REGEX =
  /^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;

/**
 * IP address of all zeroes.
 * @const {Buffer}
 */

IP.ZERO_IP = ZERO_IP;

/**
 * Address types.
 * @enum {Number}
 */

IP.types = {
  DNS: -1,
  IPV4: 4,
  IPV6: 6,
  ONION: 10,
  TEREDO: 11
};

/**
 * Parse a hostname.
 * @param {String} addr
 * @param {Number?} fallback - Fallback port.
 * @returns {Object} Contains `host`, `port`, and `type`.
 */

IP.fromHostname = function fromHostname(addr, fallback) {
  assert(typeof addr === 'string');
  assert(addr.length > 0, 'Bad address.');

  let host, port;
  if (addr[0] === '[') {
    if (addr[addr.length - 1] === ']') {
      // Case:
      // [::1]
      host = addr.slice(1, -1);
      port = null;
    } else {
      // Case:
      // [::1]:80
      addr = addr.slice(1);
      const parts = addr.split(']:');
      assert(parts.length === 2, 'Bad IPv6 address.');
      host = parts[0];
      port = parts[1];
    }
  } else {
    const parts = addr.split(':');
    switch (parts.length) {
      case 2:
        // Cases:
        // 127.0.0.1:80
        // localhost:80
        host = parts[0];
        port = parts[1];
        break;
      case 1:
        // Cases:
        // 127.0.0.1
        // localhost
        host = parts[0];
        port = null;
        break;
      default:
        // Case:
        // ::1
        assert(IP.isV6String(addr), 'Bad IPv6 address.');
        host = addr;
        port = null;
        break;
    }
  }

  assert(host.length > 0, 'Bad host.');

  if (port != null) {
    assert(port.length <= 5, 'Bad port.');
    assert(/^\d+$/.test(port), 'Bad port.');
    port = parseInt(port, 10);
    assert(port <= 0xffff);
  } else {
    port = fallback || 0;
  }

  const type = IP.getStringType(host);

  let raw;
  if (type !== IP.types.DNS) {
    raw = IP.toBuffer(host);
    host = IP.toString(raw);
  }

  let hostname;
  if (type === IP.types.IPV6)
    hostname = `[${host}]:${port}`;
  else
    hostname = `${host}:${port}`;

  return new Address(host, port, type, hostname, raw);
};

/**
 * Concatenate a host and port.
 * @param {String} host
 * @param {Number} port
 * @returns {String}
 */

IP.toHostname = function toHostname(host, port) {
  assert(typeof host === 'string');
  assert(host.length > 0);
  assert(typeof port === 'number');
  assert(port >= 0 && port <= 0xffff);

  assert(!/[\[\]]/.test(host), 'Bad host.');

  const type = IP.getStringType(host);

  if (host.indexOf(':') !== -1)
    assert(type === IP.types.IPV6, 'Bad host.');

  if (type !== IP.types.DNS)
    host = IP.normalize(host);

  if (type === IP.types.IPV6)
    return `[${host}]:${port}`;

  return `${host}:${port}`;
};

/**
 * Get address type (-1=dns, 4=ipv4, 6=ipv6, 10=tor).
 * @param {String?} str
 * @returns {Number}
 */

IP.getStringType = function getStringType(str) {
  if (IP.isV4String(str))
    return IP.types.IPV4;

  if (IP.isV6String(str))
    return IP.types.IPV6;

  if (IP.isOnionString(str))
    return IP.types.ONION;

  return IP.types.DNS;
};

/**
 * Test whether a string is IPv4.
 * @param {String?} str
 * @returns {Boolean}
 */

IP.isV4String = function isV4String(str) {
  assert(typeof str === 'string');

  if (str.length < 7)
    return false;

  if (str.length > 15)
    return false;

  return IPV4_REGEX.test(str);
};

/**
 * Test whether a string is IPv6.
 * @param {String?} str
 * @returns {Boolean}
 */

IP.isV6String = function isV6String(str) {
  assert(typeof str === 'string');

  if (str.length < 2)
    return false;

  if (str.length > 39)
    return false;

  return IPV6_REGEX.test(str);
};

/**
 * Test whether a string is an onion address.
 * @param {String?} str
 * @returns {Boolean}
 */

IP.isOnionString = function isOnionString(str) {
  assert(typeof str === 'string');

  if (str.length < 7)
    return false;

  return str.slice(-6) === '.onion';
};

/**
 * Test whether a buffer is an ipv4-mapped ipv6 address.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

IP.isMapped = function isMapped(raw) {
  assert(Buffer.isBuffer(raw));
  assert(raw.length === 16);

  return raw[0] === 0x00
    && raw[1] === 0x00
    && raw[2] === 0x00
    && raw[3] === 0x00
    && raw[4] === 0x00
    && raw[5] === 0x00
    && raw[6] === 0x00
    && raw[7] === 0x00
    && raw[8] === 0x00
    && raw[9] === 0x00
    && raw[10] === 0xff
    && raw[11] === 0xff;
};

/**
 * Parse an IP string and return a buffer.
 * @param {String} str
 * @returns {Buffer}
 */

IP.toBuffer = function toBuffer(str) {
  assert(typeof str === 'string');

  const raw = Buffer.allocUnsafe(16);

  if (IP.isV4String(str)) {
    raw.fill(0);
    raw[10] = 0xff;
    raw[11] = 0xff;
    return IP.parseV4(str, raw, 12);
  }

  if (IP.isOnionString(str)) {
    const prefix = TOR_ONION;
    prefix.copy(raw, 0);
    const data = base32.decode(str.slice(0, -6));
    assert(data.length === 10, 'Invalid onion address.');
    data.copy(raw, 6);
    return raw;
  }

  return IP.parseV6(str, raw, 0);
};

/**
 * Convert an IPv4 string to a buffer.
 * @private
 * @param {String} str
 * @param {Buffer} raw
 * @param {Number} offset
 * @returns {Buffer}
 */

IP.parseV4 = function parseV4(str, raw, offset) {
  const parts = str.split('.');

  assert(parts.length === 4);

  for (let ch of parts) {
    assert(ch.length > 0);
    assert(ch.length <= 3);
    ch = parseInt(ch, 10);
    assert(ch >= 0 && ch <= 255);
    raw[offset++] = ch;
  }

  return raw;
};

/**
 * Convert an IPv6 string to a buffer.
 * @private
 * @param {String} str
 * @param {Buffer} raw
 * @param {Number} offset
 * @returns {Buffer}
 */

IP.parseV6 = function parseV6(str, raw, offset) {
  const parts = str.split(':');
  let missing = 8 - parts.length;

  assert(parts.length >= 2, 'Not an IPv6 address.');

  for (const word of parts) {
    if (IP.isV4String(word))
      missing--;
  }

  const start = offset;
  let colon = false;

  for (let i = 0; i < parts.length; i++) {
    let word = parts[i];

    if (word.length === 0) {
      assert(!colon, 'Overuse of double colon in IPv6 address.');

      colon = true;
      missing += 1;

      // Eat extra colons.
      // e.g. :::0
      while (i + 1 < parts.length) {
        word = parts[i + 1];
        if (word.length !== 0)
          break;
        missing += 1;
        i++;
      }

      while (missing > 0) {
        raw[offset++] = 0;
        raw[offset++] = 0;
        missing--;
      }

      continue;
    }

    if (IP.isV4String(word)) {
      IP.parseV4(word, raw, offset);
      offset += 4;
      continue;
    }

    assert(word.length <= 4);

    word = parseInt(word, 16);

    assert(word === word, 'Non-number in IPv6 address.');

    raw[offset++] = (word >> 8) & 0xff;
    raw[offset++] = word & 0xff;
  }

  assert(missing === 0, 'IPv6 address has missing sections.');
  assert.strictEqual(offset, start + 16);

  return raw;
};

/**
 * Convert a buffer to an ip string.
 * @param {Buffer} raw
 * @returns {String}
 */

IP.toString = function toString(raw) {
  assert(Buffer.isBuffer(raw));

  if (raw.length === 4) {
    let host = '';
    host += raw[0];
    host += '.' + raw[1];
    host += '.' + raw[2];
    host += '.' + raw[3];
    return host;
  }

  if (raw.length === 16) {
    if (IP.isMapped(raw)) {
      let host = '';
      host += raw[12];
      host += '.' + raw[13];
      host += '.' + raw[14];
      host += '.' + raw[15];
      return host;
    }

    if (IP.isOnion(raw)) {
      const host = base32.encode(raw.slice(6));
      return `${host}.onion`;
    }

    let host = '';

    host += raw.readUInt16BE(0, true).toString(16);

    for (let i = 2; i < 16; i += 2) {
      host += ':';
      host += raw.readUInt16BE(i, true).toString(16);
    }

    host = host.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3');
    host = host.replace(/:{3,4}/, '::');

    return host;
  }

  throw new Error(`Invalid IP address: ${raw.toString('hex')}.`);
};

/**
 * Normalize an ip.
 * @param {String} str
 * @returns {String}
 */

IP.normalize = function normalize(str) {
  return IP.toString(IP.toBuffer(str));
};

/**
 * Test whether the address is IPv4.
 * @returns {Boolean}
 */

IP.isIPv4 = function isIPv4(raw) {
  return IP.isMapped(raw);
};

/**
 * Test whether the address is IPv6.
 * @returns {Boolean}
 */

IP.isIPv6 = function isIPv6(raw) {
  return !IP.isMapped(raw) && !IP.isOnion(raw);
};

/**
 * Get address type.
 * @param {Buffer} raw
 * @returns {Number}
 */

IP.getType = function getType(raw) {
  if (IP.isIPv4(raw))
    return IP.types.IPV4;

  if (IP.isIPv6(raw))
    return IP.types.IPV6;

  if (IP.isOnion(raw))
    return IP.types.ONION;

  throw new Error('Unknown type.');
};

/**
 * Get addr network. Similar to
 * type, but includes teredo.
 * @param {Buffer} raw
 * @returns {Number}
 */

IP.getNetwork = function getNetwork(raw) {
  if (IP.isRFC4380(raw))
    return IP.types.TEREDO;

  return IP.getType(raw);
};

/**
 * Test whether the host is null.
 * @returns {Boolean}
 */

IP.isNull = function isNull(raw) {
  if (IP.isIPv4(raw)) {
    // 0.0.0.0
    return raw[12] === 0
      && raw[13] === 0
      && raw[14] === 0
      && raw[15] === 0;
  }
  // ::
  return IP.isEqual(raw, ZERO_IP);
};

/**
 * Test whether the host is a broadcast address.
 * @returns {Boolean}
 */

IP.isBroadcast = function isBroadcast(raw) {
  if (IP.isIPv4(raw)) {
    // 255.255.255.255
    return raw[12] === 255
      && raw[13] === 255
      && raw[14] === 255
      && raw[15] === 255;
  }
  return false;
};

/**
 * Test whether the ip is RFC 1918.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

IP.isRFC1918 = function isRFC1918(raw) {
  if (!IP.isIPv4(raw))
    return false;

  if (raw[12] === 10)
    return true;

  if (raw[12] === 192 && raw[13] === 168)
    return true;

  if (raw[12] === 172 && (raw[13] >= 16 && raw[13] <= 31))
    return true;

  return false;
};

/**
 * Test whether the ip is RFC 2544.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

IP.isRFC2544 = function isRFC2544(raw) {
  if (!IP.isIPv4(raw))
    return false;

  if (raw[12] === 198 && (raw[13] === 18 || raw[13] === 19))
    return true;

  if (raw[12] === 169 && raw[13] === 254)
    return true;

  return false;
};

/**
 * Test whether the ip is RFC 3927.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

IP.isRFC3927 = function isRFC3927(raw) {
  if (!IP.isIPv4(raw))
    return false;

  if (raw[12] === 169 && raw[13] === 254)
    return true;

  return false;
};

/**
 * Test whether the ip is RFC 6598.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

IP.isRFC6598 = function isRFC6598(raw) {
  if (!IP.isIPv4(raw))
    return false;

  if (raw[12] === 100
      && (raw[13] >= 64 && raw[13] <= 127)) {
    return true;
  }

  return false;
};

/**
 * Test whether the ip is RFC 5737.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

IP.isRFC5737 = function isRFC5737(raw) {
  if (!IP.isIPv4(raw))
    return false;

  if (raw[12] === 192
      && (raw[13] === 0 && raw[14] === 2)) {
    return true;
  }

  if (raw[12] === 198 && raw[13] === 51 && raw[14] === 100)
    return true;

  if (raw[12] === 203 && raw[13] === 0 && raw[14] === 113)
    return true;

  return false;
};

/**
 * Test whether the ip is RFC 3849.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

IP.isRFC3849 = function isRFC3849(raw) {
  if (raw[0] === 0x20 && raw[1] === 0x01
      && raw[2] === 0x0d && raw[3] === 0xb8) {
    return true;
  }

  return false;
};

/**
 * Test whether the ip is RFC 3964.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

IP.isRFC3964 = function isRFC3964(raw) {
  if (raw[0] === 0x20 && raw[1] === 0x02)
    return true;

  return false;
};

/**
 * Test whether the ip is RFC 6052.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

IP.isRFC6052 = function isRFC6052(raw) {
  return IP.hasPrefix(raw, RFC6052);
};

/**
 * Test whether the ip is RFC 4380.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

IP.isRFC4380 = function isRFC4380(raw) {
  if (raw[0] === 0x20 && raw[1] === 0x01
      && raw[2] === 0x00 && raw[3] === 0x00) {
    return true;
  }

  return false;
};

/**
 * Test whether the ip is RFC 4862.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

IP.isRFC4862 = function isRFC4862(raw) {
  return IP.hasPrefix(raw, RFC4862);
};

/**
 * Test whether the ip is RFC 4193.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

IP.isRFC4193 = function isRFC4193(raw) {
  if ((raw[0] & 0xfe) === 0xfc)
    return true;

  return false;
};

/**
 * Test whether the ip is RFC 6145.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

IP.isRFC6145 = function isRFC6145(raw) {
  return IP.hasPrefix(raw, RFC6145);
};

/**
 * Test whether the ip is RFC 4843.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

IP.isRFC4843 = function isRFC4843(raw) {
  if (raw[0] === 0x20 && raw[1] === 0x01
      && raw[2] === 0x00 && (raw[3] & 0xf0) === 0x10) {
    return true;
  }

  return false;
};

/**
 * Test whether the ip has a tor onion prefix.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

IP.isOnion = function isOnion(raw) {
  return IP.hasPrefix(raw, TOR_ONION);
};

/**
 * Test whether the ip is local.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

IP.isLocal = function isLocal(raw) {
  if (IP.isIPv4(raw)) {
    if (raw[12] === 127 && raw[13] === 0)
      return true;
    return false;
  }

  if (IP.isEqual(raw, LOCAL_IP))
    return true;

  return false;
};

/**
 * Test whether the ip is a multicast address.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

IP.isMulticast = function isMulticast(raw) {
  if (IP.isIPv4(raw)) {
    if ((raw[12] & 0xf0) === 0xe0)
      return true;
    return false;
  }
  return raw[0] === 0xff;
};

/**
 * Test whether the ip is valid.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

IP.isValid = function isValid(raw) {
  if (IP.hasPrefix(raw, SHIFTED))
    return false;

  if (IP.isNull(raw))
    return false;

  if (IP.isBroadcast(raw))
    return false;

  if (IP.isRFC3849(raw))
    return false;

  return true;
};

/**
 * Test whether the ip is routable.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

IP.isRoutable = function isRoutable(raw) {
  if (!IP.isValid(raw))
    return false;

  if (IP.isRFC1918(raw))
    return false;

  if (IP.isRFC2544(raw))
    return false;

  if (IP.isRFC3927(raw))
    return false;

  if (IP.isRFC4862(raw))
    return false;

  if (IP.isRFC6598(raw))
    return false;

  if (IP.isRFC5737(raw))
    return false;

  if (IP.isRFC4193(raw) && !IP.isOnion(raw))
    return false;

  if (IP.isRFC4843(raw))
    return false;

  if (IP.isLocal(raw))
    return false;

  return true;
};

/**
 * Calculate reachable score from source to destination.
 * @param {Buffer} src
 * @param {Buffer} dest
 * @returns {Number} Ranges from 0-6.
 */

IP.getReachability = function getReachability(src, dest) {
  const UNREACHABLE = 0;
  const DEFAULT = 1;
  const TEREDO = 2;
  const IPV6_WEAK = 3;
  const IPV4 = 4;
  const IPV6_STRONG = 5;
  const PRIVATE = 6;

  if (!IP.isRoutable(src))
    return UNREACHABLE;

  const srcNet = IP.getNetwork(src);
  const destNet = IP.getNetwork(dest);
  const types = IP.types;

  switch (destNet) {
    case types.IPV4:
      switch (srcNet) {
        case types.IPV4:
          return IPV4;
        default:
          return DEFAULT;
      }
      break;
    case types.IPV6:
      switch (srcNet) {
        case types.TEREDO:
          return TEREDO;
        case types.IPV4:
          return IPV4;
        case types.IPV6:
          if (IP.isRFC3964(src)
              || IP.isRFC6052(src)
              || IP.isRFC6145(src)) {
            // tunnel
            return IPV6_WEAK;
          }
          return IPV6_STRONG;
        default:
          return DEFAULT;
      }
      break;
    case types.ONION:
      switch (srcNet) {
        case types.IPV4:
          return IPV4;
        case types.ONION:
          return PRIVATE;
        default:
          return DEFAULT;
      }
      break;
    case types.TEREDO:
      switch (srcNet) {
        case types.TEREDO:
          return TEREDO;
        case types.IPV6:
          return IPV6_WEAK;
        case types.IPV4:
          return IPV4;
        default:
          return DEFAULT;
      }
      break;
    default:
      switch (srcNet) {
        case types.TEREDO:
          return TEREDO;
        case types.IPV6:
          return IPV6_WEAK;
        case types.IPV4:
          return IPV4;
        case types.ONION:
          return PRIVATE;
        default:
          return DEFAULT;
      }
      break;
  }
};

/**
 * Test whether an IP has a prefix.
 * @param {Buffer} raw
 * @param {Buffer} prefix
 * @returns {Boolean}
 */

IP.hasPrefix = function hasPrefix(raw, prefix) {
  assert(Buffer.isBuffer(raw));
  assert(Buffer.isBuffer(prefix));
  assert(raw.length >= prefix.length);

  for (let i = 0; i < prefix.length; i++) {
    if (raw[i] !== prefix[i])
      return false;
  }

  return true;
};

/**
 * Test whether two IPs are equal.
 * @param {Buffer} a
 * @param {Buffer} b
 * @returns {Boolean}
 */

IP.isEqual = function isEqual(a, b) {
  assert(a.length === 16);
  assert(b.length === 16);
  return a.equals(b);
};

/**
 * Get IP address from network interfaces.
 * @param {String?} name - `public` or `private`.
 * @param {String?} family - IP family name.
 * @returns {String}
 */

IP.getInterfaces = function getInterfaces(name, family) {
  const interfaces = os.networkInterfaces();
  const result = [];

  for (const key of Object.keys(interfaces)) {
    const items = interfaces[key];

    for (const details of items) {
      const type = details.family.toLowerCase();

      if (family && type !== family)
        continue;

      if (details.internal)
        continue;

      let raw;
      try {
        raw = IP.toBuffer(details.address);
      } catch (e) {
        continue;
      }

      if (IP.isNull(raw))
        continue;

      if (IP.isLocal(raw))
        continue;

      if (name === 'public') {
        if (!IP.isRoutable(raw))
          continue;
      } else if (name === 'private') {
        if (IP.isRoutable(raw))
          continue;
      }

      result.push(IP.toString(raw));
    }
  }

  return result;
};

/**
 * Get private IP from network interfaces.
 * @param {String?} family - IP family name.
 * @returns {String}
 */

IP.getPrivate = function getPrivate(family) {
  return IP.getInterfaces('private', family);
};

/**
 * Get public IP from network interfaces.
 * @param {String?} family - IP family name.
 * @returns {String}
 */

IP.getPublic = function getPublic(family) {
  return IP.getInterfaces('public', family);
};

/**
 * Represents a parsed address.
 * @constructor
 * @alias module:utils/ip.Address
 * @param {String} host
 * @param {Number} port
 * @param {Number} type
 * @param {String} hostname
 * @param {Buffer|null} raw
 * @property {String} host
 * @property {Number} port
 * @property {Number} type
 * @property {String} hostname
 * @property {Buffer} raw
 */

function Address(host, port, type, hostname, raw) {
  this.host = host || '0.0.0.0';
  this.port = port || 0;
  this.type = type || IP.types.IPV4;
  this.hostname = hostname || '0.0.0.0:0';
  this.raw = raw || ZERO_IP;
}

/*
 * Expose
 */

IP.Address = Address;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * keyring.js - keyring object for wmcc_core.
 */



const assert = __webpack_require__(0);
const encoding = __webpack_require__(3);
const digest = __webpack_require__(5);
const Network = __webpack_require__(6);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const base58 = __webpack_require__(26);
const Script = __webpack_require__(8);
const Address = __webpack_require__(11);
const Output = __webpack_require__(13);
const secp256k1 = __webpack_require__(12);

/**
 * Represents a key ring which amounts to an address.
 * @alias module:primitives.KeyRing
 * @constructor
 * @param {Object} options
 * @param {Network} network
 */

function KeyRing(options, network) {
  if (!(this instanceof KeyRing))
    return new KeyRing(options, network);

  this.network = Network.primary;
  this.witness = false;
  this.nested = false;
  this.publicKey = encoding.ZERO_KEY;
  this.privateKey = null;
  this.script = null;

  this._keyHash = null;
  this._keyAddress = null;
  this._program = null;
  this._nestedHash = null;
  this._nestedAddress = null;
  this._scriptHash160 = null;
  this._scriptHash256 = null;
  this._scriptAddress = null;

  if (options)
    this.fromOptions(options, network);
}

/**
 * Inject properties from options object.
 * @private
 * @param {Object} options
 */

KeyRing.prototype.fromOptions = function fromOptions(options, network) {
  if (!network)
    network = options.network;

  let key = toKey(options);

  if (Buffer.isBuffer(key))
    return this.fromKey(key, network);

  key = toKey(options.key);

  if (options.publicKey)
    key = toKey(options.publicKey);

  if (options.privateKey)
    key = toKey(options.privateKey);

  if (options.witness != null) {
    assert(typeof options.witness === 'boolean');
    this.witness = options.witness;
  }

  if (options.nested != null) {
    assert(typeof options.nested === 'boolean');
    this.nested = options.nested;
  }

  const script = options.script;
  const compress = options.compressed;

  if (script)
    return this.fromScript(key, script, compress, network);

  return this.fromKey(key, compress, network);
};

/**
 * Instantiate key ring from options.
 * @param {Object} options
 * @returns {KeyRing}
 */

KeyRing.fromOptions = function fromOptions(options) {
  return new KeyRing().fromOptions(options);
};

/**
 * Clear cached key/script hashes.
 */

KeyRing.prototype.refresh = function refresh() {
  this._keyHash = null;
  this._keyAddress = null;
  this._program = null;
  this._nestedHash = null;
  this._nestedAddress = null;
  this._scriptHash160 = null;
  this._scriptHash256 = null;
  this._scriptAddress = null;
};

/**
 * Inject data from private key.
 * @private
 * @param {Buffer} key
 * @param {Boolean?} compress
 * @param {(NetworkType|Network)?} network
 */

KeyRing.prototype.fromPrivate = function fromPrivate(key, compress, network) {
  assert(Buffer.isBuffer(key), 'Private key must be a buffer.');
  assert(secp256k1.privateKeyVerify(key), 'Not a valid private key.');

  if (typeof compress !== 'boolean') {
    network = compress;
    compress = null;
  }

  this.network = Network.get(network);
  this.privateKey = key;
  this.publicKey = secp256k1.publicKeyCreate(key, compress !== false);

  return this;
};

/**
 * Instantiate keyring from a private key.
 * @param {Buffer} key
 * @param {Boolean?} compress
 * @param {(NetworkType|Network)?} network
 * @returns {KeyRing}
 */

KeyRing.fromPrivate = function fromPrivate(key, compress, network) {
  return new KeyRing().fromPrivate(key, compress, network);
};

/**
 * Inject data from public key.
 * @private
 * @param {Buffer} key
 * @param {(NetworkType|Network)?} network
 */

KeyRing.prototype.fromPublic = function fromPublic(key, network) {
  assert(Buffer.isBuffer(key), 'Public key must be a buffer.');
  assert(secp256k1.publicKeyVerify(key), 'Not a valid public key.');
  this.network = Network.get(network);
  this.publicKey = key;
  return this;
};

/**
 * Generate a keyring.
 * @private
 * @param {Boolean?} compress
 * @param {(Network|NetworkType)?} network
 * @returns {KeyRing}
 */

KeyRing.prototype.generate = function generate(compress, network) {
  if (typeof compress !== 'boolean') {
    network = compress;
    compress = null;
  }

  const key = secp256k1.generatePrivateKey();

  return this.fromKey(key, compress, network);
};

/**
 * Generate a keyring.
 * @param {Boolean?} compress
 * @param {(Network|NetworkType)?} network
 * @returns {KeyRing}
 */

KeyRing.generate = function generate(compress, network) {
  return new KeyRing().generate(compress, network);
};

/**
 * Instantiate keyring from a public key.
 * @param {Buffer} publicKey
 * @param {(NetworkType|Network)?} network
 * @returns {KeyRing}
 */

KeyRing.fromPublic = function fromPublic(key, network) {
  return new KeyRing().fromPublic(key, network);
};

/**
 * Inject data from public key.
 * @private
 * @param {Buffer} privateKey
 * @param {Boolean?} compress
 * @param {(NetworkType|Network)?} network
 */

KeyRing.prototype.fromKey = function fromKey(key, compress, network) {
  assert(Buffer.isBuffer(key), 'Key must be a buffer.');

  if (typeof compress !== 'boolean') {
    network = compress;
    compress = null;
  }

  if (key.length === 32)
    return this.fromPrivate(key, compress !== false, network);

  return this.fromPublic(key, network);
};

/**
 * Instantiate keyring from a public key.
 * @param {Buffer} publicKey
 * @param {Boolean?} compress
 * @param {(NetworkType|Network)?} network
 * @returns {KeyRing}
 */

KeyRing.fromKey = function fromKey(key, compress, network) {
  return new KeyRing().fromKey(key, compress, network);
};

/**
 * Inject data from script.
 * @private
 * @param {Buffer} key
 * @param {Script} script
 * @param {Boolean?} compress
 * @param {(NetworkType|Network)?} network
 */

KeyRing.prototype.fromScript = function fromScript(key, script, compress, network) {
  assert(script instanceof Script, 'Non-script passed into KeyRing.');

  if (typeof compress !== 'boolean') {
    network = compress;
    compress = null;
  }

  this.fromKey(key, compress, network);
  this.script = script;

  return this;
};

/**
 * Instantiate keyring from script.
 * @param {Buffer} key
 * @param {Script} script
 * @param {Boolean?} compress
 * @param {(NetworkType|Network)?} network
 * @returns {KeyRing}
 */

KeyRing.fromScript = function fromScript(key, script, compress, network) {
  return new KeyRing().fromScript(key, script, compress, network);
};

/**
 * Calculate WIF serialization size.
 * @returns {Number}
 */

KeyRing.prototype.getSecretSize = function getSecretSize() {
  let size = 0;

  size += 1;
  size += this.privateKey.length;

  if (this.publicKey.length === 33)
    size += 1;

  size += 4;

  return size;
};

/**
 * Convert key to a CBitcoinSecret.
 * @param {(Network|NetworkType)?} network
 * @returns {Base58String}
 */

KeyRing.prototype.toSecret = function toSecret(network) {
  const size = this.getSecretSize();
  const bw = new StaticWriter(size);

  assert(this.privateKey, 'Cannot serialize without private key.');

  if (!network)
    network = this.network;

  network = Network.get(network);

  bw.writeU8(network.keyPrefix.privkey);
  bw.writeBytes(this.privateKey);

  if (this.publicKey.length === 33)
    bw.writeU8(1);

  bw.writeChecksum();

  return base58.encode(bw.render());
};

/**
 * Inject properties from serialized CBitcoinSecret.
 * @private
 * @param {Base58String} secret
 * @param {(Network|NetworkType)?} network
 */

KeyRing.prototype.fromSecret = function fromSecret(data, network) {
  const br = new BufferReader(base58.decode(data), true);

  const version = br.readU8();

  network = Network.fromWIF(version, network);

  const key = br.readBytes(32);

  let compress = false;

  if (br.left() > 4) {
    assert(br.readU8() === 1, 'Bad compression flag.');
    compress = true;
  }

  br.verifyChecksum();

  return this.fromPrivate(key, compress, network);
};

/**
 * Instantiate a keyring from a serialized CBitcoinSecret.
 * @param {Base58String} secret
 * @param {(Network|NetworkType)?} network
 * @returns {KeyRing}
 */

KeyRing.fromSecret = function fromSecret(data, network) {
  return new KeyRing().fromSecret(data, network);
};

/**
 * Get private key.
 * @param {String?} enc - Can be `"hex"`, `"base58"`, or `null`.
 * @returns {Buffer} Private key.
 */

KeyRing.prototype.getPrivateKey = function getPrivateKey(enc) {
  if (!this.privateKey)
    return null;

  if (enc === 'base58')
    return this.toSecret();

  if (enc === 'hex')
    return this.privateKey.toString('hex');

  return this.privateKey;
};

/**
 * Get public key.
 * @param {String?} enc - `"hex"` or `null`.
 * @returns {Buffer}
 */

KeyRing.prototype.getPublicKey = function getPublicKey(enc) {
  if (enc === 'base58')
    return base58.encode(this.publicKey);

  if (enc === 'hex')
    return this.publicKey.toString('hex');

  return this.publicKey;
};

/**
 * Get redeem script.
 * @returns {Script}
 */

KeyRing.prototype.getScript = function getScript() {
  return this.script;
};

/**
 * Get witness program.
 * @returns {Buffer}
 */

KeyRing.prototype.getProgram = function getProgram() {
  if (!this.witness)
    return null;

  if (!this._program) {
    let program;
    if (!this.script) {
      const hash = digest.hash160(this.publicKey);
      program = Script.fromProgram(0, hash);
    } else {
      const hash = this.script.sha256();
      program = Script.fromProgram(0, hash);
    }
    this._program = program;
  }

  return this._program;
};

/**
 * Get address' ripemd160 program scripthash
 * (for witness programs behind a scripthash).
 * @param {String?} enc - `"hex"` or `null`.
 * @returns {Buffer}
 */

KeyRing.prototype.getNestedHash = function getNestedHash(enc) {
  if (!this.witness)
    return null;

  if (!this._nestedHash)
    this._nestedHash = this.getProgram().hash160();

  return enc === 'hex'
    ? this._nestedHash.toString('hex')
    : this._nestedHash;
};

/**
 * Get address' scripthash address for witness program.
 * @param {String?} enc - `"base58"` or `null`.
 * @returns {Address|Base58Address}
 */

KeyRing.prototype.getNestedAddress = function getNestedAddress(enc) {
  if (!this.witness)
    return null;

  if (!this._nestedAddress) {
    const hash = this.getNestedHash();
    const addr = Address.fromScripthash(hash, this.network);
    this._nestedAddress = addr;
  }

  if (enc === 'base58')
    return this._nestedAddress.toBase58();

  if (enc === 'string')
    return this._nestedAddress.toString();

  return this._nestedAddress;
};

/**
 * Get scripthash.
 * @param {String?} enc - `"hex"` or `null`.
 * @returns {Buffer}
 */

KeyRing.prototype.getScriptHash = function getScriptHash(enc) {
  if (this.witness)
    return this.getScriptHash256(enc);
  return this.getScriptHash160(enc);
};

/**
 * Get ripemd160 scripthash.
 * @param {String?} enc - `"hex"` or `null`.
 * @returns {Buffer}
 */

KeyRing.prototype.getScriptHash160 = function getScriptHash160(enc) {
  if (!this.script)
    return null;

  if (!this._scriptHash160)
    this._scriptHash160 = this.script.hash160();

  return enc === 'hex'
    ? this._scriptHash160.toString('hex')
    : this._scriptHash160;
};

/**
 * Get sha256 scripthash.
 * @param {String?} enc - `"hex"` or `null`.
 * @returns {Buffer}
 */

KeyRing.prototype.getScriptHash256 = function getScriptHash256(enc) {
  if (!this.script)
    return null;

  if (!this._scriptHash256)
    this._scriptHash256 = this.script.sha256();

  return enc === 'hex'
    ? this._scriptHash256.toString('hex')
    : this._scriptHash256;
};

/**
 * Get scripthash address.
 * @param {String?} enc - `"base58"` or `null`.
 * @returns {Address|Base58Address}
 */

KeyRing.prototype.getScriptAddress = function getScriptAddress(enc) {
  if (!this.script)
    return null;

  if (!this._scriptAddress) {
    let addr;
    if (this.witness) {
      const hash = this.getScriptHash256();
      addr = Address.fromWitnessScripthash(hash, this.network);
    } else {
      const hash = this.getScriptHash160();
      addr = Address.fromScripthash(hash, this.network);
    }
    this._scriptAddress = addr;
  }

  if (enc === 'base58')
    return this._scriptAddress.toBase58();

  if (enc === 'string')
    return this._scriptAddress.toString();

  return this._scriptAddress;
};

/**
 * Get public key hash.
 * @param {String?} enc - `"hex"` or `null`.
 * @returns {Buffer}
 */

KeyRing.prototype.getKeyHash = function getKeyHash(enc) {
  if (!this._keyHash)
    this._keyHash = digest.hash160(this.publicKey);

  return enc === 'hex'
    ? this._keyHash.toString('hex')
    : this._keyHash;
};

/**
 * Get pubkeyhash address.
 * @param {String?} enc - `"base58"` or `null`.
 * @returns {Address|Base58Address}
 */

KeyRing.prototype.getKeyAddress = function getKeyAddress(enc) {
  if (!this._keyAddress) {
    const hash = this.getKeyHash();

    let addr;
    if (this.witness)
      addr = Address.fromWitnessPubkeyhash(hash, this.network);
    else
      addr = Address.fromPubkeyhash(hash, this.network);

    this._keyAddress = addr;
  }

  if (enc === 'base58')
    return this._keyAddress.toBase58();

  if (enc === 'string')
    return this._keyAddress.toString();

  return this._keyAddress;
};

/**
 * Get hash.
 * @param {String?} enc - `"hex"` or `null`.
 * @returns {Buffer}
 */

KeyRing.prototype.getHash = function getHash(enc) {
  if (this.nested)
    return this.getNestedHash(enc);

  if (this.script)
    return this.getScriptHash(enc);

  return this.getKeyHash(enc);
};

/**
 * Get base58 address.
 * @param {String?} enc - `"base58"` or `null`.
 * @returns {Address|Base58Address}
 */

KeyRing.prototype.getAddress = function getAddress(enc) {
  if (this.nested)
    return this.getNestedAddress(enc);

  if (this.script)
    return this.getScriptAddress(enc);

  return this.getKeyAddress(enc);
};

/**
 * Test an address hash against hash and program hash.
 * @param {Buffer} hash
 * @returns {Boolean}
 */

KeyRing.prototype.ownHash = function ownHash(hash) {
  if (!hash)
    return false;

  if (hash.equals(this.getKeyHash()))
    return true;

  if (this.script) {
    if (hash.equals(this.getScriptHash()))
      return true;
  }

  if (this.witness) {
    if (hash.equals(this.getNestedHash()))
      return true;
  }

  return false;
};

/**
 * Check whether transaction output belongs to this address.
 * @param {TX|Output} tx - Transaction or Output.
 * @param {Number?} index - Output index.
 * @returns {Boolean}
 */

KeyRing.prototype.ownOutput = function ownOutput(tx, index) {
  let output;

  if (tx instanceof Output) {
    output = tx;
  } else {
    output = tx.outputs[index];
    assert(output, 'Output does not exist.');
  }

  return this.ownHash(output.getHash());
};

/**
 * Test a hash against script hashes to
 * find the correct redeem script, if any.
 * @param {Buffer} hash
 * @returns {Script|null}
 */

KeyRing.prototype.getRedeem = function getRedeem(hash) {
  if (this.witness) {
    if (hash.equals(this.getNestedHash()))
      return this.getProgram();
  }

  if (this.script) {
    if (hash.equals(this.getScriptHash160()))
      return this.script;

    if (hash.equals(this.getScriptHash256()))
      return this.script;
  }

  return null;
};

/**
 * Sign a message.
 * @param {Buffer} msg
 * @returns {Buffer} Signature in DER format.
 */

KeyRing.prototype.sign = function sign(msg) {
  assert(this.privateKey, 'Cannot sign without private key.');
  return secp256k1.sign(msg, this.privateKey);
};

/**
 * Verify a message.
 * @param {Buffer} msg
 * @param {Buffer} sig - Signature in DER format.
 * @returns {Boolean}
 */

KeyRing.prototype.verify = function verify(msg, sig) {
  return secp256k1.verify(msg, sig, this.publicKey);
};

/**
 * Get witness program version.
 * @returns {Number}
 */

KeyRing.prototype.getVersion = function getVersion() {
  if (!this.witness)
    return -1;

  if (this.nested)
    return -1;

  return 0;
};

/**
 * Get address type.
 * @returns {ScriptType}
 */

KeyRing.prototype.getType = function getType() {
  if (this.nested)
    return Address.types.SCRIPTHASH;

  if (this.witness)
    return Address.types.WITNESS;

  if (this.script)
    return Address.types.SCRIPTHASH;

  return Address.types.PUBKEYHASH;
};

/**
 * Inspect keyring.
 * @returns {Object}
 */

KeyRing.prototype.inspect = function inspect() {
  return this.toJSON();
};

/**
 * Convert an KeyRing to a more json-friendly object.
 * @returns {Object}
 */

KeyRing.prototype.toJSON = function toJSON() {
  return {
    network: this.network.type,
    witness: this.witness,
    nested: this.nested,
    publicKey: this.publicKey.toString('hex'),
    script: this.script ? this.script.toRaw().toString('hex') : null,
    program: this.witness ? this.getProgram().toRaw().toString('hex') : null,
    type: Address.typesByVal[this.getType()].toLowerCase(),
    address: this.getAddress('string')
  };
};

/**
 * Inject properties from json object.
 * @private
 * @param {Object} json
 */

KeyRing.prototype.fromJSON = function fromJSON(json) {
  assert(json);
  assert(typeof json.network === 'string');
  assert(typeof json.witness === 'boolean');
  assert(typeof json.nested === 'boolean');
  assert(typeof json.publicKey === 'string');
  assert(!json.script || typeof json.script === 'string');

  this.nework = Network.get(json.network);
  this.witness = json.witness;
  this.nested = json.nested;
  this.publicKey = Buffer.from(json.publicKey, 'hex');

  if (json.script)
    this.script = Buffer.from(json.script, 'hex');

  return this;
};

/**
 * Instantiate an KeyRing from a jsonified transaction object.
 * @param {Object} json - The jsonified transaction object.
 * @returns {KeyRing}
 */

KeyRing.fromJSON = function fromJSON(json) {
  return new KeyRing().fromJSON(json);
};

/**
 * Calculate serialization size.
 * @returns {Number}
 */

KeyRing.prototype.getSize = function getSize() {
  let size = 0;
  size += 1;
  if (this.privateKey) {
    size += encoding.sizeVarBytes(this.privateKey);
    size += 1;
  } else {
    size += encoding.sizeVarBytes(this.publicKey);
  }
  size += this.script ? this.script.getVarSize() : 1;
  return size;
};

/**
 * Write the keyring to a buffer writer.
 * @param {BufferWriter} bw
 */

KeyRing.prototype.toWriter = function toWriter(bw) {
  let field = 0;

  if (this.witness)
    field |= 1;

  if (this.nested)
    field |= 2;

  bw.writeU8(field);

  if (this.privateKey) {
    bw.writeVarBytes(this.privateKey);
    bw.writeU8(this.publicKey.length === 33);
  } else {
    bw.writeVarBytes(this.publicKey);
  }

  if (this.script)
    bw.writeVarBytes(this.script.toRaw());
  else
    bw.writeVarint(0);

  return bw;
};

/**
 * Serialize the keyring.
 * @returns {Buffer}
 */

KeyRing.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 * @param {Network?} network
 */

KeyRing.prototype.fromReader = function fromReader(br, network) {
  this.network = Network.get(network);

  const field = br.readU8();

  this.witness = (field & 1) !== 0;
  this.nested = (field & 2) !== 0;

  const key = br.readVarBytes();

  if (key.length === 32) {
    const compress = br.readU8() === 1;
    this.privateKey = key;
    this.publicKey = secp256k1.publicKeyCreate(key, compress);
  } else {
    this.publicKey = key;
    assert(secp256k1.publicKeyVerify(key), 'Invalid public key.');
  }

  const script = br.readVarBytes();

  if (script.length > 0)
    this.script = Script.fromRaw(script);

  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 * @param {Network?} network
 */

KeyRing.prototype.fromRaw = function fromRaw(data, network) {
  return this.fromReader(new BufferReader(data), network);
};

/**
 * Instantiate a keyring from buffer reader.
 * @param {BufferReader} br
 * @returns {KeyRing}
 */

KeyRing.fromReader = function fromReader(br) {
  return new KeyRing().fromReader(br);
};

/**
 * Instantiate a keyring from serialized data.
 * @param {Buffer} data
 * @returns {KeyRing}
 */

KeyRing.fromRaw = function fromRaw(data) {
  return new KeyRing().fromRaw(data);
};

/**
 * Test whether an object is a KeyRing.
 * @param {Object} obj
 * @returns {Boolean}
 */

KeyRing.isKeyRing = function isKeyRing(obj) {
  return obj instanceof KeyRing;
};

/*
 * Helpers
 */

function toKey(opt) {
  if (!opt)
    return opt;

  if (opt.privateKey)
    return opt.privateKey;

  if (opt.publicKey)
    return opt.publicKey;

  return opt;
}

/*
 * Expose
 */

module.exports = KeyRing;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * mtx.js - mutable transaction object for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const Script = __webpack_require__(8);
const TX = __webpack_require__(16);
const Input = __webpack_require__(42);
const Output = __webpack_require__(13);
const Coin = __webpack_require__(44);
const Outpoint = __webpack_require__(21);
const CoinView = __webpack_require__(30);
const Address = __webpack_require__(11);
const encoding = __webpack_require__(3);
const consensus = __webpack_require__(7);
const policy = __webpack_require__(19);
const Amount = __webpack_require__(20);
const Stack = __webpack_require__(41);

/**
 * A mutable transaction object.
 * @alias module:primitives.MTX
 * @extends TX
 * @constructor
 * @param {Object} options
 * @param {Number?} options.version
 * @param {Number?} options.changeIndex
 * @param {Input[]?} options.inputs
 * @param {Output[]?} options.outputs
 * @property {Number} version - Transaction version.
 * @property {Number} flag - Flag field for segregated witness.
 * Always non-zero (1 if not present).
 * @property {Input[]} inputs
 * @property {Output[]} outputs
 * @property {Number} locktime - nLockTime
 * @property {CoinView} view
 */

function MTX(options) {
  if (!(this instanceof MTX))
    return new MTX(options);

  TX.call(this);

  this.mutable = true;
  this.changeIndex = -1;
  this.view = new CoinView();

  if (options)
    this.fromOptions(options);
}

Object.setPrototypeOf(MTX.prototype, TX.prototype);

/**
 * Inject properties from options object.
 * @private
 * @param {Object} options
 */

MTX.prototype.fromOptions = function fromOptions(options) {
  if (options.version != null) {
    assert(util.isU32(options.version), 'Version must a be uint32.');
    this.version = options.version;
  }

  if (options.inputs) {
    assert(Array.isArray(options.inputs), 'Inputs must be an array.');
    for (const input of options.inputs)
      this.addInput(input);
  }

  if (options.outputs) {
    assert(Array.isArray(options.outputs), 'Outputs must be an array.');
    for (const output of options.outputs)
      this.addOutput(output);
  }

  if (options.locktime != null) {
    assert(util.isU32(options.locktime), 'Locktime must be a uint32.');
    this.locktime = options.locktime;
  }

  if (options.changeIndex != null) {
    if (options.changeIndex !== -1) {
      assert(util.isU32(options.changeIndex),
        'Change index must be a uint32.');
      this.changeIndex = options.changeIndex;
    } else {
      this.changeIndex = -1;
    }
  }

  return this;
};

/**
 * Instantiate MTX from options.
 * @param {Object} options
 * @returns {MTX}
 */

MTX.fromOptions = function fromOptions(options) {
  return new MTX().fromOptions(options);
};

/**
 * Clone the transaction. Note that
 * this will not carry over the view.
 * @returns {MTX}
 */

MTX.prototype.clone = function clone() {
  const mtx = new MTX();
  mtx.inject(this);
  mtx.changeIndex = this.changeIndex;
  return mtx;
};

/**
 * Add an input to the transaction.
 * @param {Input|Object} options
 * @returns {Input}
 *
 * @example
 * mtx.addInput({ prevout: { hash: ... }, script: ... });
 * mtx.addInput(new Input());
 */

MTX.prototype.addInput = function addInput(options) {
  const input = Input.fromOptions(options);
  this.inputs.push(input);
  return input;
};

/**
 * Add an outpoint as an input.
 * @param {Outpoint|Object} outpoint
 * @returns {Input}
 *
 * @example
 * mtx.addOutpoint({ hash: ..., index: 0 });
 * mtx.addOutpoint(new Outpoint(hash, index));
 */

MTX.prototype.addOutpoint = function addOutpoint(outpoint) {
  const prevout = Outpoint.fromOptions(outpoint);
  const input = Input.fromOutpoint(prevout);
  this.inputs.push(input);
  return input;
};

/**
 * Add a coin as an input. Note that this will
 * add the coin to the internal coin viewpoint.
 * @param {Coin} coin
 * @returns {Input}
 *
 * @example
 * mtx.addCoin(Coin.fromTX(tx, 0, -1));
 */

MTX.prototype.addCoin = function addCoin(coin) {
  assert(coin instanceof Coin, 'Cannot add non-coin.');

  const input = Input.fromCoin(coin);

  this.inputs.push(input);
  this.view.addCoin(coin);

  return input;
};

/**
 * Add a transaction as an input. Note that
 * this will add the coin to the internal
 * coin viewpoint.
 * @param {TX} tx
 * @param {Number} index
 * @param {Number?} height
 * @returns {Input}
 *
 * @example
 * mtx.addTX(tx, 0);
 */

MTX.prototype.addTX = function addTX(tx, index, height) {
  assert(tx instanceof TX, 'Cannot add non-transaction.');

  if (height == null)
    height = -1;

  const input = Input.fromTX(tx, index);
  //const coin = Coin.fromTX(tx, index, height);

  this.inputs.push(input);
  //this.view.addCoin(coin);
  this.view.addIndex(tx, index, height);

  return input;
};

/**
 * Add an output.
 * @param {Address|Script|Output|Object} script - Script or output options.
 * @param {Amount?} value
 * @returns {Output}
 *
 * @example
 * mtx.addOutput(new Output());
 * mtx.addOutput({ address: ..., value: 100000 });
 * mtx.addOutput(address, 100000);
 * mtx.addOutput(script, 100000);
 */

MTX.prototype.addOutput = function addOutput(script, value) {
  let output;

  if (value != null) {
    assert(util.isU64(value), 'Value must be a uint64.');
    output = Output.fromScript(script, value);
  } else {
    output = Output.fromOptions(script);
  }

  this.outputs.push(output);

  return output;
};

/**
 * Verify all transaction inputs.
 * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
 * @returns {Boolean} Whether the inputs are valid.
 * @throws {ScriptError} on invalid inputs
 */

MTX.prototype.check = function check(flags) {
  return TX.prototype.check.call(this, this.view, flags);
};

/**
 * Verify the transaction inputs on the worker pool
 * (if workers are enabled).
 * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
 * @param {WorkerPool?} pool
 * @returns {Promise}
 */

MTX.prototype.checkAsync = function checkAsync(flags, pool) {
  return TX.prototype.checkAsync.call(this, this.view, flags, pool);
};

/**
 * Verify all transaction inputs.
 * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
 * @returns {Boolean} Whether the inputs are valid.
 */

MTX.prototype.verify = function verify(flags) {
  try {
    this.check(flags);
  } catch (e) {
    if (e.type === 'ScriptError')
      return false;
    throw e;
  }
  return true;
};

/**
 * Verify the transaction inputs on the worker pool
 * (if workers are enabled).
 * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
 * @param {WorkerPool?} pool
 * @returns {Promise}
 */

MTX.prototype.verifyAsync = async function verifyAsync(flags, pool) {
  try {
    await this.checkAsync(flags, pool);
  } catch (e) {
    if (e.type === 'ScriptError')
      return false;
    throw e;
  }
  return true;
};

/**
 * Calculate the fee for the transaction.
 * @returns {Amount} fee (zero if not all coins are available).
 */

MTX.prototype.getFee = function getFee() {
  return TX.prototype.getFee.call(this, this.view);
};

/**
 * Calculate the total input value.
 * @returns {Amount} value
 */

MTX.prototype.getInputValue = function getInputValue() {
  return TX.prototype.getInputValue.call(this, this.view);
};

/**
 * Get all input addresses.
 * @returns {Address[]} addresses
 */

MTX.prototype.getInputAddresses = function getInputAddresses() {
  return TX.prototype.getInputAddresses.call(this, this.view);
};

/**
 * Get all addresses.
 * @returns {Address[]} addresses
 */

MTX.prototype.getAddresses = function getAddresses() {
  return TX.prototype.getAddresses.call(this, this.view);
};

/**
 * Get all input address hashes.
 * @returns {Hash[]} hashes
 */

MTX.prototype.getInputHashes = function getInputHashes(enc) {
  return TX.prototype.getInputHashes.call(this, this.view, enc);
};

/**
 * Get all address hashes.
 * @returns {Hash[]} hashes
 */

MTX.prototype.getHashes = function getHashes(enc) {
  return TX.prototype.getHashes.call(this, this.view, enc);
};

/**
 * Test whether the transaction has
 * all coins available/filled.
 * @returns {Boolean}
 */

MTX.prototype.hasCoins = function hasCoins() {
  return TX.prototype.hasCoins.call(this, this.view);
};

/**
 * Calculate virtual sigop count.
 * @param {VerifyFlags?} flags
 * @returns {Number} sigop count
 */

MTX.prototype.getSigops = function getSigops(flags) {
  return TX.prototype.getSigops.call(this, this.view, flags);
};

/**
 * Calculate sigops weight, taking into account witness programs.
 * @param {VerifyFlags?} flags
 * @returns {Number} sigop weight
 */

MTX.prototype.getSigopsCost = function getSigopsCost(flags) {
  return TX.prototype.getSigopsCost.call(this, this.view, flags);
};

/**
 * Calculate the virtual size of the transaction
 * (weighted against bytes per sigop cost).
 * @returns {Number} vsize
 */

MTX.prototype.getSigopsSize = function getSigopsSize() {
  return TX.prototype.getSigopsSize.call(this, this.getSigopsCost());
};

/**
 * Perform contextual checks to verify input, output,
 * and fee values, as well as coinbase spend maturity
 * (coinbases can only be spent 100 blocks or more
 * after they're created). Note that this function is
 * consensus critical.
 * @param {Number} height - Height at which the
 * transaction is being spent. In the mempool this is
 * the chain height plus one at the time it entered the pool.
 * @returns {Boolean}
 */

MTX.prototype.verifyInputs = function verifyInputs(height) {
  const [fee] = this.checkInputs(height);
  return fee !== -1;
};

/**
 * Perform contextual checks to verify input, output,
 * and fee values, as well as coinbase spend maturity
 * (coinbases can only be spent 100 blocks or more
 * after they're created). Note that this function is
 * consensus critical.
 * @param {Number} height - Height at which the
 * transaction is being spent. In the mempool this is
 * the chain height plus one at the time it entered the pool.
 * @returns {Array} [fee, reason, score]
 */

MTX.prototype.checkInputs = function checkInputs(height) {
  return TX.prototype.checkInputs.call(this, this.view, height);
};

/**
 * Build input script (or witness) templates (with
 * OP_0 in place of signatures).
 * @param {Number} index - Input index.
 * @param {Coin|Output} coin
 * @param {KeyRing} ring
 * @returns {Boolean} Whether the script was able to be built.
 */

MTX.prototype.scriptInput = function scriptInput(index, coin, ring) {
  const input = this.inputs[index];

  assert(input, 'Input does not exist.');
  assert(coin, 'No coin passed.');

  // Don't bother with any below calculation
  // if the output is already templated.
  if (input.script.raw.length !== 0
      || input.witness.items.length !== 0) {
    return true;
  }

  // Get the previous output's script
  const prev = coin.script;

  // This is easily the hardest part about
  // building a transaction with segwit:
  // figuring out where the redeem script
  // and witness redeem scripts go.
  const sh = prev.getScripthash();

  if (sh) {
    const redeem = ring.getRedeem(sh);

    if (!redeem)
      return false;

    // Witness program nested in regular P2SH.
    if (redeem.isProgram()) {
      // P2WSH nested within pay-to-scripthash.
      const wsh = redeem.getWitnessScripthash();
      if (wsh) {
        const wredeem = ring.getRedeem(wsh);

        if (!wredeem)
          return false;

        const witness = this.scriptVector(wredeem, ring);

        if (!witness)
          return false;

        witness.push(wredeem.toRaw());

        input.witness.fromStack(witness);
        input.script.fromItems([redeem.toRaw()]);

        return true;
      }

      // P2WPKH nested within pay-to-scripthash.
      const wpkh = redeem.getWitnessPubkeyhash();
      if (wpkh) {
        const pkh = Script.fromPubkeyhash(wpkh);
        const witness = this.scriptVector(pkh, ring);

        if (!witness)
          return false;

        input.witness.fromStack(witness);
        input.script.fromItems([redeem.toRaw()]);

        return true;
      }

      // Unknown witness program.
      return false;
    }

    // Regular P2SH.
    const vector = this.scriptVector(redeem, ring);

    if (!vector)
      return false;

    vector.push(redeem.toRaw());

    input.script.fromStack(vector);

    return true;
  }

  // Witness program.
  if (prev.isProgram()) {
    // Bare P2WSH.
    const wsh = prev.getWitnessScripthash();
    if (wsh) {
      const wredeem = ring.getRedeem(wsh);

      if (!wredeem)
        return false;

      const vector = this.scriptVector(wredeem, ring);

      if (!vector)
        return false;

      vector.push(wredeem.toRaw());

      input.witness.fromStack(vector);

      return true;
    }

    // Bare P2WPKH.
    const wpkh = prev.getWitnessPubkeyhash();
    if (wpkh) {
      const pkh = Script.fromPubkeyhash(wpkh);
      const vector = this.scriptVector(pkh, ring);

      if (!vector)
        return false;

      input.witness.fromStack(vector);

      return true;
    }

    // Bare... who knows?
    return false;
  }

  // Wow, a normal output! Praise be to Jengus and Gord.
  const vector = this.scriptVector(prev, ring);

  if (!vector)
    return false;

  input.script.fromStack(vector);

  return true;
};

/**
 * Build script for a single vector
 * based on a previous script.
 * @param {Script} prev
 * @param {Buffer} ring
 * @return {Boolean}
 */

MTX.prototype.scriptVector = function scriptVector(prev, ring) {
  // P2PK
  const pk = prev.getPubkey();
  if (pk) {
    if (!pk.equals(ring.publicKey))
      return null;

    const stack = new Stack();

    stack.pushInt(0);

    return stack;
  }

  // P2PKH
  const pkh = prev.getPubkeyhash();
  if (pkh) {
    if (!pkh.equals(ring.getKeyHash()))
      return null;

    const stack = new Stack();

    stack.pushInt(0);
    stack.pushData(ring.publicKey);

    return stack;
  }

  // Multisig
  const [, n] = prev.getMultisig();
  if (n !== -1) {
    if (prev.indexOf(ring.publicKey) === -1)
      return null;

    // Technically we should create m signature slots,
    // but we create n signature slots so we can order
    // the signatures properly.
    const stack = new Stack();

    stack.pushInt(0);

    // Fill script with `n` signature slots.
    for (let i = 0; i < n; i++)
      stack.pushInt(0);

    return stack;
  }

  return null;
};

/**
 * Sign a transaction input on the worker pool
 * (if workers are enabled).
 * @param {Number} index
 * @param {Coin|Output} coin
 * @param {KeyRing} ring
 * @param {SighashType?} type
 * @param {WorkerPool?} pool
 * @returns {Promise}
 */

MTX.prototype.signInputAsync = async function signInputAsync(index, coin, ring, type, pool) {
  if (!pool)
    return this.signInput(index, coin, ring, type);

  return await pool.signInput(this, index, coin, ring, type, pool);
};

/**
 * Sign an input.
 * @param {Number} index - Index of input being signed.
 * @param {Coin|Output} coin
 * @param {KeyRing} ring - Private key.
 * @param {SighashType} type
 * @returns {Boolean} Whether the input was able to be signed.
 */

MTX.prototype.signInput = function signInput(index, coin, ring, type) {
  const input = this.inputs[index];
  const key = ring.privateKey;

  assert(input, 'Input does not exist.');
  assert(coin, 'No coin passed.');

  // Get the previous output's script
  const value = coin.value;
  let prev = coin.script;
  let vector = input.script;
  let version = 0;
  let redeem = false;

  // Grab regular p2sh redeem script.
  if (prev.isScripthash()) {
    prev = input.script.getRedeem();
    if (!prev)
      throw new Error('Input has not been templated.');
    redeem = true;
  }

  // If the output script is a witness program,
  // we have to switch the vector to the witness
  // and potentially alter the length. Note that
  // witnesses are stack items, so the `dummy`
  // _has_ to be an empty buffer (what OP_0
  // pushes onto the stack).
  if (prev.isWitnessScripthash()) {
    prev = input.witness.getRedeem();
    if (!prev)
      throw new Error('Input has not been templated.');
    vector = input.witness;
    redeem = true;
    version = 1;
  } else {
    const wpkh = prev.getWitnessPubkeyhash();
    if (wpkh) {
      prev = Script.fromPubkeyhash(wpkh);
      vector = input.witness;
      redeem = false;
      version = 1;
    }
  }

  // Create our signature.
  const sig = this.signature(index, prev, value, key, type, version);

  if (redeem) {
    const stack = vector.toStack();
    const redeem = stack.pop();

    const result = this.signVector(prev, stack, sig, ring);

    if (!result)
      return false;

    result.push(redeem);

    vector.fromStack(result);

    return true;
  }

  const stack = vector.toStack();
  const result = this.signVector(prev, stack, sig, ring);

  if (!result)
    return false;

  vector.fromStack(result);

  return true;
};

/**
 * Add a signature to a vector
 * based on a previous script.
 * @param {Script} prev
 * @param {Stack} vector
 * @param {Buffer} sig
 * @param {KeyRing} ring
 * @return {Boolean}
 */

MTX.prototype.signVector = function signVector(prev, vector, sig, ring) {
  // P2PK
  const pk = prev.getPubkey();
  if (pk) {
    // Make sure the pubkey is ours.
    if (!ring.publicKey.equals(pk))
      return null;

    if (vector.length === 0)
      throw new Error('Input has not been templated.');

    // Already signed.
    if (vector.get(0).length > 0)
      return vector;

    vector.set(0, sig);

    return vector;
  }

  // P2PKH
  const pkh = prev.getPubkeyhash();
  if (pkh) {
    // Make sure the pubkey hash is ours.
    if (!ring.getKeyHash().equals(pkh))
      return null;

    if (vector.length !== 2)
      throw new Error('Input has not been templated.');

    if (vector.get(1).length === 0)
      throw new Error('Input has not been templated.');

    // Already signed.
    if (vector.get(0).length > 0)
      return vector;

    vector.set(0, sig);

    return vector;
  }

  // Multisig
  const [m, n] = prev.getMultisig();
  if (m !== -1) {
    if (vector.length < 2)
      throw new Error('Input has not been templated.');

    if (vector.get(0).length !== 0)
      throw new Error('Input has not been templated.');

    // Too many signature slots. Abort.
    if (vector.length - 1 > n)
      throw new Error('Input has not been templated.');

    // Count the number of current signatures.
    let total = 0;
    for (let i = 1; i < vector.length; i++) {
      const item = vector.get(i);
      if (item.length > 0)
        total++;
    }

    // Signatures are already finalized.
    if (total === m && vector.length - 1 === m)
      return vector;

    // Add some signature slots for us to use if
    // there was for some reason not enough.
    while (vector.length - 1 < n)
      vector.pushInt(0);

    // Grab the redeem script's keys to figure
    // out where our key should go.
    const keys = [];
    for (const op of prev.code) {
      if (op.data)
        keys.push(op.data);
    }

    // Find the key index so we can place
    // the signature in the same index.
    let keyIndex = util.indexOf(keys, ring.publicKey);

    // Our public key is not in the prev_out
    // script. We tried to sign a transaction
    // that is not redeemable by us.
    if (keyIndex === -1)
      return null;

    // Offset key index by one to turn it into
    // "sig index". Accounts for OP_0 byte at
    // the start.
    keyIndex++;

    // Add our signature to the correct slot
    // and increment the total number of
    // signatures.
    if (keyIndex < vector.length && total < m) {
      if (vector.get(keyIndex).length === 0) {
        vector.set(keyIndex, sig);
        total++;
      }
    }

    // All signatures added. Finalize.
    if (total >= m) {
      // Remove empty slots left over.
      for (let i = vector.length - 1; i >= 1; i--) {
        const item = vector.get(i);
        if (item.length === 0)
          vector.remove(i);
      }

      // Remove signatures which are not required.
      // This should never happen.
      while (total > m) {
        vector.pop();
        total--;
      }

      // Sanity checks.
      assert(total === m);
      assert(vector.length - 1 === m);
    }

    return vector;
  }

  return null;
};

/**
 * Test whether the transaction is fully-signed.
 * @returns {Boolean}
 */

MTX.prototype.isSigned = function isSigned() {
  for (let i = 0; i < this.inputs.length; i++) {
    const {prevout} = this.inputs[i];
    const coin = this.view.getOutput(prevout);

    if (!coin)
      return false;

    if (!this.isInputSigned(i, coin))
      return false;
  }

  return true;
};

/**
 * Test whether an input is fully-signed.
 * @param {Number} index
 * @param {Coin|Output} coin
 * @returns {Boolean}
 */

MTX.prototype.isInputSigned = function isInputSigned(index, coin) {
  const input = this.inputs[index];

  assert(input, 'Input does not exist.');
  assert(coin, 'No coin passed.');

  let prev = coin.script;
  let vector = input.script;
  let redeem = false;

  // Grab redeem script if possible.
  if (prev.isScripthash()) {
    prev = input.script.getRedeem();
    if (!prev)
      return false;
    redeem = true;
  }

  // If the output script is a witness program,
  // we have to switch the vector to the witness
  // and potentially alter the length.
  if (prev.isWitnessScripthash()) {
    prev = input.witness.getRedeem();
    if (!prev)
      return false;
    vector = input.witness;
    redeem = true;
  } else {
    const wpkh = prev.getWitnessPubkeyhash();
    if (wpkh) {
      prev = Script.fromPubkeyhash(wpkh);
      vector = input.witness;
      redeem = false;
    }
  }

  const stack = vector.toStack();

  if (redeem)
    stack.pop();

  return this.isVectorSigned(prev, stack);
};

/**
 * Test whether a vector is fully-signed.
 * @param {Script} prev
 * @param {Stack} vector
 * @returns {Boolean}
 */

MTX.prototype.isVectorSigned = function isVectorSigned(prev, vector) {
  if (prev.isPubkey()) {
    if (vector.length !== 1)
      return false;

    if (vector.get(0).length === 0)
      return false;

    return true;
  }

  if (prev.isPubkeyhash()) {
    if (vector.length !== 2)
      return false;

    if (vector.get(0).length === 0)
      return false;

    if (vector.get(1).length === 0)
      return false;

    return true;
  }

  const [m] = prev.getMultisig();

  if (m !== -1) {
    // Ensure we have the correct number
    // of required signatures.
    if (vector.length - 1 !== m)
      return false;

    // Ensure all members are signatures.
    for (let i = 1; i < vector.length; i++) {
      const item = vector.get(i);
      if (item.length === 0)
        return false;
    }

    return true;
  }

  return false;
};

/**
 * Build input scripts (or witnesses).
 * @param {KeyRing} ring - Address used to sign. The address
 * must be able to redeem the coin.
 * @returns {Number} Number of inputs templated.
 */

MTX.prototype.template = function template(ring) {
  if (Array.isArray(ring)) {
    let total = 0;
    for (const key of ring)
      total += this.template(key);
    return total;
  }

  let total = 0;

  for (let i = 0; i < this.inputs.length; i++) {
    const {prevout} = this.inputs[i];
    const coin = this.view.getOutput(prevout);

    if (!coin)
      continue;

    if (!ring.ownOutput(coin))
      continue;

    // Build script for input
    if (!this.scriptInput(i, coin, ring))
      continue;

    total++;
  }

  return total;
};

/**
 * Built input scripts (or witnesses) and sign the inputs.
 * @param {KeyRing} ring - Address used to sign. The address
 * must be able to redeem the coin.
 * @param {SighashType} type
 * @returns {Number} Number of inputs signed.
 */

MTX.prototype.sign = function sign(ring, type) {
  if (Array.isArray(ring)) {
    let total = 0;
    for (const key of ring)
      total += this.sign(key, type);
    return total;
  }

  assert(ring.privateKey, 'No private key available.');

  let total = 0;

  for (let i = 0; i < this.inputs.length; i++) {
    const {prevout} = this.inputs[i];
    const coin = this.view.getOutput(prevout);

    if (!coin)
      continue;

    if (!ring.ownOutput(coin))
      continue;

    // Build script for input
    if (!this.scriptInput(i, coin, ring))
      continue;

    // Sign input
    if (!this.signInput(i, coin, ring, type))
      continue;

    total++;
  }

  return total;
};

/**
 * Sign the transaction inputs on the worker pool
 * (if workers are enabled).
 * @param {KeyRing} ring
 * @param {SighashType?} type
 * @param {WorkerPool?} pool
 * @returns {Promise}
 */

MTX.prototype.signAsync = async function signAsync(ring, type, pool) {
  if (!pool)
    return this.sign(ring, type);

  return await pool.sign(this, ring, type);
};

/**
 * Estimate maximum possible size.
 * @param {Function?} estimate - Input script size estimator.
 * @returns {Number}
 */

MTX.prototype.estimateSize = async function estimateSize(estimate) {
  const scale = consensus.WITNESS_SCALE_FACTOR;

  let total = 0;

  // Calculate the size, minus the input scripts.
  total += 4;
  total += encoding.sizeVarint(this.inputs.length);
  total += this.inputs.length * 40;

  total += encoding.sizeVarint(this.outputs.length);

  for (const output of this.outputs)
    total += output.getSize();

  total += 4;

  // Add size for signatures and public keys
  for (const {prevout} of this.inputs) {
    const coin = this.view.getOutput(prevout);

    // We're out of luck here.
    // Just assume it's a p2pkh.
    if (!coin) {
      total += 110;
      continue;
    }

    // Previous output script.
    const prev = coin.script;

    // P2PK
    if (prev.isPubkey()) {
      // varint script size
      total += 1;
      // OP_PUSHDATA0 [signature]
      total += 1 + 73;
      continue;
    }

    // P2PKH
    if (prev.isPubkeyhash()) {
      // varint script size
      total += 1;
      // OP_PUSHDATA0 [signature]
      total += 1 + 73;
      // OP_PUSHDATA0 [key]
      total += 1 + 33;
      continue;
    }

    const [m] = prev.getMultisig();
    if (m !== -1) {
      let size = 0;
      // Bare Multisig
      // OP_0
      size += 1;
      // OP_PUSHDATA0 [signature] ...
      size += (1 + 73) * m;
      // varint len
      size += encoding.sizeVarint(size);
      total += size;
      continue;
    }

    // P2WPKH
    if (prev.isWitnessPubkeyhash()) {
      let size = 0;
      // varint-items-len
      size += 1;
      // varint-len [signature]
      size += 1 + 73;
      // varint-len [key]
      size += 1 + 33;
      // vsize
      size = (size + scale - 1) / scale | 0;
      total += size;
      continue;
    }

    // Call out to the custom estimator.
    if (estimate) {
      const size = await estimate(prev);
      if (size !== -1) {
        total += size;
        continue;
      }
    }

    // P2SH
    if (prev.isScripthash()) {
      // varint size
      total += 1;
      // 2-of-3 multisig input
      total += 149;
      continue;
    }

    // P2WSH
    if (prev.isWitnessScripthash()) {
      let size = 0;
      // varint-items-len
      size += 1;
      // 2-of-3 multisig input
      size += 149;
      // vsize
      size = (size + scale - 1) / scale | 0;
      total += size;
      continue;
    }

    // Unknown.
    total += 110;
  }

  return total;
};

/**
 * Select necessary coins based on total output value.
 * @param {Coin[]} coins
 * @param {Object?} options
 * @returns {CoinSelection}
 * @throws on not enough funds available.
 */

MTX.prototype.selectCoins = function selectCoins(coins, options) {
  const selector = new CoinSelector(this, options);
  return selector.select(coins);
};

/**
 * Attempt to subtract a fee from a single output.
 * @param {Number} index
 * @param {Amount} fee
 */

MTX.prototype.subtractIndex = function subtractIndex(index, fee) {
  assert(typeof index === 'number');
  assert(typeof fee === 'number');

  const output = this.outputs[index];

  if (!output)
    throw new Error('Subtraction index does not exist.');

  if (output.value < fee + output.getDustThreshold())
    throw new Error('Could not subtract fee.');

  output.value -= fee;
};

/**
 * Attempt to subtract a fee from all outputs evenly.
 * @param {Amount} fee
 */

MTX.prototype.subtractFee = function subtractFee(fee) {
  assert(typeof fee === 'number');

  let outputs = 0;

  for (const output of this.outputs) {
    // Ignore nulldatas and
    // other OP_RETURN scripts.
    if (output.script.isUnspendable())
      continue;
    outputs += 1;
  }

  if (outputs === 0)
    throw new Error('Could not subtract fee.');

  const left = fee % outputs;
  const share = (fee - left) / outputs;

  // First pass, remove even shares.
  for (const output of this.outputs) {
    if (output.script.isUnspendable())
      continue;

    if (output.value < share + output.getDustThreshold())
      throw new Error('Could not subtract fee.');

    output.value -= share;
  }

  // Second pass, remove the remainder
  // for the one unlucky output.
  for (const output of this.outputs) {
    if (output.script.isUnspendable())
      continue;

    if (output.value >= left + output.getDustThreshold()) {
      output.value -= left;
      return;
    }
  }

  throw new Error('Could not subtract fee.');
};

/**
 * Select coins and fill the inputs.
 * @param {Coin[]} coins
 * @param {Object} options - See {@link MTX#selectCoins} options.
 * @returns {CoinSelector}
 */

MTX.prototype.fund = async function fund(coins, options) {
  assert(options, 'Options are required.');
  assert(options.changeAddress, 'Change address is required.');
  assert(this.inputs.length === 0, 'TX is already funded.');

  // Select necessary coins.
  const select = await this.selectCoins(coins, options);

  // Add coins to transaction.
  for (const coin of select.chosen)
    this.addCoin(coin);

  // Attempt to subtract fee.
  if (select.subtractFee) {
    const index = select.subtractIndex;
    if (index !== -1)
      this.subtractIndex(index, select.fee);
    else
      this.subtractFee(select.fee);
  }

  // Add a change output.
  const output = new Output();
  output.value = select.change;
  output.script.fromAddress(select.changeAddress);

  if (output.isDust(policy.MIN_RELAY)) {
    // Do nothing. Change is added to fee.
    this.changeIndex = -1;
    assert.strictEqual(this.getFee(), select.fee + select.change);
  } else {
    this.outputs.push(output);
    this.changeIndex = this.outputs.length - 1;
    assert.strictEqual(this.getFee(), select.fee);
  }

  return select;
};

/**
 * Sort inputs and outputs according to BIP69.
 * @see https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki
 */

MTX.prototype.sortMembers = function sortMembers() {
  let changeOutput = null;

  if (this.changeIndex !== -1) {
    changeOutput = this.outputs[this.changeIndex];
    assert(changeOutput);
  }

  this.inputs.sort(sortInputs);
  this.outputs.sort(sortOutputs);

  if (this.changeIndex !== -1) {
    this.changeIndex = this.outputs.indexOf(changeOutput);
    assert(this.changeIndex !== -1);
  }
};

/**
 * Avoid fee sniping.
 * @param {Number} - Current chain height.
 * @see bitcoin/src/wallet/wallet.cpp
 */

MTX.prototype.avoidFeeSniping = function avoidFeeSniping(height) {
  assert(typeof height === 'number', 'Must pass in height.');

  if (util.random(0, 10) === 0) {
    height -= util.random(0, 100);

    if (height < 0)
      height = 0;
  }

  this.setLocktime(height);
};

/**
 * Set locktime and sequences appropriately.
 * @param {Number} locktime
 */

MTX.prototype.setLocktime = function setLocktime(locktime) {
  assert(util.isU32(locktime), 'Locktime must be a uint32.');
  assert(this.inputs.length > 0, 'Cannot set sequence with no inputs.');

  for (const input of this.inputs) {
    if (input.sequence === 0xffffffff)
      input.sequence = 0xfffffffe;
  }

  this.locktime = locktime;
};

/**
 * Set sequence locktime.
 * @param {Number} index - Input index.
 * @param {Number} locktime
 * @param {Boolean?} seconds
 */

MTX.prototype.setSequence = function setSequence(index, locktime, seconds) {
  const input = this.inputs[index];

  assert(input, 'Input does not exist.');
  assert(util.isU32(locktime), 'Locktime must be a uint32.');

  this.version = 2;

  if (seconds) {
    locktime >>>= consensus.SEQUENCE_GRANULARITY;
    locktime &= consensus.SEQUENCE_MASK;
    locktime |= consensus.SEQUENCE_TYPE_FLAG;
  } else {
    locktime &= consensus.SEQUENCE_MASK;
  }

  input.sequence = locktime;
};

/**
 * Inspect the transaction.
 * @returns {Object}
 */

MTX.prototype.inspect = function inspect() {
  return this.format();
};

/**
 * Inspect the transaction.
 * @returns {Object}
 */

MTX.prototype.format = function format() {
  return TX.prototype.format.call(this, this.view);
};

/**
 * Convert transaction to JSON.
 * @returns {Object}
 */

MTX.prototype.toJSON = function toJSON() {
  return TX.prototype.getJSON.call(this, null, this.view);
};

/**
 * Convert transaction to JSON.
 * @param {Network} network
 * @returns {Object}
 */

MTX.prototype.getJSON = function getJSON(network) {
  return TX.prototype.getJSON.call(this, network, this.view);
};

/**
 * Instantiate a transaction from a
 * jsonified transaction object.
 * @param {Object} json - The jsonified transaction object.
 * @returns {MTX}
 */

MTX.fromJSON = function fromJSON(json) {
  return new MTX().fromJSON(json);
};

/**
 * Instantiate a transaction from a buffer reader.
 * @param {BufferReader} br
 * @returns {MTX}
 */

MTX.fromReader = function fromReader(br) {
  return new MTX().fromReader(br);
};

/**
 * Instantiate a transaction from a serialized Buffer.
 * @param {Buffer} data
 * @param {String?} enc - Encoding, can be `'hex'` or null.
 * @returns {MTX}
 */

MTX.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new MTX().fromRaw(data);
};

/**
 * Convert the MTX to a TX.
 * @returns {TX}
 */

MTX.prototype.toTX = function toTX() {
  return new TX().inject(this);
};

/**
 * Convert the MTX to a TX.
 * @returns {Array} [tx, view]
 */

MTX.prototype.commit = function commit() {
  return [this.toTX(), this.view];
};

/**
 * Instantiate MTX from TX.
 * @param {TX} tx
 * @returns {MTX}
 */

MTX.fromTX = function fromTX(tx) {
  return new MTX().inject(tx);
};

/**
 * Test whether an object is an MTX.
 * @param {Object} obj
 * @returns {Boolean}
 */

MTX.isMTX = function isMTX(obj) {
  return obj instanceof MTX;
};

/**
 * Coin Selector
 * @alias module:primitives.CoinSelector
 * @constructor
 * @param {TX} tx
 * @param {Object?} options
 */

function CoinSelector(tx, options) {
  if (!(this instanceof CoinSelector))
    return new CoinSelector(tx, options);

  this.tx = tx.clone();
  this.coins = [];
  this.outputValue = 0;
  this.index = 0;
  this.chosen = [];
  this.change = 0;
  this.fee = CoinSelector.MIN_FEE;

  this.selection = 'value';
  this.subtractFee = false;
  this.subtractIndex = -1;
  this.height = -1;
  this.depth = -1;
  this.hardFee = -1;
  this.rate = CoinSelector.FEE_RATE;
  this.maxFee = -1;
  this.round = false;
  this.changeAddress = null;

  // Needed for size estimation.
  this.estimate = null;

  if (options)
    this.fromOptions(options);
}

/**
 * Default fee rate
 * for coin selection.
 * @const {Amount}
 * @default
 */

CoinSelector.FEE_RATE = 10000;

/**
 * Minimum fee to start with
 * during coin selection.
 * @const {Amount}
 * @default
 */

CoinSelector.MIN_FEE = 10000;

/**
 * Maximum fee to allow
 * after coin selection.
 * @const {Amount}
 * @default
 */

CoinSelector.MAX_FEE = consensus.COIN / 10;

/**
 * Initialize selector options.
 * @param {Object} options
 * @private
 */

CoinSelector.prototype.fromOptions = function fromOptions(options) {
  if (options.selection) {
    assert(typeof options.selection === 'string');
    this.selection = options.selection;
  }

  if (options.subtractFee != null) {
    if (typeof options.subtractFee === 'number') {
      assert(util.isInt(options.subtractFee));
      assert(options.subtractFee >= -1);
      this.subtractIndex = options.subtractFee;
      this.subtractFee = this.subtractIndex !== -1;
    } else {
      assert(typeof options.subtractFee === 'boolean');
      this.subtractFee = options.subtractFee;
    }
  }

  if (options.subtractIndex != null) {
    assert(util.isInt(options.subtractIndex));
    assert(options.subtractIndex >= -1);
    this.subtractIndex = options.subtractIndex;
    this.subtractFee = this.subtractIndex !== -1;
  }

  if (options.height != null) {
    assert(util.isInt(options.height));
    assert(options.height >= -1);
    this.height = options.height;
  }

  if (options.confirmations != null) {
    assert(util.isInt(options.confirmations));
    assert(options.confirmations >= -1);
    this.depth = options.confirmations;
  }

  if (options.depth != null) {
    assert(util.isInt(options.depth));
    assert(options.depth >= -1);
    this.depth = options.depth;
  }

  if (options.hardFee != null) {
    assert(util.isInt(options.hardFee));
    assert(options.hardFee >= -1);
    this.hardFee = options.hardFee;
  }

  if (options.rate != null) {
    assert(util.isU64(options.rate));
    this.rate = options.rate;
  }

  if (options.maxFee != null) {
    assert(util.isInt(options.maxFee));
    assert(options.maxFee >= -1);
    this.maxFee = options.maxFee;
  }

  if (options.round != null) {
    assert(typeof options.round === 'boolean');
    this.round = options.round;
  }

  if (options.changeAddress) {
    const addr = options.changeAddress;
    if (typeof addr === 'string') {
      this.changeAddress = Address.fromString(addr);
    } else {
      assert(addr instanceof Address);
      this.changeAddress = addr;
    }
  }

  if (options.estimate) {
    assert(typeof options.estimate === 'function');
    this.estimate = options.estimate;
  }

  return this;
};

/**
 * Initialize the selector with coins to select from.
 * @param {Coin[]} coins
 */

CoinSelector.prototype.init = function init(coins) {
  this.coins = coins.slice();
  this.outputValue = this.tx.getOutputValue();
  this.index = 0;
  this.chosen = [];
  this.change = 0;
  this.fee = CoinSelector.MIN_FEE;
  this.tx.inputs.length = 0;

  switch (this.selection) {
    case 'all':
    case 'random':
      this.coins.sort(sortRandom);
      break;
    case 'age':
      this.coins.sort(sortAge);
      break;
    case 'value':
      this.coins.sort(sortValue);
      break;
    default:
      throw new FundingError(`Bad selection type: ${this.selection}.`);
  }
};

/**
 * Calculate total value required.
 * @returns {Amount}
 */

CoinSelector.prototype.total = function total() {
  if (this.subtractFee)
    return this.outputValue;
  return this.outputValue + this.fee;
};

/**
 * Test whether the selector has
 * completely funded the transaction.
 * @returns {Boolean}
 */

CoinSelector.prototype.isFull = function isFull() {
  return this.tx.getInputValue() >= this.total();
};

/**
 * Test whether a coin is spendable
 * with regards to the options.
 * @param {Coin} coin
 * @returns {Boolean}
 */

CoinSelector.prototype.isSpendable = function isSpendable(coin) {
  if (this.height === -1)
    return true;

  if (coin.coinbase) {
    if (coin.height === -1)
      return false;

    if (this.height + 1 < coin.height + consensus.COINBASE_MATURITY)
      return false;

    return true;
  }

  if (this.depth === -1)
    return true;

  const depth = coin.getDepth(this.height);

  if (depth < this.depth)
    return false;

  return true;
};

/**
 * Get the current fee based on a size.
 * @param {Number} size
 * @returns {Amount}
 */

CoinSelector.prototype.getFee = function getFee(size) {
  // This is mostly here for testing.
  // i.e. A fee rounded to the nearest
  // kb is easier to predict ahead of time.
  if (this.round) {
    const fee = policy.getRoundFee(size, this.rate);
    return Math.min(fee, CoinSelector.MAX_FEE);
  }

  const fee = policy.getMinFee(size, this.rate);
  return Math.min(fee, CoinSelector.MAX_FEE);
};

/**
 * Fund the transaction with more
 * coins if the `output value + fee`
 * total was updated.
 */

CoinSelector.prototype.fund = function fund() {
  while (this.index < this.coins.length) {
    const coin = this.coins[this.index++];

    if (!this.isSpendable(coin))
      continue;

    this.tx.addCoin(coin);
    this.chosen.push(coin);

    if (this.selection === 'all')
      continue;

    if (this.isFull())
      break;
  }
};

/**
 * Initiate selection from `coins`.
 * @param {Coin[]} coins
 * @returns {CoinSelector}
 */

CoinSelector.prototype.select = async function select(coins) {
  this.init(coins);

  if (this.hardFee !== -1) {
    this.selectHard();
  } else {
    // This is potentially asynchronous:
    // it may invoke the size estimator
    // required for redeem scripts (we
    // may be calling out to a wallet
    // or something similar).
    await this.selectEstimate();
  }

  if (!this.isFull()) {
    // Still failing to get enough funds.
    throw new FundingError(
      'Not enough funds.',
      this.tx.getInputValue(),
      this.total());
  }

  // How much money is left after filling outputs.
  this.change = this.tx.getInputValue() - this.total();

  return this;
};

/**
 * Initialize selection based on size estimate.
 */

CoinSelector.prototype.selectEstimate = async function selectEstimate() {
  // Set minimum fee and do
  // an initial round of funding.
  this.fee = CoinSelector.MIN_FEE;
  this.fund();

  // Add dummy output for change.
  const change = new Output();

  if (this.changeAddress) {
    change.script.fromAddress(this.changeAddress);
  } else {
    // In case we don't have a change address,
    // we use a fake p2pkh output to gauge size.
    change.script.fromPubkeyhash(encoding.ZERO_HASH160);
  }

  this.tx.outputs.push(change);

  // Keep recalculating the fee and funding
  // until we reach some sort of equilibrium.
  do {
    const size = await this.tx.estimateSize(this.estimate);

    this.fee = this.getFee(size);

    if (this.maxFee > 0 && this.fee > this.maxFee)
      throw new FundingError('Fee is too high.');

    // Failed to get enough funds, add more coins.
    if (!this.isFull())
      this.fund();
  } while (!this.isFull() && this.index < this.coins.length);
};

/**
 * Initiate selection based on a hard fee.
 */

CoinSelector.prototype.selectHard = function selectHard() {
  this.fee = Math.min(this.hardFee, CoinSelector.MAX_FEE);
  this.fund();
};

/**
 * An error thrown from the coin selector.
 * @constructor
 * @ignore
 * @extends Error
 * @param {String} msg
 * @param {Amount} available
 * @param {Amount} required
 * @property {String} message - Error message.
 * @property {Amount} availableFunds
 * @property {Amount} requiredFunds
 */

function FundingError(msg, available, required) {
  Error.call(this);

  this.type = 'FundingError';
  this.message = msg;
  this.availableFunds = -1;
  this.requiredFunds = -1;

  if (available != null) {
    this.message += ` (available=${Amount.wmcc(available)},`;
    this.message += ` required=${Amount.wmcc(required)})`;
    this.availableFunds = available;
    this.requiredFunds = required;
  }

  if (Error.captureStackTrace)
    Error.captureStackTrace(this, FundingError);
}

Object.setPrototypeOf(FundingError.prototype, Error.prototype);

/*
 * Helpers
 */

function sortAge(a, b) {
  a = a.height === -1 ? 0x7fffffff : a.height;
  b = b.height === -1 ? 0x7fffffff : b.height;
  return a - b;
}

function sortRandom(a, b) {
  return Math.random() > 0.5 ? 1 : -1;
}

function sortValue(a, b) {
  if (a.height === -1 && b.height !== -1)
    return 1;

  if (a.height !== -1 && b.height === -1)
    return -1;

  return b.value - a.value;
}

function sortInputs(a, b) {
  return a.compare(b);
}

function sortOutputs(a, b) {
  return a.compare(b);
}

/*
 * Expose
 */

exports = MTX;
exports.MTX = MTX;
exports.Selector = CoinSelector;
exports.FundingError = FundingError;

module.exports = exports;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * int64.js - int64s for wmcc_core.
 */



module.exports = __webpack_require__(131);


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * coinentry.js - coin entry object for wmcc_core.
 */



const assert = __webpack_require__(0);
const Coin = __webpack_require__(44);
const Output = __webpack_require__(13);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const encoding = __webpack_require__(3);
const compress = __webpack_require__(102);

/*
 * Constants
 */

const NUM_FLAGS = 1;
const MAX_HEIGHT = ((1 << (32 - NUM_FLAGS)) >>> 0) - 1;

/**
 * Represents an unspent output.
 * @alias module:coins.CoinEntry
 * @constructor
 * @property {Number} version - Transaction version.
 * @property {Number} height - Transaction height (-1 if unconfirmed).
 * @property {Boolean} coinbase - Whether the containing
 * transaction is a coinbase.
 * @property {Output} output
 * @property {Boolean} spent
 * @property {Buffer} raw
 */

function CoinEntry() {
  if (!(this instanceof CoinEntry))
    return new CoinEntry();

  this.version = 1;
  this.height = -1;
  this.coinbase = false;
  this.output = new Output();
  this.spent = false;
  this.raw = null;
}

/**
 * Convert coin entry to an output.
 * @returns {Output}
 */

CoinEntry.prototype.toOutput = function toOutput() {
  return this.output;
};

/**
 * Convert coin entry to a coin.
 * @param {Outpoint} prevout
 * @returns {Coin}
 */

CoinEntry.prototype.toCoin = function toCoin(prevout) {
  const coin = new Coin();
  coin.version = this.version;
  coin.height = this.height;
  coin.coinbase = this.coinbase;
  coin.script = this.output.script;
  coin.value = this.output.value;
  coin.hash = prevout.hash;
  coin.index = prevout.index;
  return coin;
};

/**
 * Inject properties from TX.
 * @param {TX} tx
 * @param {Number} index
 */

CoinEntry.prototype.fromOutput = function fromOutput(output) {
  this.output = output;
  return this;
};

/**
 * Instantiate a coin from a TX
 * @param {TX} tx
 * @param {Number} index - Output index.
 * @returns {CoinEntry}
 */

CoinEntry.fromOutput = function fromOutput(output) {
  return new CoinEntry().fromOutput(output);
};

/**
 * Inject properties from TX.
 * @param {TX} tx
 * @param {Number} index
 */

CoinEntry.prototype.fromCoin = function fromCoin(coin) {
  this.version = coin.version;
  this.height = coin.height;
  this.coinbase = coin.coinbase;
  this.output.script = coin.script;
  this.output.value = coin.value;
  return this;
};

/**
 * Instantiate a coin from a TX
 * @param {TX} tx
 * @param {Number} index - Output index.
 * @returns {CoinEntry}
 */

CoinEntry.fromCoin = function fromCoin(coin) {
  return new CoinEntry().fromCoin(coin);
};

/**
 * Inject properties from TX.
 * @param {TX} tx
 * @param {Number} index
 */

CoinEntry.prototype.fromTX = function fromTX(tx, index, height) {
  assert(typeof index === 'number');
  assert(typeof height === 'number');
  assert(index >= 0 && index < tx.outputs.length);
  this.version = tx.version;
  this.height = height;
  this.coinbase = tx.isCoinbase();
  this.output = tx.outputs[index];
  return this;
};

/**
 * Instantiate a coin from a TX
 * @param {TX} tx
 * @param {Number} index - Output index.
 * @returns {CoinEntry}
 */

CoinEntry.fromTX = function fromTX(tx, index, height) {
  return new CoinEntry().fromTX(tx, index, height);
};

/**
 * Calculate size of coin.
 * @returns {Number}
 */

CoinEntry.prototype.getSize = function getSize() {
  if (this.raw)
    return this.raw.length;

  let size = 0;
  size += encoding.sizeVarint(this.version);
  size += 4;
  size += compress.size(this.output);

  return size;
};

/**
 * Write the coin to a buffer writer.
 * @param {BufferWriter} bw
 */

CoinEntry.prototype.toWriter = function toWriter(bw) {
  if (this.raw) {
    bw.writeBytes(this.raw);
    return bw;
  }

  let height = this.height;
  let field = 0;

  if (this.coinbase)
    field |= 1;

  if (height === -1)
    height = MAX_HEIGHT;

  field |= height << NUM_FLAGS;

  bw.writeVarint(this.version);
  bw.writeU32(field);
  compress.pack(this.output, bw);

  return bw;
};

/**
 * Serialize the coin.
 * @returns {Buffer}
 */

CoinEntry.prototype.toRaw = function toRaw() {
  if (this.raw)
    return this.raw;

  const size = this.getSize();
  const bw = new StaticWriter(size);

  this.toWriter(bw);

  this.raw = bw.render();

  return this.raw;
};

/**
 * Inject properties from serialized buffer writer.
 * @private
 * @param {BufferReader} br
 */

CoinEntry.prototype.fromReader = function fromReader(br) {
  const version = br.readVarint();
  const field = br.readU32();

  let height = field >>> NUM_FLAGS;

  if (height === MAX_HEIGHT)
    height = -1;

  this.version = version;
  this.coinbase = (field & 1) !== 0;
  this.height = height;

  compress.unpack(this.output, br);

  return this;
};

/**
 * Instantiate a coin from a serialized Buffer.
 * @param {Buffer} data
 * @returns {CoinEntry}
 */

CoinEntry.fromReader = function fromReader(data) {
  return new CoinEntry().fromReader(data);
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

CoinEntry.prototype.fromRaw = function fromRaw(data) {
  this.fromReader(new BufferReader(data));
  this.raw = data;
  return this;
};

/**
 * Instantiate a coin from a serialized Buffer.
 * @param {Buffer} data
 * @returns {CoinEntry}
 */

CoinEntry.fromRaw = function fromRaw(data) {
  return new CoinEntry().fromRaw(data);
};

/*
 * Expose
 */

module.exports = CoinEntry;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * block.js - block object for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const encoding = __webpack_require__(3);
const digest = __webpack_require__(5);
const merkle = __webpack_require__(63);
const consensus = __webpack_require__(7);
const AbstractBlock = __webpack_require__(67);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const TX = __webpack_require__(16);
const MerkleBlock = __webpack_require__(69);
const Headers = __webpack_require__(37);
const Network = __webpack_require__(6);

/**
 * Represents a full block.
 * @alias module:primitives.Block
 * @constructor
 * @extends AbstractBlock
 * @param {NakedBlock} options
 */

function Block(options) {
  if (!(this instanceof Block))
    return new Block(options);

  AbstractBlock.call(this);

  this.txs = [];

  this._raw = null;
  this._size = -1;
  this._witness = -1;

  if (options)
    this.fromOptions(options);
}

Object.setPrototypeOf(Block.prototype, AbstractBlock.prototype);

/**
 * Inject properties from options object.
 * @private
 * @param {Object} options
 */

Block.prototype.fromOptions = function fromOptions(options) {
  this.parseOptions(options);

  if (options.txs) {
    assert(Array.isArray(options.txs));
    for (const tx of options.txs) {
      assert(tx instanceof TX);
      this.txs.push(tx);
    }
  }
};

/**
 * Instantiate block from options.
 * @param {Object} options
 * @returns {Block}
 */

Block.fromOptions = function fromOptions(options) {
  return new Block().fromOptions(options);
};

/**
 * Clear any cached values.
 * @param {Boolean?} all - Clear transactions.
 */

Block.prototype.refresh = function refresh(all) {
  this._refresh();

  this._raw = null;
  this._size = -1;
  this._witness = -1;

  if (!all)
    return;

  for (const tx of this.txs)
    tx.refresh();
};

/**
 * Serialize the block. Include witnesses if present.
 * @returns {Buffer}
 */

Block.prototype.toRaw = function toRaw() {
  return this.frame().data;
};

/**
 * Serialize the block, do not include witnesses.
 * @returns {Buffer}
 */

Block.prototype.toNormal = function toNormal() {
  if (this.hasWitness())
    return this.frameNormal().data;
  return this.toRaw();
};

/**
 * Serialize the block. Include witnesses if present.
 * @param {BufferWriter} bw
 */

Block.prototype.toWriter = function toWriter(bw) {
  if (this.mutable)
    return this.writeWitness(bw);

  const raw = this.frame();
  bw.writeBytes(raw.data);

  return bw;
};

/**
 * Serialize the block, do not include witnesses.
 * @param {BufferWriter} bw
 */

Block.prototype.toNormalWriter = function toNormalWriter(bw) {
  if (this.hasWitness()) {
    this.writeNormal(bw);
    return bw;
  }
  return this.toWriter(bw);
};

/**
 * Get the raw block serialization.
 * Include witnesses if present.
 * @private
 * @returns {RawBlock}
 */

Block.prototype.frame = function frame() {
  if (this.mutable) {
    assert(!this._raw);
    return this.frameWitness();
  }

  if (this._raw) {
    assert(this._size >= 0);
    assert(this._witness >= 0);
    const raw = new RawBlock(this._size, this._witness);
    raw.data = this._raw;
    return raw;
  }

  const raw = this.frameWitness();

  this._raw = raw.data;
  this._size = raw.size;
  this._witness = raw.witness;

  return raw;
};

/**
 * Calculate real size and size of the witness bytes.
 * @returns {Object} Contains `size` and `witness`.
 */

Block.prototype.getSizes = function getSizes() {
  if (this.mutable)
    return this.getWitnessSizes();
  return this.frame();
};

/**
 * Calculate virtual block size.
 * @returns {Number} Virtual size.
 */

Block.prototype.getVirtualSize = function getVirtualSize() {
  const scale = consensus.WITNESS_SCALE_FACTOR;
  return (this.getWeight() + scale - 1) / scale | 0;
};

/**
 * Calculate block weight.
 * @returns {Number} weight
 */

Block.prototype.getWeight = function getWeight() {
  const raw = this.getSizes();
  const base = raw.size - raw.witness;
  return base * (consensus.WITNESS_SCALE_FACTOR - 1) + raw.size;
};

/**
 * Get real block size.
 * @returns {Number} size
 */

Block.prototype.getSize = function getSize() {
  return this.getSizes().size;
};

/**
 * Get base block size (without witness).
 * @returns {Number} size
 */

Block.prototype.getBaseSize = function getBaseSize() {
  const raw = this.getSizes();
  return raw.size - raw.witness;
};

/**
 * Test whether the block contains a
 * transaction with a non-empty witness.
 * @returns {Boolean}
 */

Block.prototype.hasWitness = function hasWitness() {
  if (this._witness !== -1)
    return this._witness !== 0;

  for (const tx of this.txs) {
    if (tx.hasWitness())
      return true;
  }

  return false;
};

/**
 * Test the block's transaction vector against a hash.
 * @param {Hash} hash
 * @returns {Boolean}
 */

Block.prototype.hasTX = function hasTX(hash) {
  return this.indexOf(hash) !== -1;
};

/**
 * Find the index of a transaction in the block.
 * @param {Hash} hash
 * @returns {Number} index (-1 if not present).
 */

Block.prototype.indexOf = function indexOf(hash) {
  for (let i = 0; i < this.txs.length; i++) {
    const tx = this.txs[i];
    if (tx.hash('hex') === hash)
      return i;
  }

  return -1;
};

/**
 * Calculate merkle root. Returns null
 * if merkle tree has been malleated.
 * @param {String?} enc - Encoding, can be `'hex'` or null.
 * @returns {Hash|null}
 */

Block.prototype.createMerkleRoot = function createMerkleRoot(enc) {
  const leaves = [];

  for (const tx of this.txs)
    leaves.push(tx.hash());

  const [root, malleated] = merkle.createRoot(leaves);

  if (malleated)
    return null;

  return enc === 'hex' ? root.toString('hex') : root;
};

/**
 * Create a witness nonce (for mining).
 * @returns {Buffer}
 */

Block.prototype.createWitnessNonce = function createWitnessNonce() {
  return Buffer.from(encoding.ZERO_HASH);
};

/**
 * Calculate commitment hash (the root of the
 * witness merkle tree hashed with the witnessNonce).
 * @param {String?} enc - Encoding, can be `'hex'` or null.
 * @returns {Hash}
 */

Block.prototype.createCommitmentHash = function createCommitmentHash(enc) {
  const nonce = this.getWitnessNonce();
  const leaves = [];

  assert(nonce, 'No witness nonce present.');

  leaves.push(encoding.ZERO_HASH);

  for (let i = 1; i < this.txs.length; i++) {
    const tx = this.txs[i];
    leaves.push(tx.witnessHash());
  }

  const [root] = merkle.createRoot(leaves);

  // Note: malleation check ignored here.
  // assert(!malleated);

  const hash = digest.root256(root, nonce);

  return enc === 'hex'
    ? hash.toString('hex')
    : hash;
};

/**
 * Retrieve the merkle root from the block header.
 * @param {String?} enc
 * @returns {Hash}
 */

Block.prototype.getMerkleRoot = function getMerkleRoot(enc) {
  if (enc === 'hex')
    return this.merkleRoot;
  return Buffer.from(this.merkleRoot, 'hex');
};

/**
 * Retrieve the witness nonce from the
 * coinbase's witness vector (if present).
 * @returns {Buffer|null}
 */

Block.prototype.getWitnessNonce = function getWitnessNonce() {
  if (this.txs.length === 0)
    return null;

  const coinbase = this.txs[0];

  if (coinbase.inputs.length !== 1)
    return null;

  const input = coinbase.inputs[0];

  if (input.witness.items.length !== 1)
    return null;

  if (input.witness.items[0].length !== 32)
    return null;

  return input.witness.items[0];
};

/**
 * Retrieve the commitment hash
 * from the coinbase's outputs.
 * @param {String?} enc
 * @returns {Hash|null}
 */

Block.prototype.getCommitmentHash = function getCommitmentHash(enc) {
  if (this.txs.length === 0)
    return null;

  const coinbase = this.txs[0];
  let hash;

  for (let i = coinbase.outputs.length - 1; i >= 0; i--) {
    const output = coinbase.outputs[i];
    if (output.script.isCommitment()) {
      hash = output.script.getCommitment();
      break;
    }
  }

  if (!hash)
    return null;

  return enc === 'hex'
    ? hash.toString('hex')
    : hash;
};

/**
 * Do non-contextual verification on the block. Including checking the block
 * size, the coinbase and the merkle root. This is consensus-critical.
 * @returns {Boolean}
 */

Block.prototype.verifyBody = function verifyBody() {
  const [valid] = this.checkBody();
  return valid;
};

/**
 * Do non-contextual verification on the block. Including checking the block
 * size, the coinbase and the merkle root. This is consensus-critical.
 * @returns {Array} [valid, reason, score]
 */

Block.prototype.checkBody = function checkBody() {
  // Check merkle root.
  const root = this.createMerkleRoot('hex');

  // If the merkle is mutated,
  // we have duplicate txs.
  if (!root)
    return [false, 'bad-txns-duplicate', 100];

  if (this.merkleRoot !== root)
    return [false, 'bad-txnmrklroot', 100];

  // Check base size.
  if (this.txs.length === 0
      || this.txs.length > consensus.MAX_BLOCK_SIZE
      || this.getBaseSize() > consensus.MAX_BLOCK_SIZE) {
    return [false, 'bad-blk-length', 100];
  }

  // First TX must be a coinbase.
  if (this.txs.length === 0 || !this.txs[0].isCoinbase())
    return [false, 'bad-cb-missing', 100];

  // Test all transactions.
  const scale = consensus.WITNESS_SCALE_FACTOR;
  let sigops = 0;

  for (let i = 0; i < this.txs.length; i++) {
    const tx = this.txs[i];

    // The rest of the txs must not be coinbases.
    if (i > 0 && tx.isCoinbase())
      return [false, 'bad-cb-multiple', 100];

    // Sanity checks.
    const [valid, reason, score] = tx.checkSanity(this.getCoinbaseHeight());

    if (!valid)
      return [valid, reason, score];

    // Count legacy sigops (do not count scripthash or witness).
    sigops += tx.getLegacySigops();
    if (sigops * scale > consensus.MAX_BLOCK_SIGOPS_COST)
      return [false, 'bad-blk-sigops', 100];
  }

  return [true, 'valid', 0];
};

/**
 * Retrieve the coinbase height from the coinbase input script.
 * @returns {Number} height (-1 if not present).
 */

Block.prototype.getCoinbaseHeight = function getCoinbaseHeight() {
  if (this.version < 2)
    return -1;

  if (this.txs.length === 0)
    return -1;

  const coinbase = this.txs[0];

  if (coinbase.inputs.length === 0)
    return -1;

  return coinbase.inputs[0].script.getCoinbaseHeight();
};

/**
 * Get the "claimed" reward by the coinbase.
 * @returns {Amount} claimed
 */

Block.prototype.getClaimed = function getClaimed() {
  assert(this.txs.length > 0);
  assert(this.txs[0].isCoinbase());
  return this.txs[0].getOutputValue();
};

/**
 * Get all unique outpoint hashes in the
 * block. Coinbases are ignored.
 * @returns {Hash[]} Outpoint hashes.
 */

Block.prototype.getPrevout = function getPrevout() {
  const prevout = Object.create(null);

  for (let i = 1; i < this.txs.length; i++) {
    const tx = this.txs[i];

    for (const input of tx.inputs)
      prevout[input.prevout.hash] = true;
  }

  return Object.keys(prevout);
};

/**
 * Get the output of Coinreserve.
 * @returns {Output} coinreserve
 */

Block.prototype.getCoinreserve = function getCoinreserve() {
  assert(this.txs.length > 0);
  assert(this.txs[0].isCoinbase());
  return this.txs[0].outputs[1];
};

/**
 * Inspect the block and return a more
 * user-friendly representation of the data.
 * @returns {Object}
 */

Block.prototype.inspect = function inspect() {
  return this.format();
};

/**
 * Inspect the block and return a more
 * user-friendly representation of the data.
 * @param {CoinView} view
 * @param {Number} height
 * @returns {Object}
 */

Block.prototype.format = function format(view, height) {
  const commitmentHash = this.getCommitmentHash('hex');
  return {
    hash: this.rhash(),
    height: height != null ? height : -1,
    size: this.getSize(),
    virtualSize: this.getVirtualSize(),
    date: util.date(this.time),
    version: util.hex32(this.version),
    prevBlock: util.revHex(this.prevBlock),
    merkleRoot: util.revHex(this.merkleRoot),
    commitmentHash: commitmentHash
      ? util.revHex(commitmentHash)
      : null,
    time: this.time,
    bits: this.bits,
    nonce: this.nonce,
    txs: this.txs.map((tx, i) => {
      return tx.format(view, null, i);
    })
  };
};

/**
 * Convert the block to an object suitable
 * for JSON serialization.
 * @returns {Object}
 */

Block.prototype.toJSON = function toJSON() {
  return this.getJSON();
};

/**
 * Convert the block to an object suitable
 * for JSON serialization. Note that the hashes
 * will be reversed to abide by wmccd's legacy
 * of little-endian uint256s.
 * @param {Network} network
 * @param {CoinView} view
 * @param {Number} height
 * @returns {Object}
 */

Block.prototype.getJSON = function getJSON(network, view, height) {
  network = Network.get(network);
  return {
    hash: this.rhash(),
    height: height,
    version: this.version,
    prevBlock: util.revHex(this.prevBlock),
    merkleRoot: util.revHex(this.merkleRoot),
    time: this.time,
    bits: this.bits,
    nonce: this.nonce,
    txs: this.txs.map((tx, i) => {
      return tx.getJSON(network, view, null, i);
    })
  };
};

/**
 * Inject properties from json object.
 * @private
 * @param {Object} json
 */

Block.prototype.fromJSON = function fromJSON(json) {
  assert(json, 'Block data is required.');
  assert(Array.isArray(json.txs));

  this.parseJSON(json);

  for (const tx of json.txs)
    this.txs.push(TX.fromJSON(tx));

  return this;
};

/**
 * Instantiate a block from a jsonified block object.
 * @param {Object} json - The jsonified block object.
 * @returns {Block}
 */

Block.fromJSON = function fromJSON(json) {
  return new Block().fromJSON(json);
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

Block.prototype.fromReader = function fromReader(br) {
  br.start();

  this.readHead(br);

  const count = br.readVarint();
  let witness = 0;

  for (let i = 0; i < count; i++) {
    const tx = TX.fromReader(br);
    witness += tx._witness;
    this.txs.push(tx);
  }

  if (!this.mutable) {
    this._raw = br.endData();
    this._size = this._raw.length;
    this._witness = witness;
  }

  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

Block.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate a block from a serialized Buffer.
 * @param {Buffer} data
 * @param {String?} enc - Encoding, can be `'hex'` or null.
 * @returns {Block}
 */

Block.fromReader = function fromReader(data) {
  return new Block().fromReader(data);
};

/**
 * Instantiate a block from a serialized Buffer.
 * @param {Buffer} data
 * @param {String?} enc - Encoding, can be `'hex'` or null.
 * @returns {Block}
 */

Block.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new Block().fromRaw(data);
};

/**
 * Convert the Block to a MerkleBlock.
 * @param {Bloom} filter - Bloom filter for transactions
 * to match. The merkle block will contain only the
 * matched transactions.
 * @returns {MerkleBlock}
 */

Block.prototype.toMerkle = function toMerkle(filter) {
  return MerkleBlock.fromBlock(this, filter);
};

/**
 * Serialze block with or without witness data.
 * @private
 * @param {Boolean} witness
 * @param {BufferWriter?} writer
 * @returns {Buffer}
 */

Block.prototype.writeNormal = function writeNormal(bw) {
  this.writeHead(bw);

  bw.writeVarint(this.txs.length);

  for (const tx of this.txs)
    tx.toNormalWriter(bw);

  return bw;
};

/**
 * Serialze block with or without witness data.
 * @private
 * @param {Boolean} witness
 * @param {BufferWriter?} writer
 * @returns {Buffer}
 */

Block.prototype.writeWitness = function writeWitness(bw) {
  this.writeHead(bw);

  bw.writeVarint(this.txs.length);

  for (const tx of this.txs)
    tx.toWriter(bw);

  return bw;
};

/**
 * Serialze block with or without witness data.
 * @private
 * @param {Boolean} witness
 * @param {BufferWriter?} writer
 * @returns {Buffer}
 */

Block.prototype.frameNormal = function frameNormal() {
  const raw = this.getNormalSizes();
  const bw = new StaticWriter(raw.size);
  this.writeNormal(bw);
  raw.data = bw.render();
  return raw;
};

/**
 * Serialze block without witness data.
 * @private
 * @param {BufferWriter?} writer
 * @returns {Buffer}
 */

Block.prototype.frameWitness = function frameWitness() {
  const raw = this.getWitnessSizes();
  const bw = new StaticWriter(raw.size);
  this.writeWitness(bw);
  raw.data = bw.render();
  return raw;
};

/**
 * Convert the block to a headers object.
 * @returns {Headers}
 */

Block.prototype.toHeaders = function toHeaders() {
  return Headers.fromBlock(this);
};

/**
 * Get real block size without witness.
 * @returns {RawBlock}
 */

Block.prototype.getNormalSizes = function getNormalSizes() {
  let size = 0;

  size += 80;
  size += encoding.sizeVarint(this.txs.length);

  for (const tx of this.txs)
    size += tx.getBaseSize();

  return new RawBlock(size, 0);
};

/**
 * Get real block size with witness.
 * @returns {RawBlock}
 */

Block.prototype.getWitnessSizes = function getWitnessSizes() {
  let size = 0;
  let witness = 0;

  size += 80;
  size += encoding.sizeVarint(this.txs.length);

  for (const tx of this.txs) {
    const raw = tx.getSizes();
    size += raw.size;
    witness += raw.witness;
  }

  return new RawBlock(size, witness);
};

/**
 * Test whether an object is a Block.
 * @param {Object} obj
 * @returns {Boolean}
 */

Block.isBlock = function isBlock(obj) {
  return obj instanceof Block;
};

/*
 * Helpers
 */

function RawBlock(size, witness) {
  this.data = null;
  this.size = size;
  this.witness = witness;
}

/*
 * Expose
 */

module.exports = Block;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * ccmp.js - constant-time compare for wmcc_core.
 */



const assert = __webpack_require__(0);

/**
 * memcmp in constant time (can only return true or false).
 * This protects us against timing attacks when
 * comparing an input against a secret string.
 * @alias module:crypto.ccmp
 * @see https://cryptocoding.net/index.php/Coding_rules
 * @see `$ man 3 memcmp` (NetBSD's consttime_memequal)
 * @param {Buffer} a
 * @param {Buffer} b
 * @returns {Boolean}
 */

module.exports = function ccmp(a, b) {
  assert(Buffer.isBuffer(a));
  assert(Buffer.isBuffer(b));

  if (b.length === 0)
    return a.length === 0;

  let res = a.length ^ b.length;

  for (let i = 0; i < a.length; i++)
    res |= a[i] ^ b[i % b.length];

  return res === 0;
};


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * packets.js - worker packets for wmcc_core.
 */



/**
 * @module workers/packets
 */

const assert = __webpack_require__(0);
const BufferReader = __webpack_require__(2);
const encoding = __webpack_require__(3);
const Script = __webpack_require__(8);
const Witness = __webpack_require__(55);
const Output = __webpack_require__(13);
const MTX = __webpack_require__(48);
const TX = __webpack_require__(16);
const KeyRing = __webpack_require__(47);
const CoinView = __webpack_require__(30);
const ScriptError = __webpack_require__(35);

/*
 * Constants
 */

const packetTypes = {
  ENV: 0,
  EVENT: 1,
  LOG: 2,
  ERROR: 3,
  ERRORRESULT: 4,
  CHECK: 5,
  CHECKRESULT: 6,
  SIGN: 7,
  SIGNRESULT: 8,
  CHECKINPUT: 9,
  CHECKINPUTRESULT: 10,
  SIGNINPUT: 11,
  SIGNINPUTRESULT: 12,
  ECVERIFY: 13,
  ECVERIFYRESULT: 14,
  ECSIGN: 15,
  ECSIGNRESULT: 16,
  MINE: 17,
  MINERESULT: 18,
  SCRYPT: 19,
  SCRYPTRESULT: 20
};

/**
 * Packet
 * @constructor
 */

function Packet() {
  this.id = ++Packet.id >>> 0;
}

Packet.id = 0;

Packet.prototype.cmd = -1;

Packet.prototype.getSize = function getSize() {
  throw new Error('Abstract method.');
};

Packet.prototype.toWriter = function toWriter() {
  throw new Error('Abstract method.');
};

Packet.prototype.fromRaw = function fromRaw() {
  throw new Error('Abstract method.');
};

Packet.fromRaw = function fromRaw() {
  throw new Error('Abstract method.');
};

/**
 * EnvPacket
 * @constructor
 */

function EnvPacket(env) {
  Packet.call(this);
  this.env = env || {};
  this.json = JSON.stringify(this.env);
}

Object.setPrototypeOf(EnvPacket.prototype, Packet.prototype);

EnvPacket.prototype.cmd = packetTypes.ENV;

EnvPacket.prototype.getSize = function getSize() {
  return encoding.sizeVarString(this.json, 'utf8');
};

EnvPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeVarString(this.json, 'utf8');
  return bw;
};

EnvPacket.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);
  this.json = br.readVarString('utf8');
  this.env = JSON.parse(this.json);
  return this;
};

EnvPacket.fromRaw = function fromRaw(data) {
  return new EnvPacket().fromRaw(data);
};

/**
 * EventPacket
 * @constructor
 */

function EventPacket(items) {
  Packet.call(this);
  this.items = items || [];
  this.json = JSON.stringify(this.items);
}

Object.setPrototypeOf(EventPacket.prototype, Packet.prototype);

EventPacket.prototype.cmd = packetTypes.EVENT;

EventPacket.prototype.getSize = function getSize() {
  return encoding.sizeVarString(this.json, 'utf8');
};

EventPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeVarString(this.json, 'utf8');
  return bw;
};

EventPacket.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);
  this.json = br.readVarString('utf8');
  this.items = JSON.parse(this.json);
  return this;
};

EventPacket.fromRaw = function fromRaw(data) {
  return new EventPacket().fromRaw(data);
};

/**
 * LogPacket
 * @constructor
 */

function LogPacket(text) {
  Packet.call(this);
  this.text = text || '';
}

Object.setPrototypeOf(LogPacket.prototype, Packet.prototype);

LogPacket.prototype.cmd = packetTypes.LOG;

LogPacket.prototype.getSize = function getSize() {
  return encoding.sizeVarString(this.text, 'utf8');
};

LogPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeVarString(this.text, 'utf8');
  return bw;
};

LogPacket.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);
  this.text = br.readVarString('utf8');
  return this;
};

LogPacket.fromRaw = function fromRaw(data) {
  return new LogPacket().fromRaw(data);
};

/**
 * ErrorPacket
 * @constructor
 */

function ErrorPacket(error) {
  Packet.call(this);
  this.error = error || new Error();
}

Object.setPrototypeOf(ErrorPacket.prototype, Packet.prototype);

ErrorPacket.prototype.cmd = packetTypes.ERROR;

ErrorPacket.prototype.getSize = function getSize() {
  const err = this.error;

  let size = 0;

  size += encoding.sizeVarString(stringify(err.message), 'utf8');
  size += encoding.sizeVarString(stringify(err.stack), 'utf8');
  size += encoding.sizeVarString(stringify(err.type), 'utf8');

  switch (typeof err.code) {
    case 'number':
      size += 1;
      size += 4;
      break;
    case 'string':
      size += 1;
      size += encoding.sizeVarString(err.code, 'utf8');
      break;
    default:
      size += 1;
      break;
  }

  return size;
};

ErrorPacket.prototype.toWriter = function toWriter(bw) {
  const err = this.error;

  bw.writeVarString(stringify(err.message), 'utf8');
  bw.writeVarString(stringify(err.stack), 'utf8');
  bw.writeVarString(stringify(err.type), 'utf8');

  switch (typeof err.code) {
    case 'number':
      bw.writeU8(2);
      bw.writeI32(err.code);
      break;
    case 'string':
      bw.writeU8(1);
      bw.writeVarString(err.code, 'utf8');
      break;
    default:
      bw.writeU8(0);
      break;
  }

  return bw;
};

ErrorPacket.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);
  const err = this.error;

  err.message = br.readVarString('utf8');
  err.stack = br.readVarString('utf8');
  err.type = br.readVarString('utf8');

  switch (br.readU8()) {
    case 2:
      err.code = br.readI32();
      break;
    case 1:
      err.code = br.readVarString('utf8');
      break;
    default:
      err.code = null;
      break;
  }

  return this;
};

ErrorPacket.fromRaw = function fromRaw(data) {
  return new ErrorPacket().fromRaw(data);
};

/**
 * ErrorResultPacket
 * @constructor
 */

function ErrorResultPacket(error) {
  ErrorPacket.call(this, error);
}

Object.setPrototypeOf(ErrorResultPacket.prototype, ErrorPacket.prototype);

ErrorResultPacket.prototype.cmd = packetTypes.ERRORRESULT;

ErrorResultPacket.fromRaw = function fromRaw(data) {
  return new ErrorResultPacket().fromRaw(data);
};

/**
 * CheckPacket
 * @constructor
 */

function CheckPacket(tx, view, flags) {
  Packet.call(this);
  this.tx = tx || null;
  this.view = view || null;
  this.flags = flags != null ? flags : null;
}

Object.setPrototypeOf(CheckPacket.prototype, Packet.prototype);

CheckPacket.prototype.cmd = packetTypes.CHECK;

CheckPacket.prototype.getSize = function getSize() {
  return this.tx.getSize() + this.view.getSize(this.tx) + 4;
};

CheckPacket.prototype.toWriter = function toWriter(bw) {
  this.tx.toWriter(bw);
  this.view.toWriter(bw, this.tx);
  bw.writeI32(this.flags != null ? this.flags : -1);
  return bw;
};

CheckPacket.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);

  this.tx = TX.fromReader(br);
  this.view = CoinView.fromReader(br, this.tx);
  this.flags = br.readI32();

  if (this.flags === -1)
    this.flags = null;

  return this;
};

CheckPacket.fromRaw = function fromRaw(data) {
  return new CheckPacket().fromRaw(data);
};

/**
 * CheckResultPacket
 * @constructor
 */

function CheckResultPacket(error) {
  Packet.call(this);
  this.error = error || null;
}

Object.setPrototypeOf(CheckResultPacket.prototype, Packet.prototype);

CheckResultPacket.prototype.cmd = packetTypes.CHECKRESULT;

CheckResultPacket.prototype.getSize = function getSize() {
  const err = this.error;

  let size = 0;

  if (!err) {
    size += 1;
    return size;
  }

  size += 1;
  size += encoding.sizeVarString(stringify(err.message), 'utf8');
  size += encoding.sizeVarString(stringify(err.stack), 'utf8');
  size += encoding.sizeVarString(stringify(err.code), 'utf8');
  size += 1;
  size += 4;

  return size;
};

CheckResultPacket.prototype.toWriter = function toWriter(bw) {
  const err = this.error;

  if (!err) {
    bw.writeU8(0);
    return bw;
  }

  bw.writeU8(1);
  bw.writeVarString(stringify(err.message), 'utf8');
  bw.writeVarString(stringify(err.stack), 'utf8');
  bw.writeVarString(stringify(err.code), 'utf8');
  bw.writeU8(err.op === -1 ? 0xff : err.op);
  bw.writeU32(err.ip === -1 ? 0xffffffff : err.ip);

  return bw;
};

CheckResultPacket.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);

  if (br.readU8() === 0)
    return this;

  const err = new ScriptError('');

  err.message = br.readVarString('utf8');
  err.stack = br.readVarString('utf8');
  err.code = br.readVarString('utf8');
  err.op = br.readU8();
  err.ip = br.readU32();

  if (err.op === 0xff)
    err.op = -1;

  if (err.ip === 0xffffffff)
    err.ip = -1;

  this.error = err;

  return this;
};

CheckResultPacket.fromRaw = function fromRaw(data) {
  return new CheckResultPacket().fromRaw(data);
};

/**
 * SignPacket
 * @constructor
 */

function SignPacket(tx, rings, type) {
  Packet.call(this);
  this.tx = tx || null;
  this.rings = rings || [];
  this.type = type != null ? type : 1;
}

Object.setPrototypeOf(SignPacket.prototype, Packet.prototype);

SignPacket.prototype.cmd = packetTypes.SIGN;

SignPacket.prototype.getSize = function getSize() {
  let size = 0;

  size += this.tx.getSize();
  size += this.tx.view.getSize(this.tx);
  size += encoding.sizeVarint(this.rings.length);

  for (const ring of this.rings)
    size += ring.getSize();

  size += 1;

  return size;
};

SignPacket.prototype.toWriter = function toWriter(bw) {
  this.tx.toWriter(bw);
  this.tx.view.toWriter(bw, this.tx);

  bw.writeVarint(this.rings.length);

  for (const ring of this.rings)
    ring.toWriter(bw);

  bw.writeU8(this.type);

  return bw;
};

SignPacket.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);

  this.tx = MTX.fromReader(br);
  this.tx.view.fromReader(br, this.tx);

  const count = br.readVarint();

  for (let i = 0; i < count; i++) {
    const ring = KeyRing.fromReader(br);
    this.rings.push(ring);
  }

  this.type = br.readU8();

  return this;
};

SignPacket.fromRaw = function fromRaw(data) {
  return new SignPacket().fromRaw(data);
};

/**
 * SignResultPacket
 * @constructor
 */

function SignResultPacket(total, witness, script) {
  Packet.call(this);
  this.total = total || 0;
  this.script = script || [];
  this.witness = witness || [];
}

Object.setPrototypeOf(SignResultPacket.prototype, Packet.prototype);

SignResultPacket.prototype.cmd = packetTypes.SIGNRESULT;

SignResultPacket.prototype.fromTX = function fromTX(tx, total) {
  this.total = total;

  for (const input of tx.inputs) {
    this.script.push(input.script);
    this.witness.push(input.witness);
  }

  return this;
};

SignResultPacket.fromTX = function fromTX(tx, total) {
  return new SignResultPacket().fromTX(tx, total);
};

SignResultPacket.prototype.getSize = function getSize() {
  let size = 0;

  size += encoding.sizeVarint(this.total);
  size += encoding.sizeVarint(this.script.length);

  for (let i = 0; i < this.script.length; i++) {
    const script = this.script[i];
    const witness = this.witness[i];
    size += script.getVarSize();
    size += witness.getVarSize();
  }

  return size;
};

SignResultPacket.prototype.toWriter = function toWriter(bw) {
  assert(this.script.length === this.witness.length);

  bw.writeVarint(this.total);
  bw.writeVarint(this.script.length);

  for (let i = 0; i < this.script.length; i++) {
    this.script[i].toWriter(bw);
    this.witness[i].toWriter(bw);
  }

  return bw;
};

SignResultPacket.prototype.inject = function inject(tx) {
  assert(this.script.length === tx.inputs.length);
  assert(this.witness.length === tx.inputs.length);

  for (let i = 0; i < tx.inputs.length; i++) {
    const input = tx.inputs[i];
    input.script = this.script[i];
    input.witness = this.witness[i];
  }
};

SignResultPacket.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);

  this.total = br.readVarint();

  const count = br.readVarint();

  for (let i = 0; i < count; i++) {
    this.script.push(Script.fromReader(br));
    this.witness.push(Witness.fromReader(br));
  }

  return this;
};

SignResultPacket.fromRaw = function fromRaw(data) {
  return new SignResultPacket().fromRaw(data);
};

/**
 * CheckInputPacket
 * @constructor
 */

function CheckInputPacket(tx, index, coin, flags) {
  Packet.call(this);
  this.tx = tx || null;
  this.index = index;
  this.coin = coin || null;
  this.flags = flags != null ? flags : null;
}

Object.setPrototypeOf(CheckInputPacket.prototype, Packet.prototype);

CheckInputPacket.prototype.cmd = packetTypes.CHECKINPUT;

CheckInputPacket.prototype.getSize = function getSize() {
  let size = 0;
  size += this.tx.getSize();
  size += encoding.sizeVarint(this.index);
  size += encoding.sizeVarint(this.coin.value);
  size += this.coin.script.getVarSize();
  size += 4;
  return size;
};

CheckInputPacket.prototype.toWriter = function toWriter(bw) {
  this.tx.toWriter(bw);
  bw.writeVarint(this.index);
  bw.writeVarint(this.coin.value);
  this.coin.script.toWriter(bw);
  bw.writeI32(this.flags != null ? this.flags : -1);
  return bw;
};

CheckInputPacket.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);

  this.tx = TX.fromReader(br);
  this.index = br.readVarint();

  this.coin = new Output();
  this.coin.value = br.readVarint();
  this.coin.script.fromReader(br);

  this.flags = br.readI32();

  if (this.flags === -1)
    this.flags = null;

  return this;
};

CheckInputPacket.fromRaw = function fromRaw(data) {
  return new CheckInputPacket().fromRaw(data);
};

/**
 * CheckInputResultPacket
 * @constructor
 */

function CheckInputResultPacket(error) {
  CheckResultPacket.call(this, error);
}

Object.setPrototypeOf(
  CheckInputResultPacket.prototype,
  CheckResultPacket.prototype);

CheckInputResultPacket.prototype.cmd = packetTypes.CHECKINPUTRESULT;

CheckInputResultPacket.fromRaw = function fromRaw(data) {
  return new CheckInputResultPacket().fromRaw(data);
};

/**
 * SignInputPacket
 * @constructor
 */

function SignInputPacket(tx, index, coin, ring, type) {
  Packet.call(this);
  this.tx = tx || null;
  this.index = index;
  this.coin = coin || null;
  this.ring = ring || null;
  this.type = type != null ? type : 1;
}

Object.setPrototypeOf(SignInputPacket.prototype, Packet.prototype);

SignInputPacket.prototype.cmd = packetTypes.SIGNINPUT;

SignInputPacket.prototype.getSize = function getSize() {
  let size = 0;
  size += this.tx.getSize();
  size += encoding.sizeVarint(this.index);
  size += encoding.sizeVarint(this.coin.value);
  size += this.coin.script.getVarSize();
  size += this.ring.getSize();
  size += 1;
  return size;
};

SignInputPacket.prototype.toWriter = function toWriter(bw) {
  this.tx.toWriter(bw);
  bw.writeVarint(this.index);
  bw.writeVarint(this.coin.value);
  this.coin.script.toWriter(bw);
  this.ring.toWriter(bw);
  bw.writeU8(this.type);
  return bw;
};

SignInputPacket.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);

  this.tx = MTX.fromReader(br);
  this.index = br.readVarint();

  this.coin = new Output();
  this.coin.value = br.readVarint();
  this.coin.script.fromReader(br);

  this.ring = KeyRing.fromReader(br);
  this.type = br.readU8();

  return this;
};

SignInputPacket.fromRaw = function fromRaw(data) {
  return new SignInputPacket().fromRaw(data);
};

/**
 * SignInputResultPacket
 * @constructor
 */

function SignInputResultPacket(value, witness, script) {
  Packet.call(this);
  this.value = value || false;
  this.script = script || null;
  this.witness = witness || null;
}

Object.setPrototypeOf(SignInputResultPacket.prototype, Packet.prototype);

SignInputResultPacket.prototype.cmd = packetTypes.SIGNINPUTRESULT;

SignInputResultPacket.prototype.fromTX = function fromTX(tx, i, value) {
  const input = tx.inputs[i];

  assert(input);

  this.value = value;
  this.script = input.script;
  this.witness = input.witness;

  return this;
};

SignInputResultPacket.fromTX = function fromTX(tx, i, value) {
  return new SignInputResultPacket().fromTX(tx, i, value);
};

SignInputResultPacket.prototype.getSize = function getSize() {
  return 1 + this.script.getVarSize() + this.witness.getVarSize();
};

SignInputResultPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeU8(this.value ? 1 : 0);
  this.script.toWriter(bw);
  this.witness.toWriter(bw);
  return bw;
};

SignInputResultPacket.prototype.inject = function inject(tx, i) {
  const input = tx.inputs[i];
  assert(input);
  input.script = this.script;
  input.witness = this.witness;
};

SignInputResultPacket.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);
  this.value = br.readU8() === 1;
  this.script = Script.fromReader(br);
  this.witness = Witness.fromReader(br);
  return this;
};

SignInputResultPacket.fromRaw = function fromRaw(data) {
  return new SignInputResultPacket().fromRaw(data);
};

/**
 * ECVerifyPacket
 * @constructor
 */

function ECVerifyPacket(msg, sig, key) {
  Packet.call(this);
  this.msg = msg || null;
  this.sig = sig || null;
  this.key = key || null;
}

Object.setPrototypeOf(ECVerifyPacket.prototype, Packet.prototype);

ECVerifyPacket.prototype.cmd = packetTypes.ECVERIFY;

ECVerifyPacket.prototype.getSize = function getSize() {
  let size = 0;
  size += encoding.sizeVarBytes(this.msg);
  size += encoding.sizeVarBytes(this.sig);
  size += encoding.sizeVarBytes(this.key);
  return size;
};

ECVerifyPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeVarBytes(this.msg);
  bw.writeVarBytes(this.sig);
  bw.writeVarBytes(this.key);
  return bw;
};

ECVerifyPacket.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);
  this.msg = br.readVarBytes();
  this.sig = br.readVarBytes();
  this.key = br.readVarBytes();
  return this;
};

ECVerifyPacket.fromRaw = function fromRaw(data) {
  return new ECVerifyPacket().fromRaw(data);
};

/**
 * ECVerifyResultPacket
 * @constructor
 */

function ECVerifyResultPacket(value) {
  Packet.call(this);
  this.value = value;
}

Object.setPrototypeOf(ECVerifyResultPacket.prototype, Packet.prototype);

ECVerifyResultPacket.prototype.cmd = packetTypes.ECVERIFYRESULT;

ECVerifyResultPacket.prototype.getSize = function getSize() {
  return 1;
};

ECVerifyResultPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeU8(this.value ? 1 : 0);
  return bw;
};

ECVerifyResultPacket.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);
  this.value = br.readU8() === 1;
  return this;
};

ECVerifyResultPacket.fromRaw = function fromRaw(data) {
  return new ECVerifyResultPacket().fromRaw(data);
};

/**
 * ECSignPacket
 * @constructor
 */

function ECSignPacket(msg, key) {
  Packet.call(this);
  this.msg = msg || null;
  this.key = key || null;
}

Object.setPrototypeOf(ECSignPacket.prototype, Packet.prototype);

ECSignPacket.prototype.cmd = packetTypes.ECSIGN;

ECSignPacket.prototype.getSize = function getSize() {
  let size = 0;
  size += encoding.sizeVarBytes(this.msg);
  size += encoding.sizeVarBytes(this.key);
  return size;
};

ECSignPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeVarBytes(this.msg);
  bw.writeVarBytes(this.key);
  return bw;
};

ECSignPacket.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);
  this.msg = br.readVarBytes();
  this.key = br.readVarBytes();
  return this;
};

ECSignPacket.fromRaw = function fromRaw(data) {
  return new ECSignPacket().fromRaw(data);
};

/**
 * ECSignResultPacket
 * @constructor
 */

function ECSignResultPacket(sig) {
  Packet.call(this);
  this.sig = sig;
}

Object.setPrototypeOf(ECSignResultPacket.prototype, Packet.prototype);

ECSignResultPacket.prototype.cmd = packetTypes.ECSIGNRESULT;

ECSignResultPacket.prototype.getSize = function getSize() {
  return encoding.sizeVarBytes(this.sig);
};

ECSignResultPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeVarBytes(this.sig);
  return bw;
};

ECSignResultPacket.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);
  this.sig = br.readVarBytes();
  return this;
};

ECSignResultPacket.fromRaw = function fromRaw(data) {
  return new ECSignResultPacket().fromRaw(data);
};

/**
 * MinePacket
 * @constructor
 */

function MinePacket(data, target, min, max) {
  Packet.call(this);
  this.data = data || null;
  this.target = target || null;
  this.min = min != null ? min : -1;
  this.max = max != null ? max : -1;
}

Object.setPrototypeOf(MinePacket.prototype, Packet.prototype);

MinePacket.prototype.cmd = packetTypes.MINE;

MinePacket.prototype.getSize = function getSize() {
  return 120;
};

MinePacket.prototype.toWriter = function toWriter(bw) {
  bw.writeBytes(this.data);
  bw.writeBytes(this.target);
  bw.writeU32(this.min);
  bw.writeU32(this.max);
  return bw;
};

MinePacket.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);
  this.data = br.readBytes(80);
  this.target = br.readBytes(32);
  this.min = br.readU32();
  this.max = br.readU32();
  return this;
};

MinePacket.fromRaw = function fromRaw(data) {
  return new MinePacket().fromRaw(data);
};

/**
 * MineResultPacket
 * @constructor
 */

function MineResultPacket(nonce) {
  Packet.call(this);
  this.nonce = nonce != null ? nonce : -1;
}

Object.setPrototypeOf(MineResultPacket.prototype, Packet.prototype);

MineResultPacket.prototype.cmd = packetTypes.MINERESULT;

MineResultPacket.prototype.getSize = function getSize() {
  return 5;
};

MineResultPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeU8(this.nonce !== -1 ? 1 : 0);
  bw.writeU32(this.nonce);
  return bw;
};

MineResultPacket.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);
  this.nonce = -1;
  if (br.readU8() === 1)
    this.nonce = br.readU32();
  return this;
};

MineResultPacket.fromRaw = function fromRaw(data) {
  return new MineResultPacket().fromRaw(data);
};

/**
 * ScryptPacket
 * @constructor
 */

function ScryptPacket(passwd, salt, N, r, p, len) {
  Packet.call(this);
  this.passwd = passwd || null;
  this.salt = salt || null;
  this.N = N != null ? N : -1;
  this.r = r != null ? r : -1;
  this.p = p != null ? p : -1;
  this.len = len != null ? len : -1;
}

Object.setPrototypeOf(ScryptPacket.prototype, Packet.prototype);

ScryptPacket.prototype.cmd = packetTypes.SCRYPT;

ScryptPacket.prototype.getSize = function getSize() {
  let size = 0;
  size += encoding.sizeVarBytes(this.passwd);
  size += encoding.sizeVarBytes(this.salt);
  size += 16;
  return size;
};

ScryptPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeVarBytes(this.passwd);
  bw.writeVarBytes(this.salt);
  bw.writeU32(this.N);
  bw.writeU32(this.r);
  bw.writeU32(this.p);
  bw.writeU32(this.len);
  return bw;
};

ScryptPacket.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);
  this.passwd = br.readVarBytes();
  this.salt = br.readVarBytes();
  this.N = br.readU32();
  this.r = br.readU32();
  this.p = br.readU32();
  this.len = br.readU32();
  return this;
};

ScryptPacket.fromRaw = function fromRaw(data) {
  return new ScryptPacket().fromRaw(data);
};

/**
 * ScryptResultPacket
 * @constructor
 */

function ScryptResultPacket(key) {
  Packet.call(this);
  this.key = key || null;
}

Object.setPrototypeOf(ScryptResultPacket.prototype, Packet.prototype);

ScryptResultPacket.prototype.cmd = packetTypes.SCRYPTRESULT;

ScryptResultPacket.prototype.getSize = function getSize() {
  return encoding.sizeVarBytes(this.key);
};

ScryptResultPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeVarBytes(this.key);
  return bw;
};

ScryptResultPacket.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);
  this.key = br.readVarBytes();
  return this;
};

ScryptResultPacket.fromRaw = function fromRaw(data) {
  return new ScryptResultPacket().fromRaw(data);
};

/*
 * Helpers
 */

function stringify(value) {
  if (typeof value !== 'string')
    return '';
  return value;
}

/*
 * Expose
 */

exports.types = packetTypes;
exports.EnvPacket = EnvPacket;
exports.EventPacket = EventPacket;
exports.LogPacket = LogPacket;
exports.ErrorPacket = ErrorPacket;
exports.ErrorResultPacket = ErrorResultPacket;
exports.CheckPacket = CheckPacket;
exports.CheckResultPacket = CheckResultPacket;
exports.SignPacket = SignPacket;
exports.SignResultPacket = SignResultPacket;
exports.CheckInputPacket = CheckInputPacket;
exports.CheckInputResultPacket = CheckInputResultPacket;
exports.SignInputPacket = SignInputPacket;
exports.SignInputResultPacket = SignInputResultPacket;
exports.ECVerifyPacket = ECVerifyPacket;
exports.ECVerifyResultPacket = ECVerifyResultPacket;
exports.ECSignPacket = ECSignPacket;
exports.ECSignResultPacket = ECSignResultPacket;
exports.MinePacket = MinePacket;
exports.MineResultPacket = MineResultPacket;
exports.ScryptPacket = ScryptPacket;
exports.ScryptResultPacket = ScryptResultPacket;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var hash = exports;

hash.utils = __webpack_require__(15);
hash.common = __webpack_require__(32);
hash.sha = __webpack_require__(149);
hash.ripemd = __webpack_require__(153);
hash.hmac = __webpack_require__(154);

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * witness.js - witness object for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const Script = __webpack_require__(8);
const common = __webpack_require__(28);
const encoding = __webpack_require__(3);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const Address = __webpack_require__(11);
const Stack = __webpack_require__(41);
const scriptTypes = common.types;
const scriptTypesByVal = common.typesByVal;

/**
 * Refers to the witness field of segregated witness transactions.
 * @alias module:script.Witness
 * @constructor
 * @param {Buffer[]|NakedWitness} items - Array of
 * stack items.
 * @property {Buffer[]} items
 * @property {Script?} redeem
 * @property {Number} length
 */

function Witness(options) {
  if (!(this instanceof Witness))
    return new Witness(options);

  Stack.call(this, []);

  if (options)
    this.fromOptions(options);
}

Object.setPrototypeOf(Witness.prototype, Stack.prototype);

/**
 * Inject properties from options object.
 * @private
 * @param {Object} options
 */

Witness.prototype.fromOptions = function fromOptions(options) {
  assert(options, 'Witness data is required.');

  if (Array.isArray(options))
    return this.fromArray(options);

  if (options.items)
    return this.fromArray(options.items);

  return this;
};

/**
 * Instantiate witness from options.
 * @param {Object} options
 * @returns {Witness}
 */

Witness.fromOptions = function fromOptions(options) {
  return new Witness().fromOptions(options);
};

/**
 * Convert witness to an array of buffers.
 * @returns {Buffer[]}
 */

Witness.prototype.toArray = function toArray() {
  return this.items.slice();
};

/**
 * Inject properties from an array of buffers.
 * @private
 * @param {Buffer[]} items
 */

Witness.prototype.fromArray = function fromArray(items) {
  assert(Array.isArray(items));
  this.items = items;
  return this;
};

/**
 * Insantiate witness from an array of buffers.
 * @param {Buffer[]} items
 * @returns {Witness}
 */

Witness.fromArray = function fromArray(items) {
  return new Witness().fromArray(items);
};

/**
 * Convert witness to an array of buffers.
 * @returns {Buffer[]}
 */

Witness.prototype.toItems = function toItems() {
  return this.items.slice();
};

/**
 * Inject properties from an array of buffers.
 * @private
 * @param {Buffer[]} items
 */

Witness.prototype.fromItems = function fromItems(items) {
  assert(Array.isArray(items));
  this.items = items;
  return this;
};

/**
 * Insantiate witness from an array of buffers.
 * @param {Buffer[]} items
 * @returns {Witness}
 */

Witness.fromItems = function fromItems(items) {
  return new Witness().fromItems(items);
};

/**
 * Convert witness to a stack.
 * @returns {Stack}
 */

Witness.prototype.toStack = function toStack() {
  return new Stack(this.toArray());
};

/**
 * Inject properties from a stack.
 * @private
 * @param {Stack} stack
 */

Witness.prototype.fromStack = function fromStack(stack) {
  return this.fromArray(stack.items);
};

/**
 * Insantiate witness from a stack.
 * @param {Stack} stack
 * @returns {Witness}
 */

Witness.fromStack = function fromStack(stack) {
  return new Witness().fromStack(stack);
};

/**
 * Inspect a Witness object.
 * @returns {String} Human-readable script.
 */

Witness.prototype.inspect = function inspect() {
  return `<Witness: ${this.toString()}>`;
};

/**
 * Clone the witness object.
 * @returns {Witness} A clone of the current witness object.
 */

Witness.prototype.clone = function clone() {
  return new Witness().inject(this);
};

/**
 * Inject properties from witness.
 * Used for cloning.
 * @private
 * @param {Witness} witness
 * @returns {Witness}
 */

Witness.prototype.inject = function inject(witness) {
  this.items = witness.items.slice();
  return this;
};

/**
 * Compile witness (NOP).
 * @returns {Witness}
 */

Witness.prototype.compile = function compile() {
  return this;
};

/**
 * "Guess" the type of the witness.
 * This method is not 100% reliable.
 * @returns {ScriptType}
 */

Witness.prototype.getInputType = function getInputType() {
  if (this.isPubkeyhashInput())
    return scriptTypes.WITNESSPUBKEYHASH;

  if (this.isScripthashInput())
    return scriptTypes.WITNESSSCRIPTHASH;

  return scriptTypes.NONSTANDARD;
};

/**
 * "Guess" the type of the witness.
 * This method is not 100% reliable.
 * @returns {ScriptType}
 */

Witness.prototype.getInputTypeVal = function getInputTypeVal() {
  if (this.isPubkeyhashInput())
    return scriptTypesByVal[scriptTypes.WITNESSPUBKEYHASH];

  if (this.isScripthashInput())
    return scriptTypesByVal[scriptTypes.WITNESSSCRIPTHASH];

  return scriptTypesByVal[scriptTypes.NONSTANDARD];
};

/**
 * "Guess" the address of the witness.
 * This method is not 100% reliable.
 * @returns {Address|null}
 */

Witness.prototype.getInputAddress = function getInputAddress() {
  return Address.fromWitness(this);
};

/**
 * "Test" whether the witness is a pubkey input.
 * Always returns false.
 * @returns {Boolean}
 */

Witness.prototype.isPubkeyInput = function isPubkeyInput() {
  return false;
};

/**
 * Get P2PK signature if present.
 * Always returns null.
 * @returns {Buffer|null}
 */

Witness.prototype.getPubkeyInput = function getPubkeyInput() {
  return null;
};

/**
 * "Guess" whether the witness is a pubkeyhash input.
 * This method is not 100% reliable.
 * @returns {Boolean}
 */

Witness.prototype.isPubkeyhashInput = function isPubkeyhashInput() {
  return this.items.length === 2
    && common.isSignatureEncoding(this.items[0])
    && common.isKeyEncoding(this.items[1]);
};

/**
 * Get P2PKH signature and key if present.
 * @returns {Array} [sig, key]
 */

Witness.prototype.getPubkeyhashInput = function getPubkeyhashInput() {
  if (!this.isPubkeyhashInput())
    return [null, null];
  return [this.items[0], this.items[1]];
};

/**
 * "Test" whether the witness is a multisig input.
 * Always returns false.
 * @returns {Boolean}
 */

Witness.prototype.isMultisigInput = function isMultisigInput() {
  return false;
};

/**
 * Get multisig signatures key if present.
 * Always returns null.
 * @returns {Buffer[]|null}
 */

Witness.prototype.getMultisigInput = function getMultisigInput() {
  return null;
};

/**
 * "Guess" whether the witness is a scripthash input.
 * This method is not 100% reliable.
 * @returns {Boolean}
 */

Witness.prototype.isScripthashInput = function isScripthashInput() {
  return this.items.length > 0 && !this.isPubkeyhashInput();
};

/**
 * Get P2SH redeem script if present.
 * @returns {Buffer|null}
 */

Witness.prototype.getScripthashInput = function getScripthashInput() {
  if (!this.isScripthashInput())
    return null;
  return this.items[this.items.length - 1];
};

/**
 * "Guess" whether the witness is an unknown/non-standard type.
 * This method is not 100% reliable.
 * @returns {Boolean}
 */

Witness.prototype.isUnknownInput = function isUnknownInput() {
  return this.getInputType() === scriptTypes.NONSTANDARD;
};

/**
 * Test the witness against a bloom filter.
 * @param {Bloom} filter
 * @returns {Boolean}
 */

Witness.prototype.test = function test(filter) {
  for (const item of this.items) {
    if (item.length === 0)
      continue;

    if (filter.test(item))
      return true;
  }

  return false;
};

/**
 * Grab and deserialize the redeem script from the witness.
 * @returns {Script} Redeem script.
 */

Witness.prototype.getRedeem = function getRedeem() {
  if (this.items.length === 0)
    return null;

  const redeem = this.items[this.items.length - 1];

  if (!redeem)
    return null;

  return Script.fromRaw(redeem);
};

/**
 * Find a data element in a witness.
 * @param {Buffer} data - Data element to match against.
 * @returns {Number} Index (`-1` if not present).
 */

Witness.prototype.indexOf = function indexOf(data) {
  return util.indexOf(this.items, data);
};

/**
 * Calculate size of the witness
 * excluding the varint size bytes.
 * @returns {Number}
 */

Witness.prototype.getSize = function getSize() {
  let size = 0;

  for (const item of this.items)
    size += encoding.sizeVarBytes(item);

  return size;
};

/**
 * Calculate size of the witness
 * including the varint size bytes.
 * @returns {Number}
 */

Witness.prototype.getVarSize = function getVarSize() {
  return encoding.sizeVarint(this.items.length) + this.getSize();
};

/**
 * Write witness to a buffer writer.
 * @param {BufferWriter} bw
 */

Witness.prototype.toWriter = function toWriter(bw) {
  bw.writeVarint(this.items.length);

  for (const item of this.items)
    bw.writeVarBytes(item);

  return bw;
};

/**
 * Encode the witness to a Buffer.
 * @param {String} enc - Encoding, either `'hex'` or `null`.
 * @returns {Buffer|String} Serialized script.
 */

Witness.prototype.toRaw = function toRaw() {
  const size = this.getVarSize();
  return this.toWriter(new StaticWriter(size)).render();
};

/**
 * Convert witness to a hex string.
 * @returns {String}
 */

Witness.prototype.toJSON = function toJSON() {
  return this.toRaw().toString('hex');
};

/**
 * Inject properties from json object.
 * @private
 * @param {String} json
 */

Witness.prototype.fromJSON = function fromJSON(json) {
  assert(typeof json === 'string', 'Witness must be a string.');
  return this.fromRaw(Buffer.from(json, 'hex'));
};

/**
 * Insantiate witness from a hex string.
 * @param {String} json
 * @returns {Witness}
 */

Witness.fromJSON = function fromJSON(json) {
  return new Witness().fromJSON(json);
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

Witness.prototype.fromReader = function fromReader(br) {
  const count = br.readVarint();

  for (let i = 0; i < count; i++)
    this.items.push(br.readVarBytes());

  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

Witness.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Create a witness from a buffer reader.
 * @param {BufferReader} br
 */

Witness.fromReader = function fromReader(br) {
  return new Witness().fromReader(br);
};

/**
 * Create a witness from a serialized buffer.
 * @param {Buffer|String} data - Serialized witness.
 * @param {String?} enc - Either `"hex"` or `null`.
 * @returns {Witness}
 */

Witness.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new Witness().fromRaw(data);
};

/**
 * Inject items from string.
 * @private
 * @param {String|String[]} items
 */

Witness.prototype.fromString = function fromString(items) {
  if (!Array.isArray(items)) {
    assert(typeof items === 'string');

    items = items.trim();

    if (items.length === 0)
      return this;

    items = items.split(/\s+/);
  }

  for (const item of items)
    this.items.push(Buffer.from(item, 'hex'));

  return this;
};

/**
 * Parse a test script/array
 * string into a witness object. _Must_
 * contain only stack items (no non-push
 * opcodes).
 * @param {String|String[]} items - Script string.
 * @returns {Witness}
 * @throws Parse error.
 */

Witness.fromString = function fromString(items) {
  return new Witness().fromString(items);
};

/**
 * Test an object to see if it is a Witness.
 * @param {Object} obj
 * @returns {Boolean}
 */

Witness.isWitness = function isWitness(obj) {
  return obj instanceof Witness;
};

/*
 * Expose
 */

module.exports = Witness;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * lru.js - LRU cache for wmcc_core.
 */



const assert = __webpack_require__(0);

/**
 * An LRU cache, used for caching {@link ChainEntry}s.
 * @alias module:utils.LRU
 * @constructor
 * @param {Number} capacity
 * @param {Function?} getSize
 */

function LRU(capacity, getSize) {
  if (!(this instanceof LRU))
    return new LRU(capacity, getSize);

  this.map = new Map();
  this.size = 0;
  this.items = 0;
  this.head = null;
  this.tail = null;
  this.pending = null;

  assert(typeof capacity === 'number', 'Capacity must be a number.');
  assert(capacity >= 0, 'Capacity cannot be negative.');
  assert(!getSize || typeof getSize === 'function', 'Bad size callback.');

  this.capacity = capacity;
  this.getSize = getSize;
}

/**
 * Calculate size of an item.
 * @private
 * @param {LRUItem} item
 * @returns {Number} Size.
 */

LRU.prototype._getSize = function _getSize(item) {
  if (this.getSize) {
    const keySize = Math.floor(item.key.length * 1.375);
    return 120 + keySize + this.getSize(item.value);
  }

  return 1;
};

/**
 * Compact the LRU linked list.
 * @private
 */

LRU.prototype._compact = function _compact() {
  if (this.size <= this.capacity)
    return;

  let item, next;
  for (item = this.head; item; item = next) {
    if (this.size <= this.capacity)
      break;
    this.size -= this._getSize(item);
    this.items--;
    this.map.delete(item.key);
    next = item.next;
    item.prev = null;
    item.next = null;
  }

  if (!item) {
    this.head = null;
    this.tail = null;
    return;
  }

  this.head = item;
  item.prev = null;
};

/**
 * Reset the cache. Clear all items.
 */

LRU.prototype.reset = function reset() {
  let item, next;

  for (item = this.head; item; item = next) {
    this.map.delete(item.key);
    this.items--;
    next = item.next;
    item.prev = null;
    item.next = null;
  }

  assert(!item);

  this.size = 0;
  this.head = null;
  this.tail = null;
};

/**
 * Add an item to the cache.
 * @param {String|Number} key
 * @param {Object} value
 */

LRU.prototype.set = function set(key, value) {
  if (this.capacity === 0)
    return;

  key = String(key);

  let item = this.map.get(key);

  if (item) {
    this.size -= this._getSize(item);
    item.value = value;
    this.size += this._getSize(item);
    this._removeList(item);
    this._appendList(item);
    this._compact();
    return;
  }

  item = new LRUItem(key, value);

  this.map.set(key, item);

  this._appendList(item);

  this.size += this._getSize(item);
  this.items++;

  this._compact();
};

/**
 * Retrieve an item from the cache.
 * @param {String|Number} key
 * @returns {Object} Item.
 */

LRU.prototype.get = function get(key) {
  if (this.capacity === 0)
    return null;

  key = String(key);

  const item = this.map.get(key);

  if (!item)
    return null;

  this._removeList(item);
  this._appendList(item);

  return item.value;
};

/**
 * Test whether the cache contains a key.
 * @param {String|Number} key
 * @returns {Boolean}
 */

LRU.prototype.has = function has(key) {
  if (this.capacity === 0)
    return false;
  return this.map.has(String(key));
};

/**
 * Remove an item from the cache.
 * @param {String|Number} key
 * @returns {Boolean} Whether an item was removed.
 */

LRU.prototype.remove = function remove(key) {
  if (this.capacity === 0)
    return false;

  key = String(key);

  const item = this.map.get(key);

  if (!item)
    return false;

  this.size -= this._getSize(item);
  this.items--;

  this.map.delete(key);

  this._removeList(item);

  return true;
};

/**
 * Prepend an item to the linked list (sets new head).
 * @private
 * @param {LRUItem}
 */

LRU.prototype._prependList = function _prependList(item) {
  this._insertList(null, item);
};

/**
 * Append an item to the linked list (sets new tail).
 * @private
 * @param {LRUItem}
 */

LRU.prototype._appendList = function _appendList(item) {
  this._insertList(this.tail, item);
};

/**
 * Insert item into the linked list.
 * @private
 * @param {LRUItem|null} ref
 * @param {LRUItem} item
 */

LRU.prototype._insertList = function _insertList(ref, item) {
  assert(!item.next);
  assert(!item.prev);

  if (ref == null) {
    if (!this.head) {
      this.head = item;
      this.tail = item;
    } else {
      this.head.prev = item;
      item.next = this.head;
      this.head = item;
    }
    return;
  }

  item.next = ref.next;
  item.prev = ref;
  ref.next = item;

  if (ref === this.tail)
    this.tail = item;
};

/**
 * Remove item from the linked list.
 * @private
 * @param {LRUItem}
 */

LRU.prototype._removeList = function _removeList(item) {
  if (item.prev)
    item.prev.next = item.next;

  if (item.next)
    item.next.prev = item.prev;

  if (item === this.head)
    this.head = item.next;

  if (item === this.tail)
    this.tail = item.prev || this.head;

  if (!this.head)
    assert(!this.tail);

  if (!this.tail)
    assert(!this.head);

  item.prev = null;
  item.next = null;
};

/**
 * Collect all keys in the cache, sorted by LRU.
 * @returns {String[]}
 */

LRU.prototype.keys = function keys() {
  const items = [];

  for (let item = this.head; item; item = item.next) {
    if (item === this.head)
      assert(!item.prev);
    if (!item.prev)
      assert(item === this.head);
    if (!item.next)
      assert(item === this.tail);
    items.push(item.key);
  }

  return items;
};

/**
 * Collect all values in the cache, sorted by LRU.
 * @returns {String[]}
 */

LRU.prototype.values = function values() {
  const items = [];

  for (let item = this.head; item; item = item.next)
    items.push(item.value);

  return items;
};

/**
 * Convert the LRU cache to an array of items.
 * @returns {Object[]}
 */

LRU.prototype.toArray = function toArray() {
  const items = [];

  for (let item = this.head; item; item = item.next)
    items.push(item);

  return items;
};

/**
 * Create an atomic batch for the lru
 * (used for caching database writes).
 * @returns {LRUBatch}
 */

LRU.prototype.batch = function batch() {
  return new LRUBatch(this);
};

/**
 * Start the pending batch.
 */

LRU.prototype.start = function start() {
  assert(!this.pending);
  this.pending = this.batch();
};

/**
 * Clear the pending batch.
 */

LRU.prototype.clear = function clear() {
  assert(this.pending);
  this.pending.clear();
};

/**
 * Drop the pending batch.
 */

LRU.prototype.drop = function drop() {
  assert(this.pending);
  this.pending = null;
};

/**
 * Commit the pending batch.
 */

LRU.prototype.commit = function commit() {
  assert(this.pending);
  this.pending.commit();
  this.pending = null;
};

/**
 * Push an item onto the pending batch.
 * @param {String} key
 * @param {Object} value
 */

LRU.prototype.push = function push(key, value) {
  assert(this.pending);

  if (this.capacity === 0)
    return;

  this.pending.set(key, value);
};

/**
 * Push a removal onto the pending batch.
 * @param {String} key
 */

LRU.prototype.unpush = function unpush(key) {
  assert(this.pending);

  if (this.capacity === 0)
    return;

  this.pending.remove(key);
};

/**
 * Represents an LRU item.
 * @alias module:utils.LRUItem
 * @constructor
 * @private
 * @param {String} key
 * @param {Object} value
 */

function LRUItem(key, value) {
  this.key = key;
  this.value = value;
  this.next = null;
  this.prev = null;
}

/**
 * LRU Batch
 * @alias module:utils.LRUBatch
 * @constructor
 * @param {LRU} lru
 */

function LRUBatch(lru) {
  this.lru = lru;
  this.ops = [];
}

/**
 * Push an item onto the batch.
 * @param {String} key
 * @param {Object} value
 */

LRUBatch.prototype.set = function set(key, value) {
  this.ops.push(new LRUOp(false, key, value));
};

/**
 * Push a removal onto the batch.
 * @param {String} key
 */

LRUBatch.prototype.remove = function remove(key) {
  this.ops.push(new LRUOp(true, key, null));
};

/**
 * Clear the batch.
 */

LRUBatch.prototype.clear = function clear() {
  this.ops.length = 0;
};

/**
 * Commit the batch.
 */

LRUBatch.prototype.commit = function commit() {
  for (const op of this.ops) {
    if (op.remove) {
      this.lru.remove(op.key);
      continue;
    }
    this.lru.set(op.key, op.value);
  }

  this.ops.length = 0;
};

/**
 * LRU Op
 * @alias module:utils.LRUOp
 * @constructor
 * @private
 * @param {Boolean} remove
 * @param {String} key
 * @param {Object} value
 */

function LRUOp(remove, key, value) {
  this.remove = remove;
  this.key = key;
  this.value = value;
}

/*
 * Expose
 */

module.exports = LRU;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * x15.js - x15 for wmcc_core.
 */



/**
 * @module crypto.x15
 */

/**
 * x15.js
 * @constructor
 */

module.exports = __webpack_require__(164);


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * fs.js - promisified fs module for wmcc_core.
 */



const fs = __webpack_require__(64);
const co = __webpack_require__(17);

exports.access = co.promisify(fs.access);
exports.accessSync = fs.accessSync;
exports.appendFile = co.promisify(fs.appendFile);
exports.appendFileSync = fs.appendFileSync;
exports.chmod = co.promisify(fs.chmod);
exports.chmodSync = fs.chmodSync;
exports.chown = co.promisify(fs.chown);
exports.chownSync = fs.chownSync;
exports.close = co.promisify(fs.close);
exports.closeSync = fs.closeSync;
exports.constants = fs.constants;
exports.createReadStream = fs.createReadStream;
exports.createWriteStream = fs.createWriteStream;
exports.exists = co.promisify(fs.exists);
exports.existsSync = fs.existsSync;
exports.fchmod = co.promisify(fs.fchmod);
exports.fchmodSync = fs.fchmodSync;
exports.fchown = co.promisify(fs.fchown);
exports.fchownSync = fs.fchownSync;
exports.fdatasync = co.promisify(fs.fdatasync);
exports.fdatasyncSync = fs.fdatasyncSync;
exports.fstat = co.promisify(fs.fstat);
exports.fstatSync = fs.fstatSync;
exports.fsync = co.promisify(fs.fsync);
exports.fsyncSync = fs.fsyncSync;
exports.ftruncate = co.promisify(fs.ftruncate);
exports.ftruncateSync = fs.ftruncateSync;
exports.futimes = co.promisify(fs.futimes);
exports.futimesSync = fs.futimesSync;
exports.lchmod = co.promisify(fs.lchmod);
exports.lchmodSync = fs.lchmodSync;
exports.lchown = co.promisify(fs.lchown);
exports.lchownSync = fs.lchownSync;
exports.link = co.promisify(fs.link);
exports.linkSync = fs.linkSync;
exports.lstat = co.promisify(fs.lstat);
exports.lstatSync = fs.lstatSync;
exports.mkdir = co.promisify(fs.mkdir);
exports.mkdirSync = fs.mkdirSync;
exports.mkdtemp = co.promisify(fs.mkdtemp);
exports.mkdtempSync = fs.mkdtempSync;
exports.open = co.promisify(fs.open);
exports.openSync = fs.openSync;
exports.read = co.promisify(fs.read);
exports.readSync = fs.readSync;
exports.readdir = co.promisify(fs.readdir);
exports.readdirSync = fs.readdirSync;
exports.readFile = co.promisify(fs.readFile);
exports.readFileSync = fs.readFileSync;
exports.readlink = co.promisify(fs.readlink);
exports.readlinkSync = fs.readlinkSync;
exports.realpath = co.promisify(fs.realpath);
exports.realpathSync = fs.realpathSync;
exports.rename = co.promisify(fs.rename);
exports.renameSync = fs.renameSync;
exports.rmdir = co.promisify(fs.rmdir);
exports.rmdirSync = fs.rmdirSync;
exports.stat = co.promisify(fs.stat);
exports.statSync = fs.statSync;
exports.symlink = co.promisify(fs.symlink);
exports.symlinkSync = fs.symlinkSync;
exports.truncate = co.promisify(fs.truncate);
exports.truncateSync = fs.truncateSync;
exports.unlink = co.promisify(fs.unlink);
exports.unlinkSync = fs.unlinkSync;
exports.unwatchFile = fs.unwatchFile;
exports.utimes = co.promisify(fs.utimes);
exports.utimesSync = fs.utimesSync;
exports.watch = fs.watch;
exports.watchFile = fs.watchFile;
exports.write = co.promisify(fs.write);
exports.writeSync = fs.writeSync;
exports.writeFile = co.promisify(fs.writeFile);
exports.writeFileSync = fs.writeFileSync;

exports.mkdirpSync = function mkdirpSync(dir, mode) {
  if (mode == null)
    mode = 0o750;

  let [path, parts] = getParts(dir);

  for (const part of parts) {
    path += part;

    try {
      const stat = exports.statSync(path);
      if (!stat.isDirectory())
        throw new Error('Could not create directory.');
    } catch (e) {
      if (e.code === 'ENOENT')
        exports.mkdirSync(path, mode);
      else
        throw e;
    }

    path += '/';
  }
};

exports.mkdirp = async function mkdirp(dir, mode) {
  if (mode == null)
    mode = 0o750;

  let [path, parts] = getParts(dir);

  for (const part of parts) {
    path += part;

    try {
      const stat = await exports.stat(path);
      if (!stat.isDirectory())
        throw new Error('Could not create directory.');
    } catch (e) {
      if (e.code === 'ENOENT')
        await exports.mkdir(path, mode);
      else
        throw e;
    }

    path += '/';
  }
};

function getParts(path) {
  path = path.replace(/\\/g, '/');
  path = path.replace(/(^|\/)\.\//, '$1');
  path = path.replace(/\/+\.?$/, '');

  const parts = path.split(/\/+/);

  let root = '';

  if (process.platform === 'win32') {
    if (parts[0].indexOf(':') !== -1)
      root = parts.shift() + '/';
  }

  if (parts.length > 0) {
    if (parts[0].length === 0) {
      parts.shift();
      root = '/';
    }
  }

  return [root, parts];
}


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * common.js - p2p constants for wmcc_core.
 */



/**
 * @module net/common
 */

const pkg = __webpack_require__(94);

/**
 * Default protocol version.
 * @const {Number}
 * @default
 */

exports.PROTOCOL_VERSION = 70015;

/**
 * Minimum protocol version we're willing to talk to.
 * @const {Number}
 * @default
 */

exports.MIN_VERSION = 70001;

/**
 * Minimum version for getheaders.
 * @const {Number}
 * @default
 */

exports.HEADERS_VERSION = 31800;

/**
 * Minimum version for pong.
 * @const {Number}
 * @default
 */

exports.PONG_VERSION = 60000;

/**
 * Minimum version for bip37.
 * @const {Number}
 * @default
 */

exports.BLOOM_VERSION = 70011;

/**
 * Minimum version for bip152.
 * @const {Number}
 * @default
 */

exports.SENDHEADERS_VERSION = 7012;

/**
 * Minimum version for bip152.
 * @const {Number}
 * @default
 */

exports.COMPACT_VERSION = 70014;

/**
 * Minimum version for bip152+segwit.
 * @const {Number}
 * @default
 */

exports.COMPACT_WITNESS_VERSION = 70015;

/**
 * Service bits.
 * @enum {Number}
 * @default
 */

exports.services = {
  /**
   * Whether network services are enabled.
   */

  NETWORK: 1 << 0,

  /**
   * Whether the peer supports the getutxos packet.
   */

  GETUTXO: 1 << 1,

  /**
   * Whether the peer supports BIP37.
   */

  BLOOM: 1 << 2,

  /**
   * Whether the peer supports segregated witness.
   */

  WITNESS: 1 << 3
};

/**
 * WMCC's services (we support everything).
 * @const {Number}
 * @default
 */

exports.LOCAL_SERVICES = 0
  | exports.services.NETWORK
  | exports.services.WITNESS;

/**
 * Required services (network and segwit).
 * @const {Number}
 * @default
 */

exports.REQUIRED_SERVICES = 0
  | exports.services.NETWORK;

/**
 * Default user agent: `/wmcc:[version]/`.
 * @const {String}
 * @default
 */

exports.USER_AGENT = `/wmcc:${pkg.version}/`;

/**
 * Max message size (~4mb with segwit, formerly 2mb)
 * @const {Number}
 * @default
 */

exports.MAX_MESSAGE = 4 * 1000 * 1000;

/**
 * Amount of time to ban misbheaving peers.
 * @const {Number}
 * @default
 */

exports.BAN_TIME = 24 * 60 * 60;

/**
 * Ban score threshold before ban is placed in effect.
 * @const {Number}
 * @default
 */

exports.BAN_SCORE = 100;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * packets.js - packets for wmcc_core.
 */



/**
 * @module net/packets
 */

const common = __webpack_require__(59);
const util = __webpack_require__(1);
const assert = __webpack_require__(0);
const Bloom = __webpack_require__(43);
const bip152 = __webpack_require__(96);
const NetAddress = __webpack_require__(75);
const Headers = __webpack_require__(37);
const InvItem = __webpack_require__(36);
const MemBlock = __webpack_require__(241);
const MerkleBlock = __webpack_require__(69);
const TX = __webpack_require__(16);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const encoding = __webpack_require__(3);
const DUMMY = Buffer.alloc(0);

/**
 * Packet types.
 * @enum {Number}
 * @default
 */

exports.types = {
  VERSION: 0,
  VERACK: 1,
  PING: 2,
  PONG: 3,
  GETADDR: 4,
  ADDR: 5,
  INV: 6,
  GETDATA: 7,
  NOTFOUND: 8,
  GETBLOCKS: 9,
  GETHEADERS: 10,
  HEADERS: 11,
  SENDHEADERS: 12,
  BLOCK: 13,
  TX: 14,
  REJECT: 15,
  MEMPOOL: 16,
  FILTERLOAD: 17,
  FILTERADD: 18,
  FILTERCLEAR: 19,
  MERKLEBLOCK: 20,
  FEEFILTER: 21,
  SENDCMPCT: 22,
  CMPCTBLOCK: 23,
  GETBLOCKTXN: 24,
  BLOCKTXN: 25,
  ENCINIT: 26,
  ENCACK: 27,
  AUTHCHALLENGE: 28,
  AUTHREPLY: 29,
  AUTHPROPOSE: 30,
  UNKNOWN: 31,
  // Internal
  INTERNAL: 100,
  DATA: 101
};

/**
 * Packet types by value.
 * @const {Object}
 * @default
 */

exports.typesByVal = util.reverse(exports.types);

/**
 * Base Packet
 * @constructor
 */

function Packet() {}

Packet.prototype.type = -1;
Packet.prototype.cmd = '';

/**
 * Get serialization size.
 * @returns {Number}
 */

Packet.prototype.getSize = function getSize() {
  return 0;
};

/**
 * Serialize packet to writer.
 * @param {BufferWriter} bw
 */

Packet.prototype.toWriter = function toWriter(bw) {
  return bw;
};

/**
 * Serialize packet.
 * @returns {Buffer}
 */

Packet.prototype.toRaw = function toRaw() {
  return DUMMY;
};

/**
 * Inject properties from buffer reader.
 * @param {BufferReader} br
 */

Packet.prototype.fromReader = function fromReader(br) {
  return this;
};

/**
 * Inject properties from serialized data.
 * @param {Buffer} data
 */

Packet.prototype.fromRaw = function fromRaw(data) {
  return this;
};

/**
 * Version Packet
 * @constructor
 * @param {Object?} options
 * @param {Number} options.version - Protocol version.
 * @param {Number} options.services - Service bits.
 * @param {Number} options.time - Timestamp of discovery.
 * @param {NetAddress} options.local - Our address.
 * @param {NetAddress} options.remote - Their address.
 * @param {Buffer} options.nonce
 * @param {String} options.agent - User agent string.
 * @param {Number} options.height - Chain height.
 * @param {Boolean} options.noRelay - Whether transactions
 * should be relayed immediately.
 * @property {Number} version - Protocol version.
 * @property {Number} services - Service bits.
 * @property {Number} time - Timestamp of discovery.
 * @property {NetAddress} local - Our address.
 * @property {NetAddress} remote - Their address.
 * @property {Buffer} nonce
 * @property {String} agent - User agent string.
 * @property {Number} height - Chain height.
 * @property {Boolean} noRelay - Whether transactions
 * should be relayed immediately.
 */

function VersionPacket(options) {
  if (!(this instanceof VersionPacket))
    return new VersionPacket(options);

  Packet.call(this);

  this.version = common.PROTOCOL_VERSION;
  this.services = common.LOCAL_SERVICES;
  this.time = util.now();
  this.remote = new NetAddress();
  this.local = new NetAddress();
  this.nonce = encoding.ZERO_U64;
  this.agent = common.USER_AGENT;
  this.height = 0;
  this.noRelay = false;

  if (options)
    this.fromOptions(options);
}

Object.setPrototypeOf(VersionPacket.prototype, Packet.prototype);

VersionPacket.prototype.cmd = 'version';
VersionPacket.prototype.type = exports.types.VERSION;

/**
 * Inject properties from options.
 * @private
 * @param {Object} options
 */

VersionPacket.prototype.fromOptions = function fromOptions(options) {
  if (options.version != null)
    this.version = options.version;

  if (options.services != null)
    this.services = options.services;

  if (options.time != null)
    this.time = options.time;

  if (options.remote)
    this.remote.fromOptions(options.remote);

  if (options.local)
    this.local.fromOptions(options.local);

  if (options.nonce)
    this.nonce = options.nonce;

  if (options.agent)
    this.agent = options.agent;

  if (options.height != null)
    this.height = options.height;

  if (options.noRelay != null)
    this.noRelay = options.noRelay;

  return this;
};

/**
 * Instantiate version packet from options.
 * @param {Object} options
 * @returns {VersionPacket}
 */

VersionPacket.fromOptions = function fromOptions(options) {
  return new VersionPacket().fromOptions(options);
};

/**
 * Get serialization size.
 * @returns {Number}
 */

VersionPacket.prototype.getSize = function getSize() {
  let size = 0;
  size += 20;
  size += this.remote.getSize(false);
  size += this.local.getSize(false);
  size += 8;
  size += encoding.sizeVarString(this.agent, 'ascii');
  size += 5;
  return size;
};

/**
 * Write version packet to buffer writer.
 * @param {BufferWriter} bw
 */

VersionPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeI32(this.version);
  bw.writeU32(this.services);
  bw.writeU32(0);
  bw.writeI64(this.time);
  this.remote.toWriter(bw, false);
  this.local.toWriter(bw, false);
  bw.writeBytes(this.nonce);
  bw.writeVarString(this.agent, 'ascii');
  bw.writeI32(this.height);
  bw.writeU8(this.noRelay ? 0 : 1);
  return bw;
};

/**
 * Serialize version packet.
 * @returns {Buffer}
 */

VersionPacket.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

VersionPacket.prototype.fromReader = function fromReader(br) {
  this.version = br.readI32();
  this.services = br.readU32();

  // Note: hi service bits
  // are currently unused.
  br.readU32();

  this.time = br.readI64();
  this.remote.fromReader(br, false);

  if (br.left() > 0) {
    this.local.fromReader(br, false);
    this.nonce = br.readBytes(8);
  }

  if (br.left() > 0)
    this.agent = br.readVarString('ascii', 256);

  if (br.left() > 0)
    this.height = br.readI32();

  if (br.left() > 0)
    this.noRelay = br.readU8() === 0;

  if (this.version === 10300)
    this.version = 300;

  assert(this.version >= 0, 'Version is negative.');
  assert(this.time >= 0, 'Timestamp is negative.');

  // No idea why so many peers do this.
  if (this.height < 0)
    this.height = 0;

  return this;
};

/**
 * Instantiate version packet from buffer reader.
 * @param {BufferReader} br
 * @returns {VersionPacket}
 */

VersionPacket.fromReader = function fromReader(br) {
  return new VersionPacket().fromReader(br);
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

VersionPacket.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate version packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {VersionPacket}
 */

VersionPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new VersionPacket().fromRaw(data, enc);
};

/**
 * Represents a `verack` packet.
 * @constructor
 */

function VerackPacket() {
  if (!(this instanceof VerackPacket))
    return new VerackPacket();

  Packet.call(this);
}

Object.setPrototypeOf(VerackPacket.prototype, Packet.prototype);

VerackPacket.prototype.cmd = 'verack';
VerackPacket.prototype.type = exports.types.VERACK;

/**
 * Instantiate verack packet from serialized data.
 * @param {BufferReader} br
 * @returns {VerackPacket}
 */

VerackPacket.fromReader = function fromReader(br) {
  return new VerackPacket().fromReader(br);
};

/**
 * Instantiate verack packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {VerackPacket}
 */

VerackPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new VerackPacket().fromRaw(data);
};

/**
 * Represents a `ping` packet.
 * @constructor
 * @param {BN?} nonce
 * @property {BN|null} nonce
 */

function PingPacket(nonce) {
  if (!(this instanceof PingPacket))
    return new PingPacket(nonce);

  Packet.call(this);

  this.nonce = nonce || null;
}

Object.setPrototypeOf(PingPacket.prototype, Packet.prototype);

PingPacket.prototype.cmd = 'ping';
PingPacket.prototype.type = exports.types.PING;

/**
 * Get serialization size.
 * @returns {Number}
 */

PingPacket.prototype.getSize = function getSize() {
  return this.nonce ? 8 : 0;
};

/**
 * Serialize ping packet.
 * @returns {Buffer}
 */

PingPacket.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

/**
 * Serialize ping packet to writer.
 * @param {BufferWriter} bw
 */

PingPacket.prototype.toWriter = function toWriter(bw) {
  if (this.nonce)
    bw.writeBytes(this.nonce);
  return bw;
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

PingPacket.prototype.fromReader = function fromReader(br) {
  if (br.left() >= 8)
    this.nonce = br.readBytes(8);
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

PingPacket.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate ping packet from serialized data.
 * @param {BufferReader} br
 * @returns {PingPacket}
 */

PingPacket.fromReader = function fromReader(br) {
  return new PingPacket().fromRaw(br);
};

/**
 * Instantiate ping packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {PingPacket}
 */

PingPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new PingPacket().fromRaw(data);
};

/**
 * Represents a `pong` packet.
 * @constructor
 * @param {BN?} nonce
 * @property {BN} nonce
 */

function PongPacket(nonce) {
  if (!(this instanceof PongPacket))
    return new PongPacket(nonce);

  Packet.call(this);

  this.nonce = nonce || encoding.ZERO_U64;
}

Object.setPrototypeOf(PongPacket.prototype, Packet.prototype);

PongPacket.prototype.cmd = 'pong';
PongPacket.prototype.type = exports.types.PONG;

/**
 * Get serialization size.
 * @returns {Number}
 */

PongPacket.prototype.getSize = function getSize() {
  return 8;
};

/**
 * Serialize pong packet to writer.
 * @param {BufferWriter} bw
 */

PongPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeBytes(this.nonce);
  return bw;
};

/**
 * Serialize pong packet.
 * @returns {Buffer}
 */

PongPacket.prototype.toRaw = function toRaw() {
  return this.toWriter(new StaticWriter(8)).render();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

PongPacket.prototype.fromReader = function fromReader(br) {
  this.nonce = br.readBytes(8);
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

PongPacket.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate pong packet from buffer reader.
 * @param {BufferReader} br
 * @returns {VerackPacket}
 */

PongPacket.fromReader = function fromReader(br) {
  return new PongPacket().fromReader(br);
};

/**
 * Instantiate pong packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {VerackPacket}
 */

PongPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new PongPacket().fromRaw(data);
};

/**
 * Represents a `getaddr` packet.
 * @constructor
 */

function GetAddrPacket() {
  if (!(this instanceof GetAddrPacket))
    return new GetAddrPacket();

  Packet.call(this);
}

Object.setPrototypeOf(GetAddrPacket.prototype, Packet.prototype);

GetAddrPacket.prototype.cmd = 'getaddr';
GetAddrPacket.prototype.type = exports.types.GETADDR;

/**
 * Instantiate getaddr packet from buffer reader.
 * @param {BufferReader} br
 * @returns {GetAddrPacket}
 */

GetAddrPacket.fromReader = function fromReader(br) {
  return new GetAddrPacket().fromReader(br);
};

/**
 * Instantiate getaddr packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {GetAddrPacket}
 */

GetAddrPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new GetAddrPacket().fromRaw(data);
};

/**
 * Represents a `addr` packet.
 * @constructor
 * @param {(NetAddress[])?} items
 * @property {NetAddress[]} items
 */

function AddrPacket(items) {
  if (!(this instanceof AddrPacket))
    return new AddrPacket(items);

  Packet.call(this);

  this.items = items || [];
}

Object.setPrototypeOf(AddrPacket.prototype, Packet.prototype);

AddrPacket.prototype.cmd = 'addr';
AddrPacket.prototype.type = exports.types.ADDR;

/**
 * Get serialization size.
 * @returns {Number}
 */

AddrPacket.prototype.getSize = function getSize() {
  let size = 0;
  size += encoding.sizeVarint(this.items.length);
  size += 30 * this.items.length;
  return size;
};

/**
 * Serialize addr packet to writer.
 * @param {BufferWriter} bw
 */

AddrPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeVarint(this.items.length);

  for (const item of this.items)
    item.toWriter(bw, true);

  return bw;
};

/**
 * Serialize addr packet.
 * @returns {Buffer}
 */

AddrPacket.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

AddrPacket.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data);
  const count = br.readVarint();

  for (let i = 0; i < count; i++)
    this.items.push(NetAddress.fromReader(br, true));

  return this;
};

/**
 * Instantiate addr packet from Buffer reader.
 * @param {BufferReader} br
 * @returns {AddrPacket}
 */

AddrPacket.fromReader = function fromReader(br) {
  return new AddrPacket().fromReader(br);
};

/**
 * Instantiate addr packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {AddrPacket}
 */

AddrPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new AddrPacket().fromRaw(data);
};

/**
 * Represents a `inv` packet.
 * @constructor
 * @param {(InvItem[])?} items
 * @property {InvItem[]} items
 */

function InvPacket(items) {
  if (!(this instanceof InvPacket))
    return new InvPacket(items);

  Packet.call(this);

  this.items = items || [];
}

Object.setPrototypeOf(InvPacket.prototype, Packet.prototype);

InvPacket.prototype.cmd = 'inv';
InvPacket.prototype.type = exports.types.INV;

/**
 * Get serialization size.
 * @returns {Number}
 */

InvPacket.prototype.getSize = function getSize() {
  let size = 0;
  size += encoding.sizeVarint(this.items.length);
  size += 36 * this.items.length;
  return size;
};

/**
 * Serialize inv packet to writer.
 * @param {Buffer} bw
 */

InvPacket.prototype.toWriter = function toWriter(bw) {
  assert(this.items.length <= 50000);

  bw.writeVarint(this.items.length);

  for (const item of this.items)
    item.toWriter(bw);

  return bw;
};

/**
 * Serialize inv packet.
 * @returns {Buffer}
 */

InvPacket.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

InvPacket.prototype.fromReader = function fromReader(br) {
  const count = br.readVarint();

  assert(count <= 50000, 'Inv item count too high.');

  for (let i = 0; i < count; i++)
    this.items.push(InvItem.fromReader(br));

  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

InvPacket.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate inv packet from buffer reader.
 * @param {BufferReader} br
 * @returns {InvPacket}
 */

InvPacket.fromReader = function fromReader(br) {
  return new InvPacket().fromRaw(br);
};

/**
 * Instantiate inv packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {InvPacket}
 */

InvPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new InvPacket().fromRaw(data);
};

/**
 * Represents a `getdata` packet.
 * @extends InvPacket
 * @constructor
 * @param {(InvItem[])?} items
 */

function GetDataPacket(items) {
  if (!(this instanceof GetDataPacket))
    return new GetDataPacket(items);

  InvPacket.call(this, items);
}

Object.setPrototypeOf(GetDataPacket.prototype, InvPacket.prototype);

GetDataPacket.prototype.cmd = 'getdata';
GetDataPacket.prototype.type = exports.types.GETDATA;

/**
 * Instantiate getdata packet from buffer reader.
 * @param {BufferReader} br
 * @returns {GetDataPacket}
 */

GetDataPacket.fromReader = function fromReader(br) {
  return new GetDataPacket().fromReader(br);
};

/**
 * Instantiate getdata packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {GetDataPacket}
 */

GetDataPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new GetDataPacket().fromRaw(data);
};

/**
 * Represents a `notfound` packet.
 * @extends InvPacket
 * @constructor
 * @param {(InvItem[])?} items
 */

function NotFoundPacket(items) {
  if (!(this instanceof NotFoundPacket))
    return new NotFoundPacket(items);

  InvPacket.call(this, items);
}

Object.setPrototypeOf(NotFoundPacket.prototype, InvPacket.prototype);

NotFoundPacket.prototype.cmd = 'notfound';
NotFoundPacket.prototype.type = exports.types.NOTFOUND;

/**
 * Instantiate notfound packet from buffer reader.
 * @param {BufferReader} br
 * @returns {NotFoundPacket}
 */

NotFoundPacket.fromReader = function fromReader(br) {
  return new NotFoundPacket().fromReader(br);
};

/**
 * Instantiate notfound packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {NotFoundPacket}
 */

NotFoundPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new NotFoundPacket().fromRaw(data);
};

/**
 * Represents a `getblocks` packet.
 * @constructor
 * @param {Hash[]} locator
 * @param {Hash?} stop
 * @property {Hash[]} locator
 * @property {Hash|null} stop
 */

function GetBlocksPacket(locator, stop) {
  if (!(this instanceof GetBlocksPacket))
    return new GetBlocksPacket(locator, stop);

  Packet.call(this);

  this.version = common.PROTOCOL_VERSION;
  this.locator = locator || [];
  this.stop = stop || null;
}

Object.setPrototypeOf(GetBlocksPacket.prototype, Packet.prototype);

GetBlocksPacket.prototype.cmd = 'getblocks';
GetBlocksPacket.prototype.type = exports.types.GETBLOCKS;

/**
 * Get serialization size.
 * @returns {Number}
 */

GetBlocksPacket.prototype.getSize = function getSize() {
  let size = 0;
  size += 4;
  size += encoding.sizeVarint(this.locator.length);
  size += 32 * this.locator.length;
  size += 32;
  return size;
};

/**
 * Serialize getblocks packet to writer.
 * @param {BufferWriter} bw
 */

GetBlocksPacket.prototype.toWriter = function toWriter(bw) {
  assert(this.locator.length <= 50000, 'Too many block hashes.');

  bw.writeU32(this.version);
  bw.writeVarint(this.locator.length);

  for (const hash of this.locator)
    bw.writeHash(hash);

  bw.writeHash(this.stop || encoding.ZERO_HASH);

  return bw;
};

/**
 * Serialize getblocks packet.
 * @returns {Buffer}
 */

GetBlocksPacket.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

GetBlocksPacket.prototype.fromReader = function fromReader(br) {
  this.version = br.readU32();

  const count = br.readVarint();

  assert(count <= 50000, 'Too many block hashes.');

  for (let i = 0; i < count; i++)
    this.locator.push(br.readHash('hex'));

  this.stop = br.readHash('hex');

  if (this.stop === encoding.NULL_HASH)
    this.stop = null;

  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

GetBlocksPacket.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate getblocks packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {GetBlocksPacket}
 */

GetBlocksPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new GetBlocksPacket().fromRaw(data);
};

/**
 * Represents a `getheaders` packet.
 * @extends GetBlocksPacket
 * @constructor
 * @param {Hash[]} locator
 * @param {Hash?} stop
 */

function GetHeadersPacket(locator, stop) {
  if (!(this instanceof GetHeadersPacket))
    return new GetHeadersPacket(locator, stop);

  GetBlocksPacket.call(this, locator, stop);
}

Object.setPrototypeOf(GetHeadersPacket.prototype, GetBlocksPacket.prototype);

GetHeadersPacket.prototype.cmd = 'getheaders';
GetHeadersPacket.prototype.type = exports.types.GETHEADERS;

/**
 * Instantiate getheaders packet from buffer reader.
 * @param {BufferReader} br
 * @returns {GetHeadersPacket}
 */

GetHeadersPacket.fromReader = function fromReader(br) {
  return new GetHeadersPacket().fromReader(br);
};

/**
 * Instantiate getheaders packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {GetHeadersPacket}
 */

GetHeadersPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new GetHeadersPacket().fromRaw(data);
};

/**
 * Represents a `headers` packet.
 * @constructor
 * @param {(Headers[])?} items
 * @property {Headers[]} items
 */

function HeadersPacket(items) {
  if (!(this instanceof HeadersPacket))
    return new HeadersPacket(items);

  Packet.call(this);

  this.items = items || [];
}

Object.setPrototypeOf(HeadersPacket.prototype, Packet.prototype);

HeadersPacket.prototype.cmd = 'headers';
HeadersPacket.prototype.type = exports.types.HEADERS;

/**
 * Get serialization size.
 * @returns {Number}
 */

HeadersPacket.prototype.getSize = function getSize() {
  let size = 0;

  size += encoding.sizeVarint(this.items.length);

  for (const item of this.items)
    size += item.getSize();

  return size;
};

/**
 * Serialize headers packet to writer.
 * @param {BufferWriter} bw
 */

HeadersPacket.prototype.toWriter = function toWriter(bw) {
  assert(this.items.length <= 2000, 'Too many headers.');

  bw.writeVarint(this.items.length);

  for (const item of this.items)
    item.toWriter(bw);

  return bw;
};

/**
 * Serialize headers packet.
 * @returns {Buffer}
 */

HeadersPacket.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

HeadersPacket.prototype.fromReader = function fromReader(br) {
  const count = br.readVarint();

  assert(count <= 2000, 'Too many headers.');

  for (let i = 0; i < count; i++)
    this.items.push(Headers.fromReader(br));

  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

HeadersPacket.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate headers packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {VerackPacket}
 */

HeadersPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new HeadersPacket().fromRaw(data);
};

/**
 * Represents a `sendheaders` packet.
 * @constructor
 */

function SendHeadersPacket() {
  if (!(this instanceof SendHeadersPacket))
    return new SendHeadersPacket();

  Packet.call(this);
}

Object.setPrototypeOf(SendHeadersPacket.prototype, Packet.prototype);

SendHeadersPacket.prototype.cmd = 'sendheaders';
SendHeadersPacket.prototype.type = exports.types.SENDHEADERS;

/**
 * Instantiate sendheaders packet from buffer reader.
 * @param {BufferReader} br
 * @returns {SendHeadersPacket}
 */

SendHeadersPacket.fromReader = function fromReader(br) {
  return new SendHeadersPacket().fromReader(br);
};

/**
 * Instantiate sendheaders packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {SendHeadersPacket}
 */

SendHeadersPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new SendHeadersPacket().fromRaw(data);
};

/**
 * Represents a `block` packet.
 * @constructor
 * @param {Block|null} block
 * @param {Boolean?} witness
 * @property {Block} block
 * @property {Boolean} witness
 */

function BlockPacket(block, witness) {
  if (!(this instanceof BlockPacket))
    return new BlockPacket(block, witness);

  Packet.call(this);

  this.block = block || new MemBlock();
  this.witness = witness || false;
}

Object.setPrototypeOf(BlockPacket.prototype, Packet.prototype);

BlockPacket.prototype.cmd = 'block';
BlockPacket.prototype.type = exports.types.BLOCK;

/**
 * Get serialization size.
 * @returns {Number}
 */

BlockPacket.prototype.getSize = function getSize() {
  if (this.witness)
    return this.block.getSize();
  return this.block.getBaseSize();
};

/**
 * Serialize block packet to writer.
 * @param {BufferWriter} bw
 */

BlockPacket.prototype.toWriter = function toWriter(bw) {
  if (this.witness)
    return this.block.toWriter(bw);
  return this.block.toNormalWriter(bw);
};

/**
 * Serialize block packet.
 * @returns {Buffer}
 */

BlockPacket.prototype.toRaw = function toRaw() {
  if (this.witness)
    return this.block.toRaw();
  return this.block.toNormal();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

BlockPacket.prototype.fromReader = function fromReader(br) {
  this.block.fromReader(br);
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

BlockPacket.prototype.fromRaw = function fromRaw(data) {
  this.block.fromRaw(data);
  return this;
};

/**
 * Instantiate block packet from buffer reader.
 * @param {BufferReader} br
 * @returns {BlockPacket}
 */

BlockPacket.fromReader = function fromReader(br) {
  return new BlockPacket().fromReader(br);
};

/**
 * Instantiate block packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {BlockPacket}
 */

BlockPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new BlockPacket().fromRaw(data);
};

/**
 * Represents a `tx` packet.
 * @constructor
 * @param {TX|null} tx
 * @param {Boolean?} witness
 * @property {TX} block
 * @property {Boolean} witness
 */

function TXPacket(tx, witness) {
  if (!(this instanceof TXPacket))
    return new TXPacket(tx, witness);

  Packet.call(this);

  this.tx = tx || new TX();
  this.witness = witness || false;
}

Object.setPrototypeOf(TXPacket.prototype, Packet.prototype);

TXPacket.prototype.cmd = 'tx';
TXPacket.prototype.type = exports.types.TX;

/**
 * Get serialization size.
 * @returns {Number}
 */

TXPacket.prototype.getSize = function getSize() {
  if (this.witness)
    return this.tx.getSize();
  return this.tx.getBaseSize();
};

/**
 * Serialize tx packet to writer.
 * @param {BufferWriter} bw
 */

TXPacket.prototype.toWriter = function toWriter(bw) {
  if (this.witness)
    return this.tx.toWriter(bw);
  return this.tx.toNormalWriter(bw);
};

/**
 * Serialize tx packet.
 * @returns {Buffer}
 */

TXPacket.prototype.toRaw = function toRaw() {
  if (this.witness)
    return this.tx.toRaw();
  return this.tx.toNormal();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

TXPacket.prototype.fromReader = function fromReader(br) {
  this.tx.fromRaw(br);
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

TXPacket.prototype.fromRaw = function fromRaw(data) {
  this.tx.fromRaw(data);
  return this;
};

/**
 * Instantiate tx packet from buffer reader.
 * @param {BufferReader} br
 * @returns {TXPacket}
 */

TXPacket.fromReader = function fromReader(br) {
  return new TXPacket().fromReader(br);
};

/**
 * Instantiate tx packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {TXPacket}
 */

TXPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new TXPacket().fromRaw(data);
};

/**
 * Reject Packet
 * @constructor
 * @property {(Number|String)?} code - Code
 * (see {@link RejectPacket.codes}).
 * @property {String?} msg - Message.
 * @property {String?} reason - Reason.
 * @property {(Hash|Buffer)?} data - Transaction or block hash.
 */

function RejectPacket(options) {
  if (!(this instanceof RejectPacket))
    return new RejectPacket(options);

  Packet.call(this);

  this.message = '';
  this.code = RejectPacket.codes.INVALID;
  this.reason = '';
  this.hash = null;

  if (options)
    this.fromOptions(options);
}

Object.setPrototypeOf(RejectPacket.prototype, Packet.prototype);

/**
 * Reject codes. Note that `internal` and higher
 * are not meant for use on the p2p network.
 * @enum {Number}
 * @default
 */

RejectPacket.codes = {
  MALFORMED: 0x01,
  INVALID: 0x10,
  OBSOLETE: 0x11,
  DUPLICATE: 0x12,
  NONSTANDARD: 0x40,
  DUST: 0x41,
  INSUFFICIENTFEE: 0x42,
  CHECKPOINT: 0x43,
  // Internal codes (NOT FOR USE ON NETWORK)
  INTERNAL: 0x100,
  HIGHFEE: 0x100,
  ALREADYKNOWN: 0x101,
  CONFLICT: 0x102
};

/**
 * Reject codes by value.
 * @const {RevMap}
 */

RejectPacket.codesByVal = util.reverse(RejectPacket.codes);

RejectPacket.prototype.cmd = 'reject';
RejectPacket.prototype.type = exports.types.REJECT;

/**
 * Inject properties from options object.
 * @private
 * @param {Object} options
 */

RejectPacket.prototype.fromOptions = function fromOptions(options) {
  let code = options.code;

  if (options.message)
    this.message = options.message;

  if (code != null) {
    if (typeof code === 'string')
      code = RejectPacket.codes[code.toUpperCase()];

    if (code >= RejectPacket.codes.INTERNAL)
      code = RejectPacket.codes.INVALID;

    this.code = code;
  }

  if (options.reason)
    this.reason = options.reason;

  if (options.hash)
    this.hash = options.hash;

  return this;
};

/**
 * Instantiate reject packet from options.
 * @param {Object} options
 * @returns {RejectPacket}
 */

RejectPacket.fromOptions = function fromOptions(options) {
  return new RejectPacket().fromOptions(options);
};

/**
 * Get uint256le hash if present.
 * @returns {Hash}
 */

RejectPacket.prototype.rhash = function rhash() {
  return this.hash ? util.revHex(this.hash) : null;
};

/**
 * Get symbolic code.
 * @returns {String}
 */

RejectPacket.prototype.getCode = function getCode() {
  const code = RejectPacket.codesByVal[this.code];

  if (!code)
    return this.code.toString(10);

  return code.toLowerCase();
};

/**
 * Get serialization size.
 * @returns {Number}
 */

RejectPacket.prototype.getSize = function getSize() {
  let size = 0;

  size += encoding.sizeVarString(this.message, 'ascii');
  size += 1;
  size += encoding.sizeVarString(this.reason, 'ascii');

  if (this.hash)
    size += 32;

  return size;
};

/**
 * Serialize reject packet to writer.
 * @param {BufferWriter} bw
 */

RejectPacket.prototype.toWriter = function toWriter(bw) {
  assert(this.message.length <= 12);
  assert(this.reason.length <= 111);

  bw.writeVarString(this.message, 'ascii');
  bw.writeU8(this.code);
  bw.writeVarString(this.reason, 'ascii');

  if (this.hash)
    bw.writeHash(this.hash);

  return bw;
};

/**
 * Serialize reject packet.
 * @returns {Buffer}
 */

RejectPacket.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

RejectPacket.prototype.fromReader = function fromReader(br) {
  this.message = br.readVarString('ascii', 12);
  this.code = br.readU8();
  this.reason = br.readVarString('ascii', 111);

  switch (this.message) {
    case 'block':
    case 'tx':
      this.hash = br.readHash('hex');
      break;
    default:
      this.hash = null;
      break;
  }

  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

RejectPacket.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate reject packet from buffer reader.
 * @param {BufferReader} br
 * @returns {RejectPacket}
 */

RejectPacket.fromReader = function fromReader(br) {
  return new RejectPacket().fromReader(br);
};

/**
 * Instantiate reject packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {RejectPacket}
 */

RejectPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new RejectPacket().fromRaw(data, enc);
};

/**
 * Inject properties from reason message and object.
 * @private
 * @param {Number} code
 * @param {String} reason
 * @param {String?} msg
 * @param {Hash?} hash
 */

RejectPacket.prototype.fromReason = function fromReason(code, reason, msg, hash) {
  if (typeof code === 'string')
    code = RejectPacket.codes[code.toUpperCase()];

  if (!code)
    code = RejectPacket.codes.INVALID;

  if (code >= RejectPacket.codes.INTERNAL)
    code = RejectPacket.codes.INVALID;

  this.message = '';
  this.code = code;
  this.reason = reason;

  if (msg) {
    assert(hash);
    this.message = msg;
    this.hash = hash;
  }

  return this;
};

/**
 * Instantiate reject packet from reason message.
 * @param {Number} code
 * @param {String} reason
 * @param {String?} msg
 * @param {Hash?} hash
 * @returns {RejectPacket}
 */

RejectPacket.fromReason = function fromReason(code, reason, msg, hash) {
  return new RejectPacket().fromReason(code, reason, msg, hash);
};

/**
 * Instantiate reject packet from verify error.
 * @param {VerifyError} err
 * @param {(TX|Block)?} obj
 * @returns {RejectPacket}
 */

RejectPacket.fromError = function fromError(err, obj) {
  return RejectPacket.fromReason(err.code, err.reason, obj);
};

/**
 * Inspect reject packet.
 * @returns {String}
 */

RejectPacket.prototype.inspect = function inspect() {
  const code = RejectPacket.codesByVal[this.code] || this.code;
  const hash = this.hash ? util.revHex(this.hash) : null;
  return '<Reject:'
    + ` msg=${this.message}`
    + ` code=${code}`
    + ` reason=${this.reason}`
    + ` hash=${hash}`
    + '>';
};

/**
 * Represents a `mempool` packet.
 * @constructor
 */

function MempoolPacket() {
  if (!(this instanceof MempoolPacket))
    return new MempoolPacket();

  Packet.call(this);
}

Object.setPrototypeOf(MempoolPacket.prototype, Packet.prototype);

MempoolPacket.prototype.cmd = 'mempool';
MempoolPacket.prototype.type = exports.types.MEMPOOL;

/**
 * Instantiate mempool packet from buffer reader.
 * @param {BufferReader} br
 * @returns {VerackPacket}
 */

MempoolPacket.fromReader = function fromReader(br) {
  return new MempoolPacket().fromReader(br);
};

/**
 * Instantiate mempool packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {VerackPacket}
 */

MempoolPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new MempoolPacket().fromRaw(data);
};

/**
 * Represents a `filterload` packet.
 * @constructor
 * @param {Bloom|null} filter
 */

function FilterLoadPacket(filter) {
  if (!(this instanceof FilterLoadPacket))
    return new FilterLoadPacket(filter);

  Packet.call(this);

  this.filter = filter || new Bloom();
}

Object.setPrototypeOf(FilterLoadPacket.prototype, Packet.prototype);

FilterLoadPacket.prototype.cmd = 'filterload';
FilterLoadPacket.prototype.type = exports.types.FILTERLOAD;

/**
 * Get serialization size.
 * @returns {Number}
 */

FilterLoadPacket.prototype.getSize = function getSize() {
  return this.filter.getSize();
};

/**
 * Serialize filterload packet to writer.
 * @param {BufferWriter} bw
 */

FilterLoadPacket.prototype.toWriter = function toWriter(bw) {
  return this.filter.toWriter(bw);
};

/**
 * Serialize filterload packet.
 * @returns {Buffer}
 */

FilterLoadPacket.prototype.toRaw = function toRaw() {
  return this.filter.toRaw();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

FilterLoadPacket.prototype.fromReader = function fromReader(br) {
  this.filter.fromReader(br);
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

FilterLoadPacket.prototype.fromRaw = function fromRaw(data) {
  this.filter.fromRaw(data);
  return this;
};

/**
 * Instantiate filterload packet from buffer reader.
 * @param {BufferReader} br
 * @returns {FilterLoadPacket}
 */

FilterLoadPacket.fromReader = function fromReader(br) {
  return new FilterLoadPacket().fromReader(br);
};

/**
 * Instantiate filterload packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {FilterLoadPacket}
 */

FilterLoadPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new FilterLoadPacket().fromRaw(data);
};

/**
 * Ensure the filter is within the size limits.
 * @returns {Boolean}
 */

FilterLoadPacket.prototype.isWithinConstraints = function isWithinConstraints() {
  return this.filter.isWithinConstraints();
};

/**
 * Represents a `filteradd` packet.
 * @constructor
 * @param {Buffer?} data
 * @property {Buffer} data
 */

function FilterAddPacket(data) {
  if (!(this instanceof FilterAddPacket))
    return new FilterAddPacket(data);

  Packet.call(this);

  this.data = data || DUMMY;
}

Object.setPrototypeOf(FilterAddPacket.prototype, Packet.prototype);

FilterAddPacket.prototype.cmd = 'filteradd';
FilterAddPacket.prototype.type = exports.types.FILTERADD;

/**
 * Get serialization size.
 * @returns {Number}
 */

FilterAddPacket.prototype.getSize = function getSize() {
  return encoding.sizeVarBytes(this.data);
};

/**
 * Serialize filteradd packet to writer.
 * @returns {BufferWriter} bw
 */

FilterAddPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeVarBytes(this.data);
  return bw;
};

/**
 * Serialize filteradd packet.
 * @returns {Buffer}
 */

FilterAddPacket.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

FilterAddPacket.prototype.fromReader = function fromReader(br) {
  this.data = br.readVarBytes();
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

FilterAddPacket.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate filteradd packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {FilterAddPacket}
 */

FilterAddPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new FilterAddPacket().fromRaw(data);
};

/**
 * Represents a `filterclear` packet.
 * @constructor
 */

function FilterClearPacket() {
  if (!(this instanceof FilterClearPacket))
    return new FilterClearPacket();

  Packet.call(this);
}

Object.setPrototypeOf(FilterClearPacket.prototype, Packet.prototype);

FilterClearPacket.prototype.cmd = 'filterclear';
FilterClearPacket.prototype.type = exports.types.FILTERCLEAR;

/**
 * Instantiate filterclear packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {FilterClearPacket}
 */

FilterClearPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new FilterClearPacket().fromRaw(data);
};

/**
 * Represents a `merkleblock` packet.
 * @constructor
 * @param {MerkleBlock?} block
 * @property {MerkleBlock} block
 */

function MerkleBlockPacket(block) {
  if (!(this instanceof MerkleBlockPacket))
    return new MerkleBlockPacket(block);

  Packet.call(this);

  this.block = block || new MerkleBlock();
}

Object.setPrototypeOf(MerkleBlockPacket.prototype, Packet.prototype);

MerkleBlockPacket.prototype.cmd = 'merkleblock';
MerkleBlockPacket.prototype.type = exports.types.MERKLEBLOCK;

/**
 * Get serialization size.
 * @returns {Number}
 */

MerkleBlockPacket.prototype.getSize = function getSize() {
  return this.block.getSize();
};

/**
 * Serialize merkleblock packet to writer.
 * @param {BufferWriter} bw
 */

MerkleBlockPacket.prototype.toWriter = function toWriter(bw) {
  return this.block.toWriter(bw);
};

/**
 * Serialize merkleblock packet.
 * @returns {Buffer}
 */

MerkleBlockPacket.prototype.toRaw = function toRaw() {
  return this.block.toRaw();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

MerkleBlockPacket.prototype.fromReader = function fromReader(br) {
  this.block.fromReader(br);
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

MerkleBlockPacket.prototype.fromRaw = function fromRaw(data) {
  this.block.fromRaw(data);
  return this;
};

/**
 * Instantiate merkleblock packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {MerkleBlockPacket}
 */

MerkleBlockPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new MerkleBlockPacket().fromRaw(data);
};

/**
 * Represents a `feefilter` packet.
 * @constructor
 * @param {Rate?} rate
 * @property {Rate} rate
 */

function FeeFilterPacket(rate) {
  if (!(this instanceof FeeFilterPacket))
    return new FeeFilterPacket(rate);

  Packet.call(this);

  this.rate = rate || 0;
}

Object.setPrototypeOf(FeeFilterPacket.prototype, Packet.prototype);

FeeFilterPacket.prototype.cmd = 'feefilter';
FeeFilterPacket.prototype.type = exports.types.FEEFILTER;

/**
 * Get serialization size.
 * @returns {Number}
 */

FeeFilterPacket.prototype.getSize = function getSize() {
  return 8;
};

/**
 * Serialize feefilter packet to writer.
 * @param {BufferWriter} bw
 */

FeeFilterPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeI64(this.rate);
  return bw;
};

/**
 * Serialize feefilter packet.
 * @returns {Buffer}
 */

FeeFilterPacket.prototype.toRaw = function toRaw() {
  return this.toWriter(new StaticWriter(8)).render();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

FeeFilterPacket.prototype.fromReader = function fromReader(br) {
  this.rate = br.readI64();
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

FeeFilterPacket.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate feefilter packet from buffer reader.
 * @param {BufferReader} br
 * @returns {FeeFilterPacket}
 */

FeeFilterPacket.fromReader = function fromReader(br) {
  return new FeeFilterPacket().fromReader(br);
};

/**
 * Instantiate feefilter packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {FeeFilterPacket}
 */

FeeFilterPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new FeeFilterPacket().fromRaw(data);
};

/**
 * Represents a `sendcmpct` packet.
 * @constructor
 * @param {Number|null} mode
 * @param {Number|null} version
 * @property {Number} mode
 * @property {Number} version
 */

function SendCmpctPacket(mode, version) {
  if (!(this instanceof SendCmpctPacket))
    return new SendCmpctPacket(mode, version);

  Packet.call(this);

  this.mode = mode || 0;
  this.version = version || 1;
}

Object.setPrototypeOf(SendCmpctPacket.prototype, Packet.prototype);

SendCmpctPacket.prototype.cmd = 'sendcmpct';
SendCmpctPacket.prototype.type = exports.types.SENDCMPCT;

/**
 * Get serialization size.
 * @returns {Number}
 */

SendCmpctPacket.prototype.getSize = function getSize() {
  return 9;
};

/**
 * Serialize sendcmpct packet to writer.
 * @param {BufferWriter} bw
 */

SendCmpctPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeU8(this.mode);
  bw.writeU64(this.version);
  return bw;
};

/**
 * Serialize sendcmpct packet.
 * @returns {Buffer}
 */

SendCmpctPacket.prototype.toRaw = function toRaw() {
  return this.toWriter(new StaticWriter(9)).render();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

SendCmpctPacket.prototype.fromReader = function fromReader(br) {
  this.mode = br.readU8();
  this.version = br.readU64();
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

SendCmpctPacket.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate sendcmpct packet from buffer reader.
 * @param {BufferReader} br
 * @returns {SendCmpctPacket}
 */

SendCmpctPacket.fromReader = function fromReader(br) {
  return new SendCmpctPacket().fromReader(br);
};

/**
 * Instantiate sendcmpct packet from buffer reader.
 * @param {BufferReader} br
 * @returns {SendCmpctPacket}
 */

SendCmpctPacket.fromReader = function fromReader(br) {
  return new SendCmpctPacket().fromReader(br);
};

/**
 * Instantiate sendcmpct packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {SendCmpctPacket}
 */

SendCmpctPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new SendCmpctPacket().fromRaw(data);
};

/**
 * Represents a `cmpctblock` packet.
 * @constructor
 * @param {Block|null} block
 * @param {Boolean|null} witness
 * @property {Block} block
 * @property {Boolean} witness
 */

function CmpctBlockPacket(block, witness) {
  if (!(this instanceof CmpctBlockPacket))
    return new CmpctBlockPacket(block, witness);

  Packet.call(this);

  this.block = block || new bip152.CompactBlock();
  this.witness = witness || false;
}

Object.setPrototypeOf(CmpctBlockPacket.prototype, Packet.prototype);

CmpctBlockPacket.prototype.cmd = 'cmpctblock';
CmpctBlockPacket.prototype.type = exports.types.CMPCTBLOCK;

/**
 * Serialize cmpctblock packet.
 * @returns {Buffer}
 */

CmpctBlockPacket.prototype.getSize = function getSize() {
  if (this.witness)
    return this.block.getSize(true);
  return this.block.getSize(false);
};

/**
 * Serialize cmpctblock packet to writer.
 * @param {BufferWriter} bw
 */

CmpctBlockPacket.prototype.toWriter = function toWriter(bw) {
  if (this.witness)
    return this.block.toWriter(bw);
  return this.block.toNormalWriter(bw);
};

/**
 * Serialize cmpctblock packet.
 * @returns {Buffer}
 */

CmpctBlockPacket.prototype.toRaw = function toRaw() {
  if (this.witness)
    return this.block.toRaw();
  return this.block.toNormal();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

CmpctBlockPacket.prototype.fromReader = function fromReader(br) {
  this.block.fromReader(br);
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

CmpctBlockPacket.prototype.fromRaw = function fromRaw(data) {
  this.block.fromRaw(data);
  return this;
};

/**
 * Instantiate cmpctblock packet from buffer reader.
 * @param {BufferReader} br
 * @returns {CmpctBlockPacket}
 */

CmpctBlockPacket.fromReader = function fromReader(br) {
  return new CmpctBlockPacket().fromRaw(br);
};

/**
 * Instantiate cmpctblock packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {CmpctBlockPacket}
 */

CmpctBlockPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new CmpctBlockPacket().fromRaw(data);
};

/**
 * Represents a `getblocktxn` packet.
 * @constructor
 * @param {TXRequest?} request
 * @property {TXRequest} request
 */

function GetBlockTxnPacket(request) {
  if (!(this instanceof GetBlockTxnPacket))
    return new GetBlockTxnPacket(request);

  Packet.call(this);

  this.request = request || new bip152.TXRequest();
}

Object.setPrototypeOf(GetBlockTxnPacket.prototype, Packet.prototype);

GetBlockTxnPacket.prototype.cmd = 'getblocktxn';
GetBlockTxnPacket.prototype.type = exports.types.GETBLOCKTXN;

/**
 * Get serialization size.
 * @returns {Number}
 */

GetBlockTxnPacket.prototype.getSize = function getSize() {
  return this.request.getSize();
};

/**
 * Serialize getblocktxn packet to writer.
 * @param {BufferWriter} bw
 */

GetBlockTxnPacket.prototype.toWriter = function toWriter(bw) {
  return this.request.toWriter(bw);
};

/**
 * Serialize getblocktxn packet.
 * @returns {Buffer}
 */

GetBlockTxnPacket.prototype.toRaw = function toRaw() {
  return this.request.toRaw();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

GetBlockTxnPacket.prototype.fromReader = function fromReader(br) {
  this.request.fromReader(br);
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

GetBlockTxnPacket.prototype.fromRaw = function fromRaw(data) {
  this.request.fromRaw(data);
  return this;
};

/**
 * Instantiate getblocktxn packet from buffer reader.
 * @param {BufferReader} br
 * @returns {GetBlockTxnPacket}
 */

GetBlockTxnPacket.fromReader = function fromReader(br) {
  return new GetBlockTxnPacket().fromReader(br);
};

/**
 * Instantiate getblocktxn packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {GetBlockTxnPacket}
 */

GetBlockTxnPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new GetBlockTxnPacket().fromRaw(data);
};

/**
 * Represents a `blocktxn` packet.
 * @constructor
 * @param {TXResponse?} response
 * @param {Boolean?} witness
 * @property {TXResponse} response
 * @property {Boolean} witness
 */

function BlockTxnPacket(response, witness) {
  if (!(this instanceof BlockTxnPacket))
    return new BlockTxnPacket(response, witness);

  Packet.call(this);

  this.response = response || new bip152.TXResponse();
  this.witness = witness || false;
}

Object.setPrototypeOf(BlockTxnPacket.prototype, Packet.prototype);

BlockTxnPacket.prototype.cmd = 'blocktxn';
BlockTxnPacket.prototype.type = exports.types.BLOCKTXN;

/**
 * Get serialization size.
 * @returns {Number}
 */

BlockTxnPacket.prototype.getSize = function getSize() {
  if (this.witness)
    return this.response.getSize(true);
  return this.response.getSize(false);
};

/**
 * Serialize blocktxn packet to writer.
 * @param {BufferWriter} bw
 */

BlockTxnPacket.prototype.toWriter = function toWriter(bw) {
  if (this.witness)
    return this.response.toWriter(bw);
  return this.response.toNormalWriter(bw);
};

/**
 * Serialize blocktxn packet.
 * @returns {Buffer}
 */

BlockTxnPacket.prototype.toRaw = function toRaw() {
  if (this.witness)
    return this.response.toRaw();
  return this.response.toNormal();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

BlockTxnPacket.prototype.fromReader = function fromReader(br) {
  this.response.fromReader(br);
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

BlockTxnPacket.prototype.fromRaw = function fromRaw(data) {
  this.response.fromRaw(data);
  return this;
};

/**
 * Instantiate blocktxn packet from buffer reader.
 * @param {BufferReader} br
 * @returns {BlockTxnPacket}
 */

BlockTxnPacket.fromReader = function fromReader(br) {
  return new BlockTxnPacket().fromReader(br);
};

/**
 * Instantiate blocktxn packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {BlockTxnPacket}
 */

BlockTxnPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new BlockTxnPacket().fromRaw(data);
};

/**
 * Represents a `encinit` packet.
 * @constructor
 * @param {Buffer|null} publicKey
 * @param {Number|null} cipher
 * @property {Buffer} publicKey
 * @property {Number} cipher
 */

function EncinitPacket(publicKey, cipher) {
  if (!(this instanceof EncinitPacket))
    return new EncinitPacket(publicKey, cipher);

  Packet.call(this);

  this.publicKey = publicKey || encoding.ZERO_KEY;
  this.cipher = cipher || 0;
}

Object.setPrototypeOf(EncinitPacket.prototype, Packet.prototype);

EncinitPacket.prototype.cmd = 'encinit';
EncinitPacket.prototype.type = exports.types.ENCINIT;

/**
 * Get serialization size.
 * @returns {Number}
 */

EncinitPacket.prototype.getSize = function getSize() {
  return 34;
};

/**
 * Serialize encinit packet to writer.
 * @param {BufferWriter} bw
 */

EncinitPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeBytes(this.publicKey);
  bw.writeU8(this.cipher);
  return bw;
};

/**
 * Serialize encinit packet.
 * @returns {Buffer}
 */

EncinitPacket.prototype.toRaw = function toRaw() {
  return this.toWriter(new StaticWriter(34)).render();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

EncinitPacket.prototype.fromReader = function fromReader(br) {
  this.publicKey = br.readBytes(33);
  this.cipher = br.readU8();
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

EncinitPacket.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate getblocks packet from buffer reader.
 * @param {BufferReader} br
 * @returns {EncinitPacket}
 */

EncinitPacket.fromReader = function fromReader(br) {
  return new EncinitPacket().fromReader(br);
};

/**
 * Instantiate getblocks packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {EncinitPacket}
 */

EncinitPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new EncinitPacket().fromRaw(data);
};

/**
 * Represents a `encack` packet.
 * @constructor
 * @param {Buffer?} publicKey
 * @property {Buffer} publicKey
 */

function EncackPacket(publicKey) {
  if (!(this instanceof EncackPacket))
    return new EncackPacket(publicKey);

  Packet.call(this);

  this.publicKey = publicKey || encoding.ZERO_KEY;
}

Object.setPrototypeOf(EncackPacket.prototype, Packet.prototype);

EncackPacket.prototype.cmd = 'encack';
EncackPacket.prototype.type = exports.types.ENCACK;

/**
 * Get serialization size.
 * @returns {Number}
 */

EncackPacket.prototype.getSize = function getSize() {
  return 33;
};

/**
 * Serialize encack packet to writer.
 * @param {BufferWriter} bw
 */

EncackPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeBytes(this.publicKey);
  return bw;
};

/**
 * Serialize encack packet.
 * @returns {Buffer}
 */

EncackPacket.prototype.toRaw = function toRaw() {
  return this.publicKey;
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

EncackPacket.prototype.fromReader = function fromReader(br) {
  this.publicKey = br.readBytes(33);
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

EncackPacket.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate encack packet from buffer reader.
 * @param {BufferReader} br
 * @returns {EncackPacket}
 */

EncackPacket.fromReader = function fromReader(br) {
  return new EncackPacket().fromReader(br);
};

/**
 * Instantiate encack packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {EncackPacket}
 */

EncackPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new EncackPacket().fromRaw(data);
};

/**
 * Represents a `authchallenge` packet.
 * @constructor
 * @param {Buffer?} hash
 * @property {Buffer} hash
 */

function AuthChallengePacket(hash) {
  if (!(this instanceof AuthChallengePacket))
    return new AuthChallengePacket(hash);

  Packet.call(this);

  this.hash = hash || encoding.ZERO_HASH;
}

Object.setPrototypeOf(AuthChallengePacket.prototype, Packet.prototype);

AuthChallengePacket.prototype.cmd = 'authchallenge';
AuthChallengePacket.prototype.type = exports.types.AUTHCHALLENGE;

/**
 * Get serialization size.
 * @returns {Number}
 */

EncackPacket.prototype.getSize = function getSize() {
  return 32;
};

/**
 * Serialize authchallenge packet to writer.
 * @param {BufferWriter} bw
 */

AuthChallengePacket.prototype.toWriter = function toWriter(bw) {
  bw.writeBytes(this.hash);
  return bw;
};

/**
 * Serialize authchallenge packet.
 * @returns {Buffer}
 */

AuthChallengePacket.prototype.toRaw = function toRaw() {
  return this.hash;
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

AuthChallengePacket.prototype.fromReader = function fromReader(br) {
  this.hash = br.readHash();
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

AuthChallengePacket.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate authchallenge packet from buffer reader.
 * @param {BufferReader} br
 * @returns {AuthChallengePacket}
 */

AuthChallengePacket.fromReader = function fromReader(br) {
  return new AuthChallengePacket().fromReader(br);
};

/**
 * Instantiate authchallenge packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {AuthChallengePacket}
 */

AuthChallengePacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new AuthChallengePacket().fromRaw(data);
};

/**
 * Represents a `authreply` packet.
 * @constructor
 * @param {Buffer?} signature
 * @property {Buffer} signature
 */

function AuthReplyPacket(signature) {
  if (!(this instanceof AuthReplyPacket))
    return new AuthReplyPacket(signature);

  Packet.call(this);

  this.signature = signature || encoding.ZERO_SIG64;
}

Object.setPrototypeOf(AuthReplyPacket.prototype, Packet.prototype);

AuthReplyPacket.prototype.cmd = 'authreply';
AuthReplyPacket.prototype.type = exports.types.AUTHREPLY;

/**
 * Get serialization size.
 * @returns {Number}
 */

AuthReplyPacket.prototype.getSize = function getSize() {
  return 64;
};

/**
 * Serialize authreply packet to writer.
 * @param {BufferWriter} bw
 */

AuthReplyPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeBytes(this.signature);
  return bw;
};

/**
 * Serialize authreply packet.
 * @returns {Buffer}
 */

AuthReplyPacket.prototype.toRaw = function toRaw() {
  return this.signature;
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

AuthReplyPacket.prototype.fromReader = function fromReader(br) {
  this.signature = br.readBytes(64);
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

AuthReplyPacket.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate authreply packet from buffer reader.
 * @param {BufferReader} br
 * @returns {AuthReplyPacket}
 */

AuthReplyPacket.fromReader = function fromReader(br) {
  return new AuthReplyPacket().fromReader(br);
};

/**
 * Instantiate authreply packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {AuthReplyPacket}
 */

AuthReplyPacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new AuthReplyPacket().fromRaw(data);
};

/**
 * Represents a `authpropose` packet.
 * @constructor
 * @param {Hash?} hash
 * @property {Hash} hash
 */

function AuthProposePacket(hash) {
  if (!(this instanceof AuthProposePacket))
    return new AuthProposePacket(hash);

  Packet.call(this);

  this.hash = hash || encoding.ZERO_HASH;
}

Object.setPrototypeOf(AuthProposePacket.prototype, Packet.prototype);

AuthProposePacket.prototype.cmd = 'authpropose';
AuthProposePacket.prototype.type = exports.types.AUTHPROPOSE;

/**
 * Get serialization size.
 * @returns {Number}
 */

AuthProposePacket.prototype.getSize = function getSize() {
  return 32;
};

/**
 * Serialize authpropose packet to writer.
 * @param {BufferWriter} bw
 */

AuthProposePacket.prototype.toWriter = function toWriter(bw) {
  bw.writeBytes(this.hash);
  return bw;
};

/**
 * Serialize authpropose packet.
 * @returns {Buffer}
 */

AuthProposePacket.prototype.toRaw = function toRaw() {
  return this.hash;
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

AuthProposePacket.prototype.fromReader = function fromReader(br) {
  this.hash = br.readHash();
  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

AuthProposePacket.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate authpropose packet from buffer reader.
 * @param {BufferReader} br
 * @returns {AuthProposePacket}
 */

AuthProposePacket.fromReader = function fromReader(br) {
  return new AuthProposePacket().fromReader(br);
};

/**
 * Instantiate authpropose packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {AuthProposePacket}
 */

AuthProposePacket.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new AuthProposePacket().fromRaw(data);
};

/**
 * Represents an unknown packet.
 * @constructor
 * @param {String|null} cmd
 * @param {Buffer|null} data
 * @property {String} cmd
 * @property {Buffer} data
 */

function UnknownPacket(cmd, data) {
  if (!(this instanceof UnknownPacket))
    return new UnknownPacket(cmd, data);

  Packet.call(this);

  this.cmd = cmd;
  this.data = data;
}

Object.setPrototypeOf(UnknownPacket.prototype, Packet.prototype);

UnknownPacket.prototype.type = exports.types.UNKNOWN;

/**
 * Get serialization size.
 * @returns {Number}
 */

UnknownPacket.prototype.getSize = function getSize() {
  return this.data.length;
};

/**
 * Serialize unknown packet to writer.
 * @param {BufferWriter} bw
 */

UnknownPacket.prototype.toWriter = function toWriter(bw) {
  bw.writeBytes(this.data);
  return bw;
};

/**
 * Serialize unknown packet.
 * @returns {Buffer}
 */

UnknownPacket.prototype.toRaw = function toRaw() {
  return this.data;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

UnknownPacket.prototype.fromRaw = function fromRaw(cmd, data) {
  assert(Buffer.isBuffer(data));
  this.cmd = cmd;
  this.data = data;
  return this;
};

/**
 * Instantiate unknown packet from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {UnknownPacket}
 */

UnknownPacket.fromRaw = function fromRaw(cmd, data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new UnknownPacket().fromRaw(cmd, data);
};

/**
 * Parse a payload.
 * @param {String} cmd
 * @param {Buffer} data
 * @returns {Packet}
 */

exports.fromRaw = function fromRaw(cmd, data) {
  switch (cmd) {
    case 'version':
      return VersionPacket.fromRaw(data);
    case 'verack':
      return VerackPacket.fromRaw(data);
    case 'ping':
      return PingPacket.fromRaw(data);
    case 'pong':
      return PongPacket.fromRaw(data);
    case 'getaddr':
      return GetAddrPacket.fromRaw(data);
    case 'addr':
      return AddrPacket.fromRaw(data);
    case 'inv':
      return InvPacket.fromRaw(data);
    case 'getdata':
      return GetDataPacket.fromRaw(data);
    case 'notfound':
      return NotFoundPacket.fromRaw(data);
    case 'getblocks':
      return GetBlocksPacket.fromRaw(data);
    case 'getheaders':
      return GetHeadersPacket.fromRaw(data);
    case 'headers':
      return HeadersPacket.fromRaw(data);
    case 'sendheaders':
      return SendHeadersPacket.fromRaw(data);
    case 'block':
      return BlockPacket.fromRaw(data);
    case 'tx':
      return TXPacket.fromRaw(data);
    case 'reject':
      return RejectPacket.fromRaw(data);
    case 'mempool':
      return MempoolPacket.fromRaw(data);
    case 'filterload':
      return FilterLoadPacket.fromRaw(data);
    case 'filteradd':
      return FilterAddPacket.fromRaw(data);
    case 'filterclear':
      return FilterClearPacket.fromRaw(data);
    case 'merkleblock':
      return MerkleBlockPacket.fromRaw(data);
    case 'feefilter':
      return FeeFilterPacket.fromRaw(data);
    case 'sendcmpct':
      return SendCmpctPacket.fromRaw(data);
    case 'cmpctblock':
      return CmpctBlockPacket.fromRaw(data);
    case 'getblocktxn':
      return GetBlockTxnPacket.fromRaw(data);
    case 'blocktxn':
      return BlockTxnPacket.fromRaw(data);
    case 'encinit':
      return EncinitPacket.fromRaw(data);
    case 'encack':
      return EncackPacket.fromRaw(data);
    case 'authchallenge':
      return AuthChallengePacket.fromRaw(data);
    case 'authreply':
      return AuthReplyPacket.fromRaw(data);
    case 'authpropose':
      return AuthProposePacket.fromRaw(data);
    default:
      return UnknownPacket.fromRaw(cmd, data);
  }
};

/*
 * Expose
 */

exports.Packet = Packet;
exports.VersionPacket = VersionPacket;
exports.VerackPacket = VerackPacket;
exports.PingPacket = PingPacket;
exports.PongPacket = PongPacket;
exports.GetAddrPacket = GetAddrPacket;
exports.AddrPacket = AddrPacket;
exports.InvPacket = InvPacket;
exports.GetDataPacket = GetDataPacket;
exports.NotFoundPacket = NotFoundPacket;
exports.GetBlocksPacket = GetBlocksPacket;
exports.GetHeadersPacket = GetHeadersPacket;
exports.HeadersPacket = HeadersPacket;
exports.SendHeadersPacket = SendHeadersPacket;
exports.BlockPacket = BlockPacket;
exports.TXPacket = TXPacket;
exports.RejectPacket = RejectPacket;
exports.MempoolPacket = MempoolPacket;
exports.FilterLoadPacket = FilterLoadPacket;
exports.FilterAddPacket = FilterAddPacket;
exports.FilterClearPacket = FilterClearPacket;
exports.MerkleBlockPacket = MerkleBlockPacket;
exports.FeeFilterPacket = FeeFilterPacket;
exports.SendCmpctPacket = SendCmpctPacket;
exports.CmpctBlockPacket = CmpctBlockPacket;
exports.GetBlockTxnPacket = GetBlockTxnPacket;
exports.BlockTxnPacket = BlockTxnPacket;
exports.EncinitPacket = EncinitPacket;
exports.EncackPacket = EncackPacket;
exports.AuthChallengePacket = AuthChallengePacket;
exports.AuthReplyPacket = AuthReplyPacket;
exports.AuthProposePacket = AuthProposePacket;
exports.UnknownPacket = UnknownPacket;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * common.js - commonly required functions for wallet
 */



/**
 * @exports wallet/common
 */

const common = exports;

/**
 * Test whether a string is eligible
 * to be used as a name or ID.
 * @param {String} key
 * @returns {Boolean}
 */

common.isName = function isName(key) {
  if (typeof key !== 'string')
    return false;

  if (key.length === 0)
    return false;

  if (!/^[\-\._0-9A-Za-z ]+$/.test(key))
    return false;

  if (/[ ]{2,}/.test(key))
    return false;

  // Prevents __proto__
  // from being used.
  switch (key[0]) {
    case '_':
    case '-':
    case '.':
      return false;
  }

  switch (key[key.length - 1]) {
    case '_':
    case '-':
    case '.':
      return false;
  }

  return key.length >= 1 && key.length <= 40;
};

/**
 * Sort an array of transactions by time.
 * @param {TX[]} txs
 * @returns {TX[]}
 */

common.sortTX = function sortTX(txs) {
  return txs.sort((a, b) => {
    return a.mtime - b.mtime;
  });
};

/**
 * Sort an array of coins by height.
 * @param {Coin[]} txs
 * @returns {Coin[]}
 */

common.sortCoins = function sortCoins(coins) {
  return coins.sort((a, b) => {
    a = a.height === -1 ? 0x7fffffff : a.height;
    b = b.height === -1 ? 0x7fffffff : b.height;
    return a - b;
  });
};

/**
 * Sort an array of transactions in dependency order.
 * @param {TX[]} txs
 * @returns {TX[]}
 */

common.sortDeps = function sortDeps(txs) {
  const map = new Map();

  for (const tx of txs) {
    const hash = tx.hash('hex');
    map.set(hash, tx);
  }

  const depMap = new Map();
  const depCount = new Map();
  const top = [];

  for (const [hash, tx] of map) {
    depCount.set(hash, 0);

    let hasDeps = false;

    for (const input of tx.inputs) {
      const prev = input.prevout.hash;

      if (!map.has(prev))
        continue;

      const count = depCount.get(hash);
      depCount.set(hash, count + 1);
      hasDeps = true;

      if (!depMap.has(prev))
        depMap.set(prev, []);

      depMap.get(prev).push(tx);
    }

    if (hasDeps)
      continue;

    top.push(tx);
  }

  const result = [];

  for (const tx of top) {
    const hash = tx.hash('hex');
    const deps = depMap.get(hash);

    result.push(tx);

    if (!deps)
      continue;

    for (const tx of deps) {
      const hash = tx.hash('hex');
      let count = depCount.get(hash);

      if (--count === 0)
        top.push(tx);

      depCount.set(hash, count);
    }
  }

  return result;
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * writer.js - buffer writer for wmcc_core.
 */



const assert = __webpack_require__(0);
const encoding = __webpack_require__(3);
const digest = __webpack_require__(5);

/*
 * Constants
 */

const SEEK = 0;
const UI8 = 1;
const UI16 = 2;
const UI16BE = 3;
const UI32 = 4;
const UI32BE = 5;
const UI64 = 6;
const UI64BE = 7;
const UI64N = 8;
const UI64BEN = 9;
const I8 = 10;
const I16 = 11;
const I16BE = 12;
const I32 = 13;
const I32BE = 14;
const I64 = 15;
const I64BE = 16;
const I64N = 17;
const I64BEN = 18;
const FL = 19;
const FLBE = 20;
const DBL = 21;
const DBLBE = 22;
const VARINT = 23;
const VARINTN = 24;
const VARINT2 = 25;
const VARINT2N = 26;
const BYTES = 27;
const STR = 28;
const CHECKSUM = 29;
const FILL = 30;

/**
 * An object that allows writing of buffers in a
 * sane manner. This buffer writer is extremely
 * optimized since it does not actually write
 * anything until `render` is called. It makes
 * one allocation: at the end, once it knows the
 * size of the buffer to be allocated. Because
 * of this, it can also act as a size calculator
 * which is useful for guaging block size
 * without actually serializing any data.
 * @alias module:utils.BufferWriter
 * @constructor
 */

function BufferWriter() {
  if (!(this instanceof BufferWriter))
    return new BufferWriter();

  this.ops = [];
  this.offset = 0;
}

/**
 * Allocate and render the final buffer.
 * @returns {Buffer} Rendered buffer.
 */

BufferWriter.prototype.render = function render() {
  const data = Buffer.allocUnsafe(this.offset);
  let off = 0;

  for (const op of this.ops) {
    switch (op.type) {
      case SEEK:
        off += op.value;
        break;
      case UI8:
        off = data.writeUInt8(op.value, off, true);
        break;
      case UI16:
        off = data.writeUInt16LE(op.value, off, true);
        break;
      case UI16BE:
        off = data.writeUInt16BE(op.value, off, true);
        break;
      case UI32:
        off = data.writeUInt32LE(op.value, off, true);
        break;
      case UI32BE:
        off = data.writeUInt32BE(op.value, off, true);
        break;
      case UI64:
        off = encoding.writeU64(data, op.value, off);
        break;
      case UI64BE:
        off = encoding.writeU64BE(data, op.value, off);
        break;
      case UI64N:
        off = encoding.writeU64N(data, op.value, off);
        break;
      case UI64BEN:
        off = encoding.writeU64BEN(data, op.value, off);
        break;
      case I8:
        off = data.writeInt8(op.value, off, true);
        break;
      case I16:
        off = data.writeInt16LE(op.value, off, true);
        break;
      case I16BE:
        off = data.writeInt16BE(op.value, off, true);
        break;
      case I32:
        off = data.writeInt32LE(op.value, off, true);
        break;
      case I32BE:
        off = data.writeInt32BE(op.value, off, true);
        break;
      case I64:
        off = encoding.writeI64(data, op.value, off);
        break;
      case I64BE:
        off = encoding.writeI64BE(data, op.value, off);
        break;
      case I64N:
        off = encoding.writeI64N(data, op.value, off);
        break;
      case I64BEN:
        off = encoding.writeI64BEN(data, op.value, off);
        break;
      case FL:
        off = data.writeFloatLE(op.value, off, true);
        break;
      case FLBE:
        off = data.writeFloatBE(op.value, off, true);
        break;
      case DBL:
        off = data.writeDoubleLE(op.value, off, true);
        break;
      case DBLBE:
        off = data.writeDoubleBE(op.value, off, true);
        break;
      case VARINT:
        off = encoding.writeVarint(data, op.value, off);
        break;
      case VARINTN:
        off = encoding.writeVarintN(data, op.value, off);
        break;
      case VARINT2:
        off = encoding.writeVarint2(data, op.value, off);
        break;
      case VARINT2N:
        off = encoding.writeVarint2N(data, op.value, off);
        break;
      case BYTES:
        off += op.value.copy(data, off);
        break;
      case STR:
        off += data.write(op.value, off, op.enc);
        break;
      case CHECKSUM:
        off += digest.hash256(data.slice(0, off)).copy(data, off, 0, 4);
        break;
      case FILL:
        data.fill(op.value, off, off + op.size);
        off += op.size;
        break;
      default:
        assert(false, 'Bad type.');
        break;
    }
  }

  assert(off === data.length);

  this.destroy();

  return data;
};

/**
 * Get size of data written so far.
 * @returns {Number}
 */

BufferWriter.prototype.getSize = function getSize() {
  return this.offset;
};

/**
 * Seek to relative offset.
 * @param {Number} offset
 */

BufferWriter.prototype.seek = function seek(offset) {
  this.offset += offset;
  this.ops.push(new WriteOp(SEEK, offset));
};

/**
 * Destroy the buffer writer. Remove references to `ops`.
 */

BufferWriter.prototype.destroy = function destroy() {
  this.ops.length = 0;
  this.offset = 0;
};

/**
 * Write uint8.
 * @param {Number} value
 */

BufferWriter.prototype.writeU8 = function writeU8(value) {
  this.offset += 1;
  this.ops.push(new WriteOp(UI8, value));
};

/**
 * Write uint16le.
 * @param {Number} value
 */

BufferWriter.prototype.writeU16 = function writeU16(value) {
  this.offset += 2;
  this.ops.push(new WriteOp(UI16, value));
};

/**
 * Write uint16be.
 * @param {Number} value
 */

BufferWriter.prototype.writeU16BE = function writeU16BE(value) {
  this.offset += 2;
  this.ops.push(new WriteOp(UI16BE, value));
};

/**
 * Write uint32le.
 * @param {Number} value
 */

BufferWriter.prototype.writeU32 = function writeU32(value) {
  this.offset += 4;
  this.ops.push(new WriteOp(UI32, value));
};

/**
 * Write uint32be.
 * @param {Number} value
 */

BufferWriter.prototype.writeU32BE = function writeU32BE(value) {
  this.offset += 4;
  this.ops.push(new WriteOp(UI32BE, value));
};

/**
 * Write uint64le.
 * @param {Number} value
 */

BufferWriter.prototype.writeU64 = function writeU64(value) {
  this.offset += 8;
  this.ops.push(new WriteOp(UI64, value));
};

/**
 * Write uint64be.
 * @param {Number} value
 */

BufferWriter.prototype.writeU64BE = function writeU64BE(value) {
  this.offset += 8;
  this.ops.push(new WriteOp(UI64BE, value));
};

/**
 * Write uint64le.
 * @param {U64} value
 */

BufferWriter.prototype.writeU64N = function writeU64N(value) {
  this.offset += 8;
  this.ops.push(new WriteOp(UI64N, value));
};

/**
 * Write uint64be.
 * @param {U64} value
 */

BufferWriter.prototype.writeU64BEN = function writeU64BEN(value) {
  this.offset += 8;
  this.ops.push(new WriteOp(UI64BEN, value));
};

/**
 * Write int8.
 * @param {Number} value
 */

BufferWriter.prototype.writeI8 = function writeI8(value) {
  this.offset += 1;
  this.ops.push(new WriteOp(I8, value));
};

/**
 * Write int16le.
 * @param {Number} value
 */

BufferWriter.prototype.writeI16 = function writeI16(value) {
  this.offset += 2;
  this.ops.push(new WriteOp(I16, value));
};

/**
 * Write int16be.
 * @param {Number} value
 */

BufferWriter.prototype.writeI16BE = function writeI16BE(value) {
  this.offset += 2;
  this.ops.push(new WriteOp(I16BE, value));
};

/**
 * Write int32le.
 * @param {Number} value
 */

BufferWriter.prototype.writeI32 = function writeI32(value) {
  this.offset += 4;
  this.ops.push(new WriteOp(I32, value));
};

/**
 * Write int32be.
 * @param {Number} value
 */

BufferWriter.prototype.writeI32BE = function writeI32BE(value) {
  this.offset += 4;
  this.ops.push(new WriteOp(I32BE, value));
};

/**
 * Write int64le.
 * @param {Number} value
 */

BufferWriter.prototype.writeI64 = function writeI64(value) {
  this.offset += 8;
  this.ops.push(new WriteOp(I64, value));
};

/**
 * Write int64be.
 * @param {Number} value
 */

BufferWriter.prototype.writeI64BE = function writeI64BE(value) {
  this.offset += 8;
  this.ops.push(new WriteOp(I64BE, value));
};

/**
 * Write int64le.
 * @param {I64} value
 */

BufferWriter.prototype.writeI64N = function writeI64N(value) {
  this.offset += 8;
  this.ops.push(new WriteOp(I64N, value));
};

/**
 * Write int64be.
 * @param {I64} value
 */

BufferWriter.prototype.writeI64BEN = function writeI64BEN(value) {
  this.offset += 8;
  this.ops.push(new WriteOp(I64BEN, value));
};

/**
 * Write float le.
 * @param {Number} value
 */

BufferWriter.prototype.writeFloat = function writeFloat(value) {
  this.offset += 4;
  this.ops.push(new WriteOp(FL, value));
};

/**
 * Write float be.
 * @param {Number} value
 */

BufferWriter.prototype.writeFloatBE = function writeFloatBE(value) {
  this.offset += 4;
  this.ops.push(new WriteOp(FLBE, value));
};

/**
 * Write double le.
 * @param {Number} value
 */

BufferWriter.prototype.writeDouble = function writeDouble(value) {
  this.offset += 8;
  this.ops.push(new WriteOp(DBL, value));
};

/**
 * Write double be.
 * @param {Number} value
 */

BufferWriter.prototype.writeDoubleBE = function writeDoubleBE(value) {
  this.offset += 8;
  this.ops.push(new WriteOp(DBLBE, value));
};

/**
 * Write a varint.
 * @param {Number} value
 */

BufferWriter.prototype.writeVarint = function writeVarint(value) {
  this.offset += encoding.sizeVarint(value);
  this.ops.push(new WriteOp(VARINT, value));
};

/**
 * Write a varint.
 * @param {U64} value
 */

BufferWriter.prototype.writeVarintN = function writeVarintN(value) {
  this.offset += encoding.sizeVarintN(value);
  this.ops.push(new WriteOp(VARINTN, value));
};

/**
 * Write a varint (type 2).
 * @param {Number} value
 */

BufferWriter.prototype.writeVarint2 = function writeVarint2(value) {
  this.offset += encoding.sizeVarint2(value);
  this.ops.push(new WriteOp(VARINT2, value));
};

/**
 * Write a varint (type 2).
 * @param {U64} value
 */

BufferWriter.prototype.writeVarint2N = function writeVarint2N(value) {
  this.offset += encoding.sizeVarint2N(value);
  this.ops.push(new WriteOp(VARINT2N, value));
};

/**
 * Write bytes.
 * @param {Buffer} value
 */

BufferWriter.prototype.writeBytes = function writeBytes(value) {
  if (value.length === 0)
    return;

  this.offset += value.length;
  this.ops.push(new WriteOp(BYTES, value));
};

/**
 * Write bytes with a varint length before them.
 * @param {Buffer} value
 */

BufferWriter.prototype.writeVarBytes = function writeVarBytes(value) {
  this.offset += encoding.sizeVarint(value.length);
  this.ops.push(new WriteOp(VARINT, value.length));

  if (value.length === 0)
    return;

  this.offset += value.length;
  this.ops.push(new WriteOp(BYTES, value));
};

/**
 * Copy bytes.
 * @param {Buffer} value
 * @param {Number} start
 * @param {Number} end
 */

BufferWriter.prototype.copy = function copy(value, start, end) {
  assert(end >= start);
  value = value.slice(start, end);
  this.writeBytes(value);
};

/**
 * Write string to buffer.
 * @param {String} value
 * @param {String?} enc - Any buffer-supported encoding.
 */

BufferWriter.prototype.writeString = function writeString(value, enc) {
  if (value.length === 0)
    return;

  this.offset += Buffer.byteLength(value, enc);
  this.ops.push(new WriteOp(STR, value, enc));
};

/**
 * Write a 32 byte hash.
 * @param {Hash} value
 */

BufferWriter.prototype.writeHash = function writeHash(value) {
  if (typeof value !== 'string') {
    assert(value.length === 32);
    this.writeBytes(value);
    return;
  }
  assert(value.length === 64);
  this.writeString(value, 'hex');
};

/**
 * Write a string with a varint length before it.
 * @param {String}
 * @param {String?} enc - Any buffer-supported encoding.
 */

BufferWriter.prototype.writeVarString = function writeVarString(value, enc) {
  if (value.length === 0) {
    this.ops.push(new WriteOp(VARINT, 0));
    return;
  }

  const size = Buffer.byteLength(value, enc);

  this.offset += encoding.sizeVarint(size);
  this.offset += size;

  this.ops.push(new WriteOp(VARINT, size));

  this.ops.push(new WriteOp(STR, value, enc));
};

/**
 * Write a null-terminated string.
 * @param {String|Buffer}
 * @param {String?} enc - Any buffer-supported encoding.
 */

BufferWriter.prototype.writeNullString = function writeNullString(value, enc) {
  this.writeString(value, enc);
  this.writeU8(0);
};

/**
 * Calculate and write a checksum for the data written so far.
 */

BufferWriter.prototype.writeChecksum = function writeChecksum() {
  this.offset += 4;
  this.ops.push(new WriteOp(CHECKSUM));
};

/**
 * Fill N bytes with value.
 * @param {Number} value
 * @param {Number} size
 */

BufferWriter.prototype.fill = function fill(value, size) {
  assert(size >= 0);

  if (size === 0)
    return;

  this.offset += size;
  this.ops.push(new WriteOp(FILL, value, null, size));
};

/*
 * Helpers
 */

function WriteOp(type, value, enc, size) {
  this.type = type;
  this.value = value;
  this.enc = enc;
  this.size = size;
}

/*
 * Expose
 */

module.exports = BufferWriter;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * merkle.js - merkle trees for wmcc_core.
 */



/**
 * @module crypto/merkle
 */

const digest = __webpack_require__(5);

/**
 * Build a merkle tree from leaves.
 * Note that this will mutate the `leaves` array!
 * @param {Buffer[]} leaves
 * @returns {Array} [nodes, malleated]
 */

exports.createTree = function createTree(leaves) {
  const nodes = leaves;
  let size = leaves.length;
  let malleated = false;
  let i = 0;

  if (size === 0) {
    nodes.push(Buffer.alloc(32));
    return [nodes, malleated];
  }

  while (size > 1) {
    for (let j = 0; j < size; j += 2) {
      const k = Math.min(j + 1, size - 1);
      const left = nodes[i + j];
      const right = nodes[i + k];

      if (k === j + 1 && k + 1 === size
          && left.equals(right)) {
        malleated = true;
      }

      const hash = digest.root256(left, right);

      nodes.push(hash);
    }
    i += size;
    size += 1;
    size >>>= 1;
  }

  return [nodes, malleated];
};

/**
 * Calculate merkle root from leaves.
 * @param {Buffer[]} leaves
 * @returns {Array} [root, malleated]
 */

exports.createRoot = function createRoot(leaves) {
  const [nodes, malleated] = exports.createTree(leaves);
  const root = nodes[nodes.length - 1];
  return [root, malleated];
};

/**
 * Collect a merkle branch from vector index.
 * @param {Number} index
 * @param {Buffer[]} leaves
 * @returns {Buffer[]} branch
 */

exports.createBranch = function createBranch(index, leaves) {
  let size = leaves.length;
  const [nodes] = exports.createTree(leaves);
  const branch = [];
  let i = 0;

  while (size > 1) {
    const j = Math.min(index ^ 1, size - 1);
    branch.push(nodes[i + j]);
    index >>>= 1;
    i += size;
    size += 1;
    size >>>= 1;
  }

  return branch;
};

/**
 * Derive merkle root from branch.
 * @param {Buffer} hash
 * @param {Buffer[]} branch
 * @param {Number} index
 * @returns {Buffer} root
 */

exports.deriveRoot = function deriveRoot(hash, branch, index) {
  let root = hash;

  for (const hash of branch) {
    if (index & 1)
      root = digest.root256(hash, root);
    else
      root = digest.root256(root, hash);

    index >>>= 1;
  }

  return root;
};


/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(14);

var elliptic = __webpack_require__(9);
var utils = elliptic.utils;
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
  }
  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0 && (r[1] & 0x80)) {
    r = r.slice(1);
  }
  if (s[0] === 0 && (s[1] & 0x80)) {
    s = s.slice(1);
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * murmur3.js - murmur3 hash for wmcc_core.
 */



const native = __webpack_require__(18).binding;

/**
 * Murmur3 hash.
 * @alias module:utils.murmur3
 * @param {Buffer} data
 * @param {Number} seed
 * @returns {Number}
 */

function murmur3(data, seed) {
  const tail = data.length - (data.length % 4);
  const c1 = 0xcc9e2d51;
  const c2 = 0x1b873593;
  let h1 = seed;
  let k1;

  for (let i = 0; i < tail; i += 4) {
    k1 = (data[i + 3] << 24)
      | (data[i + 2] << 16)
      | (data[i + 1] << 8)
      | data[i];
    k1 = mul32(k1, c1);
    k1 = rotl32(k1, 15);
    k1 = mul32(k1, c2);
    h1 ^= k1;
    h1 = rotl32(h1, 13);
    h1 = sum32(mul32(h1, 5), 0xe6546b64);
  }

  k1 = 0;
  switch (data.length & 3) {
    case 3:
      k1 ^= data[tail + 2] << 16;
    case 2:
      k1 ^= data[tail + 1] << 8;
    case 1:
      k1 ^= data[tail + 0];
      k1 = mul32(k1, c1);
      k1 = rotl32(k1, 15);
      k1 = mul32(k1, c2);
      h1 ^= k1;
  }

  h1 ^= data.length;
  h1 ^= h1 >>> 16;
  h1 = mul32(h1, 0x85ebca6b);
  h1 ^= h1 >>> 13;
  h1 = mul32(h1, 0xc2b2ae35);
  h1 ^= h1 >>> 16;

  if (h1 < 0)
    h1 += 0x100000000;

  return h1;
}

if (native)
  murmur3 = native.murmur3;

function mul32(a, b) {
  const alo = a & 0xffff;
  const blo = b & 0xffff;
  const ahi = a >>> 16;
  const bhi = b >>> 16;

  let lo = alo * blo;
  let hi = (ahi * blo + bhi * alo) & 0xffff;

  hi += lo >>> 16;
  lo &= 0xffff;

  let r = (hi << 16) | lo;

  if (r < 0)
    r += 0x100000000;

  return r;
}

function sum32(a, b) {
  let r = (a + b) & 0xffffffff;

  if (r < 0)
    r += 0x100000000;

  return r;
}

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}

/**
 * Expose
 */

exports = murmur3;
exports.murmur3 = murmur3;
exports.mul32 = mul32;
exports.sum32 = sum32;
exports.rotl32 = rotl32;
module.exports = exports;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * abstractblock.js - abstract block object for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const digest = __webpack_require__(5);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const InvItem = __webpack_require__(36);
const encoding = __webpack_require__(3);
const consensus = __webpack_require__(7);
const scrypt = __webpack_require__(45); // ctl
const X15 = __webpack_require__(57);

/**
 * The class which all block-like objects inherit from.
 * @alias module:primitives.AbstractBlock
 * @constructor
 * @abstract
 * @property {Number} version - Block version. Note
 * that WMCC reads versions as unsigned despite
 * them being signed on the protocol level. This
 * number will never be negative.
 * @property {Hash} prevBlock - Previous block hash.
 * @property {Hash} merkleRoot - Merkle root hash.
 * @property {Number} time - Timestamp.
 * @property {Number} bits
 * @property {Number} nonce
 */

function AbstractBlock() {
  if (!(this instanceof AbstractBlock))
    return new AbstractBlock();

  this.version = 1;
  this.prevBlock = encoding.NULL_HASH;
  this.merkleRoot = encoding.NULL_HASH;
  this.time = 0;
  this.bits = 0;
  this.nonce = 0;

  this.mutable = false;

  this._hash = null;
  this._hhash = null;
}

/**
 * Inject properties from options object.
 * @private
 * @param {NakedBlock} options
 */

AbstractBlock.prototype.parseOptions = function parseOptions(options) {
  assert(options, 'Block data is required.');
  assert(util.isU32(options.version));
  assert(typeof options.prevBlock === 'string');
  assert(typeof options.merkleRoot === 'string');
  assert(util.isU32(options.time));
  assert(util.isU32(options.bits));
  assert(util.isU32(options.nonce));

  this.version = options.version;
  this.prevBlock = options.prevBlock;
  this.merkleRoot = options.merkleRoot;
  this.time = options.time;
  this.bits = options.bits;
  this.nonce = options.nonce;

  if (options.mutable != null)
    this.mutable = Boolean(options.mutable);

  return this;
};

/**
 * Inject properties from json object.
 * @private
 * @param {Object} json
 */

AbstractBlock.prototype.parseJSON = function parseJSON(json) {
  assert(json, 'Block data is required.');
  assert(util.isU32(json.version));
  assert(typeof json.prevBlock === 'string');
  assert(typeof json.merkleRoot === 'string');
  assert(util.isU32(json.time));
  assert(util.isU32(json.bits));
  assert(util.isU32(json.nonce));

  this.version = json.version;
  this.prevBlock = util.revHex(json.prevBlock);
  this.merkleRoot = util.revHex(json.merkleRoot);
  this.time = json.time;
  this.bits = json.bits;
  this.nonce = json.nonce;

  return this;
};

/**
 * Test whether the block is a memblock.
 * @returns {Boolean}
 */

AbstractBlock.prototype.isMemory = function isMemory() {
  return false;
};

/**
 * Clear any cached values (abstract).
 */

AbstractBlock.prototype._refresh = function _refresh() {
  this._hash = null;
  this._hhash = null;
};

/**
 * Clear any cached values.
 */

AbstractBlock.prototype.refresh = function refresh() {
  return this._refresh();
};

/**
 * Hash the block headers.
 * @param {String?} enc - Can be `'hex'` or `null`.
 * @returns {Hash|Buffer} hash

AbstractBlock.prototype.hash = function hash(enc) {
  let h = this._hash;

  if (!h) {
    h = digest.hash256(this.toHead());
    if (!this.mutable)
      this._hash = h;
  }

  if (enc === 'hex') {
    let hex = this._hhash;
    if (!hex) {
      hex = h.toString('hex');
      if (!this.mutable)
        this._hhash = hex;
    }
    h = hex;
  }

  return h;
};
 */

/**
 * Hash the block headers with scrypt.
 * @param {String?} enc - Can be `'hex'` or `null`.
 * @returns {Hash|Buffer} hash
 */
// ctl
AbstractBlock.prototype.powHash = function powHash() {
  // var data = this.abbr(); // old
  const data = this.toHead(); // new
  return scrypt.derive(data, data, 1024, 1, 1, 32);
};

/**
 * Hash the block headers with x15.
 * @param {String?} enc - Can be `'hex'` or `null`.
 * @returns {Hash|Buffer} hash
 */

AbstractBlock.prototype.hash = function hash(enc) {
  let h = this._hash;

  if (!h) {
    h = X15.digest(this.toHead());
    if (!this.mutable)
      this._hash = h;
  }

  if (enc === 'hex') {
    let hex = this._hhash;
    if (!hex) {
      hex = h.toString('hex');
      if (!this.mutable)
        this._hhash = hex;
    }
    h = hex;
  }

  return h;
};

/**
 * Serialize the block headers.
 * @returns {Buffer}
 */

AbstractBlock.prototype.toHead = function toHead() {
  return this.writeHead(new StaticWriter(80)).render();
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

AbstractBlock.prototype.fromHead = function fromHead(data) {
  return this.readHead(new BufferReader(data));
};

/**
 * Serialize the block headers.
 * @param {BufferWriter} bw
 */

AbstractBlock.prototype.writeHead = function writeHead(bw) {
  bw.writeU32(this.version);
  bw.writeHash(this.prevBlock);
  bw.writeHash(this.merkleRoot);
  bw.writeU32(this.time);
  bw.writeU32(this.bits);
  bw.writeU32(this.nonce);
  return bw;
};

/**
 * Parse the block headers.
 * @param {BufferReader} br
 */

AbstractBlock.prototype.readHead = function readHead(br) {
  this.version = br.readU32();
  this.prevBlock = br.readHash('hex');
  this.merkleRoot = br.readHash('hex');
  this.time = br.readU32();
  this.bits = br.readU32();
  this.nonce = br.readU32();
  return this;
};

/**
 * Verify the block.
 * @returns {Boolean}
 */

AbstractBlock.prototype.verify = function verify() {
  if (!this.verifyPOW())
    return false;

  if (!this.verifyBody())
    return false;

  return true;
};

/**
 * Verify proof-of-work.
 * @returns {Boolean}
 */

AbstractBlock.prototype.verifyPOW = function verifyPOW() {
  // return consensus.verifyPOW(this.hash(), this.bits); // cfc
  // return consensus.verifyPOW(this.powHash(), this.bits); // ctl
  return consensus.verifyPOW(this.hash(), this.bits);
};

/**
 * Verify the block.
 * @returns {Boolean}
 */

AbstractBlock.prototype.verifyBody = function verifyBody() {
  throw new Error('Abstract method.');
};

/**
 * Get little-endian block hash.
 * @returns {Hash}
 */

AbstractBlock.prototype.rhash = function rhash() {
  return util.revHex(this.hash('hex'));
};

/**
 * Convert the block to an inv item.
 * @returns {InvItem}
 */

AbstractBlock.prototype.toInv = function toInv() {
  return new InvItem(InvItem.types.BLOCK, this.hash('hex'));
};

/*
 * Expose
 */

module.exports = AbstractBlock;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * pbkdf2.js - pbkdf2 for wmcc_core.
 */



/**
 * @module crypto.pbkdf2
 */

const crypto = __webpack_require__(24);
const co = __webpack_require__(17);

/**
 * Perform key derivation using PBKDF2.
 * @param {Buffer} key
 * @param {Buffer} salt
 * @param {Number} iter
 * @param {Number} len
 * @param {String} alg
 * @returns {Buffer}
 */

exports.derive = function derive(key, salt, iter, len, alg) {
  return crypto.pbkdf2Sync(key, salt, iter, len, alg);
};

/**
 * Execute pbkdf2 asynchronously.
 * @param {Buffer} key
 * @param {Buffer} salt
 * @param {Number} iter
 * @param {Number} len
 * @param {String} alg
 * @returns {Promise}
 */

exports.deriveAsync = function deriveAsync(key, salt, iter, len, alg) {
  return new Promise((resolve, reject) => {
    crypto.pbkdf2(key, salt, iter, len, alg, co.wrap(resolve, reject));
  });
};


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * merkleblock.js - merkleblock object for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const encoding = __webpack_require__(3);
const digest = __webpack_require__(5);
const consensus = __webpack_require__(7);
const AbstractBlock = __webpack_require__(67);
const Headers = __webpack_require__(37);
const DUMMY = Buffer.from([0]);

/**
 * Represents a merkle (filtered) block.
 * @alias module:primitives.MerkleBlock
 * @constructor
 * @extends AbstractBlock
 * @param {NakedBlock} options
 */

function MerkleBlock(options) {
  if (!(this instanceof MerkleBlock))
    return new MerkleBlock(options);

  AbstractBlock.call(this);

  this.txs = [];
  this.hashes = [];
  this.flags = DUMMY;

  this.totalTX = 0;
  this._tree = null;

  if (options)
    this.fromOptions(options);
}

Object.setPrototypeOf(MerkleBlock.prototype, AbstractBlock.prototype);

/**
 * Inject properties from options object.
 * @private
 * @param {NakedBlock} options
 */

MerkleBlock.prototype.fromOptions = function fromOptions(options) {
  this.parseOptions(options);

  assert(options, 'MerkleBlock data is required.');
  assert(Array.isArray(options.hashes));
  assert(Buffer.isBuffer(options.flags));
  assert(util.isU32(options.totalTX));

  if (options.hashes) {
    for (let hash of options.hashes) {
      if (typeof hash === 'string')
        hash = Buffer.from(hash, 'hex');
      assert(Buffer.isBuffer(hash));
      this.hashes.push(hash);
    }
  }

  if (options.flags) {
    assert(Buffer.isBuffer(options.flags));
    this.flags = options.flags;
  }

  if (options.totalTX != null) {
    assert(util.isU32(options.totalTX));
    this.totalTX = options.totalTX;
  }

  return this;
};

/**
 * Instantiate merkle block from options object.
 * @param {NakedBlock} options
 * @returns {MerkleBlock}
 */

MerkleBlock.fromOptions = function fromOptions(data) {
  return new MerkleBlock().fromOptions(data);
};

/**
 * Clear any cached values.
 * @param {Boolean?} all - Clear transactions.
 */

MerkleBlock.prototype.refresh = function refresh(all) {
  this._refresh();
  this._tree = null;

  if (!all)
    return;

  for (const tx of this.txs)
    tx.refresh();
};

/**
 * Test the block's _matched_ transaction vector against a hash.
 * @param {Hash} hash
 * @returns {Boolean}
 */

MerkleBlock.prototype.hasTX = function hasTX(hash) {
  return this.indexOf(hash) !== -1;
};

/**
 * Test the block's _matched_ transaction vector against a hash.
 * @param {Hash} hash
 * @returns {Number} Index.
 */

MerkleBlock.prototype.indexOf = function indexOf(hash) {
  const tree = this.getTree();
  const index = tree.map.get(hash);

  if (index == null)
    return -1;

  return index;
};

/**
 * Verify the partial merkletree.
 * @private
 * @returns {Boolean}
 */

MerkleBlock.prototype.verifyBody = function verifyBody() {
  const [valid] = this.checkBody();
  return valid;
};

/**
 * Verify the partial merkletree.
 * @private
 * @returns {Array} [valid, reason, score]
 */

MerkleBlock.prototype.checkBody = function checkBody() {
  const tree = this.getTree();

  if (tree.root !== this.merkleRoot)
    return [false, 'bad-txnmrklroot', 100];

  return [true, 'valid', 0];
};

/**
 * Extract the matches from partial merkle
 * tree and calculate merkle root.
 * @returns {Object}
 */

MerkleBlock.prototype.getTree = function getTree() {
  if (!this._tree) {
    try {
      this._tree = this.extractTree();
    } catch (e) {
      this._tree = new PartialTree();
    }
  }
  return this._tree;
};

/**
 * Extract the matches from partial merkle
 * tree and calculate merkle root.
 * @private
 * @returns {Object}
 */

MerkleBlock.prototype.extractTree = function extractTree() {
  const matches = [];
  const indexes = [];
  const map = new Map();
  const hashes = this.hashes;
  const flags = this.flags;
  const totalTX = this.totalTX;
  let bitsUsed = 0;
  let hashUsed = 0;
  let failed = false;
  let height = 0;

  const width = (height) => {
    return (totalTX + (1 << height) - 1) >>> height;
  };

  const traverse = (height, pos) => {
    if (bitsUsed >= flags.length * 8) {
      failed = true;
      return encoding.ZERO_HASH;
    }

    const parent = (flags[bitsUsed / 8 | 0] >>> (bitsUsed % 8)) & 1;

    bitsUsed++;

    if (height === 0 || !parent) {
      if (hashUsed >= hashes.length) {
        failed = true;
        return encoding.ZERO_HASH;
      }

      const hash = hashes[hashUsed++];

      if (height === 0 && parent) {
        const txid = hash.toString('hex');
        matches.push(hash);
        indexes.push(pos);
        map.set(txid, pos);
      }

      return hash;
    }

    const left = traverse(height - 1, pos * 2);
    let right;

    if (pos * 2 + 1 < width(height - 1)) {
      right = traverse(height - 1, pos * 2 + 1);
      if (right.equals(left))
        failed = true;
    } else {
      right = left;
    }

    return digest.root256(left, right);
  };

  if (totalTX === 0)
    throw new Error('Zero transactions.');

  if (totalTX > consensus.MAX_BLOCK_SIZE / 60)
    throw new Error('Too many transactions.');

  if (hashes.length > totalTX)
    throw new Error('Too many hashes.');

  if (flags.length * 8 < hashes.length)
    throw new Error('Flags too small.');

  while (width(height) > 1)
    height++;

  const root = traverse(height, 0);

  if (failed)
    throw new Error('Mutated merkle tree.');

  if (((bitsUsed + 7) / 8 | 0) !== flags.length)
    throw new Error('Too many flag bits.');

  if (hashUsed !== hashes.length)
    throw new Error('Incorrect number of hashes.');

  return new PartialTree(root, matches, indexes, map);
};

/**
 * Extract the coinbase height (always -1).
 * @returns {Number}
 */

MerkleBlock.prototype.getCoinbaseHeight = function getCoinbaseHeight() {
  return -1;
};

/**
 * Inspect the block and return a more
 * user-friendly representation of the data.
 * @returns {Object}
 */

MerkleBlock.prototype.inspect = function inspect() {
  return this.format();
};

/**
 * Inspect the block and return a more
 * user-friendly representation of the data.
 * @param {CoinView} view
 * @param {Number} height
 * @returns {Object}
 */

MerkleBlock.prototype.format = function format(view, height) {
  return {
    hash: this.rhash(),
    height: height != null ? height : -1,
    date: util.date(this.time),
    version: util.hex32(this.version),
    prevBlock: util.revHex(this.prevBlock),
    merkleRoot: util.revHex(this.merkleRoot),
    time: this.time,
    bits: this.bits,
    nonce: this.nonce,
    totalTX: this.totalTX,
    hashes: this.hashes.map((hash) => {
      return hash.toString('hex');
    }),
    flags: this.flags,
    map: this.getTree().map,
    txs: this.txs.length
  };
};

/**
 * Get merkleblock size.
 * @returns {Number} Size.
 */

MerkleBlock.prototype.getSize = function getSize() {
  let size = 0;
  size += 80;
  size += 4;
  size += encoding.sizeVarint(this.hashes.length);
  size += this.hashes.length * 32;
  size += encoding.sizeVarint(this.flags.length);
  size += this.flags.length;
  return size;
};

/**
 * Write the merkleblock to a buffer writer.
 * @param {BufferWriter} bw
 */

MerkleBlock.prototype.toWriter = function toWriter(bw) {
  this.writeHead(bw);

  bw.writeU32(this.totalTX);

  bw.writeVarint(this.hashes.length);

  for (const hash of this.hashes)
    bw.writeHash(hash);

  bw.writeVarBytes(this.flags);

  return bw;
};

/**
 * Serialize the merkleblock.
 * @param {String?} enc - Encoding, can be `'hex'` or null.
 * @returns {Buffer|String}
 */

MerkleBlock.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

MerkleBlock.prototype.fromReader = function fromReader(br) {
  this.readHead(br);

  this.totalTX = br.readU32();

  const count = br.readVarint();

  for (let i = 0; i < count; i++)
    this.hashes.push(br.readHash());

  this.flags = br.readVarBytes();

  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

MerkleBlock.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate a merkleblock from a buffer reader.
 * @param {BufferReader} br
 * @returns {MerkleBlock}
 */

MerkleBlock.fromReader = function fromReader(br) {
  return new MerkleBlock().fromReader(br);
};

/**
 * Instantiate a merkleblock from a serialized data.
 * @param {Buffer} data
 * @param {String?} enc - Encoding, can be `'hex'` or null.
 * @returns {MerkleBlock}
 */

MerkleBlock.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new MerkleBlock().fromRaw(data);
};

/**
 * Convert the block to an object suitable
 * for JSON serialization.
 * @returns {Object}
 */

MerkleBlock.prototype.toJSON = function toJSON() {
  return this.getJSON();
};

/**
 * Convert the block to an object suitable
 * for JSON serialization. Note that the hashes
 * will be reversed to abide by wmccd's legacy
 * of little-endian uint256s.
 * @param {Network} network
 * @param {CoinView} view
 * @param {Number} height
 * @returns {Object}
 */

MerkleBlock.prototype.getJSON = function getJSON(network, view, height) {
  return {
    hash: this.rhash(),
    height: height,
    version: this.version,
    prevBlock: util.revHex(this.prevBlock),
    merkleRoot: util.revHex(this.merkleRoot),
    time: this.time,
    bits: this.bits,
    nonce: this.nonce,
    totalTX: this.totalTX,
    hashes: this.hashes.map((hash) => {
      return util.revHex(hash.toString('hex'));
    }),
    flags: this.flags.toString('hex')
  };
};

/**
 * Inject properties from json object.
 * @private
 * @param {Object} json
 */

MerkleBlock.prototype.fromJSON = function fromJSON(json) {
  assert(json, 'MerkleBlock data is required.');
  assert(Array.isArray(json.hashes));
  assert(typeof json.flags === 'string');
  assert(util.isU32(json.totalTX));

  this.parseJSON(json);

  for (let hash of json.hashes) {
    hash = util.revHex(hash);
    this.hashes.push(Buffer.from(hash, 'hex'));
  }

  this.flags = Buffer.from(json.flags, 'hex');

  this.totalTX = json.totalTX;

  return this;
};

/**
 * Instantiate a merkle block from a jsonified block object.
 * @param {Object} json - The jsonified block object.
 * @returns {MerkleBlock}
 */

MerkleBlock.fromJSON = function fromJSON(json) {
  return new MerkleBlock().fromJSON(json);
};

/**
 * Create a merkleblock from a {@link Block} object, passing
 * it through a filter first. This will build the partial
 * merkle tree.
 * @param {Block} block
 * @param {Bloom} filter
 * @returns {MerkleBlock}
 */

MerkleBlock.fromBlock = function fromBlock(block, filter) {
  const matches = [];

  for (const tx of block.txs)
    matches.push(tx.isWatched(filter) ? 1 : 0);

  return MerkleBlock.fromMatches(block, matches);
};

/**
 * Create a merkleblock from an array of txids.
 * This will build the partial merkle tree.
 * @param {Block} block
 * @param {Hash[]} hashes
 * @returns {MerkleBlock}
 */

MerkleBlock.fromHashes = function fromHashes(block, hashes) {
  const filter = new Set();

  for (let hash of hashes) {
    if (Buffer.isBuffer(hash))
      hash = hash.toString('hex');
    filter.add(hash);
  }

  const matches = [];

  for (const tx of block.txs) {
    const hash = tx.hash('hex');
    matches.push(filter.has(hash) ? 1 : 0);
  }

  return MerkleBlock.fromMatches(block, matches);
};

/**
 * Create a merkleblock from an array of matches.
 * This will build the partial merkle tree.
 * @param {Block} block
 * @param {Number[]} matches
 * @returns {MerkleBlock}
 */

MerkleBlock.fromMatches = function fromMatches(block, matches) {
  const txs = [];
  const leaves = [];
  const bits = [];
  const hashes = [];
  const totalTX = block.txs.length;
  let height = 0;

  const width = (height) => {
    return (totalTX + (1 << height) - 1) >>> height;
  };

  const hash = (height, pos, leaves) => {
    if (height === 0)
      return leaves[pos];

    const left = hash(height - 1, pos * 2, leaves);
    let right;

    if (pos * 2 + 1 < width(height - 1))
      right = hash(height - 1, pos * 2 + 1, leaves);
    else
      right = left;

    return digest.root256(left, right);
  };

  const traverse = (height, pos, leaves, matches) => {
    let parent = 0;

    for (let p = (pos << height); p < ((pos + 1) << height) && p < totalTX; p++)
      parent |= matches[p];

    bits.push(parent);

    if (height === 0 || !parent) {
      hashes.push(hash(height, pos, leaves));
      return;
    }

    traverse(height - 1, pos * 2, leaves, matches);

    if (pos * 2 + 1 < width(height - 1))
      traverse(height - 1, pos * 2 + 1, leaves, matches);
  };

  for (let i = 0; i < block.txs.length; i++) {
    const tx = block.txs[i];

    if (matches[i])
      txs.push(tx);

    leaves.push(tx.hash());
  }

  while (width(height) > 1)
    height++;

  traverse(height, 0, leaves, matches);

  const flags = Buffer.allocUnsafe((bits.length + 7) / 8 | 0);
  flags.fill(0);

  for (let p = 0; p < bits.length; p++)
    flags[p / 8 | 0] |= bits[p] << (p % 8);

  const merkle = new MerkleBlock();
  merkle._hash = block._hash;
  merkle._hhash = block._hhash;
  merkle.version = block.version;
  merkle.prevBlock = block.prevBlock;
  merkle.merkleRoot = block.merkleRoot;
  merkle.time = block.time;
  merkle.bits = block.bits;
  merkle.nonce = block.nonce;
  merkle.totalTX = totalTX;
  merkle.hashes = hashes;
  merkle.flags = flags;
  merkle.txs = txs;

  return merkle;
};

/**
 * Test whether an object is a MerkleBlock.
 * @param {Object} obj
 * @returns {Boolean}
 */

MerkleBlock.isMerkleBlock = function isMerkleBlock(obj) {
  return obj instanceof MerkleBlock;
};

/**
 * Convert the block to a headers object.
 * @returns {Headers}
 */

MerkleBlock.prototype.toHeaders = function toHeaders() {
  return Headers.fromBlock(this);
};

/*
 * Helpers
 */

function PartialTree(root, matches, indexes, map) {
  this.root = root ? root.toString('hex') : encoding.NULL_HASH;
  this.matches = matches || [];
  this.indexes = indexes || [];
  this.map = map || new Map();
}

/*
 * Expose
 */

module.exports = MerkleBlock;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * cleanse.js - memzero for wmcc_core.
 */



/**
 * @module crypto.cleanse
 */

const native = __webpack_require__(18).binding;

let counter = 0;

/**
 * A maybe-secure memzero.
 * @param {Buffer} data
 */

module.exports = function cleanse(data) {
  let ctr = counter;

  for (let i = 0; i < data.length; i++) {
    data[i] = ctr & 0xff;
    ctr += i;
  }

  counter = ctr >>> 0;
};

if (native)
  exports.cleanse = native.cleanse;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * validator.js - validator for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);

/**
 * Validator
 * @alias module:utils.Validator
 * @constructor
 * @param {Object} options
 */

function Validator(data) {
  if (!(this instanceof Validator))
    return new Validator(data);

  this.data = [];

  if (data)
    this.init(data);
}

/**
 * Initialize the validator.
 * @private
 * @param {Object} data
 */

Validator.prototype.init = function init(data) {
  assert(data && typeof data === 'object');

  if (!Array.isArray(data))
    data = [data];

  this.data = data;
};

/**
 * Test whether value is present.
 * @param {String} key
 * @returns {Boolean}
 */

Validator.prototype.has = function has(key) {
  assert(typeof key === 'string' || typeof key === 'number',
    'Key must be a string or number.');

  for (const map of this.data) {
    const value = map[key];
    if (value != null)
      return true;
  }

  return false;
};

/**
 * Get a value (no type validation).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Object|null}
 */

Validator.prototype.get = function get(key, fallback) {
  if (fallback === undefined)
    fallback = null;

  if (Array.isArray(key)) {
    const keys = key;
    for (const key of keys) {
      const value = this.get(key);
      if (value !== null)
        return value;
    }
    return fallback;
  }

  assert(typeof key === 'string' || typeof key === 'number',
    'Key must be a string or number.');

  for (const map of this.data) {
    if (!map || typeof map !== 'object')
      throw new ValidationError('data', 'object');

    const value = map[key];

    if (value != null)
      return value;
  }

  return fallback;
};

/**
 * Get a value's type.
 * @param {String} key
 * @returns {String}
 */

Validator.prototype.typeOf = function typeOf(key) {
  const value = this.get(key);

  if (value == null)
    return 'null';

  return typeof value;
};

/**
 * Get a value (as a string).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {String|null}
 */

Validator.prototype.str = function str(key, fallback) {
  const value = this.get(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (typeof value !== 'string')
    throw new ValidationError(key, 'number');

  return value;
};

/**
 * Get a value (as an integer).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Validator.prototype.int = function int(key, fallback) {
  let value = this.get(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (typeof value !== 'string') {
    if (typeof value !== 'number')
      throw new ValidationError(key, 'int');

    if (!Number.isSafeInteger(value))
      throw new ValidationError(key, 'int');

    return value;
  }

  if (!/^\-?\d+$/.test(value))
    throw new ValidationError(key, 'int');

  value = parseInt(value, 10);

  if (!Number.isSafeInteger(value))
    throw new ValidationError(key, 'int');

  return value;
};

/**
 * Get a value (as a signed integer).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Validator.prototype.uint = function uint(key, fallback) {
  const value = this.int(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (value < 0)
    throw new ValidationError(key, 'uint');

  return value;
};

/**
 * Get a value (as a float).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Validator.prototype.float = function float(key, fallback) {
  let value = this.get(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (typeof value !== 'string') {
    if (typeof value !== 'number')
      throw new ValidationError(key, 'float');

    if (!isFinite(value))
      throw new ValidationError(key, 'float');

    return value;
  }

  if (!/^\-?\d*(?:\.\d*)?$/.test(value))
    throw new ValidationError(key, 'float');

  if (!/\d/.test(value))
    throw new ValidationError(key, 'float');

  value = parseFloat(value);

  if (!isFinite(value))
    throw new ValidationError(key, 'float');

  return value;
};

/**
 * Get a value (as a positive float).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Validator.prototype.ufloat = function ufloat(key, fallback) {
  const value = this.float(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (value < 0)
    throw new ValidationError(key, 'positive float');

  return value;
};

/**
 * Get a value (as a fixed number).
 * @param {String} key
 * @param {Number?} exp
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Validator.prototype.fixed = function fixed(key, exp, fallback) {
  const value = this.float(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  try {
    return util.fromFloat(value, exp || 0);
  } catch (e) {
    throw new ValidationError(key, 'fixed number');
  }
};

/**
 * Get a value (as a positive fixed number).
 * @param {String} key
 * @param {Number?} exp
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Validator.prototype.ufixed = function ufixed(key, exp, fallback) {
  const value = this.fixed(key, exp);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (value < 0)
    throw new ValidationError(key, 'positive fixed number');

  return value;
};

/**
 * Get a value (as an int32).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Validator.prototype.i8 = function i8(key, fallback) {
  const value = this.int(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (value < -0x80 || value > 0x7f)
    throw new ValidationError(key, 'i8');

  return value;
};

/**
 * Get a value (as an int32).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Validator.prototype.i16 = function i16(key, fallback) {
  const value = this.int(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (value < -0x8000 || value > 0x7fff)
    throw new ValidationError(key, 'i16');

  return value;
};

/**
 * Get a value (as an int32).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Validator.prototype.i32 = function i32(key, fallback) {
  const value = this.int(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if ((value | 0) !== value)
    throw new ValidationError(key, 'int32');

  return value;
};

/**
 * Get a value (as an int64).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Validator.prototype.i64 = function i64(key, fallback) {
  return this.int(key, fallback);
};

/**
 * Get a value (as a uint32).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Validator.prototype.u8 = function u8(key, fallback) {
  const value = this.uint(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if ((value & 0xff) !== value)
    throw new ValidationError(key, 'uint8');

  return value;
};

/**
 * Get a value (as a uint16).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Validator.prototype.u16 = function u16(key, fallback) {
  const value = this.uint(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if ((value & 0xffff) !== value)
    throw new ValidationError(key, 'uint16');

  return value;
};

/**
 * Get a value (as a uint32).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Validator.prototype.u32 = function u32(key, fallback) {
  const value = this.uint(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if ((value >>> 0) !== value)
    throw new ValidationError(key, 'uint32');

  return value;
};

/**
 * Get a value (as a uint64).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Validator.prototype.u64 = function u64(key, fallback) {
  return this.uint(key, fallback);
};

/**
 * Get a value (as a reverse hash).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Hash|null}
 */

Validator.prototype.hash = function hash(key, fallback) {
  const value = this.get(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (typeof value !== 'string') {
    if (!Buffer.isBuffer(value))
      throw new ValidationError(key, 'hash');

    if (value.length !== 32)
      throw new ValidationError(key, 'hash');

    return value.toString('hex');
  }

  if (value.length !== 64)
    throw new ValidationError(key, 'hex string');

  if (!/^[0-9a-f]+$/i.test(value))
    throw new ValidationError(key, 'hex string');

  let out = '';

  for (let i = 0; i < value.length; i += 2)
    out = value.slice(i, i + 2) + out;

  return out;
};

/**
 * Get a value (as a number or reverse hash).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Number|Hash|null}
 */

Validator.prototype.numhash = function numhash(key, fallback) {
  if (this.typeOf(key) === 'string')
    return this.hash(key, fallback);
  return this.uint(key, fallback);
};

/**
 * Get a value (as a boolean).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Boolean|null}
 */

Validator.prototype.bool = function bool(key, fallback) {
  const value = this.get(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  // WMCC Core compat.
  if (typeof value === 'number') {
    if (value === 1)
      return true;

    if (value === 0)
      return false;
  }

  if (typeof value !== 'string') {
    if (typeof value !== 'boolean')
      throw new ValidationError(key, 'boolean');
    return value;
  }

  if (value === 'true' || value === '1')
    return true;

  if (value === 'false' || value === '0')
    return false;

  throw new ValidationError(key, 'boolean');
};

/**
 * Get a value (as a buffer).
 * @param {String} key
 * @param {Object?} fallback
 * @param {String?} enc
 * @returns {Buffer|null}
 */

Validator.prototype.buf = function buf(key, fallback, enc) {
  const value = this.get(key);

  if (!enc)
    enc = 'hex';

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (typeof value !== 'string') {
    if (!Buffer.isBuffer(value))
      throw new ValidationError(key, 'buffer');
    return value;
  }

  const data = Buffer.from(value, enc);

  if (data.length !== Buffer.byteLength(value, enc))
    throw new ValidationError(key, `${enc} string`);

  return data;
};

/**
 * Get a value (as an array).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Array|String[]|null}
 */

Validator.prototype.array = function array(key, fallback) {
  const value = this.get(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (typeof value !== 'string') {
    if (!Array.isArray(value))
      throw new ValidationError(key, 'list/array');
    return value;
  }

  const parts = value.trim().split(/\s*,\s*/);
  const result = [];

  for (const part of parts) {
    if (part.length === 0)
      continue;

    result.push(part);
  }

  return result;
};

/**
 * Get a value (as an object).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Object|null}
 */

Validator.prototype.obj = function obj(key, fallback) {
  const value = this.get(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (typeof value !== 'object')
    throw new ValidationError(key, 'object');

  return value;
};

/**
 * Get a value (as a function).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Function|null}
 */

Validator.prototype.func = function func(key, fallback) {
  const value = this.get(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (typeof value !== 'function')
    throw new ValidationError(key, 'function');

  return value;
};

/*
 * Helpers
 */

function fmt(key) {
  if (Array.isArray(key))
    key = key[0];

  if (typeof key === 'number')
    return `Param #${key}`;

  return key;
}

function ValidationError(key, type) {
  if (!(this instanceof ValidationError))
    return new ValidationError(key, type);

  Error.call(this);

  this.type = 'ValidationError';
  this.message = `${fmt(key)} must be a ${type}.`;

  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ValidationError);
}

Object.setPrototypeOf(ValidationError.prototype, Error.prototype);

/*
 * Expose
 */

module.exports = Validator;


/***/ }),
/* 72 */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Expose `Emitter`.
 */

if (true) {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var utf8 = __webpack_require__(291);
var hasBinary = __webpack_require__(227);
var after = __webpack_require__(293);
var keys = __webpack_require__(294);

/**
 * Current protocol version.
 */
exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  if (typeof utf8encode === 'function') {
    callback = utf8encode;
    utf8encode = null;
  }

  if (Buffer.isBuffer(packet.data)) {
    return encodeBuffer(packet, supportsBinary, callback);
  } else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {
    return encodeBuffer({ type: packet.type, data: arrayBufferToBuffer(packet.data) }, supportsBinary, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
  }

  return callback('' + encoded);
};

/**
 * Encode Buffer data
 */

function encodeBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var typeBuffer = new Buffer(1);
  typeBuffer[0] = packets[packet.type];
  return callback(Buffer.concat([typeBuffer, data]));
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback){
  var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);
  var message = 'b' + packets[packet.type];
  message += data.toString('base64');
  return callback(message);
};

/**
 * Decodes a packet. Data also available as an ArrayBuffer if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  if (data === undefined) {
    return err;
  }

  var type;

  // String data
  if (typeof data === 'string') {

    type = data.charAt(0);

    if (type === 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      data = tryDecode(data);
      if (data === false) {
        return err;
      }
    }

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  // Binary data
  if (binaryType === 'arraybuffer') {
    // wrap Buffer/ArrayBuffer data into an Uint8Array
    var intArray = new Uint8Array(data);
    type = intArray[0];
    return { type: packetslist[type], data: intArray.buffer.slice(1) };
  }

  if (data instanceof ArrayBuffer) {
    data = arrayBufferToBuffer(data);
  }
  type = data[0];
  return { type: packetslist[type], data: data.slice(1) };
};

function tryDecode(data) {
  try {
    data = utf8.decode(data, { strict: false });
  } catch (e) {
    return false;
  }
  return data;
}

/**
 * Decodes a packet encoded in a base64 string.
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  var data = new Buffer(msg.substr(1), 'base64');
  if (binaryType === 'arraybuffer') {
    var abv = new Uint8Array(data.length);
    for (var i = 0; i < abv.length; i++){
      abv[i] = data[i];
    }
    data = abv.buffer;
  }
  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  if (supportsBinary && hasBinary(packets)) {
    return exports.encodePayloadAsBinary(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, supportsBinary, false, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

function setLengthHeader(message) {
  return message.length + ':' + message;
}

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  for (var i = 0; i < ary.length; i++) {
    each(ary[i], function(error, msg) {
      result[i] = msg;
      next(error, result);
    });
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data !== 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  if (data === '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = '', n, msg, packet;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (chr !== ':') {
      length += chr;
      continue;
    }

    if (length === '' || (length != (n = Number(length)))) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    msg = data.substr(i + 1, n);

    if (length != msg.length) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    if (msg.length) {
      packet = exports.decodePacket(msg, binaryType, false);

      if (err.type === packet.type && err.data === packet.data) {
        // parser error in individual packet - ignoring payload
        return callback(err, 0, 1);
      }

      var more = callback(packet, i + n, l);
      if (false === more) return;
    }

    // advance cursor
    i += n;
    length = '';
  }

  if (length !== '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 *
 * Converts a buffer to a utf8.js encoded string
 *
 * @api private
 */

function bufferToString(buffer) {
  var str = '';
  for (var i = 0, l = buffer.length; i < l; i++) {
    str += String.fromCharCode(buffer[i]);
  }
  return str;
}

/**
 *
 * Converts a utf8.js encoded string to a buffer
 *
 * @api private
 */

function stringToBuffer(string) {
  var buf = new Buffer(string.length);
  for (var i = 0, l = string.length; i < l; i++) {
    buf.writeUInt8(string.charCodeAt(i), i);
  }
  return buf;
}

/**
 *
 * Converts an ArrayBuffer to a Buffer
 *
 * @api private
 */

function arrayBufferToBuffer(data) {
  // data is either an ArrayBuffer or ArrayBufferView.
  var array = new Uint8Array(data.buffer || data);
  var length = data.byteLength || data.length;
  var offset = data.byteOffset || 0;
  var buffer = new Buffer(length);

  for (var i = 0; i < length; i++) {
    buffer[i] = array[offset + i];
  }
  return buffer;
}

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {Buffer} encoded payload
 * @api private
 */

exports.encodePayloadAsBinary = function (packets, callback) {
  if (!packets.length) {
    return callback(new Buffer(0));
  }

  map(packets, encodeOneBinaryPacket, function(err, results) {
    return callback(Buffer.concat(results));
  });
};

function encodeOneBinaryPacket(p, doneCallback) {

  function onBinaryPacketEncode(packet) {

    var encodingLength = '' + packet.length;
    var sizeBuffer;

    if (typeof packet === 'string') {
      sizeBuffer = new Buffer(encodingLength.length + 2);
      sizeBuffer[0] = 0; // is a string (not true binary = 0)
      for (var i = 0; i < encodingLength.length; i++) {
        sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
      }
      sizeBuffer[sizeBuffer.length - 1] = 255;
      return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));
    }

    sizeBuffer = new Buffer(encodingLength.length + 2);
    sizeBuffer[0] = 1; // is binary (true binary = 1)
    for (var i = 0; i < encodingLength.length; i++) {
      sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
    }
    sizeBuffer[sizeBuffer.length - 1] = 255;

    doneCallback(null, Buffer.concat([sizeBuffer, packet]));
  }

  exports.encodePacket(p, true, true, onBinaryPacketEncode);

}


/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary

 * @param {Buffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];
  var i;

  while (bufferTail.length > 0) {
    var strLen = '';
    var isString = bufferTail[0] === 0;
    for (i = 1; ; i++) {
      if (bufferTail[i] === 255)  break;
      // 310 = char length of Number.MAX_VALUE
      if (strLen.length > 310) {
        return callback(err, 0, 1);
      }
      strLen += '' + bufferTail[i];
    }
    bufferTail = bufferTail.slice(strLen.length + 1);

    var msgLength = parseInt(strLen, 10);

    var msg = bufferTail.slice(1, msgLength + 1);
    if (isString) msg = bufferToString(msg);
    buffers.push(msg);
    bufferTail = bufferTail.slice(msgLength + 1);
  }

  var total = buffers.length;
  for (i = 0; i < total; i++) {
    var buffer = buffers[i];
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  }
};


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * netaddress.js - network address object for wmcc_core.
 */



const assert = __webpack_require__(0);
const common = __webpack_require__(59);
const Network = __webpack_require__(6);
const util = __webpack_require__(1);
const IP = __webpack_require__(46);
const StaticWriter = __webpack_require__(4);
const BufferReader = __webpack_require__(2);

/**
 * Represents a network address.
 * @alias module:primitives.NetAddress
 * @constructor
 * @param {Object} options
 * @param {Number?} options.time - Timestamp.
 * @param {Number?} options.services - Service bits.
 * @param {String?} options.host - IP address (IPv6 or IPv4).
 * @param {Number?} options.port - Port.
 * @property {Host} host
 * @property {Number} port
 * @property {Number} services
 * @property {Number} time
 */

function NetAddress(options) {
  if (!(this instanceof NetAddress))
    return new NetAddress(options);

  this.host = '0.0.0.0';
  this.port = 0;
  this.services = 0;
  this.time = 0;
  this.hostname = '0.0.0.0:0';
  this.raw = IP.ZERO_IP;

  if (options)
    this.fromOptions(options);
}

/**
 * Default services for
 * unknown outbound peers.
 * @const {Number}
 * @default
 */

NetAddress.DEFAULT_SERVICES = 0
  | common.services.NETWORK
  | common.services.WITNESS
  | common.services.BLOOM;

/**
 * Inject properties from options object.
 * @private
 * @param {Object} options
 */

NetAddress.prototype.fromOptions = function fromOptions(options) {
  assert(typeof options.host === 'string');
  assert(typeof options.port === 'number');

  this.raw = IP.toBuffer(options.host);
  this.host = IP.toString(this.raw);
  this.port = options.port;

  if (options.services) {
    assert(typeof options.services === 'number');
    this.services = options.services;
  }

  if (options.time) {
    assert(typeof options.time === 'number');
    this.time = options.time;
  }

  this.hostname = IP.toHostname(this.host, this.port);

  return this;
};

/**
 * Instantiate network address from options.
 * @param {Object} options
 * @returns {NetAddress}
 */

NetAddress.fromOptions = function fromOptions(options) {
  return new NetAddress().fromOptions(options);
};

/**
 * Test whether required services are available.
 * @param {Number} services
 * @returns {Boolean}
 */

NetAddress.prototype.hasServices = function hasServices(services) {
  return (this.services & services) === services;
};

/**
 * Test whether the address is IPv4.
 * @returns {Boolean}
 */

NetAddress.isIPv4 = function isIPv4() {
  return IP.isIPv4(this.raw);
};

/**
 * Test whether the address is IPv6.
 * @returns {Boolean}
 */

NetAddress.isIPv6 = function isIPv6() {
  return IP.isIPv6(this.raw);
};

/**
 * Test whether the host is null.
 * @returns {Boolean}
 */

NetAddress.prototype.isNull = function isNull() {
  return IP.isNull(this.raw);
};

/**
 * Test whether the host is a local address.
 * @returns {Boolean}
 */

NetAddress.prototype.isLocal = function isLocal() {
  return IP.isLocal(this.raw);
};

/**
 * Test whether the host is valid.
 * @returns {Boolean}
 */

NetAddress.prototype.isValid = function isValid() {
  return IP.isValid(this.raw);
};

/**
 * Test whether the host is routable.
 * @returns {Boolean}
 */

NetAddress.prototype.isRoutable = function isRoutable() {
  return IP.isRoutable(this.raw);
};

/**
 * Test whether the host is an onion address.
 * @returns {Boolean}
 */

NetAddress.prototype.isOnion = function isOnion() {
  return IP.isOnion(this.raw);
};

/**
 * Compare against another network address.
 * @returns {Boolean}
 */

NetAddress.prototype.equal = function equal(addr) {
  return this.compare(addr) === 0;
};

/**
 * Compare against another network address.
 * @returns {Number}
 */

NetAddress.prototype.compare = function compare(addr) {
  const cmp = this.raw.compare(addr.raw);

  if (cmp !== 0)
    return cmp;

  return this.port - addr.port;
};

/**
 * Get reachable score to destination.
 * @param {NetAddress} dest
 * @returns {Number}
 */

NetAddress.prototype.getReachability = function getReachability(dest) {
  return IP.getReachability(this.raw, dest.raw);
};

/**
 * Set null host.
 */

NetAddress.prototype.setNull = function setNull() {
  this.raw = IP.ZERO_IP;
  this.host = '0.0.0.0';
  this.hostname = IP.toHostname(this.host, this.port);
};

/**
 * Set host.
 * @param {String} host
 */

NetAddress.prototype.setHost = function setHost(host) {
  this.raw = IP.toBuffer(host);
  this.host = IP.toString(this.raw);
  this.hostname = IP.toHostname(this.host, this.port);
};

/**
 * Set port.
 * @param {Number} port
 */

NetAddress.prototype.setPort = function setPort(port) {
  assert(port >= 0 && port <= 0xffff);
  this.port = port;
  this.hostname = IP.toHostname(this.host, port);
};

/**
 * Inject properties from host, port, and network.
 * @private
 * @param {String} host
 * @param {Number} port
 * @param {(Network|NetworkType)?} network
 */

NetAddress.prototype.fromHost = function fromHost(host, port, network) {
  network = Network.get(network);

  assert(port >= 0 && port <= 0xffff);

  this.raw = IP.toBuffer(host);
  this.host = IP.toString(this.raw);
  this.port = port;
  this.services = NetAddress.DEFAULT_SERVICES;
  this.time = network.now();

  this.hostname = IP.toHostname(this.host, this.port);

  return this;
};

/**
 * Instantiate a network address
 * from a host and port.
 * @param {String} host
 * @param {Number} port
 * @param {(Network|NetworkType)?} network
 * @returns {NetAddress}
 */

NetAddress.fromHost = function fromHost(host, port, network) {
  return new NetAddress().fromHost(host, port, network);
};

/**
 * Inject properties from hostname and network.
 * @private
 * @param {String} hostname
 * @param {(Network|NetworkType)?} network
 */

NetAddress.prototype.fromHostname = function fromHostname(hostname, network) {
  network = Network.get(network);

  const addr = IP.fromHostname(hostname, network.port);

  return this.fromHost(addr.host, addr.port, network);
};

/**
 * Instantiate a network address
 * from a hostname (i.e. 127.0.0.1:8333).
 * @param {String} hostname
 * @param {(Network|NetworkType)?} network
 * @returns {NetAddress}
 */

NetAddress.fromHostname = function fromHostname(hostname, network) {
  return new NetAddress().fromHostname(hostname, network);
};

/**
 * Inject properties from socket.
 * @private
 * @param {net.Socket} socket
 */

NetAddress.prototype.fromSocket = function fromSocket(socket, network) {
  const host = socket.remoteAddress;
  const port = socket.remotePort;
  assert(typeof host === 'string');
  assert(typeof port === 'number');
  return this.fromHost(IP.normalize(host), port, network);
};

/**
 * Instantiate a network address
 * from a socket.
 * @param {net.Socket} socket
 * @returns {NetAddress}
 */

NetAddress.fromSocket = function fromSocket(hostname, network) {
  return new NetAddress().fromSocket(hostname, network);
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 * @param {Boolean?} full - Include timestamp.
 */

NetAddress.prototype.fromReader = function fromReader(br, full) {
  this.time = full ? br.readU32() : 0;
  this.services = br.readU32();

  // Note: hi service bits
  // are currently unused.
  br.readU32();

  this.raw = br.readBytes(16);
  this.host = IP.toString(this.raw);
  this.port = br.readU16BE();
  this.hostname = IP.toHostname(this.host, this.port);

  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 * @param {Boolean?} full - Include timestamp.
 */

NetAddress.prototype.fromRaw = function fromRaw(data, full) {
  return this.fromReader(new BufferReader(data), full);
};

/**
 * Insantiate a network address from buffer reader.
 * @param {BufferReader} br
 * @param {Boolean?} full - Include timestamp.
 * @returns {NetAddress}
 */

NetAddress.fromReader = function fromReader(br, full) {
  return new NetAddress().fromReader(br, full);
};

/**
 * Insantiate a network address from serialized data.
 * @param {Buffer} data
 * @param {Boolean?} full - Include timestamp.
 * @returns {NetAddress}
 */

NetAddress.fromRaw = function fromRaw(data, full) {
  return new NetAddress().fromRaw(data, full);
};

/**
 * Write network address to a buffer writer.
 * @param {BufferWriter} bw
 * @param {Boolean?} full - Include timestamp.
 * @returns {Buffer}
 */

NetAddress.prototype.toWriter = function toWriter(bw, full) {
  if (full)
    bw.writeU32(this.time);

  bw.writeU32(this.services);
  bw.writeU32(0);
  bw.writeBytes(this.raw);
  bw.writeU16BE(this.port);

  return bw;
};

/**
 * Calculate serialization size of address.
 * @returns {Number}
 */

NetAddress.prototype.getSize = function getSize(full) {
  return 26 + (full ? 4 : 0);
};

/**
 * Serialize network address.
 * @param {Boolean?} full - Include timestamp.
 * @returns {Buffer}
 */

NetAddress.prototype.toRaw = function toRaw(full) {
  const size = this.getSize(full);
  return this.toWriter(new StaticWriter(size), full).render();
};

/**
 * Convert net address to json-friendly object.
 * @returns {Object}
 */

NetAddress.prototype.toJSON = function toJSON() {
  return {
    host: this.host,
    port: this.port,
    services: this.services,
    time: this.time
  };
};

/**
 * Inject properties from json object.
 * @private
 * @param {Object} json
 * @returns {NetAddress}
 */

NetAddress.prototype.fromJSON = function fromJSON(json) {
  assert(util.isU16(json.port));
  assert(util.isU32(json.services));
  assert(util.isU32(json.time));
  this.raw = IP.toBuffer(json.host);
  this.host = json.host;
  this.port = json.port;
  this.services = json.services;
  this.time = json.time;
  this.hostname = IP.toHostname(this.host, this.port);
  return this;
};

/**
 * Instantiate net address from json object.
 * @param {Object} json
 * @returns {NetAddress}
 */

NetAddress.fromJSON = function fromJSON(json) {
  return new NetAddress().fromJSON(json);
};

/**
 * Inspect the network address.
 * @returns {Object}
 */

NetAddress.prototype.inspect = function inspect() {
  return '<NetAddress:'
    + ` hostname=${this.hostname}`
    + ` services=${this.services.toString(2)}`
    + ` date=${util.date(this.time)}`
    + '>';
};

/*
 * Expose
 */

module.exports = NetAddress;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * path.js - path object for wallets.
 */



const assert = __webpack_require__(0);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const encoding = __webpack_require__(3);
const Address = __webpack_require__(11);

/**
 * Path
 * @alias module:wallet.Path
 * @constructor
 * @property {WalletID} wid
 * @property {String} name - Account name.
 * @property {Number} account - Account index.
 * @property {Number} branch - Branch index.
 * @property {Number} index - Address index.
 * @property {Address|null} address
 */

function Path(options) {
  if (!(this instanceof Path))
    return new Path(options);

  this.keyType = Path.types.HD;

  this.id = null; // Passed in by caller.
  this.wid = -1; // Passed in by caller.
  this.name = null; // Passed in by caller.
  this.account = 0;
  this.branch = -1;
  this.index = -1;

  this.encrypted = false;
  this.data = null;

  // Currently unused.
  this.type = Address.types.PUBKEYHASH;
  this.version = -1;
  this.hash = null; // Passed in by caller.

  if (options)
    this.fromOptions(options);
}

/**
 * Path types.
 * @enum {Number}
 * @default
 */

Path.types = {
  HD: 0,
  KEY: 1,
  ADDRESS: 2
};

/**
 * Instantiate path from options object.
 * @private
 * @param {Object} options
 * @returns {Path}
 */

Path.prototype.fromOptions = function fromOptions(options) {
  this.keyType = options.keyType;

  this.id = options.id;
  this.wid = options.wid;
  this.name = options.name;
  this.account = options.account;
  this.branch = options.branch;
  this.index = options.index;

  this.encrypted = options.encrypted;
  this.data = options.data;

  this.type = options.type;
  this.version = options.version;
  this.hash = options.hash;

  return this;
};

/**
 * Instantiate path from options object.
 * @param {Object} options
 * @returns {Path}
 */

Path.fromOptions = function fromOptions(options) {
  return new Path().fromOptions(options);
};

/**
 * Clone the path object.
 * @returns {Path}
 */

Path.prototype.clone = function clone() {
  const path = new Path();

  path.keyType = this.keyType;

  path.id = this.id;
  path.wid = this.wid;
  path.name = this.name;
  path.account = this.account;
  path.branch = this.branch;
  path.index = this.index;

  path.encrypted = this.encrypted;
  path.data = this.data;

  path.type = this.type;
  path.version = this.version;
  path.hash = this.hash;

  return path;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

Path.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data);

  this.account = br.readU32();
  this.keyType = br.readU8();

  switch (this.keyType) {
    case Path.types.HD:
      this.branch = br.readU32();
      this.index = br.readU32();
      break;
    case Path.types.KEY:
      this.encrypted = br.readU8() === 1;
      this.data = br.readVarBytes();
      break;
    case Path.types.ADDRESS:
      // Hash will be passed in by caller.
      break;
    default:
      assert(false);
      break;
  }

  this.version = br.readI8();
  this.type = br.readU8();

  if (this.type === 129 || this.type === 130)
    this.type = 4;

  return this;
};

/**
 * Instantiate path from serialized data.
 * @param {Buffer} data
 * @returns {Path}
 */

Path.fromRaw = function fromRaw(data) {
  return new Path().fromRaw(data);
};

/**
 * Calculate serialization size.
 * @returns {Number}
 */

Path.prototype.getSize = function getSize() {
  let size = 0;

  size += 5;

  switch (this.keyType) {
    case Path.types.HD:
      size += 8;
      break;
    case Path.types.KEY:
      size += 1;
      size += encoding.sizeVarBytes(this.data);
      break;
  }

  size += 2;

  return size;
};

/**
 * Serialize path.
 * @returns {Buffer}
 */

Path.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  const bw = new StaticWriter(size);

  bw.writeU32(this.account);
  bw.writeU8(this.keyType);

  switch (this.keyType) {
    case Path.types.HD:
      assert(!this.data);
      assert(this.index !== -1);
      bw.writeU32(this.branch);
      bw.writeU32(this.index);
      break;
    case Path.types.KEY:
      assert(this.data);
      assert(this.index === -1);
      bw.writeU8(this.encrypted ? 1 : 0);
      bw.writeVarBytes(this.data);
      break;
    case Path.types.ADDRESS:
      assert(!this.data);
      assert(this.index === -1);
      break;
    default:
      assert(false);
      break;
  }

  bw.writeI8(this.version);
  bw.writeU8(this.type);

  return bw.render();
};

/**
 * Inject properties from address.
 * @private
 * @param {Account} account
 * @param {Address} address
 */

Path.prototype.fromAddress = function fromAddress(account, address) {
  this.keyType = Path.types.ADDRESS;
  this.id = account.id;
  this.wid = account.wid;
  this.name = account.name;
  this.account = account.accountIndex;
  this.version = address.version;
  this.type = address.type;
  this.hash = address.getHash('hex');
  return this;
};

/**
 * Instantiate path from address.
 * @param {Account} account
 * @param {Address} address
 * @returns {Path}
 */

Path.fromAddress = function fromAddress(account, address) {
  return new Path().fromAddress(account, address);
};

/**
 * Convert path object to string derivation path.
 * @returns {String}
 */

Path.prototype.toPath = function toPath() {
  if (this.keyType !== Path.types.HD)
    return null;

  return `m/${this.account}'/${this.branch}/${this.index}`;
};

/**
 * Convert path object to an address (currently unused).
 * @returns {Address}
 */

Path.prototype.toAddress = function toAddress(network) {
  return Address.fromHash(this.hash, this.type, this.version, network);
};

/**
 * Convert path to a json-friendly object.
 * @returns {Object}
 */

Path.prototype.toJSON = function toJSON() {
  return {
    name: this.name,
    account: this.account,
    change: this.branch === 1,
    derivation: this.toPath()
  };
};

/**
 * Inspect the path.
 * @returns {String}
 */

Path.prototype.inspect = function inspect() {
  return `<Path: ${this.id}(${this.wid})/${this.name}:${this.toPath()}>`;
};

/**
 * Expose
 */

module.exports = Path;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * protoreader.js - protobufs for wmcc_core.
 */



const assert = __webpack_require__(0);
const BufferReader = __webpack_require__(2);

/*
 * Constants
 */

const wireType = {
  VARINT: 0,
  FIXED64: 1,
  DELIMITED: 2,
  START_GROUP: 3,
  END_GROUP: 4,
  FIXED32: 5
};

/**
 * ProtoBuf Reader
 * @alias module:utils.ProtoReader
 * @constructor
 */

function ProtoReader(data, zeroCopy) {
  if (!(this instanceof ProtoReader))
    return new ProtoReader(data, zeroCopy);

  BufferReader.call(this, data, zeroCopy);
}

Object.setPrototypeOf(ProtoReader.prototype, BufferReader.prototype);

ProtoReader.prototype.readVarint = function readVarint() {
  const {size, value} = _readVarint(this.data, this.offset);
  this.offset += size;
  return value;
};

ProtoReader.prototype.readFieldValue = function readFieldValue(tag, opt) {
  const field = this.readField(tag, opt);

  if (!field)
    return -1;

  assert(field.value != null);

  return field.value;
};

ProtoReader.prototype.readFieldU64 = function readFieldU64(tag, opt) {
  const field = this.readField(tag, opt);

  if (!field)
    return -1;

  assert(field.type === wireType.VARINT || field.type === wireType.FIXED64);

  return field.value;
};

ProtoReader.prototype.readFieldU32 = function readFieldU32(tag, opt) {
  const field = this.readField(tag, opt);

  if (!field)
    return -1;

  assert(field.type === wireType.VARINT || field.type === wireType.FIXED32);

  return field.value;
};

ProtoReader.prototype.readFieldBytes = function readFieldBytes(tag, opt) {
  const field = this.readField(tag, opt);

  if (!field)
    return null;

  assert(field.data);

  return field.data;
};

ProtoReader.prototype.readFieldString = function readFieldString(tag, opt, enc) {
  const field = this.readField(tag, opt);

  if (!field)
    return null;

  assert(field.data);

  return field.data.toString(enc || 'utf8');
};

ProtoReader.prototype.nextTag = function nextTag() {
  if (this.left() === 0)
    return -1;

  const field = this.readField();

  this.seek(-field.size);

  return field.tag;
};

ProtoReader.prototype.readField = function readField(tag, opt) {
  const offset = this.offset;
  const header = this.readVarint();
  const field = new Field(header);

  if (tag != null && field.tag !== tag) {
    assert(opt, 'Non-optional field not present.');
    this.offset = offset;
    return null;
  }

  switch (field.type) {
    case wireType.VARINT:
      field.value = this.readVarint();
      break;
    case wireType.FIXED64:
      field.value = this.readU64();
      break;
    case wireType.DELIMITED:
      field.data = this.readVarBytes();
      break;
    case wireType.START_GROUP:
      field.group = [];
      for (;;) {
        const inner = this.readField();
        if (inner.type === wireType.END_GROUP)
          break;
        field.group.push(inner);
      }
      break;
    case wireType.END_GROUP:
      assert(false, 'Unexpected end group.');
      break;
    case wireType.FIXED32:
      field.value = this.readU32();
      break;
    default:
      assert(false, 'Bad wire type.');
      break;
  }

  field.size = this.offset - offset;

  return field;
};

/*
 * Encoding
 */

function _readVarint(data, off) {
  let num = 0;
  let ch = 0x80;
  let size = 0;

  while (ch & 0x80) {
    if (off >= data.length) {
      num = 0;
      break;
    }

    ch = data[off++];

    // Optimization for javascript insanity.
    switch (size) {
      case 0:
      case 1:
      case 2:
      case 3:
        num += (ch & 0x7f) << (7 * size);
        break;
      case 4:
        num += (ch & 0x7f) * (1 << (7 * size));
        break;
      default:
        num += (ch & 0x7f) * Math.pow(2, 7 * size);
        break;
    }

    size++;

    assert(size < 7, 'Number exceeds 2^53-1.');
  }

  return new Varint(size, num);
}

/*
 * Helpers
 */

function Field(header) {
  this.tag = header >>> 3;
  this.type = header & 7;
  this.size = 0;
  this.value = 0;
  this.data = null;
  this.group = null;
}

function Varint(size, value) {
  this.size = size;
  this.value = value;
}

/*
 * Expose
 */

module.exports = ProtoReader;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * protowriter.js - protobufs for wmcc_core.
 */



/**
 * @module utils/protobuf
 */

const assert = __webpack_require__(0);
const BufferWriter = __webpack_require__(62);

/*
 * Constants
 */

const wireType = {
  VARINT: 0,
  FIXED64: 1,
  DELIMITED: 2,
  START_GROUP: 3,
  END_GROUP: 4,
  FIXED32: 5
};

/**
 * ProtoBuf Writer
 * @alias module:utils.ProtoWriter
 * @constructor
 */

function ProtoWriter() {
  if (!(this instanceof ProtoWriter))
    return new ProtoWriter();

  BufferWriter.call(this);
}

Object.setPrototypeOf(ProtoWriter.prototype, BufferWriter.prototype);

ProtoWriter.prototype.writeVarint = function writeVarint(num) {
  const size = sizeVarint(num);

  // Avoid an extra allocation until
  // we make bufferwriter more hackable.
  // More insanity here...
  switch (size) {
    case 6: {
      const value = slipVarint(num);
      this.writeU32BE(value / 0x10000 | 0);
      this.writeU16BE(value & 0xffff);
      break;
    }
    case 5: {
      const value = slipVarint(num);
      this.writeU32BE(value / 0x100 | 0);
      this.writeU8(value & 0xff);
      break;
    }
    case 4: {
      const value = slipVarint(num);
      this.writeU32BE(value);
      break;
    }
    case 3: {
      const value = slipVarint(num);
      this.writeU16BE(value >> 8);
      this.writeU8(value & 0xff);
      break;
    }
    case 2: {
      const value = slipVarint(num);
      this.writeU16BE(value);
      break;
    }
    case 1: {
      const value = slipVarint(num);
      this.writeU8(value);
      break;
    }
    default: {
      const value = Buffer.allocUnsafe(size);
      _writeVarint(value, num, 0);
      this.writeBytes(value);
      break;
    }
  }
};

ProtoWriter.prototype.writeFieldVarint = function writeFieldVarint(tag, value) {
  const header = (tag << 3) | wireType.VARINT;
  this.writeVarint(header);
  this.writeVarint(value);
};

ProtoWriter.prototype.writeFieldU64 = function writeFieldU64(tag, value) {
  assert(Number.isSafeInteger(value));
  this.writeFieldVarint(tag, value);
};

ProtoWriter.prototype.writeFieldU32 = function writeFieldU32(tag, value) {
  assert(value <= 0xffffffff);
  this.writeFieldVarint(tag, value);
};

ProtoWriter.prototype.writeFieldBytes = function writeFieldBytes(tag, data) {
  const header = (tag << 3) | wireType.DELIMITED;
  this.writeVarint(header);
  this.writeVarint(data.length);
  this.writeBytes(data);
};

ProtoWriter.prototype.writeFieldString = function writeFieldString(tag, data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc || 'utf8');
  this.writeFieldBytes(tag, data);
};

/*
 * Encoding
 */

function _writeVarint(data, num, off) {
  assert(Number.isSafeInteger(num), 'Number exceeds 2^53-1.');

  do {
    assert(off < data.length);
    let ch = num & 0x7f;
    num -= num % 0x80;
    num /= 0x80;
    if (num !== 0)
      ch |= 0x80;
    data[off] = ch;
    off++;
  } while (num > 0);

  return off;
};

function slipVarint(num) {
  assert(Number.isSafeInteger(num), 'Number exceeds 2^53-1.');

  let data = 0;
  let size = 0;

  do {
    assert(size < 7);
    let ch = num & 0x7f;
    num -= num % 0x80;
    num /= 0x80;
    if (num !== 0)
      ch |= 0x80;
    data *= 256;
    data += ch;
    size++;
  } while (num > 0);

  return data;
}

function sizeVarint(num) {
  assert(Number.isSafeInteger(num), 'Number exceeds 2^53-1.');

  let size = 0;

  do {
    num -= num % 0x80;
    num /= 0x80;
    size++;
  } while (num > 0);

  return size;
};

/*
 * Expose
 */

module.exports = ProtoWriter;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * network.js - WMCC networks for wmcc_core.
 */



/**
 * @module protocol/networks
 */

const BN = __webpack_require__(27);

const network = exports;

/**
 * Network type list.
 * @memberof module:protocol/networks
 * @const {String[]}
 * @default
 */

network.types = ['mainnet', 'testnet', 'regtest', 'simnet'];

/**
 * Mainnet
 * @static
 * @lends module:protocol/networks
 * @type {Object}
 */

const mainnet = {};

/**
 * Symbolic network type.
 * @const {String}
 * @default
 */

mainnet.type = 'mainnet';

/**
 * Default DNS seeds.
 * @const {String[]}
 * @default
 */

mainnet.seeds = [
  'mainnet.wmcc.network'
];

/**
 * Packet magic number.
 * @const {Number}
 * @default
 */

mainnet.magic = 0xc848e559;

/**
 * Default network port.
 * @const {Number}
 * @default
 */

mainnet.port = 8880;

/**
 * Checkpoint block list.
 * @const {Object}
 */

mainnet.checkpointMap = {
  /*block height: block hash*/
};

/**
 * Last checkpoint height.
 * @const {Number}
 * @default
 */

mainnet.lastCheckpoint = 0;

/**
 * @const {Number}
 * @default
 */

mainnet.halvingInterval = 42000000; //210000; ~400 years

/**
 * Genesis block header.
 * @const {NakedBlock}
 */

mainnet.genesis = {
  version: 1,
  hash: '7212511001f38a7b3b8ac819cc49024d1a2206b1b0f23fdeb485277b850f0000', /* here */
  prevBlock: '0000000000000000000000000000000000000000000000000000000000000000',
  merkleRoot: '49337a633ec2a4e8333243d82742c153a1772c9ac0646d444a330379500b75fe',
  time: 1513728000, /* here */
  bits: 504365040,
  nonce: 812349, /* here */
  height: 0
};

/**
 * Genesis block header.
 * @const {NakedBlock}

main.genesis = {
  version: 1,
  hash: '6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000',
  prevBlock: '0000000000000000000000000000000000000000000000000000000000000000',
  merkleRoot:
    '3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a',
  time: 1231006505,
  bits: 486604799,
  nonce: 2083236893,
  height: 0
};
 */

/**
 * The network's genesis block in a hex string.
 * @const {String}
 */

  mainnet.genesisBlock =
  //abstrack block
  '01000000' // version
  + '0000000000000000000000000000000000000000000000000000000000000000' // prevBlock
  + '49337a633ec2a4e8333243d82742c153a1772c9ac0646d444a330379500b75fe' // merkleRoot
  + '00a8395a' // time /* here */
  + 'f0ff0f1e' // bits // 1e0ffff0 le
  + '3d650c00' // /* here */
  // transaction
  + '01' // tx count
  + '01000000' // tx version
  + '00' // OR witness marker
  + '01' // OR witness flag
  // tx_in
  + '01' // tx_in count
  // tx_in outpoint arrays (prev_out)
  + '0000000000000000000000000000000000000000000000000000000000000000' // ref hash
  + 'ffffffff' // index
  + '30' // script length 48
  + '512067656e6573697320626c6f636b206d696e656420627920776d63635f636f' // signature script +32
  + '7265044f3aac96080000000000000000' // signature script +16
  + 'ffffffff' // sequence
  // tx_out
  + '03' // tx_out count
  // tx_out arrays
  // intial coin
  + '0080c6a47e8d0300' // tx value wmcoins 10M wmcc - initial
  + '19' // pk_script length 25
  + '76a9148efc12b15df7ae341786bb2cdeb6f5a59ed2497688ac'
  // reserve coin
  + '0080c6a47e8d0300' // tx value wmcoins 10M wmcc - reserve
  + '19' // pk_script length 25
  + '76a914456c9dc895ca8bc6e6bae8ca8f2a8a29018ca57d88ac'
  // witness 0x51 81
  + '0000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c' // +32
  + '690689799962b48bebd836974e8cf90120000000000000000000000000000000' // +32
  + '0000000000000000000000000000000000' // +17
  // lock_time
  + '00000000';

/**
 * The network's genesis block in a hex string.
 * @const {String}

mainnet.genesisBlock =
  '0100000000000000000000000000000000000000000000000000000000000000000000'
  + '003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a29ab'
  + '5f49ffff001d1dac2b7c01010000000100000000000000000000000000000000000000'
  + '00000000000000000000000000ffffffff4d04ffff001d0104455468652054696d6573'
  + '2030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66'
  + '207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01'
  + '000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f'
  + '61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f'
  + 'ac00000000';
 */

/**
 * POW-related constants.
 * @enum {Number}
 * @default
 */

mainnet.pow = {
  /**
   * Default target.
   * @const {BN}
   */

  limit: new BN(
    '00000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',
    'hex'
  ),

  /**
   * Compact pow limit.
   * @const {Number}
   * @default
   */

  bits: 504365040,

  /**
   * Minimum chainwork for best chain.
   * @const {BN}
   */

  chainwork: new BN(
    '0000000000000000000000000000000000000000000000000000000000100010',
    'hex'
  ),

  /**
   * Desired retarget period in seconds.
   * @const {Number}
   * @default
   */

  targetTimespan: 7 * 24 * 60 * 60,

  /**
   * Average block time.
   * @const {Number}
   * @default
   */

  targetSpacing: 5 * 60,

  /**
   * Retarget interval in blocks.
   * @const {Number}
   * @default
   */

  retargetInterval: 2016,

  /**
   * Whether to reset target if a block
   * has not been mined recently.
   * @const {Boolean}
   * @default
   */

  targetReset: false,

  /**
   * Do not allow retargetting.
   * @const {Boolean}
   * @default
   */

  noRetargeting: false
};

/**
 * Block constants.
 * @enum {Number}
 * @default
 */

mainnet.block = {
  /**
   * Height at which bip34 was activated.
   * Used for avoiding bip30 checks.
   */

  bip34height: 0,

  /**
   * Hash of the block that activated bip34.
   */

  bip34hash: '7212511001f38a7b3b8ac819cc49024d1a2206b1b0f23fdeb485277b850f0000', /* here */

  /**
   * Height at which bip65 was activated.
   */

  bip65height: 0,

  /**
   * Hash of the block that activated bip65.
   */

  bip65hash: '7212511001f38a7b3b8ac819cc49024d1a2206b1b0f23fdeb485277b850f0000', /* here */

  /**
   * Height at which bip66 was activated.
   */

  bip66height: 0,

  /**
   * Hash of the block that activated bip66.
   */

  bip66hash: '7212511001f38a7b3b8ac819cc49024d1a2206b1b0f23fdeb485277b850f0000', /* here */

  /**
   * Safe height to start pruning.
   */

  pruneAfterHeight: 1000,

  /**
   * Safe number of blocks to keep.
   */

  keepBlocks: 288,

  /**
   * Age used for the time delta to
   * determine whether the chain is synced.
   */

  maxTipAge: 24 * 60 * 60,

  /**
   * Height at which block processing is
   * slow enough that we can output
   * logs without spamming.
   */

  slowHeight: 650000
};

/**
 * Map of historical blocks which create duplicate transactions hashes.
 * @see https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki
 * @const {Object}
 * @default
 */

mainnet.bip30 = {
};

/**
 * For versionbits.
 * @const {Number}
 * @default
 */

mainnet.activationThreshold = 3831; // ~95% of 4032

/**
 * Confirmation window for versionbits.
 * @const {Number}
 * @default
 */

mainnet.minerWindow = 4032; // nPowTargetTimespan / nPowTargetSpacing

/**
 * Deployments for versionbits.
 * @const {Object}
 * @default
 */

mainnet.deployments = {
  csv: {
    name: 'csv',
    bit: 0,
    startTime: 1509494400, // November 1st, 2017.
    timeout: 1541030400, // November 1st, 2018.
    threshold: -1,
    window: -1,
    required: false,
    force: true
  },
  segwit: {
    name: 'segwit',
    bit: 1,
    startTime: 1509494400, // November 1st, 2017.
    timeout: 1541030400, // November 1st, 2018.
    threshold: -1,
    window: -1,
    required: true,
    force: false
  },
  segsignal: {
    name: 'segsignal',
    bit: 4,
    startTime: 1509494400, // November 1st, 2017.
    timeout: 1541030400, // November 1st, 2018.
    threshold: 269, // 80%
    window: 336, // ~2.33 days
    required: false,
    force: false
  },
  testdummy: {
    name: 'testdummy',
    bit: 28,
    startTime: 1509494400, // November 1st, 2017.
    timeout: 1541030400, // November 1st, 2018.
    threshold: -1,
    window: -1,
    required: false,
    force: true
  }
};

/**
 * Deployments for versionbits (array form, sorted).
 * @const {Array}
 * @default
 */

mainnet.deploys = [
  mainnet.deployments.csv,
  mainnet.deployments.segwit,
  mainnet.deployments.segsignal,
  mainnet.deployments.testdummy
];

/**
 * Key prefixes.
 * @enum {Number}
 * @default
 */

mainnet.keyPrefix = {
  privkey: 0x42,
  xpubkey: 0x0488b21e,
  xprivkey: 0x0488ade4,
  xpubkey58: 'xpub',
  xprivkey58: 'xprv',
  coinType: 0
};

/**
 * {@link Address} prefixes.
 * @enum {Number}
 */

mainnet.addressPrefix = {
  pubkeyhash: 0x49,
  scripthash: 0x4b,
  witnesspubkeyhash: 0x06,
  witnessscripthash: 0x0a,
  bech32: 'wc'
};

/**
 * Default value for whether the mempool
 * accepts non-standard transactions.
 * @const {Boolean}
 * @default
 */

mainnet.requireStandard = true;

/**
 * Default http port.
 * @const {Number}
 * @default
 */

mainnet.rpcPort = 7880;

/**
 * Default min relay rate.
 * @const {Rate}
 * @default
 */

mainnet.minRelay = 1000;

/**
 * Default normal relay rate.
 * @const {Rate}
 * @default
 */

mainnet.feeRate = 100000;

/**
 * Maximum normal relay rate.
 * @const {Rate}
 * @default
 */

mainnet.maxFeeRate = 400000;

/**
 * Whether to allow self-connection.
 * @const {Boolean}
 */

mainnet.selfConnect = false;

/**
 * Whether to request mempool on sync.
 * @const {Boolean}
 */

mainnet.requestMempool = false;

/*
 * Testnet (v3)
 * https://en.bitcoin.it/wiki/Testnet
 */

const testnet = {};

testnet.type = 'testnet';

testnet.seeds = [
  'testnet.wmcc.network',
  'testnet.worldmobilecoin.net'
];

testnet.magic = 0x5c6915a7;

testnet.port = 18880;

testnet.checkpointMap = {
};

testnet.lastCheckpoint = 0;

testnet.halvingInterval = 42000000;

testnet.genesis = {
  version: 1,
  hash: '43497fd7f826957108f4a30fd9cec3aeba79972084e90ead01ea330900000000',
  prevBlock: '0000000000000000000000000000000000000000000000000000000000000000',
  merkleRoot:
    '3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a',
  time: 1296688602,
  bits: 486604799,
  nonce: 414098458,
  height: 0
};

testnet.genesisBlock =
  '0100000000000000000000000000000000000000000000000000000000000000000000'
  + '003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4adae5'
  + '494dffff001d1aa4ae1801010000000100000000000000000000000000000000000000'
  + '00000000000000000000000000ffffffff4d04ffff001d0104455468652054696d6573'
  + '2030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66'
  + '207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01'
  + '000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f'
  + '61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f'
  + 'ac00000000';

testnet.pow = {
  limit: new BN(
    '00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff',
    'hex'
  ),
  bits: 486604799,
  chainwork: new BN(
    '0000000000000000000000000000000000000000000000286d17360c5492b2c4',
    'hex'
  ),
  targetTimespan: 7 * 24 * 60 * 60,
  targetSpacing: 5 * 60,
  retargetInterval: 2016,
  targetReset: true,
  noRetargeting: false
};

testnet.block = {
  bip34height: 1,
  bip34hash: 'f88ecd9912d00d3f5c2a8e0f50417d3e415c75b3abe584346da9b32300000000',
  bip65height: 1,
  bip65hash: 'b61e864fbec41dfaf09da05d1d76dc068b0dd82ee7982ff255667f0000000000',
  bip66height: 1,
  bip66hash: '82a14b9e5ea81d4832b8e2cd3c2a6092b5a3853285a8995ec4c8042100000000',
  pruneAfterHeight: 1000,
  keepBlocks: 10000,
  maxTipAge: 24 * 60 * 60,
  slowHeight: 950000
};

testnet.bip30 = {};

testnet.activationThreshold = 1512; // 75% for testchains

testnet.minerWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing

testnet.deployments = {
  csv: {
    name: 'csv',
    bit: 0,
    startTime: 1456790400, // March 1st, 2016
    timeout: 1493596800, // May 1st, 2017
    threshold: -1,
    window: -1,
    required: false,
    force: true
  },
  segwit: {
    name: 'segwit',
    bit: 1,
    startTime: 1462060800, // May 1st 2016
    timeout: 1493596800, // May 1st 2017
    threshold: -1,
    window: -1,
    required: true,
    force: false
  },
  segsignal: {
    name: 'segsignal',
    bit: 4,
    startTime: 0xffffffff,
    timeout: 0xffffffff,
    threshold: 269,
    window: 336,
    required: false,
    force: false
  },
  testdummy: {
    name: 'testdummy',
    bit: 28,
    startTime: 1199145601, // January 1, 2008
    timeout: 1230767999, // December 31, 2008
    threshold: -1,
    window: -1,
    required: false,
    force: true
  }
};

testnet.deploys = [
  testnet.deployments.csv,
  testnet.deployments.segwit,
  testnet.deployments.segsignal,
  testnet.deployments.testdummy
];

testnet.keyPrefix = {
  privkey: 0x47, //? WIF 0xef
  xpubkey: 0x043587cf,
  xprivkey: 0x04358394,
  xpubkey58: 'tpub',
  xprivkey58: 'tprv',
  coinType: 1
};

testnet.addressPrefix = {
  pubkeyhash: 0x4e,
  scripthash: 0x50,
  witnesspubkeyhash: 0x03,
  witnessscripthash: 0x28,
  bech32: 'tb'
};

testnet.requireStandard = false;

testnet.rpcPort = 17880;

testnet.minRelay = 1000;

testnet.feeRate = 20000;

testnet.maxFeeRate = 60000;

testnet.selfConnect = false;

testnet.requestMempool = false;

/*
 * Regtest
 */

const regtest = {};

regtest.type = 'regtest';

regtest.seeds = [
  '127.0.0.1'
];

regtest.magic = 0x24e09353;

regtest.port = 28880;

regtest.checkpointMap = {};
regtest.lastCheckpoint = 0;

regtest.halvingInterval = 150;

regtest.genesis = {
  version: 1,
  hash: '06226e46111a0b59caaf126043eb5bbf28c34f3a5e332a1fc7b2b73cf188910f',
  prevBlock: '0000000000000000000000000000000000000000000000000000000000000000',
  merkleRoot:
    '3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a',
  time: 1296688602,
  bits: 545259519,
  nonce: 2,
  height: 0
};

regtest.genesisBlock =
  '0100000000000000000000000000000000000000000000000000000000000000000000'
  + '003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4adae5'
  + '494dffff7f200200000001010000000100000000000000000000000000000000000000'
  + '00000000000000000000000000ffffffff4d04ffff001d0104455468652054696d6573'
  + '2030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66'
  + '207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01'
  + '000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f'
  + '61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f'
  + 'ac00000000';

regtest.pow = {
  limit: new BN(
    '7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',
    'hex'
  ),
  bits: 545259519,
  chainwork: new BN(
    '0000000000000000000000000000000000000000000000000000000000000002',
    'hex'
  ),
  targetTimespan: 7 * 24 * 60 * 60,
  targetSpacing: 5 * 60,
  retargetInterval: 2016,
  targetReset: true,
  noRetargeting: true
};

regtest.block = {
  bip34height: 0xffffffff,
  bip34hash: null,
  bip65height: 1351,
  bip65hash: null,
  bip66height: 1251,
  bip66hash: null,
  pruneAfterHeight: 1000,
  keepBlocks: 10000,
  maxTipAge: 0xffffffff,
  slowHeight: 0
};

regtest.bip30 = {};

regtest.activationThreshold = 108; // 75% for testchains

regtest.minerWindow = 144; // Faster than normal for regtest

regtest.deployments = {
  csv: {
    name: 'csv',
    bit: 0,
    startTime: 0,
    timeout: 0xffffffff,
    threshold: -1,
    window: -1,
    required: false,
    force: true
  },
  segwit: {
    name: 'segwit',
    bit: 1,
    startTime: 0,
    timeout: 0xffffffff,
    threshold: -1,
    window: -1,
    required: true,
    force: false
  },
  segsignal: {
    name: 'segsignal',
    bit: 4,
    startTime: 0xffffffff,
    timeout: 0xffffffff,
    threshold: 269,
    window: 336,
    required: false,
    force: false
  },
  testdummy: {
    name: 'testdummy',
    bit: 28,
    startTime: 0,
    timeout: 0xffffffff,
    threshold: -1,
    window: -1,
    required: false,
    force: true
  }
};

regtest.deploys = [
  regtest.deployments.csv,
  regtest.deployments.segwit,
  regtest.deployments.segsignal,
  regtest.deployments.testdummy
];

regtest.keyPrefix = {
  privkey: 0x5a,
  xpubkey: 0xeab4fa05,
  xprivkey: 0xeab404c7,
  xpubkey58: 'rpub',
  xprivkey58: 'rprv',
  coinType: 1
};

regtest.addressPrefix = {
  pubkeyhash: 0x3c,
  scripthash: 0x26,
  witnesspubkeyhash: 0x7a,
  witnessscripthash: 0x14,
  bech32: 'rb'
};

regtest.requireStandard = false;

regtest.rpcPort = 27880;

regtest.minRelay = 1000;

regtest.feeRate = 20000;

regtest.maxFeeRate = 60000;

regtest.selfConnect = true;

regtest.requestMempool = true;

/*
 * Simnet (btcd)
 */

const simnet = {};

simnet.type = 'simnet';

simnet.seeds = [
  '127.0.0.1'
];

simnet.magic = 0xcd326176;

simnet.port = 38880;

simnet.checkpointMap = {};

simnet.lastCheckpoint = 0;

simnet.halvingInterval = 210000;

simnet.genesis = {
  version: 1,
  hash: 'f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68',
  prevBlock: '0000000000000000000000000000000000000000000000000000000000000000',
  merkleRoot:
    '3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a',
  time: 1401292357,
  bits: 545259519,
  nonce: 2,
  height: 0
};

simnet.genesisBlock =
  '0100000000000000000000000000000000000000000000000000000000000000000000'
  + '003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a4506'
  + '8653ffff7f200200000001010000000100000000000000000000000000000000000000'
  + '00000000000000000000000000ffffffff4d04ffff001d0104455468652054696d6573'
  + '2030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66'
  + '207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01'
  + '000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f'
  + '61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f'
  + 'ac00000000';

simnet.pow = {
  limit: new BN(
    // High target of 0x207fffff (545259519)
    '7fffff0000000000000000000000000000000000000000000000000000000000',
    'hex'
  ),
  bits: 545259519,
  chainwork: new BN(
    '0000000000000000000000000000000000000000000000000000000000000002',
    'hex'
  ),
  targetTimespan: 7 * 24 * 60 * 60,
  targetSpacing: 5 * 60,
  retargetInterval: 2016,
  targetReset: true,
  noRetargeting: false
};

simnet.block = {
  bip34height: 0,
  bip34hash: 'f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68',
  bip65height: 0,
  bip65hash: 'f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68',
  bip66height: 0,
  bip66hash: 'f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68',
  pruneAfterHeight: 1000,
  keepBlocks: 10000,
  maxTipAge: 0xffffffff,
  slowHeight: 0
};

simnet.bip30 = {};

simnet.activationThreshold = 75; // 75% for testchains

simnet.minerWindow = 100; // nPowTargetTimespan / nPowTargetSpacing

simnet.deployments = {
  csv: {
    name: 'csv',
    bit: 0,
    startTime: 0, // March 1st, 2016
    timeout: 0xffffffff, // May 1st, 2017
    threshold: -1,
    window: -1,
    required: false,
    force: true
  },
  segwit: {
    name: 'segwit',
    bit: 1,
    startTime: 0, // May 1st 2016
    timeout: 0xffffffff, // May 1st 2017
    threshold: -1,
    window: -1,
    required: true,
    force: false
  },
  segsignal: {
    name: 'segsignal',
    bit: 4,
    startTime: 0xffffffff,
    timeout: 0xffffffff,
    threshold: 269,
    window: 336,
    required: false,
    force: false
  },
  testdummy: {
    name: 'testdummy',
    bit: 28,
    startTime: 1199145601, // January 1, 2008
    timeout: 1230767999, // December 31, 2008
    threshold: -1,
    window: -1,
    required: false,
    force: true
  }
};

simnet.deploys = [
  simnet.deployments.csv,
  simnet.deployments.segwit,
  simnet.deployments.segsignal,
  simnet.deployments.testdummy
];

simnet.keyPrefix = {
  privkey: 0x64,
  xpubkey: 0x0420bd3a,
  xprivkey: 0x0420b900,
  xpubkey58: 'spub',
  xprivkey58: 'sprv',
  coinType: 115
};

simnet.addressPrefix = {
  pubkeyhash: 0x3f,
  scripthash: 0x7b,
  witnesspubkeyhash: 0x19,
  witnessscripthash: 0x28,
  bech32: 'sc'
};

simnet.requireStandard = false;

simnet.rpcPort = 37880;

simnet.minRelay = 1000;

simnet.feeRate = 20000;

simnet.maxFeeRate = 60000;

simnet.selfConnect = false;

simnet.requestMempool = false;

/*
 * Expose
 */

network.mainnet = mainnet;
network.testnet = testnet;
network.regtest = regtest;
network.simnet = simnet;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * timedata.js - time management for wmcc_core.
 */



const EventEmitter = __webpack_require__(10);
const util = __webpack_require__(1);

/**
 * An object which handles "adjusted time". This may not
 * look it, but this is actually a semi-consensus-critical
 * piece of code. It handles version packets from peers
 * and calculates what to offset our system clock's time by.
 * @alias module:protocol.TimeData
 * @constructor
 * @param {Number} [limit=200]
 * @property {Array} samples
 * @property {Object} known
 * @property {Number} limit
 * @property {Number} offset
 */

function TimeData(limit) {
  if (!(this instanceof TimeData))
    return new TimeData(limit);

  EventEmitter.call(this);

  if (limit == null)
    limit = 200;

  this.samples = [];
  this.known = new Map();
  this.limit = limit;
  this.offset = 0;
  this.checked = false;
  this.ntp = new NTP();
}

Object.setPrototypeOf(TimeData.prototype, EventEmitter.prototype);

/**
 * Initiate ntp time.
 * return {Promise}
 */

TimeData.prototype.current = function current(options) {
  options = options || {};
  return this.ntp.getTime(options);
};

/**
 * Add time data.
 * @param {String} id
 * @param {Number} time
 */

TimeData.prototype.add = function add(id, time) {
  if (this.samples.length >= this.limit)
    return;

  if (this.known.has(id))
    return;

  const sample = time - util.now();

  this.known.set(id, sample);

  util.binaryInsert(this.samples, sample, compare);

  this.emit('sample', sample, this.samples.length);

  if (this.samples.length >= 5 && this.samples.length % 2 === 1) {
    let median = this.samples[this.samples.length >>> 1];

    if (Math.abs(median) >= 70 * 60) {
      if (!this.checked) {
        let match = false;

        for (const offset of this.samples) {
          if (offset !== 0 && Math.abs(offset) < 5 * 60) {
            match = true;
            break;
          }
        }

        if (!match) {
          this.checked = true;
          this.emit('mismatch');
        }
      }

      median = 0;
    }

    this.offset = median;
    this.emit('offset', this.offset);
  }
};

/**
 * Get the current adjusted time.
 * @returns {Number} Adjusted Time.
 */

TimeData.prototype.now = function now() {
  return util.now() + this.offset;
};

/**
 * Adjust a timestamp.
 * @param {Number} time
 * @returns {Number} Adjusted Time.
 */

TimeData.prototype.adjust = function adjust(time) {
  return time + this.offset;
};

/**
 * Unadjust a timestamp.
 * @param {Number} time
 * @returns {Number} Local Time.
 */

TimeData.prototype.local = function local(time) {
  return time - this.offset;
};

/**
 * Get the current adjusted time in milliseconds.
 * @returns {Number} Adjusted Time.
 */

TimeData.prototype.ms = function ms() {
  return util.ms() + this.offset * 1000;
};

/**
 * NTP private function to sync network time
 */

const dgram = __webpack_require__(98);

function NTP() {
  this.defaultServer = "pool.ntp.org";
  this.defaultPort = 123;
  this.replyTimeout = 10000;

  this.server = null;
  this.port = null;
};

NTP.prototype.getTime = function getTime(options) {
  return new Promise((resolve, reject) => {
    this.server = options.server || this.defaultServer;
    this.port = options.port || this.defaultPort;

    const client = dgram.createSocket("udp4");
    const data = Buffer.allocUnsafe(48);

    data[0] = 0x1B;

    const timeout = setTimeout(() => {
      client.close();
      reject('NTP Server timeout');
    }, this.replyTimeout);

    let errorFired = false;

    client.on('error', (err) => {
      if (errorFired)
        return;

      errorFired = true;
      clearTimeout(timeout);
      reject(err);
    });

    client.send(data, 0, data.length, this.port, this.server, (err) => {
      if (err) {
        if (errorFired)
          return;

        clearTimeout(timeout);
        errorFired = true;
        client.close();
        reject(err);
        return;
      }
    });

    client.once('message', (msg) => {
      clearTimeout(timeout);
      client.close();

      const offsetTransmitTime = 40;
      let intpart = 0;
      let fractpart = 0;

      for (let i = 0; i <= 3; i++)
        intpart = 256 * intpart + msg[offsetTransmitTime + i];

      for (let j = 4; j <= 7; j++)
        fractpart = 256 * fractpart + msg[offsetTransmitTime + j];

      const milliseconds = (intpart * 1000 + (fractpart * 1000) / 0x100000000);

      const date = new Date("Jan 01 1900 GMT");
      date.setUTCMilliseconds(date.getUTCMilliseconds() + milliseconds);

      resolve(Math.floor(date.getTime()/1000));
    });

  });
};

/*
 * Helpers
 */

function compare(a, b) {
  return a - b;
}

/*
 * Expose
 */

module.exports = TimeData;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * program.js - program object for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const common = __webpack_require__(28);
const scriptTypes = common.types;

/**
 * Witness Program
 * @constructor
 * @alias module:script.Program
 * @param {Number} version
 * @param {Buffer} data
 * @property {Number} version - Ranges from 0 to 16.
 * @property {String|null} type - Null if malformed. `unknown` if unknown
 * version (treated as anyone-can-spend). Otherwise one of `witnesspubkeyhash`
 * or `witnessscripthash`.
 * @property {Buffer} data - The hash (for now).
 */

function Program(version, data) {
  if (!(this instanceof Program))
    return new Program(version, data);

  assert(util.isU8(version));
  assert(version >= 0 && version <= 16);
  assert(Buffer.isBuffer(data));
  assert(data.length >= 2 && data.length <= 40);

  this.version = version;
  this.data = data;
}

/**
 * Get the witness program type.
 * @returns {ScriptType}
 */

Program.prototype.getType = function getType() {
  if (this.version === 0) {
    if (this.data.length === 20)
      return scriptTypes.WITNESSPUBKEYHASH;

    if (this.data.length === 32)
      return scriptTypes.WITNESSSCRIPTHASH;

    // Fail on bad version=0
    return scriptTypes.WITNESSMALFORMED;
  }

  if (this.version === 1) {
    if (this.data.length === 32)
      return scriptTypes.WITNESSMASTHASH;

    // Fail on bad version=1
    return scriptTypes.WITNESSMALFORMED;
  }

  // No interpretation of script (anyone can spend)
  return scriptTypes.NONSTANDARD;
};

/**
 * Test whether the program is either
 * an unknown version or malformed.
 * @returns {Boolean}
 */

Program.prototype.isUnknown = function isUnknown() {
  const type = this.getType();
  return type === scriptTypes.WITNESSMALFORMED
    || type === scriptTypes.NONSTANDARD;
};

/**
 * Test whether the program is malformed.
 * @returns {Boolean}
 */

Program.prototype.isMalformed = function isMalformed() {
  return this.getType() === scriptTypes.WITNESSMALFORMED;
};

/**
 * Inspect the program.
 * @returns {String}
 */

Program.prototype.inspect = function inspect() {
  const data = this.data.toString('hex');
  const type = common.typesByVal[this.getType()].toLowerCase();
  return `<Program: version=${this.version} data=${data} type=${type}>`;
};

/*
 * Expose
 */

module.exports = Program;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(15);
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(15);
var common = __webpack_require__(32);
var shaCommon = __webpack_require__(83);
var assert = __webpack_require__(22);

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(15);
var common = __webpack_require__(32);
var assert = __webpack_require__(22);

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * opcode.js - opcode object for wmcc_core.
 */



const assert = __webpack_require__(0);
const ScriptNum = __webpack_require__(33);
const util = __webpack_require__(1);
const common = __webpack_require__(28);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const opcodes = common.opcodes;

const opCache = [];

let PARSE_ERROR = null;

/**
 * A simple struct which contains
 * an opcode and pushdata buffer.
 * Note: this should not be called directly.
 * @alias module:script.Opcode
 * @constructor
 * @param {Number} value - Opcode.
 * @param {Buffer?} data - Pushdata buffer.
 * @property {Number} value
 * @property {Buffer|null} data
 */

function Opcode(value, data) {
  if (!(this instanceof Opcode))
    return new Opcode(value, data);

  this.value = value || 0;
  this.data = data || null;
}

/**
 * Test whether a pushdata abides by minimaldata.
 * @returns {Boolean}
 */

Opcode.prototype.isMinimal = function isMinimal() {
  if (!this.data)
    return true;

  if (this.data.length === 1) {
    if (this.data[0] === 0x81)
      return false;

    if (this.data[0] >= 1 && this.data[0] <= 16)
      return false;
  }

  if (this.data.length <= 0x4b)
    return this.value === this.data.length;

  if (this.data.length <= 0xff)
    return this.value === opcodes.OP_PUSHDATA1;

  if (this.data.length <= 0xffff)
    return this.value === opcodes.OP_PUSHDATA2;

  assert(this.value === opcodes.OP_PUSHDATA4);

  return true;
};

/**
 * Test whether opcode is a disabled opcode.
 * @returns {Boolean}
 */

Opcode.prototype.isDisabled = function isDisabled() {
  switch (this.value) {
    case opcodes.OP_CAT:
    case opcodes.OP_SUBSTR:
    case opcodes.OP_LEFT:
    case opcodes.OP_RIGHT:
    case opcodes.OP_INVERT:
    case opcodes.OP_AND:
    case opcodes.OP_OR:
    case opcodes.OP_XOR:
    case opcodes.OP_2MUL:
    case opcodes.OP_2DIV:
    case opcodes.OP_MUL:
    case opcodes.OP_DIV:
    case opcodes.OP_MOD:
    case opcodes.OP_LSHIFT:
    case opcodes.OP_RSHIFT:
      return true;
  }
  return false;
};

/**
 * Test whether opcode is a branch (if/else/endif).
 * @returns {Boolean}
 */

Opcode.prototype.isBranch = function isBranch() {
  return this.value >= opcodes.OP_IF && this.value <= opcodes.OP_ENDIF;
};

/**
 * Test opcode equality.
 * @param {Opcode} op
 * @returns {Boolean}
 */

Opcode.prototype.equals = function equals(op) {
  assert(Opcode.isOpcode(op));

  if (this.value !== op.value)
    return false;

  if (!this.data) {
    assert(!op.data);
    return true;
  }

  assert(op.data);

  return this.data.equals(op.data);
};

/**
 * Convert Opcode to opcode value.
 * @returns {Number}
 */

Opcode.prototype.toOp = function toOp() {
  return this.value;
};

/**
 * Covert opcode to data push.
 * @returns {Buffer|null}
 */

Opcode.prototype.toData = function toData() {
  return this.data;
};

/**
 * Covert opcode to data length.
 * @returns {Number}
 */

Opcode.prototype.toLength = function toLength() {
  return this.data ? this.data.length : -1;
};

/**
 * Covert and _cast_ opcode to data push.
 * @returns {Buffer|null}
 */

Opcode.prototype.toPush = function toPush() {
  if (this.value === opcodes.OP_0)
    return common.small[0 + 1];

  if (this.value === opcodes.OP_1NEGATE)
    return common.small[-1 + 1];

  if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16)
    return common.small[this.value - 0x50 + 1];

  return this.toData();
};

/**
 * Get string for opcode.
 * @param {String?} enc
 * @returns {Buffer|null}
 */

Opcode.prototype.toString = function toString(enc) {
  const data = this.toPush();

  if (!data)
    return null;

  return data.toString(enc || 'utf8');
};

/**
 * Convert opcode to small integer.
 * @returns {Number}
 */

Opcode.prototype.toSmall = function toSmall() {
  if (this.value === opcodes.OP_0)
    return 0;

  if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16)
    return this.value - 0x50;

  return -1;
};

/**
 * Convert opcode to script number.
 * @param {Boolean?} minimal
 * @param {Number?} limit
 * @returns {ScriptNum|null}
 */

Opcode.prototype.toNum = function toNum(minimal, limit) {
  if (this.value === opcodes.OP_0)
    return ScriptNum.fromInt(0);

  if (this.value === opcodes.OP_1NEGATE)
    return ScriptNum.fromInt(-1);

  if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16)
    return ScriptNum.fromInt(this.value - 0x50);

  if (!this.data)
    return null;

  return ScriptNum.decode(this.data, minimal, limit);
};

/**
 * Convert opcode to integer.
 * @param {Boolean?} minimal
 * @param {Number?} limit
 * @returns {Number}
 */

Opcode.prototype.toInt = function toInt(minimal, limit) {
  const num = this.toNum(minimal, limit);

  if (!num)
    return -1;

  return num.getInt();
};

/**
 * Convert opcode to boolean.
 * @returns {Boolean}
 */

Opcode.prototype.toBool = function toBool() {
  const smi = this.toSmall();

  if (smi === -1)
    return false;

  return smi === 1;
};

/**
 * Convert opcode to its symbolic representation.
 * @returns {String}
 */

Opcode.prototype.toSymbol = function toSymbol() {
  if (this.value === -1)
    return 'OP_INVALIDOPCODE';

  const symbol = common.opcodesByVal[this.value];

  if (!symbol)
    return `0x${util.hex8(this.value)}`;

  return symbol;
};

/**
 * Calculate opcode size.
 * @returns {Number}
 */

Opcode.prototype.getSize = function getSize() {
  if (!this.data)
    return 1;

  switch (this.value) {
    case opcodes.OP_PUSHDATA1:
      return 2 + this.data.length;
    case opcodes.OP_PUSHDATA2:
      return 3 + this.data.length;
    case opcodes.OP_PUSHDATA4:
      return 5 + this.data.length;
    default:
      return 1 + this.data.length;
  }
};

/**
 * Encode the opcode to a buffer writer.
 * @param {BufferWriter} bw
 */

Opcode.prototype.toWriter = function toWriter(bw) {
  if (this.value === -1)
    throw new Error('Cannot reserialize a parse error.');

  if (!this.data) {
    bw.writeU8(this.value);
    return bw;
  }

  switch (this.value) {
    case opcodes.OP_PUSHDATA1:
      bw.writeU8(this.value);
      bw.writeU8(this.data.length);
      bw.writeBytes(this.data);
      break;
    case opcodes.OP_PUSHDATA2:
      bw.writeU8(this.value);
      bw.writeU16(this.data.length);
      bw.writeBytes(this.data);
      break;
    case opcodes.OP_PUSHDATA4:
      bw.writeU8(this.value);
      bw.writeU32(this.data.length);
      bw.writeBytes(this.data);
      break;
    default:
      assert(this.value === this.data.length);
      bw.writeU8(this.value);
      bw.writeBytes(this.data);
      break;
  }

  return bw;
};

/**
 * Encode the opcode.
 * @returns {Buffer}
 */

Opcode.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

/**
 * Convert the opcode to a wmccd test string.
 * @returns {String} Human-readable script code.
 */

Opcode.prototype.toFormat = function toFormat() {
  if (this.value === -1)
    return '0x01';

  if (this.data) {
    // Numbers
    if (this.data.length <= 4) {
      const num = this.toNum();
      if (this.equals(Opcode.fromNum(num)))
        return num.toString(10);
    }

    const symbol = common.opcodesByVal[this.value];
    const data = this.data.toString('hex');

    // Direct push
    if (!symbol) {
      const size = util.hex8(this.value);
      return `0x${size} 0x${data}`;
    }

    // Pushdatas
    let size = this.data.length.toString(16);

    while (size.length % 2 !== 0)
      size = '0' + size;

    return `${symbol} 0x${size} 0x${data}`;
  }

  // Opcodes
  const symbol = common.opcodesByVal[this.value];
  if (symbol)
    return symbol;

  // Unknown opcodes
  const value = util.hex8(this.value);

  return `0x${value}`;
};

/**
 * Format the opcode as wmccd asm.
 * @param {Boolean?} decode - Attempt to decode hash types.
 * @returns {String} Human-readable script.
 */

Opcode.prototype.toASM = function toASM(decode) {
  if (this.value === -1)
    return '[error]';

  if (this.data)
    return common.toASM(this.data, decode);

  return common.opcodesByVal[this.value] || 'OP_UNKNOWN';
};

/**
 * Instantiate an opcode from a number opcode.
 * @param {Number} op
 * @returns {Opcode}
 */

Opcode.fromOp = function fromOp(op) {
  assert(typeof op === 'number');

  const cached = opCache[op];

  assert(cached, 'Bad opcode.');

  return cached;
};

/**
 * Instantiate a pushdata opcode from
 * a buffer (will encode minimaldata).
 * @param {Buffer} data
 * @returns {Opcode}
 */

Opcode.fromData = function fromData(data) {
  assert(Buffer.isBuffer(data));

  if (data.length === 1) {
    if (data[0] === 0x81)
      return Opcode.fromOp(opcodes.OP_1NEGATE);

    if (data[0] >= 1 && data[0] <= 16)
      return Opcode.fromOp(data[0] + 0x50);
  }

  return Opcode.fromPush(data);
};

/**
 * Instantiate a pushdata opcode from a
 * buffer (this differs from fromData in
 * that it will _always_ be a pushdata op).
 * @param {Buffer} data
 * @returns {Opcode}
 */

Opcode.fromPush = function fromPush(data) {
  assert(Buffer.isBuffer(data));

  if (data.length === 0)
    return Opcode.fromOp(opcodes.OP_0);

  if (data.length <= 0x4b)
    return new Opcode(data.length, data);

  if (data.length <= 0xff)
    return new Opcode(opcodes.OP_PUSHDATA1, data);

  if (data.length <= 0xffff)
    return new Opcode(opcodes.OP_PUSHDATA2, data);

  if (data.length <= 0xffffffff)
    return new Opcode(opcodes.OP_PUSHDATA4, data);

  throw new Error('Pushdata size too large.');
};

/**
 * Instantiate a pushdata opcode from a string.
 * @param {String} str
 * @param {String} [enc=utf8]
 * @returns {Opcode}
 */

Opcode.fromString = function fromString(str, enc) {
  assert(typeof str === 'string');
  const data = Buffer.from(str, enc || 'utf8');
  return Opcode.fromData(data);
};

/**
 * Instantiate an opcode from a small number.
 * @param {Number} num
 * @returns {Opcode}
 */

Opcode.fromSmall = function fromSmall(num) {
  assert(util.isU8(num) && num >= 0 && num <= 16);
  return Opcode.fromOp(num === 0 ? 0 : num + 0x50);
};

/**
 * Instantiate an opcode from a ScriptNum.
 * @param {ScriptNumber} num
 * @returns {Opcode}
 */

Opcode.fromNum = function fromNum(num) {
  assert(ScriptNum.isScriptNum(num));
  return Opcode.fromData(num.encode());
};

/**
 * Instantiate an opcode from a Number.
 * @param {Number} num
 * @returns {Opcode}
 */

Opcode.fromInt = function fromInt(num) {
  assert(util.isInt(num));

  if (num === 0)
    return Opcode.fromOp(opcodes.OP_0);

  if (num === -1)
    return Opcode.fromOp(opcodes.OP_1NEGATE);

  if (num >= 1 && num <= 16)
    return Opcode.fromOp(num + 0x50);

  return Opcode.fromNum(ScriptNum.fromNumber(num));
};

/**
 * Instantiate an opcode from a Number.
 * @param {Boolean} value
 * @returns {Opcode}
 */

Opcode.fromBool = function fromBool(value) {
  assert(typeof value === 'boolean');
  return Opcode.fromSmall(value ? 1 : 0);
};

/**
 * Instantiate a pushdata opcode from symbolic name.
 * @example
 *   Opcode.fromSymbol('checksequenceverify')
 * @param {String} name
 * @returns {Opcode}
 */

Opcode.fromSymbol = function fromSymbol(name) {
  assert(typeof name === 'string');
  assert(name.length > 0);

  if (!util.isUpperCase(name))
    name = name.toUpperCase();

  if (!util.startsWith(name, 'OP_'))
    name = `OP_${name}`;

  const op = common.opcodes[name];

  if (op != null)
    return Opcode.fromOp(op);

  assert(util.startsWith(name, 'OP_0X'), 'Unknown opcode.');
  assert(name.length === 7, 'Unknown opcode.');

  const value = parseInt(name.substring(5), 16);

  assert(util.isU8(value), 'Unknown opcode.');

  return Opcode.fromOp(value);
};

/**
 * Instantiate opcode from buffer reader.
 * @param {BufferReader} br
 * @returns {Opcode}
 */

Opcode.fromReader = function fromReader(br) {
  const value = br.readU8();
  const op = opCache[value];

  if (op)
    return op;

  switch (value) {
    case opcodes.OP_PUSHDATA1: {
      if (br.left() < 1)
        return PARSE_ERROR;

      const size = br.readU8();

      if (br.left() < size) {
        br.seek(br.left());
        return PARSE_ERROR;
      }

      const data = br.readBytes(size);

      return new Opcode(value, data);
    }
    case opcodes.OP_PUSHDATA2: {
      if (br.left() < 2) {
        br.seek(br.left());
        return PARSE_ERROR;
      }

      const size = br.readU16();

      if (br.left() < size) {
        br.seek(br.left());
        return PARSE_ERROR;
      }

      const data = br.readBytes(size);

      return new Opcode(value, data);
    }
    case opcodes.OP_PUSHDATA4: {
      if (br.left() < 4) {
        br.seek(br.left());
        return PARSE_ERROR;
      }

      const size = br.readU32();

      if (br.left() < size) {
        br.seek(br.left());
        return PARSE_ERROR;
      }

      const data = br.readBytes(size);

      return new Opcode(value, data);
    }
    default: {
      if (br.left() < value) {
        br.seek(br.left());
        return PARSE_ERROR;
      }

      const data = br.readBytes(value);

      return new Opcode(value, data);
    }
  }
};

/**
 * Instantiate opcode from serialized data.
 * @param {Buffer} data
 * @returns {Opcode}
 */

Opcode.fromRaw = function fromRaw(data) {
  return Opcode.fromReader(new BufferReader(data));
};

/**
 * Test whether an object an Opcode.
 * @param {Object} obj
 * @returns {Boolean}
 */

Opcode.isOpcode = function isOpcode(obj) {
  return obj instanceof Opcode;
};

/*
 * Fill Cache
 */

PARSE_ERROR = Object.freeze(new Opcode(-1));

for (let value = 0x00; value <= 0xff; value++) {
  if (value >= 0x01 && value <= 0x4e) {
    opCache.push(null);
    continue;
  }
  const op = new Opcode(value);
  opCache.push(Object.freeze(op));
}

/*
 * Expose
 */

module.exports = Opcode;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * undocoins.js - undocoins object for wmcc_core.
 */



const assert = __webpack_require__(0);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const CoinEntry = __webpack_require__(50);

/**
 * UndoCoins
 * Coins need to be resurrected from somewhere
 * during a reorg. The undo coins store all
 * spent coins in a single record per block
 * (in a compressed format).
 * @alias module:coins.UndoCoins
 * @constructor
 * @property {UndoCoin[]} items
 */

function UndoCoins() {
  if (!(this instanceof UndoCoins))
    return new UndoCoins();

  this.items = [];
}

/**
 * Push coin entry onto undo coin array.
 * @param {CoinEntry}
 * @returns {Number}
 */

UndoCoins.prototype.push = function push(coin) {
  return this.items.push(coin);
};

/**
 * Calculate undo coins size.
 * @returns {Number}
 */

UndoCoins.prototype.getSize = function getSize() {
  let size = 0;

  size += 4;

  for (const coin of this.items)
    size += coin.getSize();

  return size;
};

/**
 * Serialize all undo coins.
 * @returns {Buffer}
 */

UndoCoins.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  const bw = new StaticWriter(size);

  bw.writeU32(this.items.length);

  for (const coin of this.items)
    coin.toWriter(bw);

  return bw.render();
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 * @returns {UndoCoins}
 */

UndoCoins.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data);
  const count = br.readU32();

  for (let i = 0; i < count; i++)
    this.items.push(CoinEntry.fromReader(br));

  return this;
};

/**
 * Instantiate undo coins from serialized data.
 * @param {Buffer} data
 * @returns {UndoCoins}
 */

UndoCoins.fromRaw = function fromRaw(data) {
  return new UndoCoins().fromRaw(data);
};

/**
 * Test whether the undo coins have any members.
 * @returns {Boolean}
 */

UndoCoins.prototype.isEmpty = function isEmpty() {
  return this.items.length === 0;
};

/**
 * Render the undo coins.
 * @returns {Buffer}
 */

UndoCoins.prototype.commit = function commit() {
  const raw = this.toRaw();
  this.items.length = 0;
  return raw;
};

/**
 * Re-apply undo coins to a view, effectively unspending them.
 * @param {CoinView} view
 * @param {Outpoint} prevout
 */

UndoCoins.prototype.apply = function apply(view, prevout) {
  const undo = this.items.pop();

  assert(undo);

  view.addEntry(prevout, undo);
};

/*
 * Expose
 */

module.exports = UndoCoins;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * ldb.js - database backend for wmcc_core.
 */



const assert = __webpack_require__(0);
const LowlevelUp = __webpack_require__(200);
const backends = __webpack_require__(201);

/**
 * Create a database.
 * @alias module:db.LDB
 * @param {Object} options
 * @returns {LowlevelUp}
 */

function LDB(options) {
  const result = LDB.getBackend(options);
  const backend = result.backend;
  const location = result.location;

  return new LowlevelUp(backend, location, options);
}

/**
 * Get database name and extension based on options.
 * @param {String} db
 * @returns {Object}
 */

LDB.getName = function getName(db) {
  let name, ext;

  if (!db)
    db = 'memory';

  switch (db) {
    case 'ldb':
    case 'leveldb':
    case 'leveldown':
      name = 'leveldown';
      ext = 'ldb';
      break;
    case 'rdb':
    case 'rocksdb':
    case 'rocksdown':
      name = 'rocksdown';
      ext = 'rdb';
      break;
    case 'mdb':
    case 'lmdb':
      name = 'lmdb';
      ext = 'mdb';
      break;
    case 'mem':
    case 'memory':
    case 'rbt':
      name = 'memory';
      ext = 'mem';
      break;
    default:
      name = db;
      ext = 'db';
      break;
  }

  return [name, ext];
};

/**
 * Get target backend and location.
 * @param {Object} options
 * @returns {Object}
 */

LDB.getBackend = function getBackend(options) {
  const [name, ext] = LDB.getName(options.db);
  const backend = backends.get(name);
  let location = options.location;

  if (typeof location !== 'string') {
    assert(name === 'memory', 'Location required.');
    location = 'memory';
  }

  return {
    backend: backend,
    location: `${location}.${ext}`
  };
};

/*
 * Expose
 */

module.exports = LDB;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * common.js - bitcoin constants for wmcc_core.
 */



/**
 * @module blockchain/common
 */

/**
 * Locktime flags.
 * @enum {Number}
 */

exports.lockFlags = {
  VERIFY_SEQUENCE: 1 << 0,
  MEDIAN_TIME_PAST: 1 << 1
};

/**
 * Consensus locktime flags (used for block validation).
 * @const {LockFlags}
 * @default
 */

exports.lockFlags.MANDATORY_LOCKTIME_FLAGS = 0;

/**
 * Standard locktime flags (used for mempool validation).
 * @const {LockFlags}
 * @default
 */

exports.lockFlags.STANDARD_LOCKTIME_FLAGS = 0
  | exports.lockFlags.VERIFY_SEQUENCE
  | exports.lockFlags.MEDIAN_TIME_PAST;

/**
 * Threshold states for versionbits
 * @enum {Number}
 * @default
 */

exports.thresholdStates = {
  DEFINED: 0,
  STARTED: 1,
  LOCKED_IN: 2,
  ACTIVE: 3,
  FAILED: 4
};

/**
 * Verify flags for blocks.
 * @enum {Number}
 * @default
 */

exports.flags = {
  VERIFY_NONE: 0,
  VERIFY_POW: 1 << 0,
  VERIFY_BODY: 1 << 1
};

/**
 * Default block verify flags.
 * @const {Number}
 * @default
 */

exports.flags.DEFAULT_FLAGS = 0
  | exports.flags.VERIFY_POW
  | exports.flags.VERIFY_BODY;


/***/ }),
/* 90 */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * list.js - double linked list for wmcc_core.
 */



const assert = __webpack_require__(0);

/**
 * A double linked list.
 * @alias module:utils.List
 * @constructor
 * @property {ListItem|null} head
 * @property {ListItem|null} tail
 * @property {Number} size
 */

function List() {
  if (!(this instanceof List))
    return new List();

  this.head = null;
  this.tail = null;
  this.size = 0;
}

/**
 * Reset the cache. Clear all items.
 */

List.prototype.reset = function reset() {
  let item, next;

  for (item = this.head; item; item = next) {
    next = item.next;
    item.prev = null;
    item.next = null;
  }

  assert(!item);

  this.head = null;
  this.tail = null;
  this.size = 0;
};

/**
 * Remove the first item in the list.
 * @returns {ListItem}
 */

List.prototype.shift = function shift() {
  const item = this.head;

  if (!item)
    return null;

  this.remove(item);

  return item;
};

/**
 * Prepend an item to the linked list (sets new head).
 * @param {ListItem}
 * @returns {Boolean}
 */

List.prototype.unshift = function unshift(item) {
  return this.insert(null, item);
};

/**
 * Append an item to the linked list (sets new tail).
 * @param {ListItem}
 * @returns {Boolean}
 */

List.prototype.push = function push(item) {
  return this.insert(this.tail, item);
};

/**
 * Remove the last item in the list.
 * @returns {ListItem}
 */

List.prototype.pop = function pop() {
  const item = this.tail;

  if (!item)
    return null;

  this.remove(item);

  return item;
};

/**
 * Insert item into the linked list.
 * @private
 * @param {ListItem|null} ref
 * @param {ListItem} item
 * @returns {Boolean}
 */

List.prototype.insert = function insert(ref, item) {
  if (item.prev || item.next || item === this.head)
    return false;

  assert(!item.prev);
  assert(!item.next);

  if (ref == null) {
    if (!this.head) {
      this.head = item;
      this.tail = item;
    } else {
      this.head.prev = item;
      item.next = this.head;
      this.head = item;
    }
    this.size++;
    return true;
  }

  item.next = ref.next;
  item.prev = ref;
  ref.next = item;

  if (ref === this.tail)
    this.tail = item;

  this.size++;

  return true;
};

/**
 * Remove item from the linked list.
 * @private
 * @param {ListItem}
 * @returns {Boolean}
 */

List.prototype.remove = function remove(item) {
  if (!item.prev && !item.next && item !== this.head)
    return false;

  if (item.prev)
    item.prev.next = item.next;

  if (item.next)
    item.next.prev = item.prev;

  if (item === this.head)
    this.head = item.next;

  if (item === this.tail)
    this.tail = item.prev || this.head;

  if (!this.head)
    assert(!this.tail);

  if (!this.tail)
    assert(!this.head);

  item.prev = null;
  item.next = null;

  this.size--;

  return true;
};

/**
 * Replace an item in-place.
 * @param {ListItem} ref
 * @param {ListItem} item
 */

List.prototype.replace = function replace(ref, item) {
  if (ref.prev)
    ref.prev.next = item;

  if (ref.next)
    ref.next.prev = item;

  item.prev = ref.prev;
  item.next = ref.next;

  ref.next = null;
  ref.prev = null;

  if (this.head === ref)
    this.head = item;

  if (this.tail === ref)
    this.tail = item;
};

/**
 * Slice the list to an array of items.
 * Will remove the items sliced.
 * @param {Number?} total
 * @returns {ListItem[]}
 */

List.prototype.slice = function slice(total) {
  const items = [];
  let item, next;

  if (total == null)
    total = -1;

  for (item = this.head; item; item = next) {
    next = item.next;
    item.prev = null;
    item.next = null;

    this.size--;

    items.push(item);

    if (items.length === total)
      break;
  }

  if (next) {
    this.head = next;
    next.prev = null;
  } else {
    this.head = null;
    this.tail = null;
  }

  return items;
};

/**
 * Convert the list to an array of items.
 * @returns {ListItem[]}
 */

List.prototype.toArray = function toArray() {
  const items = [];

  for (let item = this.head; item; item = item.next)
    items.push(item);

  return items;
};

/**
 * Represents an linked list item.
 * @alias module:utils.ListItem
 * @constructor
 * @private
 * @param {String} key
 * @param {Object} value
 */

function ListItem(value) {
  this.next = null;
  this.prev = null;
  this.value = value;
}

/*
 * Expose
 */

exports = List;
exports.List = List;
exports.ListItem = ListItem;
exports.Item = ListItem;

module.exports = exports;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * request.js - http request for wmcc_core.
 */



const Stream = __webpack_require__(216).Stream;
const assert = __webpack_require__(0);
let url, qs, http, https, StringDecoder;

/*
 * Constants
 */

const USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1)'
  + ' AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.1 Safari/537.36';

/**
 * Request Options
 * @constructor
 * @ignore
 * @param {Object} options
 */

function RequestOptions(options) {
  if (!(this instanceof RequestOptions))
    return new RequestOptions(options);

  this.uri = 'http://localhost:80/';
  this.host = 'localhost';
  this.path = '/';
  this.port = 80;
  this.ssl = false;
  this.method = 'GET';
  this.strictSSL = true;
  this.pool = false;
  this.agent = USER_AGENT;

  this.type = null;
  this.expect = null;
  this.query = null;
  this.body = null;
  this.auth = null;
  this.limit = 10 << 20;
  this.maxRedirects = 5;
  this.timeout = 5000;
  this.buffer = false;
  this.headers = null;

  // Hack
  ensureRequires();

  if (options)
    this.fromOptions(options);
}

RequestOptions.prototype.setURI = function setURI(uri) {
  assert(typeof uri === 'string');

  if (!/:\/\//.test(uri))
    uri = (this.ssl ? 'https://' : 'http://') + uri;

  uri = url.parse(uri);

  assert(uri.protocol === 'http:' || uri.protocol === 'https:');

  this.uri = uri;
  this.ssl = uri.protocol === 'https:';

  if (uri.search)
    this.query = qs.parse(uri.search);

  this.host = uri.hostname;
  this.path = uri.pathname;
  this.port = uri.port || (this.ssl ? 443 : 80);

  if (uri.auth) {
    const parts = uri.auth.split(':');
    this.auth = {
      username: parts[0] || '',
      password: parts[1] || ''
    };
  }
};

RequestOptions.prototype.fromOptions = function fromOptions(options) {
  if (typeof options === 'string')
    options = { uri: options };

  if (options.ssl != null) {
    assert(typeof options.ssl === 'boolean');
    this.ssl = options.ssl;
  }

  if (options.uri != null)
    this.setURI(options.uri);

  if (options.url != null)
    this.setURI(options.url);

  if (options.method != null) {
    assert(typeof options.method === 'string');
    this.method = options.method.toUpperCase();
  }

  if (options.strictSSL != null) {
    assert(typeof options.strictSSL === 'boolean');
    this.strictSSL = options.strictSSL;
  }

  if (options.pool != null) {
    assert(typeof options.pool === 'boolean');
    this.pool = options.pool;
  }

  if (options.agent != null) {
    assert(typeof options.agent === 'string');
    this.agent = options.agent;
  }

  if (options.auth != null) {
    assert(typeof options.auth === 'object');
    assert(typeof options.auth.username === 'string');
    assert(typeof options.auth.password === 'string');
    this.auth = options.auth;
  }

  if (options.query != null) {
    if (typeof options.query === 'string') {
      this.query = qs.stringify(options.query);
    } else {
      assert(typeof options.query === 'object');
      this.query = options.query;
    }
  }

  if (options.json != null) {
    assert(typeof options.json === 'object');
    this.body = Buffer.from(JSON.stringify(options.json), 'utf8');
    this.type = 'json';
  }

  if (options.form != null) {
    assert(typeof options.form === 'object');
    this.body = Buffer.from(qs.stringify(options.form), 'utf8');
    this.type = 'form';
  }

  if (options.type != null) {
    assert(typeof options.type === 'string');
    assert(getType(options.type));
    this.type = options.type;
  }

  if (options.expect != null) {
    assert(typeof options.expect === 'string');
    assert(getType(options.expect));
    this.expect = options.expect;
  }

  if (options.body != null) {
    if (typeof options.body === 'string') {
      this.body = Buffer.from(options.body, 'utf8');
    } else {
      assert(Buffer.isBuffer(options.body));
      this.body = options.body;
    }
  }

  if (options.timeout != null) {
    assert(typeof options.timeout === 'number');
    this.timeout = options.timeout;
  }

  if (options.limit != null) {
    assert(typeof options.limit === 'number');
    this.limit = options.limit;
  }

  if (options.maxRedirects != null) {
    assert(typeof options.maxRedirects === 'number');
    this.maxRedirects = options.maxRedirects;
  }

  if (options.buffer != null) {
    assert(typeof options.buffer === 'boolean');
    this.buffer = options.buffer;
  }

  if (options.headers != null) {
    assert(typeof options.headers === 'object');
    this.headers = options.headers;
  }
};

RequestOptions.prototype.isExpected = function isExpected(type) {
  if (!this.expect)
    return true;

  return this.expect === type;
};

RequestOptions.prototype.isOverflow = function isOverflow(hdr) {
  if (!hdr)
    return false;

  if (!this.buffer)
    return false;

  const length = parseInt(hdr, 10);

  if (!isFinite(length))
    return true;

  return length > this.limit;
};

RequestOptions.prototype.getBackend = function getBackend() {
  ensureRequires(this.ssl);
  return this.ssl ? https : http;
};

RequestOptions.prototype.getHeaders = function getHeaders() {
  if (this.headers)
    return this.headers;

  const headers = Object.create(null);

  headers['User-Agent'] = this.agent;

  if (this.type)
    headers['Content-Type'] = getType(this.type);

  if (this.body)
    headers['Content-Length'] = this.body.length.toString(10);

  if (this.auth) {
    const auth = `${this.auth.username}:${this.auth.password}`;
    const data = Buffer.from(auth, 'utf8');
    headers['Authorization'] = `Basic ${data.toString('base64')}`;
  }

  return headers;
};

RequestOptions.prototype.toHTTP = function toHTTP() {
  let query = '';

  if (this.query)
    query = '?' + qs.stringify(this.query);

  return {
    method: this.method,
    host: this.host,
    port: this.port,
    path: this.path + query,
    headers: this.getHeaders(),
    agent: this.pool ? null : false,
    rejectUnauthorized: this.strictSSL
  };
};

/**
 * Request
 * @alias module:http.Request
 * @constructor
 * @private
 * @param {Object} options
 */

function Request(options) {
  if (!(this instanceof Request))
    return new Request(options);

  Stream.call(this);

  this.options = new RequestOptions(options);
  this.request = null;
  this.response = null;
  this.statusCode = 0;
  this.headers = null;
  this.type = 'bin';
  this.redirects = 0;
  this.timeout = null;
  this.finished = false;

  this.onResponse = this._onResponse.bind(this);
  this.onData = this._onData.bind(this);
  this.onEnd = this._onEnd.bind(this);

  this.total = 0;
  this.decoder = null;
  this.body = null;
  this.buffer = null;
}

Object.setPrototypeOf(Request.prototype, Stream.prototype);

Request.prototype.startTimeout = function startTimeout() {
  if (!this.options.timeout)
    return;

  this.timeout = setTimeout(() => {
    this.finish(new Error('Request timed out.'));
  }, this.options.timeout);
};

Request.prototype.stopTimeout = function stopTimeout() {
  if (this.timeout != null) {
    clearTimeout(this.timeout);
    this.timeout = null;
  }
};

Request.prototype.cleanup = function cleanup() {
  this.stopTimeout();

  if (this.request) {
    this.request.removeListener('response', this.onResponse);
    this.request.removeListener('error', this.onEnd);
    this.request.addListener('error', () => {});
  }

  if (this.response) {
    this.response.removeListener('data', this.onData);
    this.response.removeListener('error', this.onEnd);
    this.response.removeListener('end', this.onEnd);
    this.response.addListener('error', () => {});
  }
};

Request.prototype.close = function close() {
  if (this.request) {
    try {
      this.request.abort();
    } catch (e) {
      ;
    }
  }

  if (this.response) {
    try {
      this.response.destroy();
    } catch (e) {
      ;
    }
  }

  this.cleanup();

  this.request = null;
  this.response = null;
};

Request.prototype.destroy = function destroy() {
  this.close();
};

Request.prototype.start = function start() {
  const backend = this.options.getBackend();
  const options = this.options.toHTTP();

  this.startTimeout();

  this.request = backend.request(options);
  this.response = null;

  if (this.options.body)
    this.request.write(this.options.body);

  this.request.on('response', this.onResponse);
  this.request.on('error', this.onEnd);
};

Request.prototype.write = function write(data) {
  return this.request.write(data);
};

Request.prototype.end = function end() {
  return this.request.end();
};

Request.prototype.finish = function finish(err) {
  if (this.finished)
    return;

  this.finished = true;

  if (err) {
    this.destroy();
    this.emit('error', err);
    return;
  }

  this.cleanup();

  if (this.options.buffer) {
    assert(this.buffer != null);
    switch (this.type) {
      case 'bin': {
        this.body = Buffer.concat(this.buffer);
        this.buffer = null;
        break;
      }
      case 'json': {
        const buffer = this.buffer.trim();

        this.buffer = null;

        if (buffer.length === 0)
          break;

        let body;
        try {
          body = JSON.parse(buffer);
        } catch (e) {
          this.emit('error', e);
          return;
        }

        if (!body || typeof body !== 'object') {
          this.emit('error', new Error('JSON body is a non-object.'));
          return;
        }

        this.body = body;

        break;
      }
      case 'form': {
        const buffer = this.buffer;

        this.buffer = null;

        try {
          this.body = qs.parse(buffer);
        } catch (e) {
          this.emit('error', e);
          return;
        }

        break;
      }
      default: {
        this.body = this.buffer;
        this.buffer = null;
        break;
      }
    }
  }

  this.emit('end');
  this.emit('close');
};

Request.prototype._onResponse = function _onResponse(response) {
  const location = response.headers['location'];

  if (location) {
    if (++this.redirects > this.options.maxRedirects) {
      this.finish(new Error('Too many redirects.'));
      return;
    }
    this.close();
    this.options.setURI(location);
    this.start();
    this.end();
    return;
  }

  const contentType = response.headers['content-type'];
  const type = parseType(contentType);

  if (!this.options.isExpected(type)) {
    this.finish(new Error('Wrong content-type for response.'));
    return;
  }

  const length = response.headers['content-length'];

  if (this.options.isOverflow(length)) {
    this.finish(new Error('Response exceeded limit.'));
    return;
  }

  this.response = response;
  this.statusCode = response.statusCode;
  this.headers = response.headers;
  this.type = type;

  this.response.on('data', this.onData);
  this.response.on('error', this.onEnd);
  this.response.on('end', this.onEnd);

  this.emit('headers', response.headers);
  this.emit('type', this.type);
  this.emit('response', response);

  if (this.options.buffer) {
    if (this.type !== 'bin') {
      this.decoder = new StringDecoder('utf8');
      this.buffer = '';
    } else {
      this.buffer = [];
    }
  }
};

Request.prototype._onData = function _onData(data) {
  this.total += data.length;

  this.emit('data', data);

  if (this.options.buffer) {
    if (this.options.limit) {
      if (this.total > this.options.limit) {
        this.finish(new Error('Response exceeded limit.'));
        return;
      }
    }

    if (this.decoder) {
      this.buffer += this.decoder.write(data);
      return;
    }

    this.buffer.push(data);
  }
};

Request.prototype._onEnd = function _onEnd(err) {
  this.finish(err);
};

/**
 * Make an HTTP request.
 * @alias module:http.request
 * @param {Object} options
 * @param {String} options.uri
 * @param {Object?} options.query
 * @param {Object?} options.body
 * @param {Object?} options.json
 * @param {Object?} options.form
 * @param {String?} options.type - One of `"json"`,
 * `"form"`, `"text"`, or `"bin"`.
 * @param {String?} options.agent - User agent string.
 * @param {Object?} [options.strictSSL=true] - Whether to accept bad certs.
 * @param {Object?} options.method - HTTP method.
 * @param {Object?} options.auth
 * @param {String?} options.auth.username
 * @param {String?} options.auth.password
 * @param {String?} options.expect - Type to expect (see options.type).
 * Error will be returned if the response is not of this type.
 * @param {Number?} options.limit - Byte limit on response.
 * @returns {Promise}
 */

function request(options) {
  if (typeof options === 'string')
    options = { uri: options };

  options.buffer = true;

  return new Promise((resolve, reject) => {
    const req = new Request(options);

    req.on('error', err => reject(err));
    req.on('end', () => resolve(req));

    req.start();
    req.end();
  });
}

request.stream = function stream(options) {
  const req = new Request(options);
  req.start();
  return req;
};

/*
 * Helpers
 */

function parseType(type) {
  type = type || '';
  type = type.split(';')[0];
  type = type.toLowerCase();
  type = type.trim();

  switch (type) {
    case 'text/x-json':
    case 'application/json':
      return 'json';
    case 'application/x-www-form-urlencoded':
      return 'form';
    case 'text/html':
    case 'application/xhtml+xml':
      return 'html';
    case 'text/xml':
    case 'application/xml':
      return 'xml';
    case 'text/javascript':
    case 'application/javascript':
      return 'js';
    case 'text/css':
      return 'css';
    case 'text/plain':
      return 'txt';
    case 'application/octet-stream':
      return 'bin';
    default:
      return 'bin';
  }
}

function getType(type) {
  switch (type) {
    case 'json':
      return 'application/json; charset=utf-8';
    case 'form':
      return 'application/x-www-form-urlencoded; charset=utf-8';
    case 'html':
      return 'text/html; charset=utf-8';
    case 'xml':
      return 'application/xml; charset=utf-8';
    case 'js':
      return 'application/javascript; charset=utf-8';
    case 'css':
      return 'text/css; charset=utf-8';
    case 'txt':
      return 'text/plain; charset=utf-8';
    case 'bin':
      return 'application/octet-stream';
    default:
      throw new Error(`Unknown type: ${type}.`);
  }
}

function ensureRequires(ssl) {
  if (!url)
    url = __webpack_require__(90);

  if (!qs)
    qs = __webpack_require__(278);

  if (!http)
    http = __webpack_require__(72);

  if (ssl && !https)
    https = __webpack_require__(109);

  if (!StringDecoder)
    StringDecoder = __webpack_require__(170).StringDecoder;
}

/*
 * Expose
 */

module.exports = request;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  EMPTY_BUFFER: Buffer.alloc(0),
  NOOP: () => {}
};


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * pkg.js - Package constants.
 */



/**
 * Current version string.
 * @const {String}
 */

exports.version = 'v1.0.0-beta.1';

/**
 * Repository URL.
 * @const {String}
 */

exports.url = 'https://github.com/park-alter/wmcc-core';


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * mine.js - mining function for wmcc_core.
 */



const assert = __webpack_require__(0);
// const digest = require('../crypto/digest'); // cfc
const scrypt = __webpack_require__(45); // ctl
const X15 = __webpack_require__(57);

/**
 * Hash until the nonce overflows.
 * @alias module:mining.mine
 * @param {Buffer} data
 * @param {Buffer} target - Big endian.
 * @param {Number} min
 * @param {Number} max
 * @returns {Number} Nonce or -1.
 */

function mine(data, target, min, max) {
  let nonce = min;

  data.writeUInt32LE(nonce, 76, true);

  // The heart and soul of the miner: match the target.
  while (nonce <= max) {
    // Hash and test against the next target.
    // if (rcmp(digest.hash256(data), target) <= 0) // cfc
    // if (rcmp(powHash(data), target) <= 0) // ctl
    if (rcmp(calHash(data), target) <= 0)
      return nonce;

    // Increment the nonce to get a different hash.
    nonce++;

    // Update the raw buffer.
    data.writeUInt32LE(nonce, 76, true);
  }

  return -1;
}

/**
 * Proof of work function.
 * @param {Buffer} data
 * @returns {Buffer}
 */
// ctl
function powHash(data) {
  return scrypt.derive(data, data, 1024, 1, 1, 32);
}

/**
 * Proof of work function.
 * @param {Buffer} data
 * @returns {Buffer}
 */

function calHash(data) {
  return X15.digest(data);
}

/**
 * "Reverse" comparison so we don't have
 * to waste time reversing the block hash.
 * @ignore
 * @param {Buffer} a
 * @param {Buffer} b
 * @returns {Number}
 */

function rcmp(a, b) {
  assert(a.length === b.length);

  for (let i = a.length - 1; i >= 0; i--) {
    if (a[i] < b[i])
      return -1;
    if (a[i] > b[i])
      return 1;
  }

  return 0;
}

/*
 * Expose
 */

module.exports = mine;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * bip152.js - compact block object for wmcc_core.
 */



/**
 * @module net/bip152
 */

const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const encoding = __webpack_require__(3);
const consensus = __webpack_require__(7);
const digest = __webpack_require__(5);
const siphash256 = __webpack_require__(168).siphash256;
const AbstractBlock = __webpack_require__(67);
const TX = __webpack_require__(16);
const Headers = __webpack_require__(37);
const Block = __webpack_require__(51);

/**
 * Represents a compact block (bip152): `cmpctblock` packet.
 * @see https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki
 * @constructor
 * @extends AbstractBlock
 * @param {Object} options
 * @property {Buffer|null} keyNonce - Nonce for siphash key.
 * @property {Number[]} ids - Short IDs.
 * @property {Object[]} ptx - Prefilled transactions.
 * @property {TX[]} available - Available transaction vector.
 * @property {Object} idMap - Map of short ids to indexes.
 * @property {Number} count - Transactions resolved.
 * @property {Buffer|null} sipKey - Siphash key.
 */

function CompactBlock(options) {
  if (!(this instanceof CompactBlock))
    return new CompactBlock(options);

  AbstractBlock.call(this);

  this.keyNonce = null;
  this.ids = [];
  this.ptx = [];

  this.available = [];
  this.idMap = new Map();
  this.count = 0;
  this.sipKey = null;
  this.totalTX = 0;
  this.now = 0;

  if (options)
    this.fromOptions(options);
}

Object.setPrototypeOf(CompactBlock.prototype, AbstractBlock.prototype);

/**
 * Inject properties from options object.
 * @private
 * @param {Object} options
 */

CompactBlock.prototype.fromOptions = function fromOptions(options) {
  this.parseOptions(options);

  assert(Buffer.isBuffer(options.keyNonce));
  assert(Array.isArray(options.ids));
  assert(Array.isArray(options.ptx));

  this.keyNonce = options.keyNonce;
  this.ids = options.ids;
  this.ptx = options.ptx;

  if (options.available)
    this.available = options.available;

  if (options.idMap)
    this.idMap = options.idMap;

  if (options.count)
    this.count = options.count;

  if (options.totalTX != null)
    this.totalTX = options.totalTX;

  this.sipKey = this.getKey();

  return this;
};

/**
 * Instantiate compact block from options.
 * @param {Object} options
 * @returns {CompactBlock}
 */

CompactBlock.fromOptions = function fromOptions(options) {
  return new CompactBlock().fromOptions(options);
};

/**
 * Verify the block.
 * @returns {Boolean}
 */

CompactBlock.prototype.verifyBody = function verifyBody() {
  return true;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

CompactBlock.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data);

  this.readHead(br);

  this.keyNonce = br.readBytes(8);
  this.sipKey = this.getKey();

  const idCount = br.readVarint();

  this.totalTX += idCount;

  for (let i = 0; i < idCount; i++) {
    const lo = br.readU32();
    const hi = br.readU16();
    this.ids.push(hi * 0x100000000 + lo);
  }

  const txCount = br.readVarint();

  this.totalTX += txCount;

  for (let i = 0; i < txCount; i++) {
    const index = br.readVarint();

    assert(index <= 0xffff);
    assert(index < this.totalTX);

    const tx = TX.fromReader(br);

    this.ptx.push([index, tx]);
  }

  return this;
};

/**
 * Instantiate a block from serialized data.
 * @param {Buffer} data
 * @param {String?} enc
 * @returns {CompactBlock}
 */

CompactBlock.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new CompactBlock().fromRaw(data);
};

/**
 * Serialize compact block with witness data.
 * @returns {Buffer}
 */

CompactBlock.prototype.toRaw = function toRaw() {
  return this.frameRaw(true);
};

/**
 * Serialize compact block without witness data.
 * @returns {Buffer}
 */

CompactBlock.prototype.toNormal = function toNormal() {
  return this.frameRaw(false);
};

/**
 * Write serialized block to a buffer
 * writer (includes witness data).
 * @param {BufferWriter} bw
 */

CompactBlock.prototype.toWriter = function toWriter(bw) {
  return this.writeRaw(bw, true);
};

/**
 * Write serialized block to a buffer
 * writer (excludes witness data).
 * @param {BufferWriter} bw
 */

CompactBlock.prototype.toNormalWriter = function toNormalWriter(bw) {
  return this.writeRaw(bw, false);
};

/**
 * Serialize compact block.
 * @private
 * @param {Boolean} witness
 * @returns {Buffer}
 */

CompactBlock.prototype.frameRaw = function frameRaw(witness) {
  const size = this.getSize(witness);
  return this.writeRaw(new StaticWriter(size), witness).render();
};

/**
 * Calculate block serialization size.
 * @param {Boolean} witness
 * @returns {Number}
 */

CompactBlock.prototype.getSize = function getSize(witness) {
  let size = 0;

  size += 80;
  size += 8;
  size += encoding.sizeVarint(this.ids.length);
  size += this.ids.length * 6;
  size += encoding.sizeVarint(this.ptx.length);

  for (const [index, tx] of this.ptx) {
    size += encoding.sizeVarint(index);

    if (witness)
      size += tx.getSize();
    else
      size += tx.getBaseSize();
  }

  return size;
};

/**
 * Serialize block to buffer writer.
 * @private
 * @param {BufferWriter} bw
 * @param {Boolean} witness
 */

CompactBlock.prototype.writeRaw = function writeRaw(bw, witness) {
  this.writeHead(bw);

  bw.writeBytes(this.keyNonce);

  bw.writeVarint(this.ids.length);

  for (const id of this.ids) {
    const lo = id % 0x100000000;
    const hi = (id - lo) / 0x100000000;
    assert(hi <= 0xffff);
    bw.writeU32(lo);
    bw.writeU16(hi);
  }

  bw.writeVarint(this.ptx.length);

  for (const [index, tx] of this.ptx) {
    bw.writeVarint(index);

    if (witness)
      tx.toWriter(bw);
    else
      tx.toNormalWriter(bw);
  }

  return bw;
};

/**
 * Convert block to a TXRequest
 * containing missing indexes.
 * @returns {TXRequest}
 */

CompactBlock.prototype.toRequest = function toRequest() {
  return TXRequest.fromCompact(this);
};

/**
 * Attempt to fill missing transactions from mempool.
 * @param {Boolean} witness
 * @param {Mempool} mempool
 * @returns {Boolean}
 */

CompactBlock.prototype.fillMempool = function fillMempool(witness, mempool) {
  if (this.count === this.totalTX)
    return true;

  const set = new Set();

  for (const {tx} of mempool.map.values()) {
    let hash = tx.hash();

    if (witness)
      hash = tx.witnessHash();

    const id = this.sid(hash);
    const index = this.idMap.get(id);

    if (index == null)
      continue;

    if (set.has(index)) {
      // Siphash collision, just request it.
      this.available[index] = null;
      this.count--;
      continue;
    }

    this.available[index] = tx;
    set.add(index);
    this.count++;

    // We actually may have a siphash collision
    // here, but exit early anyway for perf.
    if (this.count === this.totalTX)
      return true;
  }

  return false;
};

/**
 * Attempt to fill missing transactions from TXResponse.
 * @param {TXResponse} res
 * @returns {Boolean}
 */

CompactBlock.prototype.fillMissing = function fillMissing(res) {
  let offset = 0;

  for (let i = 0; i < this.available.length; i++) {
    if (this.available[i])
      continue;

    if (offset >= res.txs.length)
      return false;

    this.available[i] = res.txs[offset++];
  }

  return offset === res.txs.length;
};

/**
 * Calculate a transaction short ID.
 * @param {Hash} hash
 * @returns {Number}
 */

CompactBlock.prototype.sid = function sid(hash) {
  if (typeof hash === 'string')
    hash = Buffer.from(hash, 'hex');

  const [hi, lo] = siphash256(hash, this.sipKey);

  return (hi & 0xffff) * 0x100000000 + (lo >>> 0);
};

/**
 * Test whether an index is available.
 * @param {Number} index
 * @returns {Boolean}
 */

CompactBlock.prototype.hasIndex = function hasIndex(index) {
  return this.available[index] != null;
};

/**
 * Initialize the siphash key.
 * @private
 * @returns {Buffer}
 */

CompactBlock.prototype.getKey = function getKey() {
  const data = Buffer.concat([this.toHead(), this.keyNonce]);
  const hash = digest.sha256(data);
  return hash.slice(0, 16);
};

/**
 * Initialize compact block and short id map.
 * @private
 */

CompactBlock.prototype.init = function init() {
  if (this.totalTX === 0)
    throw new Error('Empty vectors.');

  if (this.totalTX > consensus.MAX_BLOCK_SIZE / 10)
    throw new Error('Compact block too big.');

  // Custom limit to avoid a hashdos.
  // Min valid tx size: (4 + 1 + 41 + 1 + 9 + 4) = 60
  // Min block header size: 81
  // Max number of transactions: (1000000 - 81) / 60 = 16665
  if (this.totalTX > (consensus.MAX_BLOCK_SIZE - 81) / 60)
    throw new Error('Compact block too big.');

  // No sparse arrays here, v8.
  for (let i = 0; i < this.totalTX; i++)
    this.available.push(null);

  let last = -1;
  let offset = 0;

  for (let i = 0; i < this.ptx.length; i++) {
    const [index, tx] = this.ptx[i];
    last += index + 1;
    assert(last <= 0xffff);
    assert(last <= this.ids.length + i);
    this.available[last] = tx;
    this.count++;
  }

  for (let i = 0; i < this.ids.length; i++) {
    const id = this.ids[i];

    while (this.available[i + offset])
      offset++;

    // Fails on siphash collision.
    if (this.idMap.has(id))
      return false;

    this.idMap.set(id, i + offset);
  }

  return true;
};

/**
 * Convert completely filled compact
 * block to a regular block.
 * @returns {Block}
 */

CompactBlock.prototype.toBlock = function toBlock() {
  const block = new Block();

  block.version = this.version;
  block.prevBlock = this.prevBlock;
  block.merkleRoot = this.merkleRoot;
  block.time = this.time;
  block.bits = this.bits;
  block.nonce = this.nonce;
  block._hash = this._hash;
  block._hhash = this._hhash;

  for (const tx of this.available) {
    assert(tx, 'Compact block is not full.');
    block.txs.push(tx);
  }

  return block;
};

/**
 * Inject properties from block.
 * @private
 * @param {Block} block
 * @param {Boolean} witness
 * @param {Buffer?} nonce
 * @returns {CompactBlock}
 */

CompactBlock.prototype.fromBlock = function fromBlock(block, witness, nonce) {
  this.version = block.version;
  this.prevBlock = block.prevBlock;
  this.merkleRoot = block.merkleRoot;
  this.time = block.time;
  this.bits = block.bits;
  this.nonce = block.nonce;
  this.totalTX = block.txs.length;
  this._hash = block._hash;
  this._hhash = block._hhash;

  if (!nonce)
    nonce = util.nonce();

  this.keyNonce = nonce;
  this.sipKey = this.getKey();

  for (let i = 1; i < block.txs.length; i++) {
    const tx = block.txs[i];
    let hash = tx.hash();

    if (witness)
      hash = tx.witnessHash();

    const id = this.sid(hash);

    this.ids.push(id);
  }

  this.ptx.push([0, block.txs[0]]);

  return this;
};

/**
 * Instantiate compact block from a block.
 * @param {Block} block
 * @param {Boolean} witness
 * @param {Buffer?} nonce
 * @returns {CompactBlock}
 */

CompactBlock.fromBlock = function fromBlock(block, witness, nonce) {
  return new CompactBlock().fromBlock(block, witness, nonce);
};

/**
 * Convert block to headers.
 * @returns {Headers}
 */

CompactBlock.prototype.toHeaders = function toHeaders() {
  return Headers.fromBlock(this);
};

/**
 * Represents a BlockTransactionsRequest (bip152): `getblocktxn` packet.
 * @see https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki
 * @constructor
 * @param {Object} options
 * @property {Hash} hash
 * @property {Number[]} indexes
 */

function TXRequest(options) {
  if (!(this instanceof TXRequest))
    return new TXRequest(options);

  this.hash = encoding.NULL_HASH;
  this.indexes = [];

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from options.
 * @private
 * @param {Object} options
 * @returns {TXRequest}
 */

TXRequest.prototype.fromOptions = function fromOptions(options) {
  this.hash = options.hash;

  if (options.indexes)
    this.indexes = options.indexes;

  return this;
};

/**
 * Instantiate request from options.
 * @param {Object} options
 * @returns {TXRequest}
 */

TXRequest.fromOptions = function fromOptions(options) {
  return new TXRequest().fromOptions(options);
};

/**
 * Inject properties from compact block.
 * @private
 * @param {CompactBlock} block
 * @returns {TXRequest}
 */

TXRequest.prototype.fromCompact = function fromCompact(block) {
  this.hash = block.hash('hex');

  for (let i = 0; i < block.available.length; i++) {
    if (!block.available[i])
      this.indexes.push(i);
  }

  return this;
};

/**
 * Instantiate request from compact block.
 * @param {CompactBlock} block
 * @returns {TXRequest}
 */

TXRequest.fromCompact = function fromCompact(block) {
  return new TXRequest().fromCompact(block);
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 * @returns {TXRequest}
 */

TXRequest.prototype.fromReader = function fromReader(br) {
  this.hash = br.readHash('hex');

  const count = br.readVarint();

  for (let i = 0; i < count; i++) {
    const index = br.readVarint();
    assert(index <= 0xffff);
    this.indexes.push(index);
  }

  let offset = 0;

  for (let i = 0; i < count; i++) {
    let index = this.indexes[i];
    index += offset;
    assert(index <= 0xffff);
    this.indexes[i] = index;
    offset = index + 1;
  }

  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 * @returns {TXRequest}
 */

TXRequest.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate request from buffer reader.
 * @param {BufferReader} br
 * @returns {TXRequest}
 */

TXRequest.fromReader = function fromReader(br) {
  return new TXRequest().fromReader(br);
};

/**
 * Instantiate request from serialized data.
 * @param {Buffer} data
 * @returns {TXRequest}
 */

TXRequest.fromRaw = function fromRaw(data) {
  return new TXRequest().fromRaw(data);
};

/**
 * Calculate request serialization size.
 * @returns {Number}
 */

TXRequest.prototype.getSize = function getSize() {
  let size = 0;

  size += 32;
  size += encoding.sizeVarint(this.indexes.length);

  for (let i = 0; i < this.indexes.length; i++) {
    let index = this.indexes[i];

    if (i > 0)
      index -= this.indexes[i - 1] + 1;

    size += encoding.sizeVarint(index);
  }

  return size;
};

/**
 * Write serialized request to buffer writer.
 * @param {BufferWriter} bw
 */

TXRequest.prototype.toWriter = function toWriter(bw) {
  bw.writeHash(this.hash);

  bw.writeVarint(this.indexes.length);

  for (let i = 0; i < this.indexes.length; i++) {
    let index = this.indexes[i];

    if (i > 0)
      index -= this.indexes[i - 1] + 1;

    bw.writeVarint(index);
  }

  return bw;
};

/**
 * Serialize request.
 * @returns {Buffer}
 */

TXRequest.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

/**
 * Represents BlockTransactions (bip152): `blocktxn` packet.
 * @see https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki
 * @constructor
 * @param {Object} options
 * @property {Hash} hash
 * @property {TX[]} txs
 */

function TXResponse(options) {
  if (!(this instanceof TXResponse))
    return new TXResponse(options);

  this.hash = encoding.NULL_HASH;
  this.txs = [];

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from options.
 * @private
 * @param {Object} options
 * @returns {TXResponse}
 */

TXResponse.prototype.fromOptions = function fromOptions(options) {
  this.hash = options.hash;

  if (options.txs)
    this.txs = options.txs;

  return this;
};

/**
 * Instantiate response from options.
 * @param {Object} options
 * @returns {TXResponse}
 */

TXResponse.fromOptions = function fromOptions(options) {
  return new TXResponse().fromOptions(options);
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 * @returns {TXResponse}
 */

TXResponse.prototype.fromReader = function fromReader(br) {
  this.hash = br.readHash('hex');

  const count = br.readVarint();

  for (let i = 0; i < count; i++)
    this.txs.push(TX.fromReader(br));

  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 * @returns {TXResponse}
 */

TXResponse.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate response from buffer reader.
 * @param {BufferReader} br
 * @returns {TXResponse}
 */

TXResponse.fromReader = function fromReader(br) {
  return new TXResponse().fromReader(br);
};

/**
 * Instantiate response from serialized data.
 * @param {Buffer} data
 * @returns {TXResponse}
 */

TXResponse.fromRaw = function fromRaw(data) {
  return new TXResponse().fromRaw(data);
};

/**
 * Inject properties from block.
 * @private
 * @param {Block} block
 * @returns {TXResponse}
 */

TXResponse.prototype.fromBlock = function fromBlock(block, req) {
  this.hash = req.hash;

  for (const index of req.indexes) {
    if (index >= block.txs.length)
      break;

    this.txs.push(block.txs[index]);
  }

  return this;
};

/**
 * Instantiate response from block.
 * @param {Block} block
 * @returns {TXResponse}
 */

TXResponse.fromBlock = function fromBlock(block, req) {
  return new TXResponse().fromBlock(block, req);
};

/**
 * Serialize response with witness data.
 * @returns {Buffer}
 */

TXResponse.prototype.toRaw = function toRaw() {
  return this.frameRaw(true);
};

/**
 * Serialize response without witness data.
 * @returns {Buffer}
 */

TXResponse.prototype.toNormal = function toNormal() {
  return this.frameRaw(false);
};

/**
 * Write serialized response to a buffer
 * writer (includes witness data).
 * @param {BufferWriter} bw
 */

TXResponse.prototype.toWriter = function toWriter(bw) {
  return this.writeRaw(bw, true);
};

/**
 * Write serialized response to a buffer
 * writer (excludes witness data).
 * @param {BufferWriter} bw
 */

TXResponse.prototype.toNormalWriter = function toNormalWriter(bw) {
  return this.writeRaw(bw, false);
};

/**
 * Calculate request serialization size.
 * @returns {Number}
 */

TXResponse.prototype.getSize = function getSize(witness) {
  let size = 0;

  size += 32;
  size += encoding.sizeVarint(this.txs.length);

  for (const tx of this.txs) {
    if (witness)
      size += tx.getSize();
    else
      size += tx.getBaseSize();
  }

  return size;
};

/**
 * Write serialized response to buffer writer.
 * @private
 * @param {BufferWriter} bw
 * @param {Boolean} witness
 */

TXResponse.prototype.writeRaw = function writeRaw(bw, witness) {
  bw.writeHash(this.hash);

  bw.writeVarint(this.txs.length);

  for (const tx of this.txs) {
    if (witness)
      tx.toWriter(bw);
    else
      tx.toNormalWriter(bw);
  }

  return bw;
};

/**
 * Serialize response with witness data.
 * @private
 * @param {Boolean} witness
 * @returns {Buffer}
 */

TXResponse.prototype.frameRaw = function frameRaw(witness) {
  const size = this.getSize(witness);
  return this.writeRaw(new StaticWriter(size), witness).render();
};

/*
 * Expose
 */

exports.CompactBlock = CompactBlock;
exports.TXRequest = TXRequest;
exports.TXResponse = TXResponse;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * dns.js - dns backend for wmcc_core.
 */



/**
 * @module net/dns
 */

const dns = __webpack_require__(312);
const socks = __webpack_require__(187);

const options = {
  family: 4,
  hints: dns.ADDRCONFIG | dns.V4MAPPED,
  all: true
};

/**
 * Resolve host (async w/ libcares).
 * @param {String} host
 * @param {String?} proxy - Tor socks proxy.
 * @returns {Promise}
 */

exports.resolve = function resolve(host, proxy) {
  if (proxy)
    return socks.resolve(proxy, host);

  return new Promise((resolve, reject) => {
    dns.resolve(host, 'A', to((err, result) => {
      if (err) {
        reject(err);
        return;
      }

      if (result.length === 0) {
        reject(new Error('No DNS results.'));
        return;
      }

      resolve(result);
    }));
  });
};

/**
 * Resolve host (getaddrinfo).
 * @param {String} host
 * @param {String?} proxy - Tor socks proxy.
 * @returns {Promise}
 */

exports.lookup = function lookup(host, proxy) {
  if (proxy)
    return socks.resolve(proxy, host);

  return new Promise((resolve, reject) => {
    dns.lookup(host, options, to((err, result) => {
      if (err) {
        reject(err);
        return;
      }

      if (result.length === 0) {
        reject(new Error('No DNS results.'));
        return;
      }

      const addrs = [];

      for (const addr of result)
        addrs.push(addr.address);

      resolve(addrs);
    }));
  });
};

/*
 * Helpers
 */

function to(callback) {
  const timeout = setTimeout(() => {
    callback(new Error('DNS request timed out.'));
    callback = null;
  }, 5000);

  return function(err, result) {
    if (callback) {
      clearTimeout(timeout);
      callback(err, result);
    }
  };
}


/***/ }),
/* 98 */
/***/ (function(module, exports) {

module.exports = require("dgram");

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * bech32.js - bech32 for wmcc_core.
 *
 * Parts of this software are based on "bech32".
 * https://github.com/sipa/bech32
 *
 * Copyright (c) 2017 Pieter Wuille
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */



const native = __webpack_require__(18).binding;

/**
 * @module utils/bech32
 */

const POOL65 = Buffer.allocUnsafe(65);
const CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
const TABLE = [
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  15, -1, 10, 17, 21, 20, 26, 30,  7,  5, -1, -1, -1, -1, -1, -1,
  -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,
   1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1,
  -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,
   1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1
];

/**
 * Update checksum.
 * @ignore
 * @param {Number} chk
 * @returns {Number}
 */

function polymod(pre) {
  const b = pre >>> 25;
  return ((pre & 0x1ffffff) << 5)
    ^ (-((b >> 0) & 1) & 0x3b6a57b2)
    ^ (-((b >> 1) & 1) & 0x26508e6d)
    ^ (-((b >> 2) & 1) & 0x1ea119fa)
    ^ (-((b >> 3) & 1) & 0x3d4233dd)
    ^ (-((b >> 4) & 1) & 0x2a1462b3);
}

/**
 * Encode hrp and data as a bech32 string.
 * @ignore
 * @param {String} hrp
 * @param {Buffer} data
 * @returns {String}
 */

function serialize(hrp, data) {
  let chk = 1;
  let i;

  for (i = 0; i < hrp.length; i++) {
    const ch = hrp.charCodeAt(i);

    if ((ch >> 5) === 0)
      throw new Error('Invalid bech32 character.');

    chk = polymod(chk) ^ (ch >> 5);
  }

  if (i + 7 + data.length > 90)
    throw new Error('Invalid bech32 data length.');

  chk = polymod(chk);

  let str = '';

  for (let i = 0; i < hrp.length; i++) {
    const ch = hrp.charCodeAt(i);
    chk = polymod(chk) ^ (ch & 0x1f);
    str += hrp[i];
  }

  str += '1';

  for (let i = 0; i < data.length; i++) {
    const ch = data[i];

    if ((ch >> 5) !== 0)
      throw new Error('Invalid bech32 value.');

    chk = polymod(chk) ^ ch;
    str += CHARSET[ch];
  }

  for (let i = 0; i < 6; i++)
    chk = polymod(chk);

  chk ^= 1;

  for (let i = 0; i < 6; i++)
    str += CHARSET[(chk >>> ((5 - i) * 5)) & 0x1f];

  return str;
}

/**
 * Decode a bech32 string.
 * @param {String} str
 * @returns {Array} [hrp, data]
 */

function deserialize(str) {
  let dlen = 0;

  if (str.length < 8 || str.length > 90)
    throw new Error('Invalid bech32 string length.');

  while (dlen < str.length && str[(str.length - 1) - dlen] !== '1')
    dlen++;

  const hlen = str.length - (1 + dlen);

  if (hlen < 1 || dlen < 6)
    throw new Error('Invalid bech32 data length.');

  dlen -= 6;

  const data = Buffer.allocUnsafe(dlen);

  let chk = 1;
  let lower = false;
  let upper = false;
  let hrp = '';

  for (let i = 0; i < hlen; i++) {
    let ch = str.charCodeAt(i);

    if (ch < 0x21 || ch > 0x7e)
      throw new Error('Invalid bech32 character.');

    if (ch >= 0x61 && ch <= 0x7a) {
      lower = true;
    } else if (ch >= 0x41 && ch <= 0x5a) {
      upper = true;
      ch = (ch - 0x41) + 0x61;
    }

    hrp += String.fromCharCode(ch);
    chk = polymod(chk) ^ (ch >> 5);
  }

  chk = polymod(chk);

  let i;
  for (i = 0; i < hlen; i++)
    chk = polymod(chk) ^ (str.charCodeAt(i) & 0x1f);

  i++;

  while (i < str.length) {
    const ch = str.charCodeAt(i);
    const v = (ch & 0x80) ? -1 : TABLE[ch];

    if (ch >= 0x61 && ch <= 0x7a)
      lower = true;
    else if (ch >= 0x41 && ch <= 0x5a)
      upper = true;

    if (v === -1)
      throw new Error('Invalid bech32 character.');

    chk = polymod(chk) ^ v;

    if (i + 6 < str.length)
      data[i - (1 + hlen)] = v;

    i++;
  }

  if (lower && upper)
    throw new Error('Invalid bech32 casing.');

  if (chk !== 1)
    throw new Error('Invalid bech32 checksum.');

  return [hrp, data.slice(0, dlen)];
}

/**
 * Convert serialized data to bits,
 * suitable to be serialized as bech32.
 * @param {Buffer} data
 * @param {Buffer} output
 * @param {Number} frombits
 * @param {Number} tobits
 * @param {Number} pad
 * @param {Number} off
 * @returns {Buffer}
 */

function convert(data, output, frombits, tobits, pad, off) {
  const maxv = (1 << tobits) - 1;
  let acc = 0;
  let bits = 0;
  let j = 0;

  if (pad !== -1)
    output[j++] = pad;

  for (let i = off; i < data.length; i++) {
    const value = data[i];

    if ((value >> frombits) !== 0)
      throw new Error('Invalid bech32 bits.');

    acc = (acc << frombits) | value;
    bits += frombits;

    while (bits >= tobits) {
      bits -= tobits;
      output[j++] = (acc >>> bits) & maxv;
    }
  }

  if (pad !== -1) {
    if (bits > 0)
      output[j++] = (acc << (tobits - bits)) & maxv;
  } else {
    if (bits >= frombits || ((acc << (tobits - bits)) & maxv))
      throw new Error('Invalid bech32 bits.');
  }

  return output.slice(0, j);
}

/**
 * Serialize data to bech32 address.
 * @param {String} hrp
 * @param {Number} version
 * @param {Buffer} hash
 * @returns {String}
 */

function encode(hrp, version, hash) {
  const output = POOL65;

  if (version < 0 || version > 16)
    throw new Error('Invalid bech32 version.');

  if (hash.length < 2 || hash.length > 40)
    throw new Error('Invalid bech32 data length.');

  const data = convert(hash, output, 8, 5, version, 0);

  return serialize(hrp, data);
}

if (native)
  encode = native.toBech32;

/**
 * Deserialize data from bech32 address.
 * @param {String} str
 * @returns {Object}
 */

function decode(str) {
  const [hrp, data] = deserialize(str);

  if (data.length === 0 || data.length > 65)
    throw new Error('Invalid bech32 data length.');

  if (data[0] > 16)
    throw new Error('Invalid bech32 version.');

  const version = data[0];
  const output = data;
  const hash = convert(data, output, 5, 8, -1, 1);

  if (hash.length < 2 || hash.length > 40)
    throw new Error('Invalid bech32 data length.');

  return new AddrResult(hrp, version, hash);
}

if (native)
  decode = native.fromBech32;

/**
 * AddrResult
 * @constructor
 * @private
 * @param {String} hrp
 * @param {Number} version
 * @param {Buffer} hash
 * @property {String} hrp
 * @property {Number} version
 * @property {Buffer} hash
 */

function AddrResult(hrp, version, hash) {
  this.hrp = hrp;
  this.version = version;
  this.hash = hash;
}

/*
 * Expose
 */

exports.deserialize = deserialize;
exports.serialize = serialize;
exports.convert = convert;
exports.encode = encode;
exports.decode = decode;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * pem.js - pem parsing for wmcc_core.
 */



const assert = __webpack_require__(0);

/**
 * @exports utils/pem
 */

const PEM = exports;

/**
 * Parse PEM into separated chunks.
 * @param {String} pem
 * @returns {Object[]}
 * @throws on parse error
 */

PEM.parse = function parse(pem) {
  const chunks = [];
  let chunk = '';
  let tag;

  while (pem.length) {
    let m;

    m = /^-----BEGIN ([^\-]+)-----/.exec(pem);
    if (m) {
      pem = pem.substring(m[0].length);
      tag = m[1];
      continue;
    }

    m = /^-----END ([^\-]+)-----/.exec(pem);
    if (m) {
      pem = pem.substring(m[0].length);

      assert(tag === m[1], 'Tag mismatch.');

      const type = tag.split(' ')[0].toLowerCase();
      const data = Buffer.from(chunk, 'base64');

      chunks.push({
        tag: tag,
        type: type,
        data: data
      });

      chunk = '';
      tag = null;

      continue;
    }

    m = /^[a-zA-Z0-9\+=\/]+/.exec(pem);
    if (m) {
      pem = pem.substring(m[0].length);
      chunk += m[0];
      continue;
    }

    m = /^\s+/.exec(pem);
    if (m) {
      pem = pem.substring(m[0].length);
      continue;
    }

    throw new Error('PEM parse error.');
  }

  assert(chunks.length !== 0, 'PEM parse error.');
  assert(!tag, 'Un-ended tag.');
  assert(chunk.length === 0, 'Trailing data.');

  return chunks;
};

/**
 * Decode PEM into a manageable format.
 * @param {String} pem
 * @returns {Object}
 * @throws on parse error
 */

PEM.decode = function decode(pem) {
  const chunks = PEM.parse(pem);
  const body = chunks[0];
  const extra = chunks[1];

  let params = null;

  if (extra) {
    if (extra.tag.indexOf('PARAMETERS') !== -1)
      params = extra.data;
  }

  let alg = null;

  switch (body.type) {
    case 'dsa':
      alg = 'dsa';
      break;
    case 'rsa':
      alg = 'rsa';
      break;
    case 'ec':
      alg = 'ecdsa';
      break;
  }

  return {
    type: body.type,
    alg: alg,
    data: body.data,
    params: params
  };
};

/**
 * Encode DER to PEM.
 * @param {Buffer} der
 * @param {String} type - e.g. "ec".
 * @param {String?} suffix - e.g. "public key".
 * @returns {String}
 */

PEM.encode = function encode(der, type, suffix) {
  let pem = '';

  if (suffix)
    type += ' ' + suffix;

  type = type.toUpperCase();
  der = der.toString('base64');

  for (let i = 0; i < der.length; i += 64)
    pem += der.slice(i, i + 64) + '\n';

  return ''
    + `-----BEGIN ${type}-----\n`
    + pem
    + `-----END ${type}-----\n`;
};


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * coins.js - coins object for  wmcc_core.
 */



const assert = __webpack_require__(0);
const CoinEntry = __webpack_require__(50);

/**
 * Represents the outputs for a single transaction.
 * @alias module:coins.Coins
 * @constructor
 * @property {Map[]} outputs - Coins.
 */

function Coins() {
  if (!(this instanceof Coins))
    return new Coins();

  this.outputs = new Map();
}

/**
 * Add a single entry to the collection.
 * @param {Number} index
 * @param {CoinEntry} coin
 * @returns {CoinEntry}
 */

Coins.prototype.add = function add(index, coin) {
  //assert(index >= 0);
  //assert(!this.outputs.has(index));
  assert((index >>> 0) === index);
  assert(coin);

  this.outputs.set(index, coin);
  return coin;
};

/**
 * Add a single output to the collection.
 * @param {Number} index
 * @param {Output} output
 * @returns {CoinEntry}
 */

Coins.prototype.addOutput = function addOutput(index, output) {
  //assert(!output.script.isUnspendable());
  return this.add(index, CoinEntry.fromOutput(output));
};

/**
 * Add an output to the collection by output index.
 * @param {TX} tx
 * @param {Number} index
 * @param {Number} height
 * @returns {CoinEntry}
 */

Coins.prototype.addIndex = function addIndex(tx, index, height) {
  return this.add(index, CoinEntry.fromTX(tx, index, height));
};

/**
 * Add a single coin to the collection.
 * @param {Coin} coin
 * @returns {CoinEntry}
 */

Coins.prototype.addCoin = function addCoin(coin) {
  //assert(!coin.script.isUnspendable());
  return this.add(coin.index, CoinEntry.fromCoin(coin));
};

/**
 * Test whether the collection has a coin.
 * @param {Number} index
 * @returns {Boolean}
 */

Coins.prototype.has = function has(index) {
  return this.outputs.has(index);
};

/**
 * Test whether the collection has an unspent coin.
 * @param {Number} index
 * @returns {Boolean}
 */

Coins.prototype.isUnspent = function isUnspent(index) {
  const coin = this.outputs.get(index);

  if (!coin || coin.spent)
    return false;

  return true;
};

/**
 * Get a coin entry.
 * @param {Number} index
 * @returns {CoinEntry|null}
 */

Coins.prototype.get = function get(index) {
  return this.outputs.get(index) || null;
};

/**
 * Get an output.
 * @param {Number} index
 * @returns {Output|null}
 */

Coins.prototype.getOutput = function getOutput(index) {
  const coin = this.outputs.get(index);

  if (!coin)
    return null;

  return coin.output;
};

/**
 * Get a coin.
 * @param {Outpoint} prevout
 * @returns {Coin|null}
 */

Coins.prototype.getCoin = function getCoin(prevout) {
  const coin = this.outputs.get(prevout.index);

  if (!coin)
    return null;

  return coin.toCoin(prevout);
};

/**
 * Spend a coin entry and return it.
 * @param {Number} index
 * @returns {CoinEntry|null}
 */

Coins.prototype.spend = function spend(index) {
  const coin = this.get(index);

  if (!coin || coin.spent)
    return null;

  coin.spent = true;

  return coin;
};

/**
 * Remove a coin entry and return it.
 * @param {Number} index
 * @returns {CoinEntry|null}
 */

Coins.prototype.remove = function remove(index) {
  const coin = this.get(index);

  if (!coin)
    return null;

  this.outputs.delete(index);

  return coin;
};

/**
 * Test whether the coins are fully spent.
 * @returns {Boolean}
 */

Coins.prototype.isEmpty = function isEmpty() {
  return this.outputs.size === 0;
};

/**
 * Inject properties from tx.
 * @private
 * @param {TX} tx
 * @param {Number} height
 * @returns {Coins}
 */

Coins.prototype.fromTX = function fromTX(tx, height) {
  assert(typeof height === 'number');

  for (let i = 0; i < tx.outputs.length; i++) {
    const output = tx.outputs[i];

    if (output.script.isUnspendable())
      continue;

    //this.outputs.set(i, CoinEntry.fromTX(tx, i, height));
    const entry = CoinEntry.fromTX(tx, i, height);

    this.outputs.set(i, entry);
  }

  return this;
};

/**
 * Instantiate a coins object from a transaction.
 * @param {TX} tx
 * @param {Number} height
 * @returns {Coins}
 */

Coins.fromTX = function fromTX(tx, height) {
  return new Coins().fromTX(tx, height);
};

/*
 * Expose
 */

module.exports = Coins;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * compress.js - coin compressor for wmcc_core.
 */



/**
 * @module coins/compress
 * @ignore
 */

const assert = __webpack_require__(0);
const secp256k1 = __webpack_require__(12);
const encoding = __webpack_require__(3);
const consensus = __webpack_require__(7);

/*
 * Constants
 */

const COMPRESS_TYPES = 6;
const EMPTY_BUFFER = Buffer.alloc(0);

/**
 * Compress a script, write directly to the buffer.
 * @param {Script} script
 * @param {BufferWriter} bw
 */

function compressScript(script, bw) {
  // Attempt to compress the output scripts.
  // We can _only_ ever compress them if
  // they are serialized as minimaldata, as
  // we need to recreate them when we read
  // them.

  // P2PKH -> 0 | key-hash
  // Saves 5 bytes.
  const pkh = script.getPubkeyhash(true);
  if (pkh) {
    bw.writeU8(0);
    bw.writeBytes(pkh);
    return bw;
  }

  // P2SH -> 1 | script-hash
  // Saves 3 bytes.
  const sh = script.getScripthash();
  if (sh) {
    bw.writeU8(1);
    bw.writeBytes(sh);
    return bw;
  }

  // P2PK -> 2-5 | compressed-key
  // Only works if the key is valid.
  // Saves up to 35 bytes.
  const pk = script.getPubkey(true);
  if (pk) {
    if (publicKeyVerify(pk)) {
      const key = compressKey(pk);
      bw.writeBytes(key);
      return bw;
    }
  }

  // Raw -> varlen + 10 | script
  bw.writeVarint(script.raw.length + COMPRESS_TYPES);
  bw.writeBytes(script.raw);

  return bw;
}

/**
 * Decompress a script from buffer reader.
 * @param {Script} script
 * @param {BufferReader} br
 */

function decompressScript(script, br) {
  // Decompress the script.
  switch (br.readU8()) {
    case 0: {
      const hash = br.readBytes(20, true);
      script.fromPubkeyhash(hash);
      break;
    }
    case 1: {
      const hash = br.readBytes(20, true);
      script.fromScripthash(hash);
      break;
    }
    case 2:
    case 3:
    case 4:
    case 5: {
      br.offset -= 1;
      const data = br.readBytes(33, true);
      // Decompress the key. If this fails,
      // we have database corruption!
      const key = decompressKey(data);
      script.fromPubkey(key);
      break;
    }
    default: {
      br.offset -= 1;
      const size = br.readVarint() - COMPRESS_TYPES;
      if (size > consensus.MAX_SCRIPT_SIZE) {
        // This violates consensus rules.
        // We don't need to read it.
        script.fromNulldata(EMPTY_BUFFER);
        br.seek(size);
      } else {
        const data = br.readBytes(size);
        script.fromRaw(data);
      }
      break;
    }
  }

  return script;
}

/**
 * Calculate script size.
 * @returns {Number}
 */

function sizeScript(script) {
  if (script.isPubkeyhash(true))
    return 21;

  if (script.isScripthash())
    return 21;

  const pk = script.getPubkey(true);
  if (pk) {
    if (publicKeyVerify(pk))
      return 33;
  }

  let size = 0;
  size += encoding.sizeVarint(script.raw.length + COMPRESS_TYPES);
  size += script.raw.length;

  return size;
}

/**
 * Compress an output.
 * @param {Output} output
 * @param {BufferWriter} bw
 */

function compressOutput(output, bw) {
  bw.writeVarint(output.value);
  compressScript(output.script, bw);
  return bw;
}

/**
 * Decompress a script from buffer reader.
 * @param {Output} output
 * @param {BufferReader} br
 */

function decompressOutput(output, br) {
  output.value = br.readVarint();
  decompressScript(output.script, br);
  return output;
}

/**
 * Calculate output size.
 * @returns {Number}
 */

function sizeOutput(output) {
  let size = 0;
  size += encoding.sizeVarint(output.value);
  size += sizeScript(output.script);
  return size;
}

/**
 * Compress value using an exponent. Takes advantage of
 * the fact that many bitcoin values are divisible by 10.
 * @see https://github.com/btcsuite/btcd/blob/master/blockchain/compress.go
 * @param {Amount} value
 * @returns {Number}
 */

function compressValue(value) {
  if (value === 0)
    return 0;

  let exp = 0;
  while (value % 10 === 0 && exp < 9) {
    value /= 10;
    exp++;
  }

  if (exp < 9) {
    const last = value % 10;
    value = (value - last) / 10;
    return 1 + 10 * (9 * value + last - 1) + exp;
  }

  return 10 + 10 * (value - 1);
}

/**
 * Decompress value.
 * @param {Number} value - Compressed value.
 * @returns {Amount} value
 */

function decompressValue(value) {
  if (value === 0)
    return 0;

  value--;

  let exp = value % 10;

  value = (value - exp) / 10;

  let n;
  if (exp < 9) {
    const last = value % 9;
    value = (value - last) / 9;
    n = value * 10 + last + 1;
  } else {
    n = value + 1;
  }

  while (exp > 0) {
    n *= 10;
    exp--;
  }

  return n;
}

/**
 * Verify a public key (no hybrid keys allowed).
 * @param {Buffer} key
 * @returns {Boolean}
 */

function publicKeyVerify(key) {
  if (key.length === 0)
    return false;

  switch (key[0]) {
    case 0x02:
    case 0x03:
      return key.length === 33;
    case 0x04:
      if (key.length !== 65)
        return false;

      return secp256k1.publicKeyVerify(key);
    default:
      return false;
  }
}

/**
 * Compress a public key to coins compression format.
 * @param {Buffer} key
 * @returns {Buffer}
 */

function compressKey(key) {
  let out;

  switch (key[0]) {
    case 0x02:
    case 0x03:
      // Key is already compressed.
      out = key;
      break;
    case 0x04:
      // Compress the key normally.
      out = secp256k1.publicKeyConvert(key, true);
      // Store the oddness.
      // Pseudo-hybrid format.
      out[0] = 0x04 | (key[64] & 0x01);
      break;
    default:
      throw new Error('Bad point format.');
  }

  assert(out.length === 33);

  return out;
}

/**
 * Decompress a public key from the coins compression format.
 * @param {Buffer} key
 * @returns {Buffer}
 */

function decompressKey(key) {
  const format = key[0];

  assert(key.length === 33);

  switch (format) {
    case 0x02:
    case 0x03:
      return key;
    case 0x04:
      key[0] = 0x02;
      break;
    case 0x05:
      key[0] = 0x03;
      break;
    default:
      throw new Error('Bad point format.');
  }

  // Decompress the key.
  const out = secp256k1.publicKeyConvert(key, false);

  // Reset the first byte so as not to
  // mutate the original buffer.
  key[0] = format;

  return out;
}

// Make eslint happy.
compressValue;
decompressValue;

/*
 * Expose
 */

exports.pack = compressOutput;
exports.unpack = decompressOutput;
exports.size = sizeOutput;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * chainentry.js - chainentry object for wmcc_core.
 */



const assert = __webpack_require__(0);
const BN = __webpack_require__(27);
const consensus = __webpack_require__(7);
const util = __webpack_require__(1);
const digest = __webpack_require__(5);
const X15 = __webpack_require__(57);
const encoding = __webpack_require__(3);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const Headers = __webpack_require__(37);
const InvItem = __webpack_require__(36);
const ZERO = new BN(0);

/**
 * Represents an entry in the chain. Unlike
 * other bitcoin fullnodes, we store the
 * chainwork _with_ the entry in order to
 * avoid reading the entire chain index on
 * boot and recalculating the chainworks.
 * @alias module:blockchain.ChainEntry
 * @constructor
 * @param {Object?} options
 * @property {Hash} hash
 * @property {Number} version - Transaction version. Note that wmcc_core reads
 * versions as unsigned even though they are signed at the protocol level.
 * This value will never be negative.
 * @property {Hash} prevBlock
 * @property {Hash} merkleRoot
 * @property {Number} time
 * @property {Number} bits
 * @property {Number} nonce
 * @property {Number} height
 * @property {BN} chainwork
 * @property {ReversedHash} rhash - Reversed block hash (uint256le).
 */

function ChainEntry(options) {
  if (!(this instanceof ChainEntry))
    return new ChainEntry(options);

  this.hash = encoding.NULL_HASH;
  this.version = 1;
  this.prevBlock = encoding.NULL_HASH;
  this.merkleRoot = encoding.NULL_HASH;
  this.time = 0;
  this.bits = 0;
  this.nonce = 0;
  this.height = 0;
  this.chainwork = ZERO;

  if (options)
    this.fromOptions(options);
}

/**
 * The max chainwork (1 << 256).
 * @const {BN}
 */

ChainEntry.MAX_CHAINWORK = new BN(1).ushln(256);

/**
 * Inject properties from options.
 * @private
 * @param {Object} options
 */

ChainEntry.prototype.fromOptions = function fromOptions(options) {
  assert(options, 'Block data is required.');
  assert(typeof options.hash === 'string');
  assert(util.isU32(options.version));
  assert(typeof options.prevBlock === 'string');
  assert(typeof options.merkleRoot === 'string');
  assert(util.isU32(options.time));
  assert(util.isU32(options.bits));
  assert(util.isU32(options.nonce));
  assert(util.isU32(options.height));
  assert(!options.chainwork || BN.isBN(options.chainwork));

  this.hash = options.hash;
  this.version = options.version;
  this.prevBlock = options.prevBlock;
  this.merkleRoot = options.merkleRoot;
  this.time = options.time;
  this.bits = options.bits;
  this.nonce = options.nonce;
  this.height = options.height;
  this.chainwork = options.chainwork || ZERO;

  return this;
};

/**
 * Instantiate chainentry from options.
 * @param {Object} options
 * @param {ChainEntry} prev - Previous entry.
 * @returns {ChainEntry}
 */

ChainEntry.fromOptions = function fromOptions(options, prev) {
  return new ChainEntry().fromOptions(options, prev);
};

/**
 * Calculate the proof: (1 << 256) / (target + 1)
 * @returns {BN} proof
 */

ChainEntry.prototype.getProof = function getProof() {
  const target = consensus.fromCompact(this.bits);

  if (target.isNeg() || target.cmpn(0) === 0)
    return new BN(0);

  return ChainEntry.MAX_CHAINWORK.div(target.iaddn(1));
};

/**
 * Calculate the chainwork by
 * adding proof to previous chainwork.
 * @returns {BN} chainwork
 */

ChainEntry.prototype.getChainwork = function getChainwork(prev) {
  const proof = this.getProof();

  if (!prev)
    return proof;

  return proof.iadd(prev.chainwork);
};

/**
 * Test against the genesis block.
 * @returns {Boolean}
 */

ChainEntry.prototype.isGenesis = function isGenesis() {
  return this.prevBlock === encoding.NULL_HASH;
};

/**
 * Test whether the entry contains an unknown version bit.
 * @param {Network} network
 * @returns {Boolean}
 */

ChainEntry.prototype.hasUnknown = function hasUnknown(network) {
  const bits = this.version & consensus.VERSION_TOP_MASK;
  const topBits = consensus.VERSION_TOP_BITS;

  if ((bits >>> 0) !== topBits)
    return false;

  return (this.version & network.unknownBits) !== 0;
};

/**
 * Test whether the entry contains a version bit.
 * @param {Number} bit
 * @returns {Boolean}
 */

ChainEntry.prototype.hasBit = function hasBit(bit) {
  return consensus.hasBit(this.version, bit);
};

/**
 * Get little-endian block hash.
 * @returns {Hash}
 */

ChainEntry.prototype.rhash = function rhash() {
  return util.revHex(this.hash);
};

/**
 * Inject properties from block.
 * @private
 * @param {Block|MerkleBlock} block
 * @param {ChainEntry} prev - Previous entry.
 */

ChainEntry.prototype.fromBlock = function fromBlock(block, prev) {
  this.hash = block.hash('hex');
  this.version = block.version;
  this.prevBlock = block.prevBlock;
  this.merkleRoot = block.merkleRoot;
  this.time = block.time;
  this.bits = block.bits;
  this.nonce = block.nonce;
  this.height = prev ? prev.height + 1: 0;
  this.chainwork = this.getChainwork(prev);
  return this;
};

/**
 * Instantiate chainentry from block.
 * @param {Block|MerkleBlock} block
 * @param {ChainEntry} prev - Previous entry.
 * @returns {ChainEntry}
 */

ChainEntry.fromBlock = function fromBlock(block, prev) {
  return new ChainEntry().fromBlock(block, prev);
};

/**
 * Serialize the entry to internal database format.
 * @returns {Buffer}
 */

ChainEntry.prototype.toRaw = function toRaw() {
  const bw = new StaticWriter(116);

  bw.writeU32(this.version);
  bw.writeHash(this.prevBlock);
  bw.writeHash(this.merkleRoot);
  bw.writeU32(this.time);
  bw.writeU32(this.bits);
  bw.writeU32(this.nonce);
  bw.writeU32(this.height);
  bw.writeBytes(this.chainwork.toArrayLike(Buffer, 'le', 32));

  return bw.render();
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

ChainEntry.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);
  // const hash = digest.hash256(br.readBytes(80));
  const hash = X15.digest(br.readBytes(80));

  br.seek(-80);

  this.hash = hash.toString('hex');
  this.version = br.readU32();
  this.prevBlock = br.readHash('hex');
  this.merkleRoot = br.readHash('hex');
  this.time = br.readU32();
  this.bits = br.readU32();
  this.nonce = br.readU32();
  this.height = br.readU32();
  this.chainwork = new BN(br.readBytes(32), 'le');

  return this;
};

/**
 * Deserialize the entry.
 * @param {Buffer} data
 * @returns {ChainEntry}
 */

ChainEntry.fromRaw = function fromRaw(data) {
  return new ChainEntry().fromRaw(data);
};

/**
 * Serialize the entry to an object more
 * suitable for JSON serialization.
 * @returns {Object}
 */

ChainEntry.prototype.toJSON = function toJSON() {
  return {
    hash: util.revHex(this.hash),
    version: this.version,
    prevBlock: util.revHex(this.prevBlock),
    merkleRoot: util.revHex(this.merkleRoot),
    time: this.time,
    bits: this.bits,
    nonce: this.nonce,
    height: this.height,
    chainwork: this.chainwork.toString('hex', 64)
  };
};

/**
 * Inject properties from json object.
 * @private
 * @param {Object} json
 */

ChainEntry.prototype.fromJSON = function fromJSON(json) {
  assert(json, 'Block data is required.');
  assert(typeof json.hash === 'string');
  assert(util.isU32(json.version));
  assert(typeof json.prevBlock === 'string');
  assert(typeof json.merkleRoot === 'string');
  assert(util.isU32(json.time));
  assert(util.isU32(json.bits));
  assert(util.isU32(json.nonce));
  assert(typeof json.chainwork === 'string');

  this.hash = util.revHex(json.hash);
  this.version = json.version;
  this.prevBlock = util.revHex(json.prevBlock);
  this.merkleRoot = util.revHex(json.merkleRoot);
  this.time = json.time;
  this.bits = json.bits;
  this.nonce = json.nonce;
  this.height = json.height;
  this.chainwork = new BN(json.chainwork, 'hex');

  return this;
};

/**
 * Instantiate block from jsonified object.
 * @param {Object} json
 * @returns {ChainEntry}
 */

ChainEntry.fromJSON = function fromJSON(json) {
  return new ChainEntry().fromJSON(json);
};

/**
 * Convert the entry to a headers object.
 * @returns {Headers}
 */

ChainEntry.prototype.toHeaders = function toHeaders() {
  return Headers.fromEntry(this);
};

/**
 * Convert the entry to an inv item.
 * @returns {InvItem}
 */

ChainEntry.prototype.toInv = function toInv() {
  return new InvItem(InvItem.types.BLOCK, this.hash);
};

/**
 * Return a more user-friendly object.
 * @returns {Object}
 */

ChainEntry.prototype.inspect = function inspect() {
  const json = this.toJSON();
  json.version = util.hex32(json.version);
  return json;
};

/**
 * Test whether an object is a {@link ChainEntry}.
 * @param {Object} obj
 * @returns {Boolean}
 */

ChainEntry.isChainEntry = function isChainEntry(obj) {
  return obj instanceof ChainEntry;
};

/*
 * Expose
 */

module.exports = ChainEntry;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * chain.js - blockchain management for wmcc_core.
 */



const assert = __webpack_require__(0);
const path = __webpack_require__(25);
const AsyncObject = __webpack_require__(31);
const Network = __webpack_require__(6);
const Logger = __webpack_require__(34);
const ChainDB = __webpack_require__(163);
const common = __webpack_require__(89);
const consensus = __webpack_require__(7);
const util = __webpack_require__(1);
const Lock = __webpack_require__(23);
const LRU = __webpack_require__(56);
const ChainEntry = __webpack_require__(103);
const CoinView = __webpack_require__(30);
const Script = __webpack_require__(8);
const {VerifyError} = __webpack_require__(105);
const co = __webpack_require__(17);
const thresholdStates = common.thresholdStates;

/**
 * Represents a blockchain.
 * @alias module:blockchain.Chain
 * @constructor
 * @param {Object} options
 * @param {String?} options.name - Database name.
 * @param {String?} options.location - Database file location.
 * @param {String?} options.db - Database backend (`"leveldb"` by default).
 * @param {Number?} options.maxOrphans
 * @param {Boolean?} options.spv
 * @property {Boolean} loaded
 * @property {ChainDB} db - Note that Chain `options` will be passed
 * to the instantiated ChainDB.
 * @property {Lock} locker
 * @property {Object} invalid
 * @property {ChainEntry?} tip
 * @property {Number} height
 * @property {DeploymentState} state
 * @property {Object} orphan - Orphan map.
 * @emits Chain#open
 * @emits Chain#error
 * @emits Chain#block
 * @emits Chain#competitor
 * @emits Chain#resolved
 * @emits Chain#checkpoint
 * @emits Chain#fork
 * @emits Chain#reorganize
 * @emits Chain#invalid
 * @emits Chain#exists
 * @emits Chain#purge
 * @emits Chain#connect
 * @emits Chain#reconnect
 * @emits Chain#disconnect
 */

function Chain(options) {
  if (!(this instanceof Chain))
    return new Chain(options);

  AsyncObject.call(this);

  this.options = new ChainOptions(options);

  this.network = this.options.network;
  this.logger = this.options.logger.context('chain');
  this.workers = this.options.workers;

  this.db = new ChainDB(this.options);

  this.locker = new Lock(true);
  this.invalid = new LRU(100);
  this.state = new DeploymentState();

  this.tip = new ChainEntry();
  this.height = -1;
  this.synced = false;

  this.orphanMap = new Map();
  this.orphanPrev = new Map();
}

Object.setPrototypeOf(Chain.prototype, AsyncObject.prototype);

/**
 * Size of set to pick median time from.
 * @const {Number}
 * @default
 */

Chain.MEDIAN_TIMESPAN = 11;

/**
 * Open the chain, wait for the database to load.
 * @alias Chain#open
 * @returns {Promise}
 */

Chain.prototype._open = async function _open() {
  this.logger.info('Chain is loading.');

  if (this.options.checkpoints)
    this.logger.info('Checkpoints are enabled.');

  if (this.options.coinCache)
    this.logger.info('Coin cache is enabled.');

  if (this.options.bip91)
    this.logger.warning('BIP91 enabled. Segsignal will be enforced.');

  if (this.options.bip148)
    this.logger.warning('BIP148 enabled. UASF will be enforced.');

  await this.db.open();

  const tip = await this.db.getTip();

  assert(tip);

  this.tip = tip;
  this.height = tip.height;

  this.logger.info('Chain Height: %d', tip.height);

  this.logger.memory();

  const state = await this.getDeploymentState();

  this.setDeploymentState(state);

  this.logger.memory();

  this.emit('tip', tip);

  this.maybeSync();
};

/**
 * Close the chain, wait for the database to close.
 * @alias Chain#close
 * @returns {Promise}
 */

Chain.prototype._close = function _close() {
  return this.db.close();
};

/**
 * Perform all necessary contextual verification on a block.
 * @private
 * @param {Block} block
 * @param {ChainEntry} prev
 * @param {Number} flags
 * @returns {Promise} - Returns {@link ContextResult}.
 */

Chain.prototype.verifyContext = async function verifyContext(block, prev, flags) {
  // Initial non-contextual verification.
  const state = await this.verify(block, prev, flags);

  // Skip everything if we're in SPV mode.
  if (this.options.spv) {
    const view = new CoinView();
    return [view, state];
  }

  // Skip everything if we're using checkpoints.
  if (this.isHistorical(prev)) {
    const view = await this.updateInputs(block, prev);
    return [view, state];
  }

  // BIP30 - Verify there are no duplicate txids.
  // Note that BIP34 made it impossible to create
  // duplicate txids.
  if (!state.hasBIP34())
    await this.verifyDuplicates(block, prev);

  // Verify scripts, spend and add coins.
  const view = await this.verifyInputs(block, prev, state);

  return [view, state];
};

/**
 * Perform all necessary contextual verification
 * on a block, without POW check.
 * @param {Block} block
 * @returns {Promise}
 */

Chain.prototype.verifyBlock = async function verifyBlock(block) {
  const unlock = await this.locker.lock();
  try {
    return await this._verifyBlock(block);
  } finally {
    unlock();
  }
};

/**
 * Perform all necessary contextual verification
 * on a block, without POW check (no lock).
 * @private
 * @param {Block} block
 * @returns {Promise}
 */

Chain.prototype._verifyBlock = async function _verifyBlock(block) {
  const flags = common.flags.DEFAULT_FLAGS & ~common.flags.VERIFY_POW;
  return await this.verifyContext(block, this.tip, flags);
};

/**
 * Test whether the hash is in the main chain.
 * @param {Hash} hash
 * @returns {Promise} - Returns Boolean.
 */

Chain.prototype.isMainHash = function isMainHash(hash) {
  return this.db.isMainHash(hash);
};

/**
 * Test whether the entry is in the main chain.
 * @param {ChainEntry} entry
 * @returns {Promise} - Returns Boolean.
 */

Chain.prototype.isMainChain = function isMainChain(entry) {
  return this.db.isMainChain(entry);
};

/**
 * Get ancestor by `height`.
 * @param {ChainEntry} entry
 * @param {Number} height
 * @returns {Promise} - Returns ChainEntry.
 */

Chain.prototype.getAncestor = function getAncestor(entry, height) {
  return this.db.getAncestor(entry, height);
};

/**
 * Get previous entry.
 * @param {ChainEntry} entry
 * @returns {Promise} - Returns ChainEntry.
 */

Chain.prototype.getPrevious = function getPrevious(entry) {
  return this.db.getPrevious(entry);
};

/**
 * Get previous cached entry.
 * @param {ChainEntry} entry
 * @returns {ChainEntry|null}
 */

Chain.prototype.getPrevCache = function getPrevCache(entry) {
  return this.db.getPrevCache(entry);
};

/**
 * Get next entry.
 * @param {ChainEntry} entry
 * @returns {Promise} - Returns ChainEntry.
 */

Chain.prototype.getNext = function getNext(entry) {
  return this.db.getNext(entry);
};

/**
 * Get next entry.
 * @param {ChainEntry} entry
 * @returns {Promise} - Returns ChainEntry.
 */

Chain.prototype.getNextEntry = function getNextEntry(entry) {
  return this.db.getNextEntry(entry);
};

/**
 * Calculate median time past.
 * @param {ChainEntry} prev
 * @param {Number?} time
 * @returns {Promise} - Returns Number.
 */

Chain.prototype.getMedianTime = async function getMedianTime(prev, time) {
  let timespan = Chain.MEDIAN_TIMESPAN;

  const median = [];

  // In case we ever want to check
  // the MTP of the _current_ block
  // (necessary for BIP148).
  if (time != null) {
    median.push(time);
    timespan -= 1;
  }

  let entry = prev;

  for (let i = 0; i < timespan && entry; i++) {
    median.push(entry.time);

    const cache = this.getPrevCache(entry);

    if (cache)
      entry = cache;
    else
      entry = await this.getPrevious(entry);
  }

  median.sort(cmp);

  return median[median.length >>> 1];
};

/**
 * Test whether the entry is potentially
 * an ancestor of a checkpoint.
 * @param {ChainEntry} prev
 * @returns {Boolean}
 */

Chain.prototype.isHistorical = function isHistorical(prev) {
  if (this.options.checkpoints) {
    if (prev.height + 1 <= this.network.lastCheckpoint)
      return true;
  }
  return false;
};

/**
 * Contextual verification for a block, including
 * version deployments (IsSuperMajority), versionbits,
 * coinbase height, finality checks.
 * @private
 * @param {Block} block
 * @param {ChainEntry} prev
 * @param {Number} flags
 * @returns {Promise} - Returns {@link DeploymentState}.
 */

Chain.prototype.verify = async function verify(block, prev, flags) {
  assert(typeof flags === 'number');

  // Extra sanity check.
  if (block.prevBlock !== prev.hash)
    throw new VerifyError(block, 'invalid', 'bad-prevblk', 0);

  // Verify a checkpoint if there is one.
  const hash = block.hash('hex');
  if (!this.verifyCheckpoint(prev, hash)) {
    throw new VerifyError(block,
      'checkpoint',
      'checkpoint mismatch',
      100);
  }

  // Skip everything when using checkpoints.
  // We can do this safely because every
  // block in between each checkpoint was
  // validated outside in the header chain.
  if (this.isHistorical(prev)) {
    if (this.options.spv)
      return this.state;

    // Once segwit is active, we will still
    // need to check for block mutability.
    if (!block.hasWitness() && !block.getCommitmentHash())
      return new DeploymentState();

    flags &= ~common.flags.VERIFY_BODY;
  }

  // Non-contextual checks.
  if (flags & common.flags.VERIFY_BODY) {
    const [valid, reason, score] = block.checkBody();

    if (!valid)
      throw new VerifyError(block, 'invalid', reason, score, true);
  }

  // Ensure the POW is what we expect.
  const bits = await this.getTarget(block.time, prev);

  if (block.bits !== bits) {
    throw new VerifyError(block,
      'invalid',
      'bad-diffbits',
      100);
  }

  // Skip all blocks in spv mode once
  // we've verified the network target.
  if (this.options.spv)
    return this.state;

  // Ensure the timestamp is correct.
  const mtp = await this.getMedianTime(prev);

  if (block.time <= mtp) {
    throw new VerifyError(block,
      'invalid',
      'time-too-old',
      0);
  }

  // Check timestamp against adj-time+2hours.
  // If this fails we may be able to accept
  // the block later.
  if (block.time > this.network.now() + 2 * 60 * 60) {
    throw new VerifyError(block,
      'invalid',
      'time-too-new',
      0,
      true);
  }

  // Calculate height of current block.
  const height = prev.height + 1;

  // Only allow version 2 blocks (coinbase height)
  // once the majority of blocks are using it.
  if (block.version < 2 && height >= this.network.block.bip34height)
    throw new VerifyError(block, 'obsolete', 'bad-version', 0);

  // Only allow version 3 blocks (sig validation)
  // once the majority of blocks are using it.
  if (block.version < 3 && height >= this.network.block.bip66height)
    throw new VerifyError(block, 'obsolete', 'bad-version', 0);

  // Only allow version 4 blocks (checklocktimeverify)
  // once the majority of blocks are using it.
  if (block.version < 4 && height >= this.network.block.bip65height)
    throw new VerifyError(block, 'obsolete', 'bad-version', 0);

  // Get the new deployment state.
  const state = await this.getDeployments(block.time, prev);

  // Enforce BIP91/BIP148.
  if (state.hasBIP91() || state.hasBIP148()) {
    const {segwit} = this.network.deployments;
    if (!consensus.hasBit(block.version, segwit.bit))
      throw new VerifyError(block, 'invalid', 'bad-no-segwit', 0);
  }

  // Get timestamp for tx.isFinal().
  const time = state.hasMTP() ? mtp : block.time;

  // Transactions must be finalized with
  // regards to nSequence and nLockTime.
  for (const tx of block.txs) {
    if (!tx.isFinal(height, time)) {
      throw new VerifyError(block,
        'invalid',
        'bad-txns-nonfinal',
        10);
    }
  }

  // Make sure the height contained
  // in the coinbase is correct.
  if (state.hasBIP34()) {
    if (block.getCoinbaseHeight() !== height) {
      throw new VerifyError(block,
        'invalid',
        'bad-cb-height',
        100);
    }
  }

  // Check the commitment hash for segwit.
  let commit = null;
  if (state.hasWitness()) {
    commit = block.getCommitmentHash();
    if (commit) {
      // These are totally malleable. Someone
      // may have even accidentally sent us
      // the non-witness version of the block.
      // We don't want to consider this block
      // "invalid" if either of these checks
      // fail.
      if (!block.getWitnessNonce()) {
        throw new VerifyError(block,
          'invalid',
          'bad-witness-nonce-size',
          100,
          true);
      }

      if (!commit.equals(block.createCommitmentHash())) {
        throw new VerifyError(block,
          'invalid',
          'bad-witness-merkle-match',
          100,
          true);
      }
    }
  }

  // Blocks that do not commit to
  // witness data cannot contain it.
  if (!commit) {
    if (block.hasWitness()) {
      throw new VerifyError(block,
        'invalid',
        'unexpected-witness',
        100,
        true);
    }
  }

  // Check block weight (different from block size
  // check in non-contextual verification).
  if (block.getWeight() > consensus.MAX_BLOCK_WEIGHT) {
    throw new VerifyError(block,
      'invalid',
      'bad-blk-weight',
      100);
  }

  return state;
};

/**
 * Check all deployments on a chain, ranging from p2sh to segwit.
 * @param {Number} time
 * @param {ChainEntry} prev
 * @returns {Promise} - Returns {@link DeploymentState}.
 */

Chain.prototype.getDeployments = async function getDeployments(time, prev) {
  const deployments = this.network.deployments;
  const height = prev.height + 1;
  const state = new DeploymentState();

  // For some reason bitcoind has p2sh in the
  // mandatory flags by default, when in reality
  // it wasn't activated until march 30th 2012.
  // The first p2sh output and redeem script
  // appeared on march 7th 2012, only it did
  // not have a signature. See:
  // 6a26d2ecb67f27d1fa5524763b49029d7106e91e3cc05743073461a719776192
  // 9c08a4d78931342b37fd5f72900fb9983087e6f46c4a097d8a1f52c74e28eaf6
  if (time >= consensus.BIP16_TIME)
    state.flags |= Script.flags.VERIFY_P2SH;

  // Coinbase heights are now enforced (bip34).
  if (height >= this.network.block.bip34height)
    state.bip34 = true;

  // Signature validation is now enforced (bip66).
  if (height >= this.network.block.bip66height)
    state.flags |= Script.flags.VERIFY_DERSIG;

  // CHECKLOCKTIMEVERIFY is now usable (bip65).
  if (height >= this.network.block.bip65height)
    state.flags |= Script.flags.VERIFY_CHECKLOCKTIMEVERIFY;

  // CHECKSEQUENCEVERIFY and median time
  // past locktimes are now usable (bip9 & bip113).
  if (await this.isActive(prev, deployments.csv)) {
    state.flags |= Script.flags.VERIFY_CHECKSEQUENCEVERIFY;
    state.lockFlags |= common.lockFlags.VERIFY_SEQUENCE;
    state.lockFlags |= common.lockFlags.MEDIAN_TIME_PAST;
  }

  // Check the state of the segwit deployment.
  const witness = await this.getState(prev, deployments.segwit);

  // Segregrated witness (bip141) is now usable
  // along with SCRIPT_VERIFY_NULLDUMMY (bip147).
  if (witness === thresholdStates.ACTIVE) {
    state.flags |= Script.flags.VERIFY_WITNESS;
    state.flags |= Script.flags.VERIFY_NULLDUMMY;
  }

  // Segsignal is now enforced (bip91).
  if (this.options.bip91) {
    if (witness === thresholdStates.STARTED) {
      if (await this.isActive(prev, deployments.segsignal))
        state.bip91 = true;
    }
  }

  // UASF is now enforced (bip148) (mainnet-only).
  if (this.options.bip148 && this.network === Network.mainnet) {
    /* ctl
    if (witness !== thresholdStates.LOCKED_IN
        && witness !== thresholdStates.ACTIVE) {
      // The BIP148 MTP check is nonsensical in
      // that it includes the _current_ entry's
      // timestamp. This requires some hackery,
      // since wmcc_core only operates on the sane
      // assumption that deployment checks should
      // only ever examine the values of the
      // previous block (necessary for mining).
      const mtp = await this.getMedianTime(prev, time);
      if (mtp >= 1501545600 && mtp <= 1510704000)
        state.bip148 = true;
    }*/
    state.bip148 = true;
  }

  return state;
};

/**
 * Set a new deployment state.
 * @param {DeploymentState} state
 */

Chain.prototype.setDeploymentState = function setDeploymentState(state) {
  if (this.options.checkpoints && this.height < this.network.lastCheckpoint) {
    this.state = state;
    return;
  }

  if (!this.state.hasP2SH() && state.hasP2SH())
    this.logger.warning('P2SH has been activated.');

  if (!this.state.hasBIP34() && state.hasBIP34())
    this.logger.warning('BIP34 has been activated.');

  if (!this.state.hasBIP66() && state.hasBIP66())
    this.logger.warning('BIP66 has been activated.');

  if (!this.state.hasCLTV() && state.hasCLTV())
    this.logger.warning('BIP65 has been activated.');

  if (!this.state.hasCSV() && state.hasCSV())
    this.logger.warning('CSV has been activated.');

  if (!this.state.hasWitness() && state.hasWitness())
    this.logger.warning('Segwit has been activated.');

  if (!this.state.hasBIP91() && state.hasBIP91())
    this.logger.warning('BIP91 has been activated.');

  if (!this.state.hasBIP148() && state.hasBIP148())
    this.logger.warning('BIP148 has been activated.');

  this.state = state;
};

/**
 * Determine whether to check block for duplicate txids in blockchain
 * history (BIP30). If we're on a chain that has bip34 activated, we
 * can skip this.
 * @private
 * @see https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki
 * @param {Block} block
 * @param {ChainEntry} prev
 * @returns {Promise}
 */

Chain.prototype.verifyDuplicates = async function verifyDuplicates(block, prev) {
  for (const tx of block.txs) {
    if (!await this.hasCoins(tx))
      continue;

    const height = prev.height + 1;
    const hash = this.network.bip30[height];

    // Blocks 91842 and 91880 created duplicate
    // txids by using the same exact output script
    // and extraNonce.
    if (!hash || block.hash('hex') !== hash)
      throw new VerifyError(block, 'invalid', 'bad-txns-BIP30', 100);
  }
};

/**
 * Spend and update inputs (checkpoints only).
 * @private
 * @param {Block} block
 * @param {ChainEntry} prev
 * @returns {Promise} - Returns {@link CoinView}.
 */

Chain.prototype.updateInputs = async function updateInputs(block, prev) {
  const view = new CoinView();
  const height = prev.height + 1;
  const cb = block.txs[0];

  view.addTX(cb, height);

  for (let i = 1; i < block.txs.length; i++) {
    const tx = block.txs[i];

    assert(await view.spendInputs(this.db, tx),
      'BUG: Spent inputs in historical data!');

    view.addTX(tx, height);
  }

  return view;
};

/**
 * Check block transactions for all things pertaining
 * to inputs. This function is important because it is
 * what actually fills the coins into the block. This
 * function will check the block reward, the sigops,
 * the tx values, and execute and verify the scripts (it
 * will attempt to do this on the worker pool). If
 * `checkpoints` is enabled, it will skip verification
 * for historical data.
 * @private
 * @see TX#verifyInputs
 * @see TX#verify
 * @param {Block} block
 * @param {ChainEntry} prev
 * @param {DeploymentState} state
 * @returns {Promise} - Returns {@link CoinView}.
 */

Chain.prototype.verifyInputs = async function verifyInputs(block, prev, state) {
  const view = new CoinView();
  const height = prev.height + 1;
  const interval = this.network.halvingInterval;
  const prevblock = await this.getBlock(prev.hash);
  const prevcr = prevblock.getCoinreserve();
  const cr = block.getCoinreserve();

  let sigops = 0;
  let reward = 0;
  let change = false;
  let craddr = null;

  // Check all transactions
  for (let i = 0; i < block.txs.length; i++) {
    const tx = block.txs[i];

    // Ensure tx is not double spending an output.
    if (i > 0) {
      if (!await view.spendInputs(this.db, tx)) {
        throw new VerifyError(block,
          'invalid',
          'bad-txns-inputs-missingorspent',
          100);
      }
    }

    // Ensure tx contain coinreserve and not duplicate.
    if (i > 0) {
      const addr = this.findCoinreserve(tx, cr);
      if (addr) {
        if (craddr || !change) {
          throw new VerifyError(block,
            'invalid',
            'bad-txns-coinreserve-duplicate',
            100);
        }
        craddr = addr;
      }
    } else {
      change = !this.isCoinreserveEquals(cr, prevcr, height);
    }

    // Verify sequence locks.
    if (i > 0 && tx.version >= 2) {
      const valid = await this.verifyLocks(prev, tx, view, state.lockFlags);

      if (!valid) {
        throw new VerifyError(block,
          'invalid',
          'bad-txns-nonfinal',
          100);
      }
    }

    // Count sigops (legacy + scripthash? + witness?)
    sigops += tx.getSigopsCost(view, state.flags);

    if (sigops > consensus.MAX_BLOCK_SIGOPS_COST) {
      throw new VerifyError(block,
        'invalid',
        'bad-blk-sigops',
        100);
    }

    // Contextual sanity checks.
    if (i > 0) {
      const [fee, reason, score] = tx.checkInputs(view, height);

      if (fee === -1) {
        throw new VerifyError(block,
          'invalid',
          reason,
          score);
      }

      reward += fee;

      if (reward > consensus.getMaxMoney(height)) {
        throw new VerifyError(block,
          'invalid',
          'bad-cb-amount',
          100);
      }
    }

    // Add new coins.
    view.addTX(tx, height);
  }

  if (!change) craddr = [cr];
  // Make sure coinreserve included in block and has only single change output
  if (!craddr) {
    throw new VerifyError(block,
      'invalid',
      'bad-txns-coinreserve-missing',
      100);
  }
  if (!this.isCoinreserveEquals(craddr[0], prevcr, height)) {
    throw new VerifyError(block,
      'invalid',
      'bad-txns-coinreserve-mismatch',
      100);
  } else if (craddr.length > 1) {
    throw new VerifyError(block,
      'invalid',
      'bad-txns-coinreserve-toomany',
      100);
  }

  // Make sure the miner isn't trying to conjure more coins.
  reward += consensus.getTotalReward(height, interval); // check this

  if (block.getClaimed() > reward) {
    throw new VerifyError(block,
      'invalid',
      'bad-cb-amount',
      100);
  }

  // Push onto verification queue.
  const jobs = [];
  for (let i = 1; i < block.txs.length; i++) {
    const tx = block.txs[i];
    jobs.push(tx.verifyAsync(view, state.flags, this.workers));
  }

  // Verify all txs in parallel.
  if (!await co.every(jobs)) {
    throw new VerifyError(block,
      'invalid',
      'mandatory-script-verify-flag-failed',
      100);
  }

  return view;
};

/**
 * Test and find whether the tx has Coinreserve.
 * @param {TX} tx
 * @param {Address} coinreserveaddress
 * @returns {Address} new coinreserveaddress.
 */

Chain.prototype.findCoinreserve = function findCoinreserve(tx, address) {
  for (let output of tx.outputs) {
    const addr = output.getAddress();
    if (addr === address)
      return filter(tx, addr);
  }
  return false;
}

/**
 * Test and find whether the tx has Coinreserve.
 * @param {Output} coinreserve output
 * @param {Output} coinreserve prev output
 * @param {Number} height
 * @returns {Boolean}
 */

Chain.prototype.isCoinreserveEquals = function isCoinreserveEquals(output, prev, height) {
  if (height === 1) {
    if (output.script.equals(prev.script))
      return true;
  } else {
    if (output.equals(prev))
      return true;
  }
  return false;
}

/**
 * Find the block at which a fork ocurred.
 * @private
 * @param {ChainEntry} fork - The current chain.
 * @param {ChainEntry} longer - The competing chain.
 * @returns {Promise}
 */

Chain.prototype.findFork = async function findFork(fork, longer) {
  while (fork.hash !== longer.hash) {
    while (longer.height > fork.height) {
      longer = await this.getPrevious(longer);
      if (!longer)
        throw new Error('No previous entry for new tip.');
    }

    if (fork.hash === longer.hash)
      return fork;

    fork = await this.getPrevious(fork);

    if (!fork)
      throw new Error('No previous entry for old tip.');
  }

  return fork;
};

/**
 * Reorganize the blockchain (connect and disconnect inputs).
 * Called when a competing chain with a higher chainwork
 * is received.
 * @private
 * @param {ChainEntry} competitor - The competing chain's tip.
 * @returns {Promise}
 */

Chain.prototype.reorganize = async function reorganize(competitor) {
  const tip = this.tip;
  const fork = await this.findFork(tip, competitor);

  assert(fork, 'No free space or data corruption.');

  // Blocks to disconnect.
  const disconnect = [];
  let entry = tip;
  while (entry.hash !== fork.hash) {
    disconnect.push(entry);
    entry = await this.getPrevious(entry);
    assert(entry);
  }

  // Blocks to connect.
  const connect = [];
  entry = competitor;
  while (entry.hash !== fork.hash) {
    connect.push(entry);
    entry = await this.getPrevious(entry);
    assert(entry);
  }

  // Disconnect blocks/txs.
  for (let i = 0; i < disconnect.length; i++) {
    const entry = disconnect[i];
    await this.disconnect(entry);
  }

  // Connect blocks/txs.
  // We don't want to connect the new tip here.
  // That will be done outside in setBestChain.
  for (let i = connect.length - 1; i >= 1; i--) {
    const entry = connect[i];
    await this.reconnect(entry);
  }

  this.logger.warning(
    'Chain reorganization: old=%s(%d) new=%s(%d)',
    tip.rhash(),
    tip.height,
    competitor.rhash(),
    competitor.height
  );

  //this.emit('reorganize', tip, competitor);
  await this.fire('reorganize', tip, competitor);
};

/**
 * Reorganize the blockchain for SPV. This
 * will reset the chain to the fork block.
 * @private
 * @param {ChainEntry} competitor - The competing chain's tip.
 * @returns {Promise}
 */

Chain.prototype.reorganizeSPV = async function reorganizeSPV(competitor) {
  const tip = this.tip;
  const fork = await this.findFork(tip, competitor);

  assert(fork, 'No free space or data corruption.');

  // Buffer disconnected blocks.
  const disconnect = [];
  let entry = tip;
  while (entry.hash !== fork.hash) {
    disconnect.push(entry);
    entry = await this.getPrevious(entry);
    assert(entry);
  }

  // Reset the main chain back
  // to the fork block, causing
  // us to redownload the blocks
  // on the new main chain.
  await this._reset(fork.hash, true);

  // Emit disconnection events now that
  // the chain has successfully reset.
  for (const entry of disconnect) {
    const headers = entry.toHeaders();
    const view = new CoinView();
    await this.fire('disconnect', entry, headers, view);
  }

  this.logger.warning(
    'SPV reorganization: old=%s(%d) new=%s(%d)',
    tip.rhash(),
    tip.height,
    competitor.rhash(),
    competitor.height
  );

  this.logger.warning(
    'Chain replay from height %d necessary.',
    fork.height);

  //this.emit('reorganize', tip, competitor);
  await this.fire('reorganize', tip, competitor);
};

/**
 * Disconnect an entry from the chain (updates the tip).
 * @param {ChainEntry} entry
 * @returns {Promise}
 */

Chain.prototype.disconnect = async function disconnect(entry) {
  let block = await this.getBlock(entry.hash);

  if (!block) {
    if (!this.options.spv)
      throw new Error('Block not found.');
    block = entry.toHeaders();
  }

  const prev = await this.getPrevious(entry);
  const view = await this.db.disconnect(entry, block);

  assert(prev);

  this.tip = prev;
  this.height = prev.height;

  this.emit('tip', prev);

  await this.fire('disconnect', entry, block, view);
};

/**
 * Reconnect an entry to the chain (updates the tip).
 * This will do contextual-verification on the block
 * (necessary because we cannot validate the inputs
 * in alternate chains when they come in).
 * @param {ChainEntry} entry
 * @param {Number} flags
 * @returns {Promise}
 */

Chain.prototype.reconnect = async function reconnect(entry) {
  const flags = common.flags.VERIFY_NONE;

  let block = await this.getBlock(entry.hash);

  if (!block) {
    if (!this.options.spv)
      throw new Error('Block not found.');
    block = entry.toHeaders();
  }

  const prev = await this.getPrevious(entry);
  assert(prev);

  let view, state;
  try {
    [view, state] = await this.verifyContext(block, prev, flags);
  } catch (err) {
    if (err.type === 'VerifyError') {
      if (!err.malleated)
        this.setInvalid(entry.hash);
      this.logger.warning(
        'Tried to reconnect invalid block: %s (%d).',
        entry.rhash(), entry.height);
    }
    throw err;
  }

  await this.db.reconnect(entry, block, view);

  this.tip = entry;
  this.height = entry.height;
  this.setDeploymentState(state);

  this.emit('tip', entry);
  this.emit('reconnect', entry, block);

  await this.fire('connect', entry, block, view);
};

/**
 * Set the best chain. This is called on every valid block
 * that comes in. It may add and connect the block (main chain),
 * save the block without connection (alternate chain), or
 * reorganize the chain (a higher fork).
 * @private
 * @param {ChainEntry} entry
 * @param {Block} block
 * @param {ChainEntry} prev
 * @param {Number} flags
 * @returns {Promise}
 */

Chain.prototype.setBestChain = async function setBestChain(entry, block, prev, flags) {
  // A higher fork has arrived.
  // Time to reorganize the chain.
  if (entry.prevBlock !== this.tip.hash) {
    this.logger.warning('WARNING: Reorganizing chain.');

    // In spv-mode, we reset the
    // chain and redownload the blocks.
    if (this.options.spv) {
      await this.reorganizeSPV(entry);
      return;
    }

    await this.reorganize(entry);
  }

  // Warn of unknown versionbits.
  if (entry.hasUnknown(this.network)) {
    this.logger.warning(
      'Unknown version bits in block %d: %s.',
      entry.height, util.hex32(entry.version));
  }

  // Otherwise, everything is in order.
  // Do "contextual" verification on our block
  // now that we're certain its previous
  // block is in the chain.
  let view, state;
  try {
    [view, state] = await this.verifyContext(block, prev, flags);
  } catch (err) {
    if (err.type === 'VerifyError') {
      if (!err.malleated)
        this.setInvalid(entry.hash);
      this.logger.warning(
        'Tried to connect invalid block: %s (%d).',
        entry.rhash(), entry.height);
    }
    throw err;
  }

  // Save block and connect inputs.
  await this.db.save(entry, block, view);

  // Expose the new state.
  this.tip = entry;
  this.height = entry.height;
  this.setDeploymentState(state);

  this.emit('tip', entry);
  this.emit('block', block, entry);

  await this.fire('connect', entry, block, view);
};

/**
 * Save block on an alternate chain.
 * @private
 * @param {ChainEntry} entry
 * @param {Block} block
 * @param {ChainEntry} prev
 * @param {Number} flags
 * @returns {Promise}
 */

Chain.prototype.saveAlternate = async function saveAlternate(entry, block, prev, flags) {
  try {
    // Do as much verification
    // as we can before saving.
    await this.verify(block, prev, flags);
  } catch (err) {
    if (err.type === 'VerifyError') {
      if (!err.malleated)
        this.setInvalid(entry.hash);
      this.logger.warning(
        'Invalid block on alternate chain: %s (%d).',
        entry.rhash(), entry.height);
    }
    throw err;
  }

  // Warn of unknown versionbits.
  if (entry.hasUnknown(this.network)) {
    this.logger.warning(
      'Unknown version bits in block %d: %s.',
      entry.height, util.hex32(entry.version));
  }

  await this.db.save(entry, block);

  this.logger.warning('Heads up: Competing chain at height %d:'
    + ' tip-height=%d competitor-height=%d'
    + ' tip-hash=%s competitor-hash=%s'
    + ' tip-chainwork=%s competitor-chainwork=%s'
    + ' chainwork-diff=%s',
    entry.height,
    this.tip.height,
    entry.height,
    this.tip.rhash(),
    entry.rhash(),
    this.tip.chainwork.toString(),
    entry.chainwork.toString(),
    this.tip.chainwork.sub(entry.chainwork).toString());

  // Emit as a "competitor" block.
  this.emit('competitor', block, entry);
};

/**
 * Reset the chain to the desired block. This
 * is useful for replaying the blockchain download
 * for SPV.
 * @param {Hash|Number} block
 * @returns {Promise}
 */

Chain.prototype.reset = async function reset(block) {
  const unlock = await this.locker.lock();
  try {
    return await this._reset(block, false);
  } finally {
    unlock();
  }
};

/**
 * Reset the chain to the desired block without a lock.
 * @private
 * @param {Hash|Number} block
 * @returns {Promise}
 */

Chain.prototype._reset = async function _reset(block, silent) {
  const tip = await this.db.reset(block);

  // Reset state.
  this.tip = tip;
  this.height = tip.height;
  this.synced = false;

  const state = await this.getDeploymentState();

  this.setDeploymentState(state);

  this.emit('tip', tip);

  if (!silent)
    await this.fire('reset', tip);

  // Reset the orphan map completely. There may
  // have been some orphans on a forked chain we
  // no longer need.
  this.purgeOrphans();

  this.maybeSync();
};

/**
 * Reset the chain to a height or hash. Useful for replaying
 * the blockchain download for SPV.
 * @param {Hash|Number} block - hash/height
 * @returns {Promise}
 */

Chain.prototype.replay = async function replay(block) {
  const unlock = await this.locker.lock();
  try {
    return await this._replay(block, true);
  } finally {
    unlock();
  }
};

/**
 * Reset the chain without a lock.
 * @private
 * @param {Hash|Number} block - hash/height
 * @param {Boolean?} silent
 * @returns {Promise}
 */

Chain.prototype._replay = async function _replay(block, silent) {
  const entry = await this.getEntry(block);

  if (!entry)
    throw new Error('Block not found.');

  if (!await this.isMainChain(entry))
    throw new Error('Cannot reset on alternate chain.');

  if (entry.isGenesis()) {
    await this._reset(entry.hash, silent);
    return;
  }

  await this._reset(entry.prevBlock, silent);
};

/**
 * Invalidate block.
 * @param {Hash} hash
 * @returns {Promise}
 */

Chain.prototype.invalidate = async function invalidate(hash) {
  const unlock = await this.locker.lock();
  try {
    return await this._invalidate(hash);
  } finally {
    unlock();
  }
};

/**
 * Invalidate block (no lock).
 * @param {Hash} hash
 * @returns {Promise}
 */

Chain.prototype._invalidate = async function _invalidate(hash) {
  await this._replay(hash, false);
  this.setInvalid(hash);
};

/**
 * Retroactively prune the database.
 * @returns {Promise}
 */

Chain.prototype.prune = async function prune() {
  const unlock = await this.locker.lock();
  try {
    return await this.db.prune();
  } finally {
    unlock();
  }
};

/**
 * Scan the blockchain for transactions containing specified address hashes.
 * @param {Hash} start - Block hash to start at.
 * @param {Bloom} filter - Bloom filter containing tx and address hashes.
 * @param {Function} iter - Iterator.
 * @returns {Promise}
 */

Chain.prototype.scan = async function scan(start, filter, iter) {
  const unlock = await this.locker.lock();
  try {
    return await this.db.scan(start, filter, iter);
  } finally {
    unlock();
  }
};

/**
 * Add a block to the chain, perform all necessary verification.
 * @param {Block} block
 * @param {Number?} flags
 * @param {Number?} id
 * @returns {Promise}
 */

Chain.prototype.add = async function add(block, flags, id) {
  const hash = block.hash('hex');
  const unlock = await this.locker.lock(hash);
  try {
    return await this._add(block, flags, id);
  } finally {
    unlock();
  }
};

/**
 * Add a block to the chain without a lock.
 * @private
 * @param {Block} block
 * @param {Number?} flags
 * @param {Number?} id
 * @returns {Promise}
 */

Chain.prototype._add = async function _add(block, flags, id) {
  const hash = block.hash('hex');

  if (flags == null)
    flags = common.flags.DEFAULT_FLAGS;

  if (id == null)
    id = -1;

  // Special case for genesis block.
  if (hash === this.network.genesis.hash) {
    this.logger.debug('Saw genesis block: %s.', block.rhash());
    throw new VerifyError(block, 'duplicate', 'duplicate', 0);
  }

  // Do we already have this block in the queue?
  if (this.hasPending(hash)) {
    this.logger.debug('Already have pending block: %s.', block.rhash());
    throw new VerifyError(block, 'duplicate', 'duplicate', 0);
  }

  // If the block is already known to be
  // an orphan, ignore it.
  if (this.hasOrphan(hash)) {
    this.logger.debug('Already have orphan block: %s.', block.rhash());
    throw new VerifyError(block, 'duplicate', 'duplicate', 0);
  }

  // Do not revalidate known invalid blocks.
  if (this.hasInvalid(block)) {
    this.logger.debug('Invalid ancestors for block: %s.', block.rhash());
    throw new VerifyError(block, 'duplicate', 'duplicate', 100);
  }

  // Check the POW before doing anything.
  if (flags & common.flags.VERIFY_POW) {
    if (!block.verifyPOW())
      throw new VerifyError(block, 'invalid', 'high-hash', 50);
  }

  // Do we already have this block?
  if (await this.hasEntry(hash)) {
    this.logger.debug('Already have block: %s.', block.rhash());
    throw new VerifyError(block, 'duplicate', 'duplicate', 0);
  }

  // Find the previous block entry.
  const prev = await this.getEntry(block.prevBlock);

  // If previous block wasn't ever seen,
  // add it current to orphans and return.
  if (!prev) {
    this.storeOrphan(block, flags, id);
    return null;
  }

  // Connect the block.
  const entry = await this.connect(prev, block, flags);

  // Handle any orphans.
  if (this.hasNextOrphan(hash))
    await this.handleOrphans(entry);

  return entry;
};

/**
 * Connect block to chain.
 * @private
 * @param {ChainEntry} prev
 * @param {Block} block
 * @param {Number} flags
 * @returns {Promise}
 */

Chain.prototype.connect = async function connect(prev, block, flags) {
  const start = util.hrtime();

  // Sanity check.
  assert(block.prevBlock === prev.hash);

  // Explanation: we try to keep as much data
  // off the javascript heap as possible. Blocks
  // in the future may be 8mb or 20mb, who knows.
  // In fullnode-mode we store the blocks in
  // "compact" form (the headers plus the raw
  // Buffer object) until they're ready to be
  // fully validated here. They are deserialized,
  // validated, and connected. Hopefully the
  // deserialized blocks get cleaned up by the
  // GC quickly.
  if (block.isMemory()) {
    try {
      block = block.toBlock();
    } catch (e) {
      this.logger.error(e);
      throw new VerifyError(block,
        'malformed',
        'error parsing message',
        10,
        true);
    }
  }

  // Create a new chain entry.
  const entry = ChainEntry.fromBlock(block, prev);

  // The block is on a alternate chain if the
  // chainwork is less than or equal to
  // our tip's. Add the block but do _not_
  // connect the inputs.
  if (entry.chainwork.lte(this.tip.chainwork)) {
    // Save block to an alternate chain.
    await this.saveAlternate(entry, block, prev, flags);
  } else {
    // Attempt to add block to the chain index.
    await this.setBestChain(entry, block, prev, flags);
  }

  // Keep track of stats.
  this.logStatus(start, block, entry);

  // Check sync state.
  this.maybeSync();

  return entry;
};

/**
 * Handle orphans.
 * @private
 * @param {ChainEntry} entry
 * @returns {Promise}
 */

Chain.prototype.handleOrphans = async function handleOrphans(entry) {
  let orphan = this.resolveOrphan(entry.hash);

  while (orphan) {
    const {block, flags, id} = orphan;

    try {
      entry = await this.connect(entry, block, flags);
    } catch (err) {
      if (err.type === 'VerifyError') {
        this.logger.warning(
          'Could not resolve orphan block %s: %s.',
          block.rhash(), err.message);

        this.emit('bad orphan', err, id);

        break;
      }
      throw err;
    }

    this.logger.debug(
      'Orphan block was resolved: %s (%d).',
      block.rhash(), entry.height);

    this.emit('resolved', block, entry);

    orphan = this.resolveOrphan(entry.hash);
  }
};

/**
 * Test whether the chain has reached its slow height.
 * @private
 * @returns {Boolean}
 */

Chain.prototype.isSlow = function isSlow() {
  if (this.options.spv)
    return false;

  if (this.synced)
    return true;

  if (this.height === 1 || this.height % 20 === 0)
    return true;

  if (this.height >= this.network.block.slowHeight)
    return true;

  return false;
};

/**
 * Calculate the time difference from
 * start time and log block.
 * @private
 * @param {Array} start
 * @param {Block} block
 * @param {ChainEntry} entry
 */

Chain.prototype.logStatus = function logStatus(start, block, entry) {
  if (!this.isSlow())
    return;

  // Report memory for debugging.
  this.logger.memory();

  const elapsed = util.hrtime(start);

  this.logger.info(
    'Block %s (%d) added to chain (size=%d txs=%d time=%d).',
    entry.rhash(),
    entry.height,
    block.getSize(),
    block.txs.length,
    elapsed);

  if (this.db.coinCache.capacity > 0) {
    this.logger.debug('Coin Cache: size=%dmb, items=%d.',
      util.mb(this.db.coinCache.size), this.db.coinCache.items);
  }
};

/**
 * Verify a block hash and height against the checkpoints.
 * @private
 * @param {ChainEntry} prev
 * @param {Hash} hash
 * @returns {Boolean}
 */

Chain.prototype.verifyCheckpoint = function verifyCheckpoint(prev, hash) {
  if (!this.options.checkpoints)
    return true;

  const height = prev.height + 1;
  const checkpoint = this.network.checkpointMap[height];

  if (!checkpoint)
    return true;

  if (hash === checkpoint) {
    this.logger.debug('Hit checkpoint block %s (%d).',
      util.revHex(hash), height);
    this.emit('checkpoint', hash, height);
    return true;
  }

  // Someone is either mining on top of
  // an old block for no reason, or the
  // consensus protocol is broken and
  // there was a 20k+ block reorg.
  this.logger.warning(
    'Checkpoint mismatch at height %d: expected=%s received=%s',
    height,
    util.revHex(checkpoint),
    util.revHex(hash)
  );

  this.purgeOrphans();

  return false;
};

/**
 * Store an orphan.
 * @private
 * @param {Block} block
 * @param {Number?} flags
 * @param {Number?} id
 */

Chain.prototype.storeOrphan = function storeOrphan(block, flags, id) {
  //const hash = block.hash('hex');
  const height = block.getCoinbaseHeight();
  //let orphan = this.orphanPrev.get(block.prevBlock);
  const orphan = this.orphanPrev.get(block.prevBlock);

  // The orphan chain forked.
  if (orphan) {
    //assert(orphan.block.hash('hex') !== hash);
    assert(orphan.block.hash('hex') !== block.hash('hex'));
    assert(orphan.block.prevBlock === block.prevBlock);

    this.logger.warning(
      'Removing forked orphan block: %s (%d).',
      orphan.block.rhash(), height);

    this.removeOrphan(orphan);
  }

  this.limitOrphans();

  //orphan = new Orphan(block, flags, id);
  //this.addOrphan(orphan);
  this.addOrphan(new Orphan(block, flags, id));

  this.logger.debug(
    'Storing orphan block: %s (%d).',
    block.rhash(), height);

  this.emit('orphan', block);
};

/**
 * Add an orphan.
 * @private
 * @param {Orphan} orphan
 * @returns {Orphan}
 */

Chain.prototype.addOrphan = function addOrphan(orphan) {
  const block = orphan.block;
  const hash = block.hash('hex');

  assert(!this.orphanMap.has(hash));
  assert(!this.orphanPrev.has(block.prevBlock));
  assert(this.orphanMap.size >= 0);

  this.orphanMap.set(hash, orphan);
  this.orphanPrev.set(block.prevBlock, orphan);

  return orphan;
};

/**
 * Remove an orphan.
 * @private
 * @param {Orphan} orphan
 * @returns {Orphan}
 */

Chain.prototype.removeOrphan = function removeOrphan(orphan) {
  const block = orphan.block;
  const hash = block.hash('hex');

  assert(this.orphanMap.has(hash));
  assert(this.orphanPrev.has(block.prevBlock));
  assert(this.orphanMap.size > 0);

  this.orphanMap.delete(hash);
  this.orphanPrev.delete(block.prevBlock);

  return orphan;
};

/**
 * Test whether a hash would resolve the next orphan.
 * @private
 * @param {Hash} hash - Previous block hash.
 * @returns {Boolean}
 */

Chain.prototype.hasNextOrphan = function hasNextOrphan(hash) {
  return this.orphanPrev.has(hash);
};

/**
 * Resolve an orphan.
 * @private
 * @param {Hash} hash - Previous block hash.
 * @returns {Orphan}
 */

Chain.prototype.resolveOrphan = function resolveOrphan(hash) {
  const orphan = this.orphanPrev.get(hash);

  if (!orphan)
    return null;

  return this.removeOrphan(orphan);
};

/**
 * Purge any waiting orphans.
 */

Chain.prototype.purgeOrphans = function purgeOrphans() {
  const count = this.orphanMap.size;

  if (count === 0)
    return;

  this.orphanMap.clear();
  this.orphanPrev.clear();

  this.logger.debug('Purged %d orphans.', count);
};

/**
 * Prune orphans, only keep the orphan with the highest
 * coinbase height (likely to be the peer's tip).
 */

Chain.prototype.limitOrphans = function limitOrphans() {
  const now = util.now();

  let oldest = null;
  for (const orphan of this.orphanMap.values()) {
    if (now < orphan.time + 60 * 60) {
      if (!oldest || orphan.time < oldest.time)
        oldest = orphan;
      continue;
    }

    this.removeOrphan(orphan);
  }

  if (this.orphanMap.size < this.options.maxOrphans)
    return;

  if (!oldest)
    return;

  this.removeOrphan(oldest);
};

/**
 * Test whether an invalid block hash has been seen.
 * @private
 * @param {Block} block
 * @returns {Boolean}
 */

Chain.prototype.hasInvalid = function hasInvalid(block) {
  const hash = block.hash('hex');

  if (this.invalid.has(hash))
    return true;

  if (this.invalid.has(block.prevBlock)) {
    this.setInvalid(hash);
    return true;
  }

  return false;
};

/**
 * Mark a block as invalid.
 * @private
 * @param {Hash} hash
 */

Chain.prototype.setInvalid = function setInvalid(hash) {
  this.invalid.set(hash, true);
};

/**
 * Forget an invalid block hash.
 * @private
 * @param {Hash} hash
 */

Chain.prototype.removeInvalid = function removeInvalid(hash) {
  this.invalid.remove(hash);
};

/**
 * Test the chain to see if it contains
 * a block, or has recently seen a block.
 * @param {Hash} hash
 * @returns {Promise} - Returns Boolean.
 */

Chain.prototype.has = async function has(hash) {
  if (this.hasOrphan(hash))
    return true;

  if (this.locker.has(hash))
    return true;

  if (this.invalid.has(hash))
    return true;

  return await this.hasEntry(hash);
};

/**
 * Find the corresponding block entry by hash or height.
 * @param {Hash|Number} hash/height
 * @returns {Promise} - Returns {@link ChainEntry}.
 */

Chain.prototype.getEntry = function getEntry(hash) {
  return this.db.getEntry(hash);
};

/**
 * Retrieve a chain entry by height.
 * @param {Number} height
 * @returns {Promise} - Returns {@link ChainEntry}.
 */

Chain.prototype.getEntryByHeight = function getEntryByHeight(height) {
  return this.db.getEntryByHeight(height);
};

/**
 * Retrieve a chain entry by hash.
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link ChainEntry}.
 */

Chain.prototype.getEntryByHash = function getEntryByHash(hash) {
  return this.db.getEntryByHash(hash);
};

/**
 * Get the hash of a block by height. Note that this
 * will only return hashes in the main chain.
 * @param {Number} height
 * @returns {Promise} - Returns {@link Hash}.
 */

Chain.prototype.getHash = function getHash(height) {
  return this.db.getHash(height);
};

/**
 * Get the height of a block by hash.
 * @param {Hash} hash
 * @returns {Promise} - Returns Number.
 */

Chain.prototype.getHeight = function getHeight(hash) {
  return this.db.getHeight(hash);
};

/**
 * Test the chain to see if it contains a block.
 * @param {Hash} hash
 * @returns {Promise} - Returns Boolean.
 */

Chain.prototype.hasEntry = function hasEntry(hash) {
  return this.db.hasEntry(hash);
};

/**
 * Get the _next_ block hash (does not work by height).
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link Hash}.
 */

Chain.prototype.getNextHash = function getNextHash(hash) {
  return this.db.getNextHash(hash);
};

/**
 * Check whether coins are still unspent. Necessary for bip30.
 * @see https://bitcointalk.org/index.php?topic=67738.0
 * @param {TX} tx
 * @returns {Promise} - Returns Boolean.
 */

Chain.prototype.hasCoins = function hasCoins(tx) {
  return this.db.hasCoins(tx);
};

/**
 * Get all tip hashes.
 * @returns {Promise} - Returns {@link Hash}[].
 */

Chain.prototype.getTips = function getTips() {
  return this.db.getTips();
};

/**
 * Get a coin (unspents only).
 * @private
 * @param {Outpoint} prevout
 * @returns {Promise} - Returns {@link CoinEntry}.
 */

Chain.prototype.readCoin = function readCoin(prevout) {
  return this.db.readCoin(prevout);
};

/**
 * Get a coin (unspents only).
 * @param {Hash} hash
 * @param {Number} index
 * @returns {Promise} - Returns {@link Coin}.
 */

Chain.prototype.getCoin = function getCoin(hash, index) {
  return this.db.getCoin(hash, index);
};

/**
 * Retrieve a block from the database (not filled with coins).
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link Block}.
 */

Chain.prototype.getBlock = function getBlock(hash) {
  return this.db.getBlock(hash);
};

/**
 * Retrieve a block from the database (not filled with coins).
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link Block}.
 */

Chain.prototype.getRawBlock = function getRawBlock(block) {
  return this.db.getRawBlock(block);
};

/**
 * Get a historical block coin viewpoint.
 * @param {Block} hash
 * @returns {Promise} - Returns {@link CoinView}.
 */

Chain.prototype.getBlockView = function getBlockView(block) {
  return this.db.getBlockView(block);
};

/**
 * Get a transaction with metadata.
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link TXMeta}.
 */

Chain.prototype.getMeta = function getMeta(hash) {
  return this.db.getMeta(hash);
};

/**
 * Retrieve a transaction.
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link TX}.
 */

Chain.prototype.getTX = function getTX(hash) {
  return this.db.getTX(hash);
};

/**
 * @param {Hash} hash
 * @returns {Promise} - Returns Boolean.
 */

Chain.prototype.hasTX = function hasTX(hash) {
  return this.db.hasTX(hash);
};

/**
 * Get all coins pertinent to an address.
 * @param {Address[]} addrs
 * @returns {Promise} - Returns {@link Coin}[].
 */

Chain.prototype.getCoinsByAddress = function getCoinsByAddress(addrs, after) {
  return this.db.getCoinsByAddress(addrs, after);
};

/**
 * Get all transaction hashes to an address.
 * @param {Address[]} addrs
 * @returns {Promise} - Returns {@link Hash}[].
 */

Chain.prototype.getHashesByAddress = function getHashesByAddress(addrs) {
  return this.db.getHashesByAddress(addrs);
};

/**
 * Get all transactions pertinent to an address.
 * @param {Address[]} addrs
 * @returns {Promise} - Returns {@link TX}[].
 */

Chain.prototype.getTXByAddress = function getTXByAddress(addrs) {
  return this.db.getTXByAddress(addrs);
};

/**
 * Get all transactions pertinent to an address.
 * @param {Address[]} addrs
 * @returns {Promise} - Returns {@link TXMeta}[].
 */

Chain.prototype.getMetaByAddress = function getMetaByAddress(addrs) {
  return this.db.getMetaByAddress(addrs);
};

/**
 * Get an orphan block.
 * @param {Hash} hash
 * @returns {Block}
 */

Chain.prototype.getOrphan = function getOrphan(hash) {
  return this.orphanMap.get(hash) || null;
};

/**
 * Test the chain to see if it contains an orphan.
 * @param {Hash} hash
 * @returns {Promise} - Returns Boolean.
 */

Chain.prototype.hasOrphan = function hasOrphan(hash) {
  return this.orphanMap.has(hash);
};

/**
 * Test the chain to see if it contains a pending block in its queue.
 * @param {Hash} hash
 * @returns {Promise} - Returns Boolean.
 */

Chain.prototype.hasPending = function hasPending(hash) {
  return this.locker.hasPending(hash);
};

/**
 * Get coin viewpoint.
 * @param {TX} tx
 * @returns {Promise} - Returns {@link CoinView}.
 */

Chain.prototype.getCoinView = function getCoinView(tx) {
  return this.db.getCoinView(tx);
};

/**
 * Get coin viewpoint (spent).
 * @param {TX} tx
 * @returns {Promise} - Returns {@link CoinView}.
 */

Chain.prototype.getSpentView = async function getSpentView(tx) {
  const unlock = await this.locker.lock();
  try {
    return await this.db.getSpentView(tx);
  } finally {
    unlock();
  }
};

/**
 * Test the chain to see if it is synced.
 * @returns {Boolean}
 */

Chain.prototype.isFull = function isFull() {
  return this.synced;
};

/**
 * Potentially emit a `full` event.
 * @private
 */

Chain.prototype.maybeSync = function maybeSync() {
  if (this.synced)
    return;

  if (this.options.checkpoints) {
    if (this.height < this.network.lastCheckpoint)
      return;
  }

  if (this.tip.time < util.now() - this.network.block.maxTipAge)
    return;

  if (!this.hasChainwork())
    return;

  this.synced = true;
  this.emit('full');
};

/**
 * Test the chain to see if it has the
 * minimum required chainwork for the
 * network.
 * @returns {Boolean}
 */

Chain.prototype.hasChainwork = function hasChainwork() {
  return this.tip.chainwork.gte(this.network.pow.chainwork);
};

/**
 * Get the fill percentage.
 * @returns {Number} percent - Ranges from 0.0 to 1.0.
 */

Chain.prototype.getProgress = function getProgress() {
  const start = this.network.genesis.time;
  const current = this.tip.time - start;
  const end = util.now() - start - 40 * 60;
  return Math.min(1, current / end);
};

/**
 * Calculate chain locator (an array of hashes).
 * @param {Hash?} start - Height or hash to treat as the tip.
 * The current tip will be used if not present. Note that this can be a
 * non-existent hash, which is useful for headers-first locators.
 * @returns {Promise} - Returns {@link Hash}[].
 */

Chain.prototype.getLocator = async function getLocator(start) {
  const unlock = await this.locker.lock();
  try {
    return await this._getLocator(start);
  } finally {
    unlock();
  }
};

/**
 * Calculate chain locator without a lock.
 * @private
 * @param {Hash?} start
 * @returns {Promise}
 */

Chain.prototype._getLocator = async function _getLocator(start) {
  if (start == null)
    start = this.tip.hash;

  assert(typeof start === 'string');

  let entry = await this.getEntry(start);

  const hashes = [];

  if (!entry) {
    entry = this.tip;
    hashes.push(start);
  }

  let hash = entry.hash;
  let height = entry.height;
  let step = 1;

  //const main = await this.isMainChain(entry);
  let main = await this.isMainChain(entry);

  hashes.push(hash);

  while (height > 0) {
    height -= step;

    if (height < 0)
      height = 0;

    if (hashes.length > 10)
      step *= 2;

    if (main) {
      // If we're on the main chain, we can
      // do a fast lookup of the hash.
      hash = await this.getHash(height);
      assert(hash);
    } else {
      const ancestor = await this.getAncestor(entry, height);
      assert(ancestor);
      main = await this.isMainChain(ancestor);
      hash = ancestor.hash;
    }

    hashes.push(hash);
  }

  return hashes;
};

/**
 * Calculate the orphan root of the hash (if it is an orphan).
 * @param {Hash} hash
 * @returns {Hash}
 */

Chain.prototype.getOrphanRoot = function getOrphanRoot(hash) {
  let root = null;

  assert(hash);

  for (;;) {
    const orphan = this.orphanMap.get(hash);

    if (!orphan)
      break;

    root = hash;
    hash = orphan.block.prevBlock;
  }

  return root;
};

/**
 * Calculate the time difference (in seconds)
 * between two blocks by examining chainworks.
 * @param {ChainEntry} to
 * @param {ChainEntry} from
 * @returns {Number}
 */

Chain.prototype.getProofTime = function getProofTime(to, from) {
  const pow = this.network.pow;
  let sign, work;

  if (to.chainwork.cmp(from.chainwork) > 0) {
    work = to.chainwork.sub(from.chainwork);
    sign = 1;
  } else {
    work = from.chainwork.sub(to.chainwork);
    sign = -1;
  }

  work = work.imuln(pow.targetSpacing);
  work = work.div(this.tip.getProof());

  if (work.bitLength() > 53)
    return sign * Number.MAX_SAFE_INTEGER;

  return sign * work.toNumber();
};

/**
 * Calculate the next target based on the chain tip.
 * @returns {Promise} - returns Number
 * (target is in compact/mantissa form).
 */

Chain.prototype.getCurrentTarget = async function getCurrentTarget() {
  return await this.getTarget(this.network.now(), this.tip);
};

/**
 * Calculate the next target.
 * @param {Number} time - Next block timestamp.
 * @param {ChainEntry} prev - Previous entry.
 * @returns {Promise} - returns Number
 * (target is in compact/mantissa form).
 */

Chain.prototype.getTarget = async function getTarget(time, prev) {
  const pow = this.network.pow;

  // Genesis
  if (!prev) {
    assert(time === this.network.genesis.time);
    return pow.bits;
  }

  // Do not retarget
  if ((prev.height + 1) % pow.retargetInterval !== 0) {
    if (pow.targetReset) {
      // Special behavior for testnet:
      if (time > prev.time + pow.targetSpacing * 2)
        return pow.bits;

      while (prev.height !== 0
        && prev.height % pow.retargetInterval !== 0
        && prev.bits === pow.bits) {
        const cache = this.getPrevCache(prev);

        if (cache)
          prev = cache;
        else
          prev = await this.getPrevious(prev);

        assert(prev);
      }
    }
    return prev.bits;
  }

/*  // Back 2 weeks
  const back = pow.retargetInterval - 1; // ctl
  if (prev.height + 1 !== pow.retargetInterval) back = pow.retargetInterval; // ctl
  //const height = prev.height - (pow.retargetInterval - 1); // cfc
  const height = prev.height - back; // ctl
  assert(height >= 0);

  const first = await this.getAncestor(prev, height);
  assert(first);*/

  // Back 2 weeks
  const height = prev.height - (pow.retargetInterval - 1);
  assert(height >= 0);

  const first = await this.getAncestor(prev, height);
  assert(first);

  return this.retarget(prev, first);
};

/**
 * Retarget. This is called when the chain height
 * hits a retarget diff interval.
 * @param {ChainEntry} prev - Previous entry.
 * @param {ChainEntry} first - Chain entry from 2 weeks prior.
 * @returns {Number} target - Target in compact/mantissa form.
 */

Chain.prototype.retarget = function retarget(prev, first) {
  const pow = this.network.pow;
  const targetTimespan = pow.targetTimespan;

  if (pow.noRetargeting)
    return prev.bits;

  const target = consensus.fromCompact(prev.bits);

  let actualTimespan = prev.time - first.time;

  if (actualTimespan < targetTimespan / 4 | 0)
    actualTimespan = targetTimespan / 4 | 0;

  if (actualTimespan > targetTimespan * 4)
    actualTimespan = targetTimespan * 4;

  target.imuln(actualTimespan);
  target.idivn(targetTimespan);

  if (target.cmp(pow.limit) > 0)
    return pow.bits;

  return consensus.toCompact(target);
};

/**
 * Find a locator. Analagous to bitcoind's `FindForkInGlobalIndex()`.
 * @param {Hash[]} locator - Hashes.
 * @returns {Promise} - Returns {@link Hash} (the
 * hash of the latest known block).
 */

Chain.prototype.findLocator = async function findLocator(locator) {
  for (const hash of locator) {
    if (await this.isMainHash(hash))
      return hash;
  }

  return this.network.genesis.hash;
};

/**
 * Check whether a versionbits deployment is active (BIP9: versionbits).
 * @example
 * await chain.isActive(tip, deployments.segwit);
 * @see https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki
 * @param {ChainEntry} prev - Previous chain entry.
 * @param {String} id - Deployment id.
 * @returns {Promise} - Returns Number.
 */

Chain.prototype.isActive = async function isActive(prev, deployment) {
  const state = await this.getState(prev, deployment);
  return state === thresholdStates.ACTIVE;
};

/**
 * Get chain entry state for a deployment (BIP9: versionbits).
 * @example
 * await chain.getState(tip, deployments.segwit);
 * @see https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki
 * @param {ChainEntry} prev - Previous chain entry.
 * @param {String} id - Deployment id.
 * @returns {Promise} - Returns Number.
 */

Chain.prototype.getState = async function getState(prev, deployment) {
  const bit = deployment.bit;

  let window = this.network.minerWindow;
  let threshold = this.network.activationThreshold;

  if (deployment.threshold !== -1)
    threshold = deployment.threshold;

  if (deployment.window !== -1)
    window = deployment.window;

  if (((prev.height + 1) % window) !== 0) {
    const height = prev.height - ((prev.height + 1) % window);

    prev = await this.getAncestor(prev, height);

    if (!prev)
      return thresholdStates.DEFINED;

    assert(prev.height === height);
    assert(((prev.height + 1) % window) === 0);
  }

  let entry = prev;
  let state = thresholdStates.DEFINED;

  const compute = [];

  while (entry) {
    const cached = this.db.stateCache.get(bit, entry);

    if (cached !== -1) {
      state = cached;
      break;
    }

    const time = await this.getMedianTime(entry);

    if (time < deployment.startTime) {
      state = thresholdStates.DEFINED;
      this.db.stateCache.set(bit, entry, state);
      break;
    }

    compute.push(entry);

    const height = entry.height - window;

    entry = await this.getAncestor(entry, height);
  }

  while (compute.length) {
    const entry = compute.pop();

    switch (state) {
      case thresholdStates.DEFINED: {
        const time = await this.getMedianTime(entry);

        if (time >= deployment.timeout) {
          state = thresholdStates.FAILED;
          break;
        }

        if (time >= deployment.startTime) {
          state = thresholdStates.STARTED;
          break;
        }

        break;
      }
      case thresholdStates.STARTED: {
        const time = await this.getMedianTime(entry);

        if (time >= deployment.timeout) {
          state = thresholdStates.FAILED;
          break;
        }

        let block = entry;
        let count = 0;

        for (let i = 0; i < window; i++) {
          if (block.hasBit(bit))
            count++;

          if (count >= threshold) {
            state = thresholdStates.LOCKED_IN;
            break;
          }

          block = await this.getPrevious(block);
          assert(block);
        }

        break;
      }
      case thresholdStates.LOCKED_IN: {
        state = thresholdStates.ACTIVE;
        break;
      }
      case thresholdStates.FAILED:
      case thresholdStates.ACTIVE: {
        break;
      }
      default: {
        assert(false, 'Bad state.');
        break;
      }
    }

    this.db.stateCache.set(bit, entry, state);
  }

  return state;
};

/**
 * Compute the version for a new block (BIP9: versionbits).
 * @see https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki
 * @param {ChainEntry} prev - Previous chain entry (usually the tip).
 * @returns {Promise} - Returns Number.
 */

Chain.prototype.computeBlockVersion = async function computeBlockVersion(prev) {
  let version = 0;

  for (const deployment of this.network.deploys) {
    const state = await this.getState(prev, deployment);

    if (state === thresholdStates.LOCKED_IN
        || state === thresholdStates.STARTED) {
      version |= 1 << deployment.bit;
    }
  }

  version |= consensus.VERSION_TOP_BITS;
  version >>>= 0;

  return version;
};

/**
 * Get the current deployment state of the chain. Called on load.
 * @private
 * @returns {Promise} - Returns {@link DeploymentState}.
 */

Chain.prototype.getDeploymentState = async function getDeploymentState() {
  const prev = await this.getPrevious(this.tip);

  if (!prev) {
    assert(this.tip.isGenesis());
    return this.state;
  }

  if (this.options.spv)
    return this.state;

  return await this.getDeployments(this.tip.time, prev);
};

/**
 * Check transaction finality, taking into account MEDIAN_TIME_PAST
 * if it is present in the lock flags.
 * @param {ChainEntry} prev - Previous chain entry.
 * @param {TX} tx
 * @param {LockFlags} flags
 * @returns {Promise} - Returns Boolean.
 */

Chain.prototype.verifyFinal = async function verifyFinal(prev, tx, flags) {
  const height = prev.height + 1;

  // We can skip MTP if the locktime is height.
  if (tx.locktime < consensus.LOCKTIME_THRESHOLD)
    return tx.isFinal(height, -1);

  if (flags & common.lockFlags.MEDIAN_TIME_PAST) {
    const time = await this.getMedianTime(prev);
    return tx.isFinal(height, time);
  }

  return tx.isFinal(height, this.network.now());
};

/**
 * Get the necessary minimum time and height sequence locks for a transaction.
 * @param {ChainEntry} prev
 * @param {TX} tx
 * @param {CoinView} view
 * @param {LockFlags} flags
 * @returns {Promise}
 */

Chain.prototype.getLocks = async function getLocks(prev, tx, view, flags) {
  const GRANULARITY = consensus.SEQUENCE_GRANULARITY;
  const DISABLE_FLAG = consensus.SEQUENCE_DISABLE_FLAG;
  const TYPE_FLAG = consensus.SEQUENCE_TYPE_FLAG;
  const MASK = consensus.SEQUENCE_MASK;

  if (!(flags & common.lockFlags.VERIFY_SEQUENCE))
    return [-1, -1];

  if (tx.isCoinbase() || tx.version < 2)
    return [-1, -1];

  let minHeight = -1;
  let minTime = -1;

  for (const {prevout, sequence} of tx.inputs) {
    if (sequence & DISABLE_FLAG)
      continue;

    let height = view.getHeight(prevout);

    if (height === -1)
      height = this.height + 1;

    if (!(sequence & TYPE_FLAG)) {
      height += (sequence & MASK) - 1;
      minHeight = Math.max(minHeight, height);
      continue;
    }

    height = Math.max(height - 1, 0);

    const entry = await this.getAncestor(prev, height);
    assert(entry, 'Database is corrupt.');

    let time = await this.getMedianTime(entry);
    time += ((sequence & MASK) << GRANULARITY) - 1;
    minTime = Math.max(minTime, time);
  }

  return [minHeight, minTime];
};

/**
 * Verify sequence locks.
 * @param {ChainEntry} prev
 * @param {TX} tx
 * @param {CoinView} view
 * @param {LockFlags} flags
 * @returns {Promise} - Returns Boolean.
 */

Chain.prototype.verifyLocks = async function verifyLocks(prev, tx, view, flags) {
  const [height, time] = await this.getLocks(prev, tx, view, flags);

  // Also catches case where
  // height is `-1`. Fall through.
  if (height >= prev.height + 1)
    return false;

  if (time === -1)
    return true;

  const mtp = await this.getMedianTime(prev);

  if (time >= mtp)
    return false;

  return true;
};

/**
 * ChainOptions
 * @alias module:blockchain.ChainOptions
 * @constructor
 * @param {Object} options
 */

function ChainOptions(options) {
  if (!(this instanceof ChainOptions))
    return new ChainOptions(options);

  this.network = Network.primary;
  this.logger = Logger.global;
  this.workers = null;

  this.prefix = null;
  this.location = null;
  this.db = 'memory';
  this.maxFiles = 64;
  this.cacheSize = 32 << 20;
  this.compression = true;
  this.bufferKeys = ChainDB.layout.binary;

  this.spv = false;
  this.bip91 = false;
  this.bip148 = false;
  this.prune = false;
  this.indexTX = true;
  this.indexAddress = true;
  this.forceFlags = false;

  this.coinCache = 0;
  this.entryCache = 5000;
  this.maxOrphans = 20;
  this.checkpoints = true;

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from object.
 * @private
 * @param {Object} options
 * @returns {ChainOptions}
 */

ChainOptions.prototype.fromOptions = function fromOptions(options) {
  if (options.network != null)
    this.network = Network.get(options.network);

  if (options.logger != null) {
    assert(typeof options.logger === 'object');
    this.logger = options.logger;
  }

  if (options.workers != null) {
    assert(typeof options.workers === 'object');
    this.workers = options.workers;
  }

  if (options.spv != null) {
    assert(typeof options.spv === 'boolean');
    this.spv = options.spv;
  }

  if (options.prefix != null) {
    assert(typeof options.prefix === 'string');
    this.prefix = options.prefix;
    this.location = this.spv
      ? path.join(this.prefix, 'spvchain')
      : path.join(this.prefix, 'chain');
  }

  if (options.location != null) {
    assert(typeof options.location === 'string');
    this.location = options.location;
  }

  if (options.db != null) {
    assert(typeof options.db === 'string');
    this.db = options.db;
  }

  if (options.maxFiles != null) {
    assert(util.isU32(options.maxFiles));
    this.maxFiles = options.maxFiles;
  }

  if (options.cacheSize != null) {
    assert(util.isU64(options.cacheSize));
    this.cacheSize = options.cacheSize;
  }

  if (options.compression != null) {
    assert(typeof options.compression === 'boolean');
    this.compression = options.compression;
  }

  if (options.prune != null) {
    assert(typeof options.prune === 'boolean');
    this.prune = options.prune;
  }

  if (options.indexTX != null) {
    assert(typeof options.indexTX === 'boolean');
    this.indexTX = options.indexTX;
  }

  if (options.indexAddress != null) {
    assert(typeof options.indexAddress === 'boolean');
    this.indexAddress = options.indexAddress;
  }

  if (options.forceFlags != null) {
    assert(typeof options.forceFlags === 'boolean');
    this.forceFlags = options.forceFlags;
  }

  if (options.bip91 != null) {
    assert(typeof options.bip91 === 'boolean');
    this.bip91 = options.bip91;
  }

  if (options.bip148 != null) {
    assert(typeof options.bip148 === 'boolean');
    this.bip148 = options.bip148;
  }

  if (options.coinCache != null) {
    assert(util.isU64(options.coinCache));
    this.coinCache = options.coinCache;
  }

  if (options.entryCache != null) {
    assert(util.isU32(options.entryCache));
    this.entryCache = options.entryCache;
  }

  if (options.maxOrphans != null) {
    assert(util.isU32(options.maxOrphans));
    this.maxOrphans = options.maxOrphans;
  }

  if (options.checkpoints != null) {
    assert(typeof options.checkpoints === 'boolean');
    this.checkpoints = options.checkpoints;
  }

  return this;
};

/**
 * Instantiate chain options from object.
 * @param {Object} options
 * @returns {ChainOptions}
 */

ChainOptions.fromOptions = function fromOptions(options) {
  return new ChainOptions().fromOptions(options);
};

/**
 * Represents the deployment state of the chain.
 * @alias module:blockchain.DeploymentState
 * @constructor
 * @property {VerifyFlags} flags
 * @property {LockFlags} lockFlags
 * @property {Boolean} bip34
 */

function DeploymentState() {
  if (!(this instanceof DeploymentState))
    return new DeploymentState();

  this.flags = Script.flags.MANDATORY_VERIFY_FLAGS;
  this.flags &= ~Script.flags.VERIFY_P2SH;
  this.lockFlags = common.lockFlags.MANDATORY_LOCKTIME_FLAGS;
  this.bip34 = false;
  this.bip91 = false;
  this.bip148 = false;
}

/**
 * Test whether p2sh is active.
 * @returns {Boolean}
 */

DeploymentState.prototype.hasP2SH = function hasP2SH() {
  return (this.flags & Script.flags.VERIFY_P2SH) !== 0;
};

/**
 * Test whether bip34 (coinbase height) is active.
 * @returns {Boolean}
 */

DeploymentState.prototype.hasBIP34 = function hasBIP34() {
  return this.bip34;
};

/**
 * Test whether bip66 (VERIFY_DERSIG) is active.
 * @returns {Boolean}
 */

DeploymentState.prototype.hasBIP66 = function hasBIP66() {
  return (this.flags & Script.flags.VERIFY_DERSIG) !== 0;
};

/**
 * Test whether cltv is active.
 * @returns {Boolean}
 */

DeploymentState.prototype.hasCLTV = function hasCLTV() {
  return (this.flags & Script.flags.VERIFY_CHECKLOCKTIMEVERIFY) !== 0;
};

/**
 * Test whether median time past locktime is active.
 * @returns {Boolean}
 */

DeploymentState.prototype.hasMTP = function hasMTP() {
  return (this.lockFlags & common.lockFlags.MEDIAN_TIME_PAST) !== 0;
};

/**
 * Test whether csv is active.
 * @returns {Boolean}
 */

DeploymentState.prototype.hasCSV = function hasCSV() {
  return (this.flags & Script.flags.VERIFY_CHECKSEQUENCEVERIFY) !== 0;
};

/**
 * Test whether segwit is active.
 * @returns {Boolean}
 */

DeploymentState.prototype.hasWitness = function hasWitness() {
  // return (this.flags & Script.flags.VERIFY_WITNESS) !== 0;
  // force segwit activation
  return true;
};

/**
 * Test whether bip91 is active.
 * @returns {Boolean}
 */

DeploymentState.prototype.hasBIP91 = function hasBIP91() {
  return this.bip91;
};

/**
 * Test whether bip148 is active.
 * @returns {Boolean}
 */

DeploymentState.prototype.hasBIP148 = function hasBIP148() {
  return this.bip148;
};

/**
 * Orphan
 * @constructor
 * @ignore
 */

function Orphan(block, flags, id) {
  this.block = block;
  this.flags = flags;
  this.id = id;
  this.time = util.now();
}

/*
 * Helpers
 */

function cmp(a, b) {
  return a - b;
}

function filter (arr, cmp) {
   return arr.filter(n => { return !n.equals(cmp) });
}

/*
 * Expose
 */

module.exports = Chain;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * errors.js - error objects for wmcc_core.
 */



/**
 * @module protocol/errors
 */

const assert = __webpack_require__(0);

/**
 * An error thrown during verification. Can be either
 * a mempool transaction validation error or a blockchain
 * block verification error. Ultimately used to send
 * `reject` packets to peers.
 * @constructor
 * @extends Error
 * @param {Block|TX} msg
 * @param {String} code - Reject packet code.
 * @param {String} reason - Reject packet reason.
 * @param {Number} score - Ban score increase
 * (can be -1 for no reject packet).
 * @param {Boolean} malleated
 * @property {String} code
 * @property {Buffer} hash
 * @property {Number} height (will be the coinbase height if not present).
 * @property {Number} score
 * @property {String} message
 * @property {Boolean} malleated
 */

function VerifyError(msg, code, reason, score, malleated) {
  Error.call(this);

  assert(typeof code === 'string');
  assert(typeof reason === 'string');
  assert(score >= 0);

  this.type = 'VerifyError';
  this.message = '';
  this.code = code;
  this.reason = reason;
  this.score = score;
  this.hash = msg.hash('hex');
  this.malleated = malleated || false;

  this.message = `Verification failure: ${reason}`
    + ` (code=${code} score=${score} hash=${msg.rhash()})`;

  if (Error.captureStackTrace)
    Error.captureStackTrace(this, VerifyError);
}

Object.setPrototypeOf(VerifyError.prototype, Error.prototype);

/*
 * Expose
 */

exports.VerifyError = VerifyError;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * aes.js - aes for wmcc_core.
 */



/**
 * @module crypto.aes
 */

const crypto = __webpack_require__(24);
const native = __webpack_require__(18).binding;

/**
 * Encrypt data with aes 256 cbc.
 * @param {Buffer} data
 * @param {Buffer} key
 * @param {Buffer} iv
 * @returns {Buffer}
 */

exports.encipher = function encipher(data, key, iv) {
  const ctx = crypto.createCipheriv('aes-256-cbc', key, iv);
  return Buffer.concat([ctx.update(data), ctx.final()]);
};

/**
 * Decrypt data with aes 256 cbc.
 * @param {Buffer} data
 * @param {Buffer} key
 * @param {Buffer} iv
 * @returns {Buffer}
 */

exports.decipher = function decipher(data, key, iv) {
  const ctx = crypto.createDecipheriv('aes-256-cbc', key, iv);
  try {
    return Buffer.concat([ctx.update(data), ctx.final()]);
  } catch (e) {
    throw new Error('Bad key for decryption.');
  }
};

if (native) {
  exports.encipher = native.encipher;
  exports.decipher = native.decipher;
}


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2015-2016, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * hd.js - hd keys for wmcc_core.
 */



const assert = __webpack_require__(0);
const common = __webpack_require__(108);
const Mnemonic = __webpack_require__(210);
const HDPrivateKey = __webpack_require__(276);
const HDPublicKey = __webpack_require__(213);
const wordlist = __webpack_require__(211);

/**
 * @exports hd
 */

const HD = exports;

/**
 * Instantiate an HD key (public or private) from an base58 string.
 * @param {Base58String} xkey
 * @param {Network?} network
 * @returns {HDPrivateKey|HDPublicKey}
 */

HD.fromBase58 = function fromBase58(xkey, network) {
  if (HDPrivateKey.isBase58(xkey))
    return HDPrivateKey.fromBase58(xkey, network);
  return HDPublicKey.fromBase58(xkey, network);
};

/**
 * Generate an {@link HDPrivateKey}.
 * @param {Object} options
 * @param {Buffer?} options.privateKey
 * @param {Buffer?} options.entropy
 * @param {String?} network
 * @returns {HDPrivateKey}
 */

HD.generate = function generate(network) {
  return HDPrivateKey.generate(network);
};

/**
 * Generate an {@link HDPrivateKey} from a seed.
 * @param {Object|Mnemonic|Buffer} options - seed,
 * mnemonic, mnemonic options.
 * @param {String?} network
 * @returns {HDPrivateKey}
 */

HD.fromSeed = function fromSeed(options, network) {
  return HDPrivateKey.fromSeed(options, network);
};

/**
 * Instantiate an hd private key from a mnemonic.
 * @param {Mnemonic|Object} mnemonic
 * @param {String?} network
 * @returns {HDPrivateKey}
 */

HD.fromMnemonic = function fromMnemonic(options, network) {
  return HDPrivateKey.fromMnemonic(options, network);
};

/**
 * Instantiate an HD key from a jsonified key object.
 * @param {Object} json - The jsonified transaction object.
 * @param {Network?} network
 * @returns {HDPrivateKey|HDPublicKey}
 */

HD.fromJSON = function fromJSON(json, network) {
  if (json.xprivkey)
    return HDPrivateKey.fromJSON(json, network);
  return HDPublicKey.fromJSON(json, network);
};

/**
 * Instantiate an HD key from serialized data.
 * @param {Buffer} data
 * @param {Network?} network
 * @returns {HDPrivateKey|HDPublicKey}
 */

HD.fromRaw = function fromRaw(data, network) {
  if (HDPrivateKey.isRaw(data, network))
    return HDPrivateKey.fromRaw(data, network);
  return HDPublicKey.fromRaw(data, network);
};

/**
 * Generate an hdkey from any number of options.
 * @param {Object|Mnemonic|Buffer} options - mnemonic, mnemonic
 * options, seed, or base58 key.
 * @param {(Network|NetworkType)?} network
 * @returns {HDPrivateKey|HDPublicKey}
 */

HD.from = function from(options, network) {
  assert(options, 'Options required.');

  if (HD.isHD(options))
    return options;

  if (HD.isBase58(options, network))
    return HD.fromBase58(options, network);

  if (HD.isRaw(options, network))
    return HD.fromRaw(options, network);

  if (options && typeof options === 'object')
    return HD.fromMnemonic(options, network);

  throw new Error('Cannot create HD key from bad options.');
};

/**
 * Test whether an object is in the form of a base58 hd key.
 * @param {String} data
 * @param {Network?} network
 * @returns {Boolean}
 */

HD.isBase58 = function isBase58(data, network) {
  return HDPrivateKey.isBase58(data, network)
    || HDPublicKey.isBase58(data, network);
};

/**
 * Test whether an object is in the form of a serialized hd key.
 * @param {Buffer} data
 * @param {Network?} network
 * @returns {NetworkType}
 */

HD.isRaw = function isRaw(data, network) {
  return HDPrivateKey.isRaw(data, network)
    || HDPublicKey.isRaw(data, network);
};

/**
 * Test whether an object is an HD key.
 * @param {Object} obj
 * @returns {Boolean}
 */

HD.isHD = function isHD(obj) {
  return HDPrivateKey.isHDPrivateKey(obj)
    || HDPublicKey.isHDPublicKey(obj);
};

/**
 * Test whether an object is an HD private key.
 * @param {Object} obj
 * @returns {Boolean}
 */

HD.isPrivate = function isPrivate(obj) {
  return HDPrivateKey.isHDPrivateKey(obj);
};

/**
 * Test whether an object is an HD public key.
 * @param {Object} obj
 * @returns {Boolean}
 */

HD.isPublic = function isPublic(obj) {
  return HDPublicKey.isHDPublicKey(obj);
};

/*
 * Expose
 */

HD.common = common;
HD.HD = HD;
HD.Mnemonic = Mnemonic;
HD.PrivateKey = HDPrivateKey;
HD.PublicKey = HDPublicKey;
HD.wordlist = wordlist;


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2015-2016, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * common.js - common functions for hd.
 */



const assert = __webpack_require__(0);
const LRU = __webpack_require__(56);
const common = exports;

/**
 * Index at which hardening begins.
 * @const {Number}
 * @default
 */

common.HARDENED = 0x80000000;

/**
 * Min entropy bits.
 * @const {Number}
 * @default
 */

common.MIN_ENTROPY = 128;

/**
 * Max entropy bits.
 * @const {Number}
 * @default
 */

common.MAX_ENTROPY = 512;

/**
 * LRU cache to avoid deriving keys twice.
 * @type {LRU}
 */

common.cache = new LRU(500);

/**
 * Parse a derivation path and return an array of indexes.
 * @see https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
 * @param {String} path
 * @param {Boolean} hard
 * @returns {Number[]}
 */

common.parsePath = function parsePath(path, hard) {
  assert(typeof path === 'string');
  assert(typeof hard === 'boolean');
  assert(path.length >= 1);
  assert(path.length <= 3062);

  const parts = path.split('/');
  const root = parts[0];

  if (root !== 'm'
      && root !== 'M'
      && root !== 'm\''
      && root !== 'M\'') {
    throw new Error('Invalid path root.');
  }

  const result = [];

  for (let i = 1; i < parts.length; i++) {
    let part = parts[i];

    const hardened = part[part.length - 1] === '\'';

    if (hardened)
      part = part.slice(0, -1);

    if (part.length > 10)
      throw new Error('Path index too large.');

    if (!/^\d+$/.test(part))
      throw new Error('Path index is non-numeric.');

    let index = parseInt(part, 10);

    if ((index >>> 0) !== index)
      throw new Error('Path index out of range.');

    if (hardened) {
      index |= common.HARDENED;
      index >>>= 0;
    }

    if (!hard && (index & common.HARDENED))
      throw new Error('Path index cannot be hardened.');

    result.push(index);
  }

  return result;
};

/**
 * Test whether the key is a master key.
 * @param {HDPrivateKey|HDPublicKey} key
 * @returns {Boolean}
 */

common.isMaster = function isMaster(key) {
  return key.depth === 0
    && key.childIndex === 0
    && key.parentFingerPrint === 0;
};

/**
 * Test whether the key is (most likely) a BIP44 account key.
 * @param {HDPrivateKey|HDPublicKey} key
 * @param {Number?} account
 * @returns {Boolean}
 */

common.isAccount = function isAccount(key, account) {
  if (account != null) {
    const index = (common.HARDENED | account) >>> 0;
    if (key.childIndex !== index)
      return false;
  }
  return key.depth === 3 && (key.childIndex & common.HARDENED) !== 0;
};


/***/ }),
/* 109 */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer') {
  module.exports = __webpack_require__(280);
} else {
  module.exports = __webpack_require__(282);
}


/***/ }),
/* 111 */
/***/ (function(module, exports) {

/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};


/***/ }),
/* 112 */
/***/ (function(module, exports) {


module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer') {
  module.exports = __webpack_require__(295);
} else {
  module.exports = __webpack_require__(297);
}


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Limiter = __webpack_require__(302);
const zlib = __webpack_require__(303);

const bufferUtil = __webpack_require__(177);
const { kStatusCode, NOOP } = __webpack_require__(93);

const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const EMPTY_BLOCK = Buffer.from([0x00]);

const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} options Configuration options
   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling
   *     of server context takeover
   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge
   *     disabling of client context takeover
   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the
   *     use of a custom server window size
   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support
   *     for, or request, a custom client window size
   * @param {Object} options.zlibDeflateOptions Options to pass to zlib on deflate
   * @param {Object} options.zlibInflateOptions Options to pass to zlib on inflate
   * @param {Number} options.threshold Size (in bytes) below which messages
   *     should not be compressed
   * @param {Number} options.concurrencyLimit The number of concurrent calls to
   *     zlib
   * @param {Boolean} isServer Create the instance in either server or client
   *     mode
   * @param {Number} maxPayload The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter({ concurrency });
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      this._deflate.close();
      this._deflate = null;
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        var value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited by async-limiter.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.push((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited by async-limiter.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.push((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw(
        Object.assign({}, this._options.zlibInflateOptions, { windowBits })
      );
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    if (!data || data.length === 0) {
      process.nextTick(callback, null, EMPTY_BLOCK);
      return;
    }

    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw(
        Object.assign({}, this._options.zlibDeflateOptions, { windowBits })
      );

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      //
      // An `'error'` event is emitted, only on Node.js < 10.0.0, if the
      // `zlib.DeflateRaw` instance is closed while data is being processed.
      // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong
      // time due to an abnormal WebSocket closure.
      //
      this._deflate.on('error', NOOP);
      this._deflate.on('data', deflateOnData);
    }

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // This `if` statement is only needed for Node.js < 10.0.0 because as of
        // commit https://github.com/nodejs/node/commit/5e3f5164, the flush
        // callback is no longer called if the deflate stream is closed while
        // data is being processed.
        //
        return;
      }

      var data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) data = data.slice(0, data.length - 4);

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.close();
        this._deflate = null;
      } else {
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * rpc.js - wmccd-compatible json rpc for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const co = __webpack_require__(17);
const digest = __webpack_require__(5);
const ccmp = __webpack_require__(52);
const common = __webpack_require__(89);
const secp256k1 = __webpack_require__(12);
const Amount = __webpack_require__(20);
const NetAddress = __webpack_require__(75);
const Script = __webpack_require__(8);
const Address = __webpack_require__(11);
const Block = __webpack_require__(51);
const Headers = __webpack_require__(37);
const Input = __webpack_require__(42);
const KeyRing = __webpack_require__(47);
const MerkleBlock = __webpack_require__(69);
const MTX = __webpack_require__(48);
const Network = __webpack_require__(6);
const Outpoint = __webpack_require__(21);
const Output = __webpack_require__(13);
const TX = __webpack_require__(16);
const IP = __webpack_require__(46);
const encoding = __webpack_require__(3);
const consensus = __webpack_require__(7);
const Validator = __webpack_require__(71);
const RPCBase = __webpack_require__(178);
const pkg = __webpack_require__(94);
const RPCError = RPCBase.RPCError;
const errs = RPCBase.errors;
const MAGIC_STRING = RPCBase.MAGIC_STRING;

/**
 * WMCC Core RPC
 * @alias module:http.RPC
 * @constructor
 * @param {Node} node
 */

function RPC(node) {
  if (!(this instanceof RPC))
    return new RPC(node);

  RPCBase.call(this);

  assert(node, 'RPC requires a Node.');

  this.node = node;
  this.network = node.network;
  this.workers = node.workers;
  this.chain = node.chain;
  this.mempool = node.mempool;
  this.pool = node.pool;
  this.fees = node.fees;
  this.miner = node.miner;
  this.logger = node.logger.context('rpc');

  this.mining = false;
  this.procLimit = 0;
  this.attempt = null;
  this.lastActivity = 0;
  this.boundChain = false;
  this.nonce1 = 0;
  this.nonce2 = 0;
  this.merkleMap = new Map();
  this.pollers = [];

  this.init();
}

Object.setPrototypeOf(RPC.prototype, RPCBase.prototype);

RPC.prototype.init = function init() {
  this.add('stop', this.stop);
  this.add('help', this.help);

  this.add('getblockchaininfo', this.getBlockchainInfo);
  this.add('getbestblockhash', this.getBestBlockHash);
  this.add('getblockcount', this.getBlockCount);
  this.add('getblock', this.getBlock);
  this.add('getblockbyheight', this.getBlockByHeight);
  this.add('getblockhash', this.getBlockHash);
  this.add('getblockheader', this.getBlockHeader);
  this.add('getchaintips', this.getChainTips);
  this.add('getdifficulty', this.getDifficulty);
  this.add('getmempoolancestors', this.getMempoolAncestors);
  this.add('getmempooldescendants', this.getMempoolDescendants);
  this.add('getmempoolentry', this.getMempoolEntry);
  this.add('getmempoolinfo', this.getMempoolInfo);
  this.add('getrawmempool', this.getRawMempool);
  this.add('gettxout', this.getTXOut);
  this.add('gettxoutsetinfo', this.getTXOutSetInfo);
  this.add('pruneblockchain', this.pruneBlockchain);
  this.add('verifychain', this.verifyChain);

  this.add('invalidateblock', this.invalidateBlock);
  this.add('reconsiderblock', this.reconsiderBlock);

  this.add('getnetworkhashps', this.getNetworkHashPS);
  this.add('getmininginfo', this.getMiningInfo);
  this.add('prioritisetransaction', this.prioritiseTransaction);
  this.add('getwork', this.getWork);
  this.add('getworklp', this.getWorkLongpoll);
  this.add('getblocktemplate', this.getBlockTemplate);
  this.add('submitblock', this.submitBlock);
  this.add('verifyblock', this.verifyBlock);

  this.add('setgenerate', this.setGenerate);
  this.add('getgenerate', this.getGenerate);
  this.add('generate', this.generate);
  this.add('generatetoaddress', this.generateToAddress);

  this.add('estimatefee', this.estimateFee);
  this.add('estimatepriority', this.estimatePriority);
  this.add('estimatesmartfee', this.estimateSmartFee);
  this.add('estimatesmartpriority', this.estimateSmartPriority);

  this.add('getinfo', this.getInfo);
  this.add('validateaddress', this.validateAddress);
  this.add('createmultisig', this.createMultisig);
  this.add('createwitnessaddress', this.createWitnessAddress);
  this.add('verifymessage', this.verifyMessage);
  this.add('signmessagewithprivkey', this.signMessageWithPrivkey);

  this.add('setmocktime', this.setMockTime);

  this.add('getconnectioncount', this.getConnectionCount);
  this.add('ping', this.ping);
  this.add('getpeerinfo', this.getPeerInfo);
  this.add('addnode', this.addNode);
  this.add('disconnectnode', this.disconnectNode);
  this.add('getaddednodeinfo', this.getAddedNodeInfo);
  this.add('getnettotals', this.getNetTotals);
  this.add('getnetworkinfo', this.getNetworkInfo);
  this.add('setban', this.setBan);
  this.add('listbanned', this.listBanned);
  this.add('clearbanned', this.clearBanned);

  this.add('getrawtransaction', this.getRawTransaction);
  this.add('createrawtransaction', this.createRawTransaction);
  this.add('decoderawtransaction', this.decodeRawTransaction);
  this.add('decodescript', this.decodeScript);
  this.add('sendrawtransaction', this.sendRawTransaction);
  this.add('signrawtransaction', this.signRawTransaction);

  this.add('gettxoutproof', this.getTXOutProof);
  this.add('verifytxoutproof', this.verifyTXOutProof);

  this.add('getmemoryinfo', this.getMemoryInfo);
  this.add('setloglevel', this.setLogLevel);
};

/*
 * Overall control/query calls
 */

RPC.prototype.getInfo = async function getInfo(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'getinfo');

  return {
    version: pkg.version,
    protocolversion: this.pool.options.version,
    walletversion: 0,
    balance: 0,
    blocks: this.chain.height,
    timeoffset: this.network.time.offset,
    connections: this.pool.peers.size(),
    proxy: '',
    difficulty: toDifficulty(this.chain.tip.bits),
    testnet: this.network !== Network.mainnet,
    keypoololdest: 0,
    keypoolsize: 0,
    unlocked_until: 0,
    paytxfee: Amount.wmcc(this.network.feeRate, true),
    relayfee: Amount.wmcc(this.network.minRelay, true),
    errors: ''
  };
};

RPC.prototype.help = async function help(args, _help) {
  if (args.length === 0)
    return 'Select a command.';

  const json = {
    method: args[0],
    params: []
  };

  return await this.execute(json, true);
};

RPC.prototype.stop = async function stop(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'stop');

  this.node.close().catch((err) => {
    setImmediate(() => {
      throw err;
    });
  });

  return 'Stopping.';
};

/*
 * P2P networking
 */

RPC.prototype.getNetworkInfo = async function getNetworkInfo(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'getnetworkinfo');

  const hosts = this.pool.hosts;
  const locals = [];

  for (const local of hosts.local.values()) {
    locals.push({
      address: local.addr.host,
      port: local.addr.port,
      score: local.score
    });
  }

  return {
    version: pkg.version,
    subversion: this.pool.options.agent,
    protocolversion: this.pool.options.version,
    localservices: util.hex32(this.pool.options.services),
    localrelay: !this.pool.options.noRelay,
    timeoffset: this.network.time.offset,
    networkactive: this.pool.connected,
    connections: this.pool.peers.size(),
    networks: [],
    relayfee: Amount.wmcc(this.network.minRelay, true),
    incrementalfee: 0,
    localaddresses: locals,
    warnings: ''
  };
};

RPC.prototype.addNode = async function addNode(args, help) {
  if (help || args.length !== 2)
    throw new RPCError(errs.MISC_ERROR, 'addnode "node" "add|remove|onetry"');

  const valid = new Validator([args]);
  const node = valid.str(0, '');
  const cmd = valid.str(1, '');

  switch (cmd) {
    case 'add': {
      this.pool.hosts.addNode(node);
      ; // fall through
    }
    case 'onetry': {
      const addr = parseNetAddress(node, this.network);

      if (!this.pool.peers.get(addr.hostname)) {
        const peer = this.pool.createOutbound(addr);
        this.pool.peers.add(peer);
      }

      break;
    }
    case 'remove': {
      this.pool.hosts.removeNode(node);
      break;
    }
  }

  return null;
};

RPC.prototype.disconnectNode = async function disconnectNode(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'disconnectnode "node"');

  const valid = new Validator([args]);
  const str = valid.str(0, '');

  const addr = parseIP(str, this.network);
  const peer = this.pool.peers.get(addr.hostname);

  if (peer)
    peer.destroy();

  return null;
};

RPC.prototype.getAddedNodeInfo = async function getAddedNodeInfo(args, help) {
  if (help || args.length > 1)
    throw new RPCError(errs.MISC_ERROR, 'getaddednodeinfo ( "node" )');

  const hosts = this.pool.hosts;
  const valid = new Validator([args]);
  const addr = valid.str(0, '');

  let target;
  if (args.length === 1)
    target = parseIP(addr, this.network);

  const result = [];

  for (const node of hosts.nodes) {
    if (target) {
      if (node.host !== target.host)
        continue;

      if (node.port !== target.port)
        continue;
    }

    const peer = this.pool.peers.get(node.hostname);

    if (!peer || !peer.connected) {
      result.push({
        addednode: node.hostname,
        connected: false,
        addresses: []
      });
      continue;
    }

    result.push({
      addednode: node.hostname,
      connected: peer.connected,
      addresses: [
        {
          address: peer.hostname(),
          connected: peer.outbound
            ? 'outbound'
            : 'inbound'
        }
      ]
    });
  }

  if (target && result.length === 0) {
    throw new RPCError(errs.CLIENT_NODE_NOT_ADDED,
      'Node has not been added.');
  }

  return result;
};

RPC.prototype.getConnectionCount = async function getConnectionCount(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'getconnectioncount');

  return this.pool.peers.size();
};

RPC.prototype.getNetTotals = async function getNetTotals(args, help) {
  let sent = 0;
  let recv = 0;

  if (help || args.length > 0)
    throw new RPCError(errs.MISC_ERROR, 'getnettotals');

  for (let peer = this.pool.peers.head(); peer; peer = peer.next) {
    sent += peer.socket.bytesWritten;
    recv += peer.socket.bytesRead;
  }

  return {
    totalbytesrecv: recv,
    totalbytessent: sent,
    timemillis: util.ms()
  };
};

RPC.prototype.getPeerInfo = async function getPeerInfo(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'getpeerinfo');

  const peers = [];

  for (let peer = this.pool.peers.head(); peer; peer = peer.next) {
    let offset = this.network.time.known.get(peer.hostname());
    const hashes = [];

    if (offset == null)
      offset = 0;

    for (const hash in peer.blockMap.keys()) {
      const str = util.revHex(hash);
      hashes.push(str);
    }

    peers.push({
      id: peer.id,
      addr: peer.hostname(),
      addrlocal: !peer.local.isNull()
        ? peer.local.hostname
        : undefined,
      services: util.hex32(peer.services),
      relaytxes: !peer.noRelay,
      lastsend: peer.lastSend / 1000 | 0,
      lastrecv: peer.lastRecv / 1000 | 0,
      bytessent: peer.socket.bytesWritten,
      bytesrecv: peer.socket.bytesRead,
      conntime: peer.time !== 0 ? (util.ms() - peer.time) / 1000 | 0 : 0,
      timeoffset: offset,
      pingtime: peer.lastPong !== -1
        ? (peer.lastPong - peer.lastPing) / 1000
        : -1,
      minping: peer.minPing !== -1 ? peer.minPing / 1000 : -1,
      version: peer.version,
      subver: peer.agent,
      inbound: !peer.outbound,
      startingheight: peer.height,
      besthash: peer.bestHash ? util.revHex(peer.bestHash) : null,
      bestheight: peer.bestHeight,
      banscore: peer.banScore,
      inflight: hashes,
      whitelisted: false
    });
  }

  return peers;
};

RPC.prototype.ping = async function ping(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'ping');

  for (let peer = this.pool.peers.head(); peer; peer = peer.next)
    peer.sendPing();

  return null;
};

RPC.prototype.setBan = async function setBan(args, help) {
  const valid = new Validator([args]);
  const str = valid.str(0, '');
  const action = valid.str(1, '');

  if (help
      || args.length < 2
      || (action !== 'add' && action !== 'remove')) {
    throw new RPCError(errs.MISC_ERROR,
      'setban "ip(/netmask)" "add|remove" (bantime) (absolute)');
  }

  const addr = parseNetAddress(str, this.network);

  switch (action) {
    case 'add':
      this.pool.ban(addr);
      break;
    case 'remove':
      this.pool.unban(addr);
      break;
  }

  return null;
};

RPC.prototype.listBanned = async function listBanned(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'listbanned');

  const banned = [];

  for (const [host, time] of this.pool.hosts.banned) {
    banned.push({
      address: host,
      banned_until: time + this.pool.options.banTime,
      ban_created: time,
      ban_reason: ''
    });
  }

  return banned;
};

RPC.prototype.clearBanned = async function clearBanned(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'clearbanned');

  this.pool.hosts.clearBanned();

  return null;
};

/* Block chain and UTXO */
RPC.prototype.getBlockchainInfo = async function getBlockchainInfo(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'getblockchaininfo');

  return {
    chain: this.network.type !== 'testnet'
      ? this.network.type
      : 'test',
    blocks: this.chain.height,
    headers: this.chain.height,
    bestblockhash: this.chain.tip.rhash(),
    difficulty: toDifficulty(this.chain.tip.bits),
    mediantime: await this.chain.getMedianTime(this.chain.tip),
    verificationprogress: this.chain.getProgress(),
    chainwork: this.chain.tip.chainwork.toString('hex', 64),
    pruned: this.chain.options.prune,
    softforks: this.getSoftforks(),
    bip9_softforks: await this.getBIP9Softforks(),
    pruneheight: this.chain.options.prune
      ? Math.max(0, this.chain.height - this.network.block.keepBlocks)
      : null
  };
};

RPC.prototype.getBestBlockHash = async function getBestBlockHash(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'getbestblockhash');

  return this.chain.tip.rhash();
};

RPC.prototype.getBlockCount = async function getBlockCount(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'getblockcount');

  return this.chain.tip.height;
};

RPC.prototype.getBlock = async function getBlock(args, help) {
  if (help || args.length < 1 || args.length > 3)
    throw new RPCError(errs.MISC_ERROR, 'getblock "hash" ( verbose )');

  const valid = new Validator([args]);
  const hash = valid.hash(0);
  const verbose = valid.bool(1, true);
  const details = valid.bool(2, false);

  if (!hash)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid block hash.');

  const entry = await this.chain.getEntry(hash);

  if (!entry)
    throw new RPCError(errs.MISC_ERROR, 'Block not found');

  const block = await this.chain.getBlock(entry.hash);

  if (!block) {
    if (this.chain.options.spv)
      throw new RPCError(errs.MISC_ERROR, 'Block not available (spv mode)');

    if (this.chain.options.prune)
      throw new RPCError(errs.MISC_ERROR, 'Block not available (pruned data)');

    throw new RPCError(errs.MISC_ERROR, 'Can\'t read block from disk');
  }

  if (!verbose)
    return block.toRaw().toString('hex');

  return await this.blockToJSON(entry, block, details);
};

RPC.prototype.getBlockByHeight = async function getBlockByHeight(args, help) {
  if (help || args.length < 1 || args.length > 3) {
    throw new RPCError(errs.MISC_ERROR,
      'getblockbyheight "height" ( verbose )');
  }

  const valid = new Validator([args]);
  const height = valid.u32(0, -1);
  const verbose = valid.bool(1, true);
  const details = valid.bool(2, false);

  if (height === -1)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid block height.');

  const entry = await this.chain.getEntry(height);

  if (!entry)
    throw new RPCError(errs.MISC_ERROR, 'Block not found');

  const block = await this.chain.getBlock(entry.hash);

  if (!block) {
    if (this.chain.options.spv)
      throw new RPCError(errs.MISC_ERROR, 'Block not available (spv mode)');

    if (this.chain.options.prune)
      throw new RPCError(errs.MISC_ERROR, 'Block not available (pruned data)');

    throw new RPCError(errs.DATABASE_ERROR, 'Can\'t read block from disk');
  }

  if (!verbose)
    return block.toRaw().toString('hex');

  return await this.blockToJSON(entry, block, details);
};

RPC.prototype.getBlockHash = async function getBlockHash(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'getblockhash index');

  const valid = new Validator([args]);
  const height = valid.u32(0);

  if (height == null || height > this.chain.height)
    throw new RPCError(errs.INVALID_PARAMETER, 'Block height out of range.');

  const hash = await this.chain.getHash(height);

  if (!hash)
    throw new RPCError(errs.MISC_ERROR, 'Not found.');

  return util.revHex(hash);
};

RPC.prototype.getBlockHeader = async function getBlockHeader(args, help) {
  if (help || args.length < 1 || args.length > 2)
    throw new RPCError(errs.MISC_ERROR, 'getblockheader "hash" ( verbose )');

  const valid = new Validator([args]);
  const hash = valid.hash(0);
  const verbose = valid.bool(1, true);

  if (!hash)
    throw new RPCError(errs.MISC_ERROR, 'Invalid block hash.');

  const entry = await this.chain.getEntry(hash);

  if (!entry)
    throw new RPCError(errs.MISC_ERROR, 'Block not found');

  if (!verbose)
    return entry.toRaw().toString('hex', 0, 80);

  return await this.headerToJSON(entry);
};

RPC.prototype.getChainTips = async function getChainTips(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'getchaintips');

  const tips = await this.chain.getTips();
  const result = [];

  for (const hash of tips) {
    const entry = await this.chain.getEntry(hash);

    assert(entry);

    const fork = await this.findFork(entry);
    const main = await this.chain.isMainChain(entry);

    result.push({
      height: entry.height,
      hash: entry.rhash(),
      branchlen: entry.height - fork.height,
      status: main ? 'active' : 'valid-headers'
    });
  }

  return result;
};

RPC.prototype.getDifficulty = async function getDifficulty(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'getdifficulty');

  return toDifficulty(this.chain.tip.bits);
};

RPC.prototype.getMempoolInfo = async function getMempoolInfo(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'getmempoolinfo');

  if (!this.mempool)
    throw new RPCError(errs.MISC_ERROR, 'No mempool available.');

  return {
    size: this.mempool.map.size,
    bytes: this.mempool.getSize(),
    usage: this.mempool.getSize(),
    maxmempool: this.mempool.options.maxSize,
    mempoolminfee: Amount.wmcc(this.mempool.options.minRelay, true)
  };
};

RPC.prototype.getMempoolAncestors = async function getMempoolAncestors(args, help) {
  if (help || args.length < 1 || args.length > 2)
    throw new RPCError(errs.MISC_ERROR, 'getmempoolancestors txid (verbose)');

  const valid = new Validator([args]);
  const hash = valid.hash(0);
  const verbose = valid.bool(1, false);

  if (!this.mempool)
    throw new RPCError(errs.MISC_ERROR, 'No mempool available.');

  if (!hash)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid TXID.');

  const entry = this.mempool.getEntry(hash);

  if (!entry)
    throw new RPCError(errs.MISC_ERROR, 'Transaction not in mempool.');

  const entries = this.mempool.getAncestors(entry);
  const out = [];

  if (verbose) {
    for (const entry of entries)
      out.push(this.entryToJSON(entry));
  } else {
    for (const entry of entries)
      out.push(entry.txid());
  }

  return out;
};

RPC.prototype.getMempoolDescendants = async function getMempoolDescendants(args, help) {
  if (help || args.length < 1 || args.length > 2)
    throw new RPCError(errs.MISC_ERROR, 'getmempooldescendants txid (verbose)');

  const valid = new Validator([args]);
  const hash = valid.hash(0);
  const verbose = valid.bool(1, false);

  if (!this.mempool)
    throw new RPCError(errs.MISC_ERROR, 'No mempool available.');

  if (!hash)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid TXID.');

  const entry = this.mempool.getEntry(hash);

  if (!entry)
    throw new RPCError(errs.MISC_ERROR, 'Transaction not in mempool.');

  const entries = this.mempool.getDescendants(entry);
  const out = [];

  if (verbose) {
    for (const entry of entries)
      out.push(this.entryToJSON(entry));
  } else {
    for (const entry of entries)
      out.push(entry.txid());
  }

  return out;
};

RPC.prototype.getMempoolEntry = async function getMempoolEntry(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'getmempoolentry txid');

  const valid = new Validator([args]);
  const hash = valid.hash(0);

  if (!this.mempool)
    throw new RPCError(errs.MISC_ERROR, 'No mempool available.');

  if (!hash)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid TXID.');

  const entry = this.mempool.getEntry(hash);

  if (!entry)
    throw new RPCError(errs.MISC_ERROR, 'Transaction not in mempool.');

  return this.entryToJSON(entry);
};

RPC.prototype.getRawMempool = async function getRawMempool(args, help) {
  if (help || args.length > 1)
    throw new RPCError(errs.MISC_ERROR, 'getrawmempool ( verbose )');

  const valid = new Validator([args]);
  const verbose = valid.bool(0, false);

  if (!this.mempool)
    throw new RPCError(errs.MISC_ERROR, 'No mempool available.');

  if (verbose) {
    const out = {};

    for (const entry of this.mempool.map.values())
      out[entry.txid()] = this.entryToJSON(entry);

    return out;
  }

  const hashes = this.mempool.getSnapshot();

  return hashes.map(util.revHex);
};

RPC.prototype.getTXOut = async function getTXOut(args, help) {
  if (help || args.length < 2 || args.length > 3)
    throw new RPCError(errs.MISC_ERROR, 'gettxout "txid" n ( includemempool )');

  const valid = new Validator([args]);
  const hash = valid.hash(0);
  const index = valid.u32(1);
  const mempool = valid.bool(2, true);

  if (this.chain.options.spv)
    throw new RPCError(errs.MISC_ERROR, 'Cannot get coins in SPV mode.');

  if (this.chain.options.prune)
    throw new RPCError(errs.MISC_ERROR, 'Cannot get coins when pruned.');

  if (!hash || index == null)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid outpoint.');

  let coin;
  if (mempool) {
    if (!this.mempool)
      throw new RPCError(errs.MISC_ERROR, 'No mempool available.');
    coin = this.mempool.getCoin(hash, index);
  }

  if (!coin)
    coin = await this.chain.getCoin(hash, index);

  if (!coin)
    return null;

  return {
    bestblock: this.chain.tip.rhash(),
    confirmations: coin.getDepth(this.chain.height),
    value: Amount.wmcc(coin.value, true),
    scriptPubKey: this.scriptToJSON(coin.script, true),
    version: coin.version,
    coinbase: coin.coinbase
  };
};

RPC.prototype.getTXOutProof = async function getTXOutProof(args, help) {
  if (help || (args.length !== 1 && args.length !== 2)) {
    throw new RPCError(errs.MISC_ERROR,
      'gettxoutproof ["txid",...] ( blockhash )');
  }

  const valid = new Validator([args]);
  const txids = valid.array(0);
  const hash = valid.hash(1);

  if (this.chain.options.spv)
    throw new RPCError(errs.MISC_ERROR, 'Cannot get coins in SPV mode.');

  if (this.chain.options.prune)
    throw new RPCError(errs.MISC_ERROR, 'Cannot get coins when pruned.');

  if (!txids || txids.length === 0)
    throw new RPCError(errs.INVALID_PARAMETER, 'Invalid TXIDs.');

  const items = new Validator([txids]);
  const set = new Set();
  const hashes = [];

  let last = null;

  for (let i = 0; i < txids.length; i++) {
    const hash = items.hash(i);

    if (!hash)
      throw new RPCError(errs.TYPE_ERROR, 'Invalid TXID.');

    if (set.has(hash))
      throw new RPCError(errs.INVALID_PARAMETER, 'Duplicate txid.');

    set.add(hash);
    hashes.push(hash);

    last = hash;
  }

  let block = null;

  if (hash) {
    block = await this.chain.getBlock(hash);
  } else if (this.chain.options.indexTX) {
    const tx = await this.chain.getMeta(last);
    if (tx)
      block = await this.chain.getBlock(tx.block);
  } else {
    const coin = await this.chain.getCoin(last, 0);
    if (coin)
      block = await this.chain.getBlock(coin.height);
  }

  if (!block)
    throw new RPCError(errs.MISC_ERROR, 'Block not found.');

  for (const hash of hashes) {
    if (!block.hasTX(hash)) {
      throw new RPCError(errs.VERIFY_ERROR,
        'Block does not contain all txids.');
    }
  }

  block = MerkleBlock.fromHashes(block, hashes);

  return block.toRaw().toString('hex');
};

RPC.prototype.verifyTXOutProof = async function verifyTXOutProof(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'verifytxoutproof "proof"');

  const valid = new Validator([args]);
  const data = valid.buf(0);

  if (!data)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid hex string.');

  const block = MerkleBlock.fromRaw(data);

  if (!block.verify())
    return [];

  const entry = await this.chain.getEntry(block.hash('hex'));

  if (!entry)
    throw new RPCError(errs.MISC_ERROR, 'Block not found in chain.');

  const tree = block.getTree();
  const out = [];

  for (const hash of tree.matches)
    out.push(util.revHex(hash));

  return out;
};

RPC.prototype.getTXOutSetInfo = async function getTXOutSetInfo(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'gettxoutsetinfo');

  if (this.chain.options.spv)
    throw new RPCError(errs.MISC_ERROR, 'Chainstate not available (SPV mode).');

  return {
    height: this.chain.height,
    bestblock: this.chain.tip.rhash(),
    transactions: this.chain.db.state.tx,
    txouts: this.chain.db.state.coin,
    bytes_serialized: 0,
    hash_serialized: 0,
    total_amount: Amount.wmcc(this.chain.db.state.value, true)
  };
};

RPC.prototype.pruneBlockchain = async function pruneBlockchain(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'pruneblockchain');

  if (this.chain.options.spv)
    throw new RPCError(errs.MISC_ERROR, 'Cannot prune chain in SPV mode.');

  if (this.chain.options.prune)
    throw new RPCError(errs.MISC_ERROR, 'Chain is already pruned.');

  if (this.chain.height < this.network.block.pruneAfterHeight)
    throw new RPCError(errs.MISC_ERROR, 'Chain is too short for pruning.');

  try {
    await this.chain.prune();
  } catch (e) {
    throw new RPCError(errs.DATABASE_ERROR, e.message);
  }
};

RPC.prototype.verifyChain = async function verifyChain(args, help) {
  if (help || args.length > 2)
    throw new RPCError(errs.MISC_ERROR, 'verifychain ( checklevel numblocks )');

  const valid = new Validator([args]);
  const level = valid.u32(0);
  const blocks = valid.u32(1);

  if (level == null || blocks == null)
    throw new RPCError(errs.TYPE_ERROR, 'Missing parameters.');

  if (this.chain.options.spv)
    throw new RPCError(errs.MISC_ERROR, 'Cannot verify chain in SPV mode.');

  if (this.chain.options.prune)
    throw new RPCError(errs.MISC_ERROR, 'Cannot verify chain when pruned.');

  return null;
};

/*
 * Mining
 */

RPC.prototype.submitWork = async function submitWork(data) {
  const unlock = await this.locker.lock();
  try {
    return await this._submitWork(data);
  } finally {
    unlock();
  }
};

RPC.prototype._submitWork = async function _submitWork(data) {
  const attempt = this.attempt;

  if (!attempt)
    return false;

  if (data.length !== 128)
    throw new RPCError(errs.INVALID_PARAMETER, 'Invalid work size.');

  const raw = data.slice(0, 80);
  swap32(raw);

  const header = Headers.fromHead(raw);

  if (header.prevBlock !== attempt.prevBlock
      || header.bits !== attempt.bits) {
    return false;
  }

  if (!header.verify())
    return false;

  const nonces = this.merkleMap.get(header.merkleRoot);

  if (!nonces)
    return false;

  const [n1, n2] = nonces;
  const nonce = header.nonce;
  const time = header.time;

  const proof = attempt.getProof(n1, n2, time, nonce);

  if (!proof.verify(attempt.target))
    return false;

  const block = attempt.commit(proof);

  let entry;
  try {
    entry = await this.chain.add(block);
  } catch (err) {
    if (err.type === 'VerifyError') {
      this.logger.warning('RPC block rejected: %s (%s).',
        block.rhash(), err.reason);
      return false;
    }
    throw err;
  }

  if (!entry) {
    this.logger.warning('RPC block rejected: %s (bad-prevblk).',
      block.rhash());
    return false;
  }

  return true;
};

RPC.prototype.createWork = async function createWork(data) {
  const unlock = await this.locker.lock();
  try {
    return await this._createWork(data);
  } finally {
    unlock();
  }
};

RPC.prototype._createWork = async function _createWork() {
  const attempt = await this.updateWork();
  const n1 = this.nonce1;
  const n2 = this.nonce2;
  const time = attempt.time;

  const data = Buffer.allocUnsafe(128);
  data.fill(0);

  const root = attempt.getRoot(n1, n2);
  const head = attempt.getHeader(root, time, 0);

  head.copy(data, 0);

  data[80] = 0x80;
  data.writeUInt32BE(80 * 8, data.length - 4, true);

  swap32(data);

  return {
    data: data.toString('hex'),
    target: attempt.target.toString('hex'),
    height: attempt.height
  };
};

RPC.prototype.getWorkLongpoll = async function getWorkLongpoll(args, help) {
  await this.longpoll();
  return await this.createWork();
};

RPC.prototype.getWork = async function getWork(args, help) {
  if (args.length > 1)
    throw new RPCError(errs.MISC_ERROR, 'getwork ( "data" )');

  if (args.length === 1) {
    const valid = new Validator([args]);
    const data = valid.buf(0);

    if (!data)
      throw new RPCError(errs.TYPE_ERROR, 'Invalid work data.');

    return await this.submitWork(data);
  }

  return await this.createWork();
};

RPC.prototype.submitBlock = async function submitBlock(args, help) {
  if (help || args.length < 1 || args.length > 2) {
    throw new RPCError(errs.MISC_ERROR,
      'submitblock "hexdata" ( "jsonparametersobject" )');
  }

  const valid = new Validator([args]);
  const data = valid.buf(0);

  const block = Block.fromRaw(data);

  return await this.addBlock(block);
};

RPC.prototype.getBlockTemplate = async function getBlockTemplate(args, help) {
  if (help || args.length > 1) {
    throw new RPCError(errs.MISC_ERROR,
      'getblocktemplate ( "jsonrequestobject" )');
  }

  const validator = new Validator([args]);
  const options = validator.obj(0, {});
  const valid = new Validator([options]);
  const mode = valid.str('mode', 'template');

  if (mode !== 'template' && mode !== 'proposal')
    throw new RPCError(errs.INVALID_PARAMETER, 'Invalid mode.');

  if (mode === 'proposal') {
    const data = valid.buf('data');

    if (!data)
      throw new RPCError(errs.TYPE_ERROR, 'Missing data parameter.');

    const block = Block.fromRaw(data);

    if (block.prevBlock !== this.chain.tip.hash)
      return 'inconclusive-not-best-prevblk';

    try {
      await this.chain.verifyBlock(block);
    } catch (e) {
      if (e.type === 'VerifyError')
        return e.reason;
      throw e;
    }

    return null;
  }

  let maxVersion = valid.u32('maxversion', -1);
  let rules = valid.array('rules');

  if (rules)
    maxVersion = -1;

  const capabilities = valid.array('capabilities');
  let coinbase = false;

  if (capabilities) {
    let txnCap = false;
    let valueCap = false;

    for (const capability of capabilities) {
      if (typeof capability !== 'string')
        throw new RPCError(errs.TYPE_ERROR, 'Invalid capability.');

      switch (capability) {
        case 'coinbasetxn':
          txnCap = true;
          break;
        case 'coinbasevalue':
          // Prefer value if they support it.
          valueCap = true;
          break;
      }
    }

    // BIP22 states that we can't have coinbasetxn
    // _and_ coinbasevalue in the same template.
    // The problem is, many clients _say_ they
    // support coinbasetxn when they don't (ckpool).
    // To make matters worse, some clients will
    // parse an undefined `coinbasevalue` as zero.
    // Because of all of this, coinbasetxn is
    // disabled for now.
    valueCap = true;

    if (txnCap && !valueCap) {
      if (this.miner.addresses.length === 0) {
        throw new RPCError(errs.MISC_ERROR,
          'No addresses available for coinbase.');
      }
      coinbase = true;
    }
  }

  if (!this.network.selfConnect) {
    if (this.pool.peers.size() === 0) {
      throw new RPCError(errs.CLIENT_NOT_CONNECTED,
        'WMCoin is not connected!');
    }

    if (!this.chain.synced) {
      throw new RPCError(errs.CLIENT_IN_INITIAL_DOWNLOAD,
        'WMCoin is downloading blocks...');
    }
  }

  const lpid = valid.str('longpollid');

  if (lpid)
    await this.handleLongpoll(lpid);

  if (!rules)
    rules = [];

  return await this.createTemplate(maxVersion, coinbase, rules);
};

RPC.prototype.createTemplate = async function createTemplate(maxVersion, coinbase, rules) {
  const unlock = await this.locker.lock();
  try {
    return await this._createTemplate(maxVersion, coinbase, rules);
  } finally {
    unlock();
  }
};

RPC.prototype._createTemplate = async function _createTemplate(maxVersion, coinbase, rules) {
  const attempt = await this.getTemplate();
  const scale = attempt.witness ? 1 : consensus.WITNESS_SCALE_FACTOR;

  // Default mutable fields.
  const mutable = ['time', 'transactions', 'prevblock'];

  // The miner doesn't support
  // versionbits. Force them to
  // encode our version.
  if (maxVersion >= 2)
    mutable.push('version/force');

  // Allow the miner to change
  // our provided coinbase.
  // Note that these are implied
  // without `coinbasetxn`.
  if (coinbase) {
    mutable.push('coinbase');
    mutable.push('coinbase/append');
    mutable.push('generation');
  }

  // Build an index of every transaction.
  const index = new Map();
  for (let i = 0; i < attempt.items.length; i++) {
    const entry = attempt.items[i];
    index.set(entry.hash, i + 1);
  }

  // Calculate dependencies for each transaction.
  const txs = [];
  for (let i = 0; i < attempt.items.length; i++) {
    const entry = attempt.items[i];
    const tx = entry.tx;
    const deps = [];

    for (let j = 0; j < tx.inputs.length; j++) {
      const input = tx.inputs[j];
      const dep = index.get(input.prevout.hash);

      if (dep == null)
        continue;

      if (deps.indexOf(dep) === -1) {
        assert(dep < i + 1);
        deps.push(dep);
      }
    }

    txs.push({
      data: tx.toRaw().toString('hex'),
      txid: tx.txid(),
      hash: tx.wtxid(),
      depends: deps,
      fee: entry.fee,
      sigops: entry.sigops / scale | 0,
      weight: tx.getWeight()
    });
  }

  if (this.chain.options.bip91) {
    rules.push('segwit');
    rules.push('segsignal');
  }

  if (this.chain.options.bip148)
    rules.push('segwit');

  // Calculate version based on given rules.
  let version = attempt.version;
  const vbavailable = {};
  const vbrules = [];

  for (const deploy of this.network.deploys) {
    const state = await this.chain.getState(this.chain.tip, deploy);
    let name = deploy.name;

    switch (state) {
      case common.thresholdStates.DEFINED:
      case common.thresholdStates.FAILED:
        break;
      case common.thresholdStates.LOCKED_IN:
        version |= 1 << deploy.bit;
      case common.thresholdStates.STARTED:
        if (!deploy.force) {
          if (rules.indexOf(name) === -1)
            version &= ~(1 << deploy.bit);
          if (deploy.required)
            name = '!' + name;
        }
        vbavailable[name] = deploy.bit;
        break;
      case common.thresholdStates.ACTIVE:
        if (!deploy.force && deploy.required) {
          if (rules.indexOf(name) === -1) {
            throw new RPCError(errs.INVALID_PARAMETER,
              `Client must support ${name}.`);
          }
          name = '!' + name;
        }
        vbrules.push(name);
        break;
      default:
        assert(false, 'Bad state.');
        break;
    }
  }

  version >>>= 0;

  const json = {
    capabilities: ['proposal'],
    mutable: mutable,
    version: version,
    rules: vbrules,
    vbavailable: vbavailable,
    vbrequired: 0,
    height: attempt.height,
    previousblockhash: util.revHex(attempt.prevBlock),
    target: util.revHex(attempt.target.toString('hex')),
    bits: util.hex32(attempt.bits),
    noncerange: '00000000ffffffff',
    curtime: attempt.time,
    mintime: attempt.mtp + 1,
    maxtime: attempt.time + 7200,
    expires: attempt.time + 7200,
    sigoplimit: consensus.MAX_BLOCK_SIGOPS_COST / scale | 0,
    sizelimit: consensus.MAX_BLOCK_SIZE,
    weightlimit: undefined,
    longpollid: this.chain.tip.rhash() + util.pad32(this.totalTX()),
    submitold: false,
    coinbaseaux: {
      flags: attempt.coinbaseFlags.toString('hex')
    },
    coinbasevalue: undefined,
    coinbasetxn: undefined,
    default_witness_commitment: undefined,
    transactions: txs
  };

  // See:
  // bitcoin/bitcoin#9fc7f0bce94f1cea0239b1543227f22a3f3b9274
  if (attempt.witness) {
    json.sizelimit = consensus.MAX_RAW_BLOCK_SIZE;
    json.weightlimit = consensus.MAX_BLOCK_WEIGHT;
  }

  // The client wants a coinbasetxn
  // instead of a coinbasevalue.
  if (coinbase) {
    const tx = attempt.toCoinbase();
    const input = tx.inputs[0];

    // Pop off the nonces.
    input.script.pop();
    input.script.compile();

    if (attempt.witness) {
      // We don't include the commitment
      // output (see bip145).
      const output = tx.outputs.pop();
      assert(output.script.isCommitment());

      // Also not including the witness nonce.
      input.witness.clear();
    }

    tx.refresh();

    json.coinbasetxn = {
      data: tx.toRaw().toString('hex'),
      txid: tx.txid(),
      hash: tx.wtxid(),
      depends: [],
      fee: 0,
      sigops: tx.getSigopsCost() / scale | 0,
      weight: tx.getWeight()
    };
  } else {
    json.coinbasevalue = attempt.getReward();
  }

  if (rules.indexOf('segwit') !== -1)
    json.default_witness_commitment = attempt.getWitnessScript().toJSON();

  return json;
};

RPC.prototype.getMiningInfo = async function getMiningInfo(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'getmininginfo');

  const attempt = this.attempt;

  let size = 0;
  let weight = 0;
  let txs = 0;
  let diff = 0;

  if (attempt) {
    weight = attempt.weight;
    txs = attempt.items.length + 1;
    diff = attempt.getDifficulty();
    size = 1000;
    for (const item of attempt.items)
      size += item.tx.getBaseSize();
  }

  return {
    blocks: this.chain.height,
    currentblocksize: size,
    currentblockweight: weight,
    currentblocktx: txs,
    difficulty: diff,
    errors: '',
    genproclimit: this.procLimit,
    networkhashps: await this.getHashRate(120),
    pooledtx: this.totalTX(),
    testnet: this.network !== Network.mainnet,
    chain: this.network.type !== 'testnet'
      ? this.network.type
      : 'test',
    generate: this.mining
  };
};

RPC.prototype.getNetworkHashPS = async function getNetworkHashPS(args, help) {
  if (help || args.length > 2)
    throw new RPCError(errs.MISC_ERROR, 'getnetworkhashps ( blocks height )');

  const valid = new Validator([args]);
  const lookup = valid.u32(0, 120);
  const height = valid.u32(1);

  return await this.getHashRate(lookup, height);
};

RPC.prototype.prioritiseTransaction = async function prioritiseTransaction(args, help) {
  if (help || args.length !== 3) {
    throw new RPCError(errs.MISC_ERROR,
      'prioritisetransaction <txid> <priority delta> <fee delta>');
  }

  const valid = new Validator([args]);
  const hash = valid.hash(0);
  const pri = valid.i64(1);
  const fee = valid.i64(2);

  if (!this.mempool)
    throw new RPCError(errs.MISC_ERROR, 'No mempool available.');

  if (!hash)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid TXID');

  if (pri == null || fee == null)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid fee or priority.');

  const entry = this.mempool.getEntry(hash);

  if (!entry)
    throw new RPCError(errs.MISC_ERROR, 'Transaction not in mempool.');

  this.mempool.prioritise(entry, pri, fee);

  return true;
};

RPC.prototype.verifyBlock = async function verifyBlock(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'verifyblock "block-hex"');

  const valid = new Validator([args]);
  const data = valid.buf(0);

  if (!data)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid block hex.');

  if (this.chain.options.spv)
    throw new RPCError(errs.MISC_ERROR, 'Cannot verify block in SPV mode.');

  const block = Block.fromRaw(data);

  try {
    await this.chain.verifyBlock(block);
  } catch (e) {
    if (e.type === 'VerifyError')
      return e.reason;
    throw e;
  }

  return null;
};

/*
 * Coin generation
 */

RPC.prototype.getGenerate = async function getGenerate(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'getgenerate');
  return this.mining;
};

RPC.prototype.setGenerate = async function setGenerate(args, help) {
  if (help || args.length < 1 || args.length > 2)
    throw new RPCError(errs.MISC_ERROR, 'setgenerate mine ( proclimit )');

  const valid = new Validator([args]);
  const mine = valid.bool(0, false);
  const limit = valid.u32(1, 0);

  if (mine && this.miner.addresses.length === 0) {
    throw new RPCError(errs.MISC_ERROR,
      'No addresses available for coinbase.');
  }

  this.mining = mine;
  this.procLimit = limit;

  if (mine) {
    this.miner.cpu.start();
    return true;
  }

  await this.miner.cpu.stop();

  return false;
};

RPC.prototype.generate = async function generate(args, help) {
  if (help || args.length < 1 || args.length > 2)
    throw new RPCError(errs.MISC_ERROR, 'generate numblocks ( maxtries )');

  const valid = new Validator([args]);
  const blocks = valid.u32(0, 1);
  const tries = valid.u32(1);

  if (this.miner.addresses.length === 0) {
    throw new RPCError(errs.MISC_ERROR,
      'No addresses available for coinbase.');
  }

  return await this.mineBlocks(blocks, null, tries);
};

RPC.prototype.generateToAddress = async function generateToAddress(args, help) {
  if (help || args.length < 2 || args.length > 3) {
    throw new RPCError(errs.MISC_ERROR,
      'generatetoaddress numblocks address ( maxtries )');
  }

  const valid = new Validator([args]);
  const blocks = valid.u32(0, 1);
  const str = valid.str(1, '');
  const tries = valid.u32(2);

  const addr = parseAddress(str, this.network);

  return await this.mineBlocks(blocks, addr, tries);
};

/*
 * Raw transactions
 */

RPC.prototype.createRawTransaction = async function createRawTransaction(args, help) {
  if (help || args.length < 2 || args.length > 3) {
    throw new RPCError(errs.MISC_ERROR,
      'createrawtransaction'
      + ' [{"txid":"id","vout":n},...]'
      + ' {"address":amount,"data":"hex",...}'
      + ' ( locktime )');
  }

  const valid = new Validator([args]);
  const inputs = valid.array(0);
  const sendTo = valid.obj(1);
  const locktime = valid.u32(2);

  if (!inputs || !sendTo) {
    throw new RPCError(errs.TYPE_ERROR,
      'Invalid parameters (inputs and sendTo).');
  }

  const tx = new MTX();

  if (locktime != null)
    tx.locktime = locktime;

  for (const obj of tx.inputs) {
    const valid = new Validator([obj]);
    const hash = valid.hash('txid');
    const index = valid.u32('vout');
    let sequence = valid.u32('sequence', 0xffffffff);

    if (tx.locktime)
      sequence--;

    if (!hash || index == null)
      throw new RPCError(errs.TYPE_ERROR, 'Invalid outpoint.');

    const input = new Input();
    input.prevout.hash = hash;
    input.prevout.index = index;
    input.sequence = sequence;

    tx.inputs.push(input);
  }

  const sends = new Validator([sendTo]);
  const uniq = new Set();

  for (const key of Object.keys(sendTo)) {
    if (key === 'data') {
      const value = sends.buf(key);

      if (!value)
        throw new RPCError(errs.TYPE_ERROR, 'Invalid nulldata..');

      const output = new Output();
      output.value = 0;
      output.script.fromNulldata(value);
      tx.outputs.push(output);

      continue;
    }

    const addr = parseAddress(key, this.network);
    const b58 = addr.toString(this.network);

    if (uniq.has(b58))
      throw new RPCError(errs.INVALID_PARAMETER, 'Duplicate address');

    uniq.add(b58);

    const value = sends.ufixed(key, 8);

    if (value == null)
      throw new RPCError(errs.TYPE_ERROR, 'Invalid output value.');

    const output = new Output();
    output.value = value;
    output.script.fromAddress(addr);

    tx.outputs.push(output);
  }

  return tx.toRaw().toString('hex');
};

RPC.prototype.decodeRawTransaction = async function decodeRawTransaction(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'decoderawtransaction "hexstring"');

  const valid = new Validator([args]);
  const data = valid.buf(0);

  if (!data)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid hex string.');

  const tx = TX.fromRaw(data);

  return this.txToJSON(tx);
};

RPC.prototype.decodeScript = async function decodeScript(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'decodescript "hex"');

  const valid = new Validator([args]);
  const data = valid.buf(0);

  let script = new Script();

  if (data)
    script = Script.fromRaw(data);

  const addr = Address.fromScripthash(script.hash160());

  const json = this.scriptToJSON(script);
  json.p2sh = addr.toString(this.network);

  return json;
};

RPC.prototype.getRawTransaction = async function getRawTransaction(args, help) {
  if (help || args.length < 1 || args.length > 2)
    throw new RPCError(errs.MISC_ERROR, 'getrawtransaction "txid" ( verbose )');

  const valid = new Validator([args]);
  const hash = valid.hash(0);
  const verbose = valid.bool(1, false);

  if (!hash)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid TXID.');

  const meta = await this.node.getMeta(hash);

  if (!meta)
    throw new RPCError(errs.MISC_ERROR, 'Transaction not found.');

  const tx = meta.tx;

  if (!verbose)
    return tx.toRaw().toString('hex');

  let entry;
  if (meta.block)
    entry = await this.chain.getEntry(meta.block);

  const json = this.txToJSON(tx, entry);
  json.time = meta.mtime;
  json.hex = tx.toRaw().toString('hex');

  return json;
};

RPC.prototype.sendRawTransaction = async function sendRawTransaction(args, help) {
  if (help || args.length < 1 || args.length > 2) {
    throw new RPCError(errs.MISC_ERROR,
      'sendrawtransaction "hexstring" ( allowhighfees )');
  }

  const valid = new Validator([args]);
  const data = valid.buf(0);

  if (!data)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid hex string.');

  const tx = TX.fromRaw(data);

  this.node.relay(tx);

  return tx.txid();
};

RPC.prototype.signRawTransaction = async function signRawTransaction(args, help) {
  if (help || args.length < 1 || args.length > 4) {
    throw new RPCError(errs.MISC_ERROR,
      'signrawtransaction'
      + ' "hexstring" ('
      + ' [{"txid":"id","vout":n,"scriptPubKey":"hex",'
      + 'redeemScript":"hex"},...] ["privatekey1",...]'
      + ' sighashtype )');
  }

  const valid = new Validator([args]);
  const data = valid.buf(0);
  const prevout = valid.array(1);
  const secrets = valid.array(2);
  const sighash = valid.str(3);

  if (!data)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid hex string.');

  if (!this.mempool)
    throw new RPCError(errs.MISC_ERROR, 'No mempool available.');

  const tx = MTX.fromRaw(data);
  tx.view = await this.mempool.getSpentView(tx);

  const map = new Map();
  const keys = [];

  if (secrets) {
    const valid = new Validator([secrets]);
    for (let i = 0; i < secrets.length; i++) {
      const secret = valid.str(i, '');
      const key = parseSecret(secret, this.network);
      map.set(key.getPublicKey('hex'), key);
      keys.push(key);
    }
  }

  if (prevout) {
    for (const prev of prevout) {
      const valid = new Validator([prev]);
      const hash = valid.hash('txid');
      const index = valid.u32('index');
      const scriptRaw = valid.buf('scriptPubKey');
      const value = valid.ufixed('amount', 8);
      const redeemRaw = valid.buf('redeemScript');

      if (!hash || index == null || !scriptRaw || value == null)
        throw new RPCError(errs.INVALID_PARAMETER, 'Invalid UTXO.');

      const outpoint = new Outpoint(hash, index);

      const script = Script.fromRaw(scriptRaw);
      const coin = Output.fromScript(script, value);

      tx.view.addOutput(outpoint, coin);

      if (keys.length === 0 || !redeemRaw)
        continue;

      if (!script.isScripthash() && !script.isWitnessScripthash())
        continue;

      if (!redeemRaw) {
        throw new RPCError(errs.INVALID_PARAMETER,
          'P2SH requires redeem script.');
      }

      const redeem = Script.fromRaw(redeemRaw);

      for (const op of redeem.code) {
        if (!op.data)
          continue;

        const key = map.get(op.data.toString('hex'));

        if (key) {
          key.script = redeem;
          key.witness = script.isWitnessScripthash();
          key.refresh();
          break;
        }
      }
    }
  }

  let type = Script.hashType.ALL;
  if (sighash) {
    const parts = sighash.split('|');

    if (parts.length < 1 || parts.length > 2)
      throw new RPCError(errs.INVALID_PARAMETER, 'Invalid sighash type.');

    type = Script.hashType[parts[0]];

    if (type == null)
      throw new RPCError(errs.INVALID_PARAMETER, 'Invalid sighash type.');

    if (parts.length === 2) {
      if (parts[1] !== 'ANYONECANPAY')
        throw new RPCError(errs.INVALID_PARAMETER, 'Invalid sighash type.');
      type |= Script.hashType.ANYONECANPAY;
    }
  }

  await tx.signAsync(keys, type, this.workers);

  return {
    hex: tx.toRaw().toString('hex'),
    complete: tx.isSigned()
  };
};

/*
 * Utility Functions
 */

RPC.prototype.createMultisig = async function createMultisig(args, help) {
  if (help || args.length < 2 || args.length > 2)
    throw new RPCError(errs.MISC_ERROR, 'createmultisig nrequired ["key",...]');

  const valid = new Validator([args]);
  const keys = valid.array(1, []);
  const m = valid.u32(0, 0);
  const n = keys.length;

  if (m < 1 || n < m || n > 16)
    throw new RPCError(errs.INVALID_PARAMETER, 'Invalid m and n values.');

  const items = new Validator([keys]);

  for (let i = 0; i < keys.length; i++) {
    const key = items.buf(i);

    if (!key)
      throw new RPCError(errs.TYPE_ERROR, 'Invalid key.');

    if (!secp256k1.publicKeyVerify(key))
      throw new RPCError(errs.INVALID_ADDRESS_OR_KEY, 'Invalid key.');

    keys[i] = key;
  }

  const script = Script.fromMultisig(m, n, keys);

  if (script.getSize() > consensus.MAX_SCRIPT_PUSH)
    throw new RPCError(errs.VERIFY_ERROR, 'Redeem script exceeds size limit.');

  const addr = script.getAddress();

  return {
    address: addr.toString(this.network),
    redeemScript: script.toJSON()
  };
};

RPC.prototype.createWitnessAddress = async function createWitnessAddress(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'createwitnessaddress "script"');

  const valid = new Validator([args]);
  const raw = valid.buf(0);

  if (!raw)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid script hex.');

  const script = Script.fromRaw(raw);
  const program = script.forWitness();
  const addr = program.getAddress();

  return {
    address: addr.toString(this.network),
    witnessScript: program.toJSON()
  };
};

RPC.prototype.validateAddress = async function validateAddress(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'validateaddress "wmccaddress"');

  const valid = new Validator([args]);
  const str = valid.str(0, '');

  let addr;
  try {
    addr = Address.fromString(str, this.network);
  } catch (e) {
    return {
      isvalid: false
    };
  }

  const script = Script.fromAddress(addr);

  return {
    isvalid: true,
    address: addr.toString(this.network),
    scriptPubKey: script.toJSON(),
    ismine: false,
    iswatchonly: false
  };
};

RPC.prototype.verifyMessage = async function verifyMessage(args, help) {
  if (help || args.length !== 3) {
    throw new RPCError(errs.MISC_ERROR,
      'verifymessage "wmccaddress" "signature" "message"');
  }

  const valid = new Validator([args]);
  const b58 = valid.str(0, '');
  const sig = valid.buf(1, null, 'base64');
  const str = valid.str(2);

  if (!sig || !str)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid parameters.');

  const addr = parseAddress(b58, this.network);
  const msg = Buffer.from(MAGIC_STRING + str, 'utf8');
  const hash = digest.hash256(msg);

  const key = secp256k1.recover(hash, sig, 0, true);

  if (!key)
    return false;

  return ccmp(digest.hash160(key), addr.hash);
};

RPC.prototype.signMessageWithPrivkey = async function signMessageWithPrivkey(args, help) {
  if (help || args.length !== 2) {
    throw new RPCError(errs.MISC_ERROR,
      'signmessagewithprivkey "privkey" "message"');
  }

  const valid = new Validator([args]);
  const wif = valid.str(0, '');
  const str = valid.str(1, '');

  const key = parseSecret(wif, this.network);
  const msg = Buffer.from(MAGIC_STRING + str, 'utf8');
  const hash = digest.hash256(msg);
  const sig = key.sign(hash);

  return sig.toString('base64');
};

RPC.prototype.estimateFee = async function estimateFee(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'estimatefee nblocks');

  const valid = new Validator([args]);
  const blocks = valid.u32(0, 1);

  if (!this.fees)
    throw new RPCError(errs.MISC_ERROR, 'Fee estimation not available.');

  const fee = this.fees.estimateFee(blocks, false);

  if (fee === 0)
    return -1;

  return Amount.wmcc(fee, true);
};

RPC.prototype.estimatePriority = async function estimatePriority(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'estimatepriority nblocks');

  const valid = new Validator([args]);
  const blocks = valid.u32(0, 1);

  if (!this.fees)
    throw new RPCError(errs.MISC_ERROR, 'Priority estimation not available.');

  return this.fees.estimatePriority(blocks, false);
};

RPC.prototype.estimateSmartFee = async function estimateSmartFee(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'estimatesmartfee nblocks');

  const valid = new Validator([args]);
  const blocks = valid.u32(0, 1);

  if (!this.fees)
    throw new RPCError(errs.MISC_ERROR, 'Fee estimation not available.');

  let fee = this.fees.estimateFee(blocks, true);

  if (fee === 0)
    fee = -1;
  else
    fee = Amount.wmcc(fee, true);

  return {
    fee: fee,
    blocks: blocks
  };
};

RPC.prototype.estimateSmartPriority = async function estimateSmartPriority(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'estimatesmartpriority nblocks');

  const valid = new Validator([args]);
  const blocks = valid.u32(0, 1);

  if (!this.fees)
    throw new RPCError(errs.MISC_ERROR, 'Priority estimation not available.');

  const pri = this.fees.estimatePriority(blocks, true);

  return {
    priority: pri,
    blocks: blocks
  };
};

RPC.prototype.invalidateBlock = async function invalidateBlock(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'invalidateblock "hash"');

  const valid = new Validator([args]);
  const hash = valid.hash(0);

  if (!hash)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid block hash.');

  await this.chain.invalidate(hash);

  return null;
};

RPC.prototype.reconsiderBlock = async function reconsiderBlock(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'reconsiderblock "hash"');

  const valid = new Validator([args]);
  const hash = valid.hash(0);

  if (!hash)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid block hash.');

  this.chain.removeInvalid(hash);

  return null;
};

RPC.prototype.setMockTime = async function setMockTime(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'setmocktime timestamp');

  const valid = new Validator([args]);
  const time = valid.u32(0);

  if (time == null)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid timestamp.');

  this.network.time.offset = 0;

  const delta = this.network.now() - time;

  this.network.time.offset = -delta;

  return null;
};

RPC.prototype.getMemoryInfo = async function getMemoryInfo(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'getmemoryinfo');

  return util.memoryUsage();
};

RPC.prototype.setLogLevel = async function setLogLevel(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'setloglevel "level"');

  const valid = new Validator([args]);
  const level = valid.str(0, '');

  this.logger.setLevel(level);

  return null;
};

/*
 * Helpers
 */

RPC.prototype.handleLongpoll = async function handleLongpoll(lpid) {
  if (lpid.length !== 74)
    throw new RPCError(errs.INVALID_PARAMETER, 'Invalid longpoll ID.');

  const watched = lpid.slice(0, 64);
  const lastTX = parseInt(lpid.slice(64, 74), 10);

  if (!util.isHex(watched) || !util.isU32(lastTX))
    throw new RPCError(errs.INVALID_PARAMETER, 'Invalid longpoll ID.');

  const hash = util.revHex(watched);

  if (this.chain.tip.hash !== hash)
    return;

  await this.longpoll();
};

RPC.prototype.longpoll = function longpoll() {
  return new Promise((resolve, reject) => {
    this.pollers.push(co.job(resolve, reject));
  });
};

RPC.prototype.refreshBlock = function refreshBlock() {
  const pollers = this.pollers;

  this.attempt = null;
  this.lastActivity = 0;
  this.merkleMap.clear();
  this.nonce1 = 0;
  this.nonce2 = 0;
  this.pollers = [];

  for (const job of pollers)
    job.resolve();
};

RPC.prototype.bindChain = function bindChain() {
  if (this.boundChain)
    return;

  this.boundChain = true;

  this.node.on('connect', () => {
    if (!this.attempt)
      return;

    this.refreshBlock();
  });

  if (!this.mempool)
    return;

  this.node.on('tx', () => {
    if (!this.attempt)
      return;

    if (util.now() - this.lastActivity > 10)
      this.refreshBlock();
  });
};

RPC.prototype.getTemplate = async function getTemplate() {
  this.bindChain();

  let attempt = this.attempt;

  if (attempt) {
    this.miner.updateTime(attempt);
  } else {
    attempt = await this.miner.createBlock();
    this.attempt = attempt;
    this.lastActivity = util.now();
  }

  return attempt;
};

RPC.prototype.updateWork = async function updateWork() {
  this.bindChain();

  let attempt = this.attempt;

  if (attempt) {
    if (attempt.address.isNull()) {
      throw new RPCError(errs.MISC_ERROR,
        'No addresses available for coinbase.');
    }

    this.miner.updateTime(attempt);

    if (++this.nonce2 === 0x100000000) {
      this.nonce2 = 0;
      this.nonce1++;
    }

    const n1 = this.nonce1;
    const n2 = this.nonce2;

    const root = attempt.getRoot(n1, n2);
    const hash = root.toString('hex');

    this.merkleMap.set(hash, [n1, n2]);

    return attempt;
  }

  if (this.miner.addresses.length === 0) {
    throw new RPCError(errs.MISC_ERROR,
      'No addresses available for coinbase.');
  }

  attempt = await this.miner.createBlock();

  const n1 = this.nonce1;
  const n2 = this.nonce2;

  const root = attempt.getRoot(n1, n2);
  const hash = root.toString('hex');

  this.attempt = attempt;
  this.lastActivity = util.now();
  this.merkleMap.set(hash, [n1, n2]);

  return attempt;
};

RPC.prototype.addBlock = async function addBlock(block) {
  const unlock1 = await this.locker.lock();
  const unlock2 = await this.chain.locker.lock();
  try {
    return await this._addBlock(block);
  } finally {
    unlock2();
    unlock1();
  }
};

RPC.prototype._addBlock = async function _addBlock(block) {
  this.logger.info('Handling submitted block: %s.', block.rhash());

  const prev = await this.chain.getEntry(block.prevBlock);

  if (prev) {
    const state = await this.chain.getDeployments(block.time, prev);

    // Fix eloipool bug (witness nonce is not present).
    if (state.hasWitness() && block.getCommitmentHash()) {
      const tx = block.txs[0];
      const input = tx.inputs[0];
      if (!tx.hasWitness()) {
        this.logger.warning('Submitted block had no witness nonce.');
        this.logger.debug(tx);

        // Recreate witness nonce (all zeroes).
        input.witness.push(encoding.ZERO_HASH);
        input.witness.compile();

        tx.refresh();
        block.refresh();
      }
    }
  }

  let entry;
  try {
    entry = await this.chain._add(block);
  } catch (err) {
    if (err.type === 'VerifyError') {
      this.logger.warning('RPC block rejected: %s (%s).',
        block.rhash(), err.reason);
      return `rejected: ${err.reason}`;
    }
    throw err;
  }

  if (!entry) {
    this.logger.warning('RPC block rejected: %s (bad-prevblk).',
      block.rhash());
    return 'rejected: bad-prevblk';
  }

  return null;
};

RPC.prototype.totalTX = function totalTX() {
  return this.mempool ? this.mempool.map.size : 0;
};

RPC.prototype.getSoftforks = function getSoftforks() {
  return [
    toDeployment('bip34', 2, this.chain.state.hasBIP34()),
    toDeployment('bip66', 3, this.chain.state.hasBIP66()),
    toDeployment('bip65', 4, this.chain.state.hasCLTV())
  ];
};

RPC.prototype.getBIP9Softforks = async function getBIP9Softforks() {
  const tip = this.chain.tip;
  const forks = {};

  for (const deployment of this.network.deploys) {
    const state = await this.chain.getState(tip, deployment);
    let status;

    switch (state) {
      case common.thresholdStates.DEFINED:
        status = 'defined';
        break;
      case common.thresholdStates.STARTED:
        status = 'started';
        break;
      case common.thresholdStates.LOCKED_IN:
        status = 'locked_in';
        break;
      case common.thresholdStates.ACTIVE:
        status = 'active';
        break;
      case common.thresholdStates.FAILED:
        status = 'failed';
        break;
      default:
        assert(false, 'Bad state.');
        break;
    }

    forks[deployment.name] = {
      status: status,
      bit: deployment.bit,
      startTime: deployment.startTime,
      timeout: deployment.timeout
    };
  }

  return forks;
};

RPC.prototype.getHashRate = async function getHashRate(lookup, height) {
  let tip = this.chain.tip;

  if (height != null)
    tip = await this.chain.getEntry(height);

  if (!tip)
    return 0;

  assert(typeof lookup === 'number');
  assert(lookup >= 0);

  if (lookup === 0)
    lookup = tip.height % this.network.pow.retargetInterval + 1;

  if (lookup > tip.height)
    lookup = tip.height;

  let min = tip.time;
  let max = min;
  let entry = tip;

  for (let i = 0; i < lookup; i++) {
    entry = await this.chain.getPrevious(entry);

    if (!entry)
      throw new RPCError(errs.DATABASE_ERROR, 'Not found.');

    min = Math.min(entry.time, min);
    max = Math.max(entry.time, max);
  }

  const diff = max - min;

  if (diff === 0)
    return 0;

  const work = tip.chainwork.sub(entry.chainwork);

  return Number(work.toString()) / diff;
};

RPC.prototype.mineBlocks = async function mineBlocks(blocks, addr, tries) {
  const unlock = await this.locker.lock();
  try {
    return await this._mineBlocks(blocks, addr, tries);
  } finally {
    unlock();
  }
};

RPC.prototype._mineBlocks = async function _mineBlocks(blocks, addr, tries) {
  const hashes = [];

  for (let i = 0; i < blocks; i++) {
    const block = await this.miner.mineBlock(null, addr);
    const entry = await this.chain.add(block);
    assert(entry);
    hashes.push(entry.rhash());
  }

  return hashes;
};

RPC.prototype.findFork = async function findFork(entry) {
  while (entry) {
    if (await this.chain.isMainChain(entry))
      return entry;
    entry = await this.chain.getPrevious(entry);
  }
  throw new Error('Fork not found.');
};

RPC.prototype.txToJSON = function txToJSON(tx, entry) {
  let height = -1;
  let time = 0;
  let hash = null;
  let conf = 0;
  let coinbase = false;

  if (entry) {
    height = entry.height;
    time = entry.time;
    hash = entry.rhash();
    conf = this.chain.height - height + 1;
  }

  const vin = [];

  for (const input of tx.inputs) {
    const json = {
      coinbase: undefined,
      txid: undefined,
      scriptSig: undefined,
      txinwitness: undefined,
      sequence: input.sequence
    };

    if (tx.isCoinbase()) {
      json.coinbase = input.script.toJSON();
      coinbase = true;
    } else {
      json.txid = input.prevout.txid();
      json.vout = input.prevout.index;
      json.scriptSig = {
        asm: input.script.toASM(),
        hex: input.script.toJSON()
      };
    }

    if (input.witness.items.length > 0) {
      json.txinwitness = input.witness.items.map((item) => {
        return item.toString('hex');
      });
    }

    vin.push(json);
  }

  const vout = [];

  for (let i = 0; i < tx.outputs.length; i++) {
    const output = tx.outputs[i];
    vout.push({
      value: Amount.wmcc(output.value, true),
      n: i,
      scriptPubKey: this.scriptToJSON(output.script, true)
    });
  }

  return {
    txid: tx.txid(),
    hash: tx.wtxid(),
    size: tx.getSize(),
    vsize: tx.getVirtualSize(),
    version: tx.version,
    locktime: tx.locktime,
    vin: vin,
    vout: vout,
    coinbase: coinbase,
    blockhash: hash,
    confirmations: conf,
    time: time,
    blocktime: time,
    hex: undefined
  };
};

RPC.prototype.scriptToJSON = function scriptToJSON(script, hex) {
  const type = script.getType();

  const json = {
    asm: script.toASM(),
    hex: undefined,
    type: Script.typesByVal[type],
    reqSigs: 1,
    addresses: [],
    p2sh: undefined
  };

  if (hex)
    json.hex = script.toJSON();

  const [m] = script.getMultisig();

  if (m !== -1)
    json.reqSigs = m;

  const addr = script.getAddress();

  if (addr) {
    const str = addr.toString(this.network);
    json.addresses.push(str);
  }

  return json;
};

RPC.prototype.headerToJSON = async function headerToJSON(entry) {
  const mtp = await this.chain.getMedianTime(entry);
  const next = await this.chain.getNextHash(entry.hash);

  return {
    hash: entry.rhash(),
    confirmations: this.chain.height - entry.height + 1,
    height: entry.height,
    version: entry.version,
    versionHex: util.hex32(entry.version),
    merkleroot: util.revHex(entry.merkleRoot),
    time: entry.time,
    mediantime: mtp,
    bits: entry.bits,
    difficulty: toDifficulty(entry.bits),
    chainwork: entry.chainwork.toString('hex', 64),
    previousblockhash: entry.prevBlock !== encoding.NULL_HASH
      ? util.revHex(entry.prevBlock)
      : null,
    nextblockhash: next ? util.revHex(next) : null
  };
};

RPC.prototype.blockToJSON = async function blockToJSON(entry, block, details) {
  const mtp = await this.chain.getMedianTime(entry);
  const next = await this.chain.getNextHash(entry.hash);
  const txs = [];

  for (const tx of block.txs) {
    if (details) {
      const json = this.txToJSON(tx, entry);
      txs.push(json);
      continue;
    }
    txs.push(tx.txid());
  }

  return {
    hash: entry.rhash(),
    confirmations: this.chain.height - entry.height + 1,
    strippedsize: block.getBaseSize(),
    size: block.getSize(),
    weight: block.getWeight(),
    height: entry.height,
    version: entry.version,
    nonce: block.nonce,
    versionHex: util.hex32(entry.version),
    merkleroot: util.revHex(entry.merkleRoot),
    coinbase: block.txs[0].inputs[0].script.toJSON(),
    tx: txs,
    time: entry.time,
    mediantime: mtp,
    bits: entry.bits,
    difficulty: toDifficulty(entry.bits),
    chainwork: entry.chainwork.toString('hex', 64),
    previousblockhash: entry.prevBlock !== encoding.NULL_HASH
      ? util.revHex(entry.prevBlock)
      : null,
    nextblockhash: next ? util.revHex(next) : null
  };
};

RPC.prototype.entryToJSON = function entryToJSON(entry) {
  return {
    size: entry.size,
    fee: Amount.wmcc(entry.deltaFee, true),
    modifiedfee: 0,
    time: entry.time,
    height: entry.height,
    startingpriority: entry.priority,
    currentpriority: entry.getPriority(this.chain.height),
    descendantcount: this.mempool.countDescendants(entry),
    descendantsize: entry.descSize,
    descendantfees: entry.descFee,
    ancestorcount: this.mempool.countAncestors(entry),
    ancestorsize: 0,
    ancestorfees: 0,
    depends: this.mempool.getDepends(entry.tx).map(util.revHex)
  };
};

/*
 * Helpers
 */

function swap32(data) {
  for (let i = 0; i < data.length; i += 4) {
    const field = data.readUInt32LE(i, true);
    data.writeUInt32BE(field, i, true);
  }
  return data;
}

function toDeployment(id, version, status) {
  return {
    id: id,
    version: version,
    reject: {
      status: status
    }
  };
}

function parseAddress(raw, network) {
  try {
    return Address.fromString(raw, network);
  } catch (e) {
    throw new RPCError(errs.INVALID_ADDRESS_OR_KEY, 'Invalid address.');
  }
}

function parseSecret(raw, network) {
  try {
    return KeyRing.fromSecret(raw, network);
  } catch (e) {
    throw new RPCError(errs.INVALID_ADDRESS_OR_KEY, 'Invalid key.');
  }
}

function parseIP(addr, network) {
  try {
    return IP.fromHostname(addr, network.port);
  } catch (e) {
    throw new RPCError(errs.CLIENT_INVALID_IP_OR_SUBNET,
      'Invalid IP address or subnet.');
  }
}

function parseNetAddress(addr, network) {
  try {
    return NetAddress.fromHostname(addr, network);
  } catch (e) {
    throw new RPCError(errs.CLIENT_INVALID_IP_OR_SUBNET,
      'Invalid IP address or subnet.');
  }
}

function toDifficulty(bits) {
  let shift = (bits >>> 24) & 0xff;
  let diff = 0x0000ffff / (bits & 0x00ffffff);

  while (shift < 29) {
    diff *= 256.0;
    shift++;
  }

  while (shift > 29) {
    diff /= 256.0;
    shift--;
  }

  return diff;
}

/*
 * Expose
 */

module.exports = RPC;


/***/ }),
/* 116 */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * fees.js - fee estimation for wmcc_core.
 *
 * Ported from:
 * https://github.com/bitcoin/bitcoin/blob/master/src/policy/fees.cpp
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const consensus = __webpack_require__(7);
const policy = __webpack_require__(19);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const encoding = __webpack_require__(3);
const Logger = __webpack_require__(34);

/*
 * Constants
 */

const MAX_BLOCK_CONFIRMS = 15; /* 25 */
const DEFAULT_DECAY = 0.998;
const MIN_SUCCESS_PCT = 0.95;
const UNLIKELY_PCT = 0.5;
const SUFFICIENT_FEETXS = 1;
const SUFFICIENT_PRITXS = 0.2;
const MIN_FEERATE = 10;
const MAX_FEERATE = 1e6; /* 1e7 */
const INF_FEERATE = consensus.getMaxMoney();
const MIN_PRIORITY = 10;
const MAX_PRIORITY = 1e16;
const INF_PRIORITY = 1e9 * consensus.getMaxMoney();
const FEE_SPACING = 1.1;
const PRI_SPACING = 2;

/**
 * Confirmation stats.
 * @alias module:mempool.ConfirmStats
 * @constructor
 * @param {String} type
 * @param {Logger?} logger
 */

function ConfirmStats(type, logger) {
  if (!(this instanceof ConfirmStats))
    return new ConfirmStats(type, logger);

  this.logger = Logger.global;

  this.type = type;
  this.decay = 0;
  this.maxConfirms = 0;

  this.buckets = new Float64Array(0);
  this.bucketMap = new DoubleMap();

  this.confAvg = [];
  this.curBlockConf = [];
  this.unconfTX = [];

  this.oldUnconfTX = new Int32Array(0);
  this.curBlockTX = new Int32Array(0);
  this.txAvg = new Float64Array(0);
  this.curBlockVal = new Float64Array(0);
  this.avg = new Float64Array(0);

  if (logger) {
    assert(typeof logger === 'object');
    this.logger = logger.context('fees');
  }
}

/**
 * Initialize stats.
 * @param {Array} buckets
 * @param {Number} maxConfirms
 * @param {Number} decay
 * @private
 */

ConfirmStats.prototype.init = function init(buckets, maxConfirms, decay) {
  this.maxConfirms = maxConfirms;
  this.decay = decay;

  this.buckets = new Float64Array(buckets.length);
  this.bucketMap = new DoubleMap();

  for (let i = 0; i < buckets.length; i++) {
    this.buckets[i] = buckets[i];
    this.bucketMap.insert(buckets[i], i);
  }

  this.confAvg = new Array(maxConfirms);
  this.curBlockConf = new Array(maxConfirms);
  this.unconfTX = new Array(maxConfirms);

  for (let i = 0; i < maxConfirms; i++) {
    this.confAvg[i] = new Float64Array(buckets.length);
    this.curBlockConf[i] = new Int32Array(buckets.length);
    this.unconfTX[i] = new Int32Array(buckets.length);
  }

  this.oldUnconfTX = new Int32Array(buckets.length);
  this.curBlockTX = new Int32Array(buckets.length);
  this.txAvg = new Float64Array(buckets.length);
  this.curBlockVal = new Float64Array(buckets.length);
  this.avg = new Float64Array(buckets.length);
};

/**
 * Clear data for the current block.
 * @param {Number} height
 */

ConfirmStats.prototype.clearCurrent = function clearCurrent(height) {
  for (let i = 0; i < this.buckets.length; i++) {
    this.oldUnconfTX[i] = this.unconfTX[height % this.unconfTX.length][i];
    this.unconfTX[height % this.unconfTX.length][i] = 0;
    for (let j = 0; j < this.curBlockConf.length; j++)
      this.curBlockConf[j][i] = 0;
    this.curBlockTX[i] = 0;
    this.curBlockVal[i] = 0;
  }
};

/**
 * Record a rate or priority based on number of blocks to confirm.
 * @param {Number} blocks - Blocks to confirm.
 * @param {Rate|Number} val - Rate or priority.
 */

ConfirmStats.prototype.record = function record(blocks, val) {
  if (blocks < 1)
    return;

  const bucketIndex = this.bucketMap.search(val);

  for (let i = blocks; i <= this.curBlockConf.length; i++)
    this.curBlockConf[i - 1][bucketIndex]++;

  this.curBlockTX[bucketIndex]++;
  this.curBlockVal[bucketIndex] += val;
};

/**
 * Update moving averages.
 */

ConfirmStats.prototype.updateAverages = function updateAverages() {
  for (let i = 0; i < this.buckets.length; i++) {
    for (let j = 0; j < this.confAvg.length; j++) {
      this.confAvg[j][i] =
        this.confAvg[j][i] * this.decay + this.curBlockConf[j][i];
    }
    this.avg[i] = this.avg[i] * this.decay + this.curBlockVal[i];
    this.txAvg[i] = this.txAvg[i] * this.decay + this.curBlockTX[i];
  }
};

/**
 * Estimate the median value for rate or priority.
 * @param {Number} target - Confirmation target.
 * @param {Number} needed - Sufficient tx value.
 * @param {Number} breakpoint - Success break point.
 * @param {Boolean} greater - Whether to look for lowest value.
 * @param {Number} height - Block height.
 * @returns {Rate|Number} Returns -1 on error.
 */

ConfirmStats.prototype.estimateMedian = function estimateMedian(target, needed, breakpoint, greater, height) {
  const max = this.buckets.length - 1;
  const start = greater ? max : 0;
  const step = greater ? -1 : 1;
  const bins = this.unconfTX.length;
  let conf = 0;
  let total = 0;
  let extra = 0;
  let near = start;
  let far = start;
  let bestNear = start;
  let bestFar = start;
  let found = false;
  let median = -1;
  let sum = 0;

  for (let i = start; i >= 0 && i <= max; i += step) {
    far = i;
    conf += this.confAvg[target - 1][i];
    total += this.txAvg[i];

    for (let j = target; j < this.maxConfirms; j++)
      extra += this.unconfTX[Math.max(height - j, 0) % bins][i];

    extra += this.oldUnconfTX[i];

    if (total >= needed / (1 - this.decay)) {
      const perc = conf / (total + extra);

      if (greater && perc < breakpoint)
        break;

      if (!greater && perc > breakpoint)
        break;

      found = true;
      conf = 0;
      total = 0;
      extra = 0;
      bestNear = near;
      bestFar = far;
      near = i + step;
    }
  }

  const minBucket = bestNear < bestFar ? bestNear : bestFar;
  const maxBucket = bestNear > bestFar ? bestNear : bestFar;

  for (let i = minBucket; i <= maxBucket; i++)
    sum += this.txAvg[i];

  if (found && sum !== 0) {
    sum = sum / 2;
    for (let j = minBucket; j <= maxBucket; j++) {
      if (this.txAvg[j] < sum) {
        sum -= this.txAvg[j];
      } else {
        median = this.avg[j] / this.txAvg[j];
        break;
      }
    }
  }

  return median;
};

/**
 * Add a transaction's rate/priority to be tracked.
 * @param {Number} height - Block height.
 * @param {Number} val
 * @returns {Number} Bucket index.
 */

ConfirmStats.prototype.addTX = function addTX(height, val) {
  const bucketIndex = this.bucketMap.search(val);
  const blockIndex = height % this.unconfTX.length;
  this.unconfTX[blockIndex][bucketIndex]++;
  this.logger.spam('Adding tx to %s.', this.type);
  return bucketIndex;
};

/**
 * Remove a transaction from tracking.
 * @param {Number} entryHeight
 * @param {Number} bestHeight
 * @param {Number} bucketIndex
 */

ConfirmStats.prototype.removeTX = function removeTX(entryHeight, bestHeight, bucketIndex) {
  let blocksAgo = bestHeight - entryHeight;

  if (bestHeight === 0)
    blocksAgo = 0;

  if (blocksAgo < 0) {
    this.logger.debug('Blocks ago is negative for mempool tx.');
    return;
  }

  if (blocksAgo >= this.unconfTX.length) {
    if (this.oldUnconfTX[bucketIndex] > 0) {
      this.oldUnconfTX[bucketIndex]--;
    } else {
      this.logger.debug('Mempool tx removed >25 blocks (bucket=%d).',
        bucketIndex);
    }
  } else {
    const blockIndex = entryHeight % this.unconfTX.length;
    if (this.unconfTX[blockIndex][bucketIndex] > 0) {
      this.unconfTX[blockIndex][bucketIndex]--;
    } else {
      this.logger.debug('Mempool tx removed (block=%d, bucket=%d).',
       blockIndex, bucketIndex);
    }
  }
};

/**
 * Get serialization size.
 * @returns {Number}
 */

ConfirmStats.prototype.getSize = function getSize() {
  let size = 0;

  size += 8;

  size += sizeArray(this.buckets);
  size += sizeArray(this.avg);
  size += sizeArray(this.txAvg);

  size += encoding.sizeVarint(this.maxConfirms);

  for (let i = 0; i < this.maxConfirms; i++)
    size += sizeArray(this.confAvg[i]);

  return size;
};

/**
 * Serialize confirm stats.
 * @returns {Buffer}
 */

ConfirmStats.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  const bw = new StaticWriter(size);

  bw.writeDouble(this.decay);
  writeArray(bw, this.buckets);
  writeArray(bw, this.avg);
  writeArray(bw, this.txAvg);
  bw.writeVarint(this.maxConfirms);

  for (let i = 0; i < this.maxConfirms; i++)
    writeArray(bw, this.confAvg[i]);

  return bw.render();
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 * @returns {ConfirmStats}
 */

ConfirmStats.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data);
  const decay = br.readDouble();
  const buckets = readArray(br);
  const avg = readArray(br);
  const txAvg = readArray(br);
  const maxConfirms = br.readVarint();
  const confAvg = new Array(maxConfirms);

  for (let i = 0; i < maxConfirms; i++)
    confAvg[i] = readArray(br);

  if (decay <= 0 || decay >= 1)
    throw new Error('Decay must be between 0 and 1 (non-inclusive).');

  if (buckets.length <= 1 || buckets.length > 1000)
    throw new Error('Must have between 2 and 1000 fee/pri buckets.');

  if (avg.length !== buckets.length)
    throw new Error('Mismatch in fee/pri average bucket count.');

  if (txAvg.length !== buckets.length)
    throw new Error('Mismatch in tx count bucket count.');

  if (maxConfirms <= 0 || maxConfirms > 6 * 24 * 7)
    throw new Error('Must maintain estimates for between 1 and 1008 confirms.');

  for (let i = 0; i < maxConfirms; i++) {
    if (confAvg[i].length !== buckets.length)
      throw new Error('Mismatch in fee/pri conf average bucket count.');
  }

  this.init(buckets, maxConfirms, decay);

  this.avg = avg;
  this.txAvg = txAvg;
  this.confAvg = confAvg;

  return this;
};

/**
 * Instantiate confirm stats from serialized data.
 * @param {Buffer} data
 * @param {String} type
 * @param {Logger?} logger
 * @returns {ConfirmStats}
 */

ConfirmStats.fromRaw = function fromRaw(data, type, logger) {
  return new ConfirmStats(type, logger).fromRaw(data);
};

/**
 * Estimator for fees and priority.
 * @alias module:mempool.PolicyEstimator
 * @constructor
 * @param {Logger?} logger
 */

function PolicyEstimator(logger) {
  if (!(this instanceof PolicyEstimator))
    return new PolicyEstimator(logger);

  this.logger = Logger.global;

  this.minTrackedFee = MIN_FEERATE;
  this.minTrackedPri = MIN_PRIORITY;

  this.feeStats = new ConfirmStats('FeeRate');
  this.priStats = new ConfirmStats('Priority');

  this.feeUnlikely = 0;
  this.feeLikely = INF_FEERATE;
  this.priUnlikely = 0;
  this.priLikely = INF_PRIORITY;

  this.map = new Map();
  this.bestHeight = 0;

  if (policy.MIN_RELAY >= MIN_FEERATE)
    this.minTrackedFee = policy.MIN_RELAY;

  if (policy.FREE_THRESHOLD >= MIN_PRIORITY)
    this.minTrackedPri = policy.FREE_THRESHOLD;

  if (logger) {
    assert(typeof logger === 'object');
    this.logger = logger.context('fees');
    this.feeStats.logger = this.logger;
    this.priStats.logger = this.logger;
  }
}

/**
 * Serialization version.
 * @const {Number}
 * @default
 */

PolicyEstimator.VERSION = 0;

/**
 * Initialize the estimator.
 * @private
 */

PolicyEstimator.prototype.init = function init() {
  const minFee = this.minTrackedFee;
  const minPri = this.minTrackedPri;

  const fee = [];

  for (let b = minFee; b <= MAX_FEERATE; b *= FEE_SPACING)
    fee.push(b);

  fee.push(INF_FEERATE);

  const priority = [];

  for (let b = minPri; b <= MAX_PRIORITY; b *= PRI_SPACING)
    priority.push(b);

  priority.push(INF_PRIORITY);

  this.feeStats.init(fee, MAX_BLOCK_CONFIRMS, DEFAULT_DECAY);
  this.priStats.init(priority, MAX_BLOCK_CONFIRMS, DEFAULT_DECAY);
};

/**
 * Reset the estimator.
 */

PolicyEstimator.prototype.reset = function reset() {
  this.feeUnlikely = 0;
  this.feeLikely = INF_FEERATE;
  this.priUnlikely = 0;
  this.priLikely = INF_PRIORITY;

  this.map.clear();
  this.bestHeight = 0;

  this.init();
};

/**
 * Stop tracking a tx. Remove from map.
 * @param {Hash} hash
 */

PolicyEstimator.prototype.removeTX = function removeTX(hash) {
  const item = this.map.get(hash);

  if (!item) {
    this.logger.spam('Mempool tx %s not found.', util.revHex(hash));
    return;
  }

  this.feeStats.removeTX(item.blockHeight, this.bestHeight, item.bucketIndex);

  this.map.delete(hash);
};

/**
 * Test whether a fee should be used for calculation.
 * @param {Amount} fee
 * @param {Number} priority
 * @returns {Boolean}
 */

PolicyEstimator.prototype.isFeePoint = function isFeePoint(fee, priority) {
  if ((priority < this.minTrackedPri && fee >= this.minTrackedFee)
      || (priority < this.priUnlikely && fee > this.feeLikely)) {
    return true;
  }
  return false;
};

/**
 * Test whether a priority should be used for calculation.
 * @param {Amount} fee
 * @param {Number} priority
 * @returns {Boolean}
 */

PolicyEstimator.prototype.isPriPoint = function isPriPoint(fee, priority) {
  if ((fee < this.minTrackedFee && priority >= this.minTrackedPri)
      || (fee < this.feeUnlikely && priority > this.priLikely)) {
    return true;
  }
  return false;
};

/**
 * Process a mempool entry.
 * @param {MempoolEntry} entry
 * @param {Boolean} current - Whether the chain is synced.
 */

PolicyEstimator.prototype.processTX = function processTX(entry, current) {
  const height = entry.height;
  const hash = entry.hash('hex');

  if (this.map.has(hash)) {
    this.logger.debug('Mempool tx %s already tracked.', entry.txid());
    return;
  }

  // Ignore reorgs.
  if (height < this.bestHeight)
    return;

  // Wait for chain to sync.
  if (!current)
    return;

  // Requires other mempool txs in order to be confirmed. Ignore.
  if (entry.dependencies)
    return;

  const fee = entry.getFee();
  const rate = entry.getRate();
  const priority = entry.getPriority(height);

  this.logger.spam('Processing mempool tx %s.', entry.txid());

  if (fee === 0 || this.isPriPoint(rate, priority)) {
    const item = new StatEntry();
    item.blockHeight = height;
    item.bucketIndex = this.priStats.addTX(height, priority);
    this.map.set(hash, item);
  } else if (this.isFeePoint(rate, priority)) {
    const item = new StatEntry();
    item.blockHeight = height;
    item.bucketIndex = this.feeStats.addTX(height, rate);
    this.map.set(hash, item);
  } else {
    this.logger.spam('Not adding tx %s.', entry.txid());
  }
};

/**
 * Process an entry being removed from the mempool.
 * @param {Number} height - Block height.
 * @param {MempoolEntry} entry
 */

PolicyEstimator.prototype.processBlockTX = function processBlockTX(height, entry) {
  // Requires other mempool txs in order to be confirmed. Ignore.
  if (entry.dependencies)
    return;

  const blocks = height - entry.height;

  if (blocks <= 0) {
    this.logger.debug(
      'Block tx %s had negative blocks to confirm (%d, %d).',
      entry.txid(),
      height,
      entry.height);
    return;
  }

  const fee = entry.getFee();
  const rate = entry.getRate();
  const priority = entry.getPriority(height);

  if (fee === 0 || this.isPriPoint(rate, priority))
    this.priStats.record(blocks, priority);
  else if (this.isFeePoint(rate, priority))
    this.feeStats.record(blocks, rate);
};

/**
 * Process a block of transaction entries being removed from the mempool.
 * @param {Number} height - Block height.
 * @param {MempoolEntry[]} entries
 * @param {Boolean} current - Whether the chain is synced.
 */

PolicyEstimator.prototype.processBlock = function processBlock(height, entries, current) {
  // Ignore reorgs.
  if (height <= this.bestHeight)
    return;

  this.bestHeight = height;

  if (entries.length === 0)
    return;

  // Wait for chain to sync.
  if (!current)
    return;

  this.logger.debug('Recalculating dynamic cutoffs.');

  this.feeLikely = this.feeStats.estimateMedian(
    2, SUFFICIENT_FEETXS, MIN_SUCCESS_PCT,
    true, height);

  if (this.feeLikely === -1)
    this.feeLikely = INF_FEERATE;

  this.feeUnlikely = this.feeStats.estimateMedian(
    10, SUFFICIENT_FEETXS, UNLIKELY_PCT,
    false, height);

  if (this.feeUnlikely === -1)
    this.feeUnlikely = 0;

  this.priLikely = this.priStats.estimateMedian(
    2, SUFFICIENT_PRITXS, MIN_SUCCESS_PCT,
    true, height);

  if (this.priLikely === -1)
    this.priLikely = INF_PRIORITY;

  this.priUnlikely = this.priStats.estimateMedian(
    10, SUFFICIENT_PRITXS, UNLIKELY_PCT,
    false, height);

  if (this.priUnlikely === -1)
    this.priUnlikely = 0;

  this.feeStats.clearCurrent(height);
  this.priStats.clearCurrent(height);

  for (const entry of entries)
    this.processBlockTX(height, entry);

  this.feeStats.updateAverages();
  this.priStats.updateAverages();

  this.logger.debug('Done updating estimates'
    + ' for %d confirmed entries. New mempool map size %d.',
    entries.length, this.map.size);

  this.logger.debug('New fee rate: %d.', this.estimateFee());
};

/**
 * Estimate a fee rate.
 * @param {Number} [target=1] - Confirmation target.
 * @param {Boolean} [smart=true] - Smart estimation.
 * @returns {Rate}
 */

PolicyEstimator.prototype.estimateFee = function estimateFee(target, smart) {
  if (!target)
    target = 1;

  if (smart == null)
    smart = true;

  assert(util.isU32(target), 'Target must be a number.');
  assert(target <= this.feeStats.maxConfirms,
    'Too many confirmations for estimate.');

  if (!smart) {
    const rate = this.feeStats.estimateMedian(
      target, SUFFICIENT_FEETXS, MIN_SUCCESS_PCT,
      true, this.bestHeight);

    if (rate < 0)
      return 0;

    return Math.floor(rate);
  }

  let rate = -1;
  while (rate < 0 && target <= this.feeStats.maxConfirms) {
    rate = this.feeStats.estimateMedian(
      target++, SUFFICIENT_FEETXS, MIN_SUCCESS_PCT,
      true, this.bestHeight);
  }

  target -= 1;

  if (rate < 0)
    return 0;

  return Math.floor(rate);
};

/**
 * Estimate a priority.
 * @param {Number} [target=1] - Confirmation target.
 * @param {Boolean} [smart=true] - Smart estimation.
 * @returns {Number}
 */

PolicyEstimator.prototype.estimatePriority = function estimatePriority(target, smart) {
  if (!target)
    target = 1;

  if (smart == null)
    smart = true;

  assert(util.isU32(target), 'Target must be a number.');
  assert(target <= this.priStats.maxConfirms,
    'Too many confirmations for estimate.');

  if (!smart) {
    const priority = this.priStats.estimateMedian(
      target, SUFFICIENT_PRITXS, MIN_SUCCESS_PCT,
      true, this.bestHeight);
    return Math.floor(priority);
  }

  let priority = -1;
  while (priority < 0 && target <= this.priStats.maxConfirms) {
    priority = this.priStats.estimateMedian(
      target++, SUFFICIENT_PRITXS, MIN_SUCCESS_PCT,
      true, this.bestHeight);
  }

  target -= 1;

  if (priority < 0)
    return 0;

  return Math.floor(priority);
};

/**
 * Get serialization size.
 * @returns {Number}
 */

PolicyEstimator.prototype.getSize = function getSize() {
  let size = 0;
  size += 5;
  size += encoding.sizeVarlen(this.feeStats.getSize());
  return size;
};

/**
 * Serialize the estimator.
 * @returns {Buffer}
 */

PolicyEstimator.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  const bw = new StaticWriter(size);

  bw.writeU8(PolicyEstimator.VERSION);
  bw.writeU32(this.bestHeight);
  bw.writeVarBytes(this.feeStats.toRaw());

  return bw.render();
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 * @returns {PolicyEstimator}
 */

PolicyEstimator.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data);

  if (br.readU8() !== PolicyEstimator.VERSION)
    throw new Error('Bad serialization version for estimator.');

  this.bestHeight = br.readU32();
  this.feeStats.fromRaw(br.readVarBytes());

  return this;
};

/**
 * Instantiate a policy estimator from serialized data.
 * @param {Buffer} data
 * @param {Logger?} logger
 * @returns {PolicyEstimator}
 */

PolicyEstimator.fromRaw = function fromRaw(data, logger) {
  return new PolicyEstimator(logger).fromRaw(data);
};

/**
 * Inject properties from estimator.
 * @param {PolicyEstimator} estimator
 * @returns {PolicyEstimator}
 */

PolicyEstimator.prototype.inject = function inject(estimator) {
  this.bestHeight = estimator.bestHeight;
  this.feeStats = estimator.feeStats;
  return this;
};

/**
 * StatEntry
 * @alias module:mempool.StatEntry
 * @ignore
 */

function StatEntry() {
  this.blockHeight = -1;
  this.bucketIndex = -1;
}

/**
 * DoubleMap
 * @alias module:mempool.DoubleMap
 * @ignore
 */

function DoubleMap() {
  if (!(this instanceof DoubleMap))
    return new DoubleMap();

  this.buckets = [];
}

DoubleMap.prototype.insert = function insert(key, value) {
  const i = util.binarySearch(this.buckets, key, compare, true);
  this.buckets.splice(i, 0, [key, value]);
};

DoubleMap.prototype.search = function search(key) {
  const i = util.binarySearch(this.buckets, key, compare, true);
  assert(this.buckets.length !== 0, 'Cannot search.');
  return this.buckets[i][1];
};

/*
 * Helpers
 */

function compare(a, b) {
  return a[0] - b;
}

function sizeArray(buckets) {
  const size = encoding.sizeVarint(buckets.length);
  return size + buckets.length * 8;
}

function writeArray(bw, buckets) {
  bw.writeVarint(buckets.length);

  for (let i = 0; i < buckets.length; i++)
    bw.writeDouble(buckets[i]);
}

function readArray(br) {
  const buckets = new Float64Array(br.readVarint());

  for (let i = 0; i < buckets.length; i++)
    buckets[i] = br.readDouble();

  return buckets;
}

/*
 * Expose
 */

exports = PolicyEstimator;
exports.PolicyEstimator = PolicyEstimator;
exports.ConfirmStats = ConfirmStats;

module.exports = exports;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * rollingfilter.js - rolling bloom filter for wmcc_core.
 */



const assert = __webpack_require__(0);
const murmur3 = __webpack_require__(66);
const sum32 = murmur3.sum32;
const mul32 = murmur3.mul32;
const DUMMY = Buffer.alloc(0);

/**
 * A rolling bloom filter used internally
 * (do not relay this on the p2p network).
 * @alias module:utils.RollingFilter
 * @constructor
 * @param {Number} items - Expected number of items.
 * @param {Number} rate - False positive rate (0.0-1.0).
 */

function RollingFilter(items, rate) {
  if (!(this instanceof RollingFilter))
    return new RollingFilter(items, rate);

  this.entries = 0;
  this.generation = 1;
  this.n = 0;
  this.limit = 0;
  this.size = 0;
  this.items = 0;
  this.tweak = 0;
  this.filter = DUMMY;

  if (items != null)
    this.fromRate(items, rate);
}

/**
 * Inject properties from items and FPR.
 * @private
 * @param {Number} items - Expected number of items.
 * @param {Number} rate - False positive rate (0.0-1.0).
 * @returns {RollingFilter}
 */

RollingFilter.prototype.fromRate = function fromRate(items, rate) {
  assert(typeof items === 'number', '`items` must be a number.');
  assert(items > 0, '`items` must be greater than zero.');
  assert(Number.isSafeInteger(items), '`items` must be an integer.');
  assert(typeof rate === 'number', '`rate` must be a number.');
  assert(rate >= 0 && rate <= 1, '`rate` must be between 0.0 and 1.0.');

  const logRate = Math.log(rate);

  const n = Math.max(1, Math.min(Math.round(logRate / Math.log(0.5)), 50));
  const limit = (items + 1) / 2 | 0;

  const max = limit * 3;

  let size = -1 * n * max / Math.log(1.0 - Math.exp(logRate / n));
  size = Math.ceil(size);

  items = ((size + 63) / 64 | 0) << 1;
  items >>>= 0;
  items = Math.max(1, items);

  const tweak = (Math.random() * 0x100000000) >>> 0;

  const filter = Buffer.allocUnsafe(items * 8);
  filter.fill(0);

  this.n = n;
  this.limit = limit;
  this.size = size;
  this.items = items;
  this.tweak = tweak;
  this.filter = filter;

  return this;
};

/**
 * Instantiate rolling filter from items and FPR.
 * @param {Number} items - Expected number of items.
 * @param {Number} rate - False positive rate (0.0-1.0).
 * @returns {RollingFilter}
 */

RollingFilter.fromRate = function fromRate(items, rate) {
  return new RollingFilter().fromRate(items, rate);
};

/**
 * Perform the mumur3 hash on data.
 * @param {Buffer} val
 * @param {Number} seed
 * @returns {Number}
 */

RollingFilter.prototype.hash = function hash(val, n) {
  return murmur3(val, sum32(mul32(n, 0xfba4c795), this.tweak));
};

/**
 * Reset the filter.
 */

RollingFilter.prototype.reset = function reset() {
  if (this.entries === 0)
    return;

  this.entries = 0;
  this.generation = 1;
  this.filter.fill(0);
};

/**
 * Add data to the filter.
 * @param {Buffer|String}
 * @param {String?} enc - Can be any of the Buffer object's encodings.
 */

RollingFilter.prototype.add = function add(val, enc) {
  if (typeof val === 'string')
    val = Buffer.from(val, enc);

  if (this.entries === this.limit) {
    this.entries = 0;
    this.generation += 1;

    if (this.generation === 4)
      this.generation = 1;

    const m1 = (this.generation & 1) * 0xffffffff;
    const m2 = (this.generation >>> 1) * 0xffffffff;

    for (let i = 0; i < this.items; i += 2) {
      const pos1 = i * 8;
      const pos2 = (i + 1) * 8;
      const v1 = read(this.filter, pos1);
      const v2 = read(this.filter, pos2);
      const mhi = (v1.hi ^ m1) | (v2.hi ^ m2);
      const mlo = (v1.lo ^ m1) | (v2.lo ^ m2);

      v1.hi &= mhi;
      v1.lo &= mlo;
      v2.hi &= mhi;
      v2.lo &= mlo;

      write(this.filter, v1, pos1);
      write(this.filter, v2, pos2);
    }
  }

  this.entries += 1;

  for (let i = 0; i < this.n; i++) {
    const hash = this.hash(val, i);
    const bits = hash & 0x3f;
    const pos = (hash >>> 6) % this.items;
    const pos1 = (pos & ~1) * 8;
    const pos2 = (pos | 1) * 8;
    const bit = bits % 8;
    const oct = (bits - bit) / 8;

    this.filter[pos1 + oct] &= ~(1 << bit);
    this.filter[pos1 + oct] |= (this.generation & 1) << bit;

    this.filter[pos2 + oct] &= ~(1 << bit);
    this.filter[pos2 + oct] |= (this.generation >>> 1) << bit;
  }
};

/**
 * Test whether data is present in the filter.
 * @param {Buffer|String} val
 * @param {String?} enc - Can be any of the Buffer object's encodings.
 * @returns {Boolean}
 */

RollingFilter.prototype.test = function test(val, enc) {
  if (this.entries === 0)
    return false;

  if (typeof val === 'string')
    val = Buffer.from(val, enc);

  for (let i = 0; i < this.n; i++) {
    const hash = this.hash(val, i);
    const bits = hash & 0x3f;
    const pos = (hash >>> 6) % this.items;
    const pos1 = (pos & ~1) * 8;
    const pos2 = (pos | 1) * 8;
    const bit = bits % 8;
    const oct = (bits - bit) / 8;

    const bit1 = (this.filter[pos1 + oct] >>> bit) & 1;
    const bit2 = (this.filter[pos2 + oct] >>> bit) & 1;

    if ((bit1 | bit2) === 0)
      return false;
  }

  return true;
};

/**
 * Test whether data is present in the
 * filter and potentially add data.
 * @param {Buffer|String} val
 * @param {String?} enc - Can be any of the Buffer object's encodings.
 * @returns {Boolean} Whether data was added.
 */

RollingFilter.prototype.added = function added(val, enc) {
  if (typeof val === 'string')
    val = Buffer.from(val, enc);

  if (!this.test(val)) {
    this.add(val);
    return true;
  }

  return false;
};

/*
 * Helpers
 */

function U64(hi, lo) {
  this.hi = hi;
  this.lo = lo;
}

function read(data, off) {
  const hi = data.readUInt32LE(off + 4, true);
  const lo = data.readUInt32LE(off, true);
  return new U64(hi, lo);
}

function write(data, value, off) {
  data.writeUInt32LE(value.hi, off + 4, true);
  data.writeUInt32LE(value.lo, off, true);
}

/*
 * Expose
 */

module.exports = RollingFilter;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * bip150.js - peer auth.
 *
 * Resources:
 *   https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki
 */



const assert = __webpack_require__(0);
const path = __webpack_require__(25);
const EventEmitter = __webpack_require__(10);
const co = __webpack_require__(17);
const digest = __webpack_require__(5);
const random = __webpack_require__(29);
const ccmp = __webpack_require__(52);
const packets = __webpack_require__(60);
const secp256k1 = __webpack_require__(12);
const StaticWriter = __webpack_require__(4);
const base58 = __webpack_require__(26);
const encoding = __webpack_require__(3);
const IP = __webpack_require__(46);
const dns = __webpack_require__(97);
const fs = __webpack_require__(58);
const Logger = __webpack_require__(34);

/**
 * Represents a BIP150 input/output stream.
 * @alias module:net.BIP150
 * @constructor
 * @param {BIP151} bip151
 * @param {String} host
 * @param {Boolean} outbound
 * @param {AuthDB} db
 * @param {Buffer} key - Identity key.
 * @property {BIP151} bip151
 * @property {BIP151Stream} input
 * @property {BIP151Stream} output
 * @property {String} hostname
 * @property {Boolean} outbound
 * @property {AuthDB} db
 * @property {Buffer} privateKey
 * @property {Buffer} publicKey
 * @property {Buffer} peerIdentity
 * @property {Boolean} challengeReceived
 * @property {Boolean} replyReceived
 * @property {Boolean} proposeReceived
 * @property {Boolean} challengeSent
 * @property {Boolean} auth
 * @property {Boolean} completed
 */

function BIP150(bip151, host, outbound, db, key) {
  if (!(this instanceof BIP150))
    return new BIP150(bip151, host, outbound, db, key);

  EventEmitter.call(this);

  assert(bip151, 'BIP150 requires BIP151.');
  assert(typeof host === 'string', 'Hostname required.');
  assert(typeof outbound === 'boolean', 'Outbound flag required.');
  assert(db instanceof AuthDB, 'Auth DB required.');
  assert(Buffer.isBuffer(key), 'Identity key required.');

  this.bip151 = bip151;
  this.input = bip151.input;
  this.output = bip151.output;
  this.hostname = host;
  this.outbound = outbound;
  this.db = db;
  this.privateKey = key;
  this.publicKey = secp256k1.publicKeyCreate(key, true);

  this.peerIdentity = null;
  this.challengeReceived = false;
  this.replyReceived = false;
  this.proposeReceived = false;
  this.challengeSent = false;
  this.auth = false;
  this.completed = false;
  this.job = null;
  this.timeout = null;
  this.onAuth = null;

  this._init();
}

Object.setPrototypeOf(BIP150.prototype, EventEmitter.prototype);

/**
 * Initialize BIP150.
 * @private
 */

BIP150.prototype._init = function _init() {
  if (this.outbound)
    this.peerIdentity = this.db.getKnown(this.hostname);
};

/**
 * Test whether the state should be
 * considered authed. This differs
 * for inbound vs. outbound.
 * @returns {Boolean}
 */

BIP150.prototype.isAuthed = function isAuthed() {
  if (this.outbound)
    return this.challengeSent && this.challengeReceived;
  return this.challengeReceived && this.replyReceived;
};

/**
 * Handle a received challenge hash.
 * Returns an authreply signature.
 * @param {Buffer} hash
 * @returns {Buffer}
 * @throws on auth failure
 */

BIP150.prototype.challenge = function challenge(hash) {
  const type = this.outbound ? 'r' : 'i';

  assert(this.bip151.handshake, 'No BIP151 handshake before challenge.');
  assert(!this.challengeReceived, 'Peer challenged twice.');
  this.challengeReceived = true;

  if (hash.equals(encoding.ZERO_HASH))
    throw new Error('Auth failure.');

  const msg = this.hash(this.input.sid, type, this.publicKey);

  if (!ccmp(hash, msg))
    return encoding.ZERO_SIG64;

  if (this.isAuthed()) {
    this.auth = true;
    this.emit('auth');
  }

  const sig = secp256k1.sign(msg, this.privateKey);

  // authreply
  return secp256k1.fromDER(sig);
};

/**
 * Handle a received reply signature.
 * Returns an authpropose hash.
 * @param {Buffer} data
 * @returns {Buffer}
 * @throws on auth failure
 */

BIP150.prototype.reply = function reply(data) {
  const type = this.outbound ? 'i' : 'r';

  assert(this.challengeSent, 'Unsolicited reply.');
  assert(!this.replyReceived, 'Peer replied twice.');
  this.replyReceived = true;

  if (data.equals(encoding.ZERO_SIG64))
    throw new Error('Auth failure.');

  if (!this.peerIdentity)
    return random.randomBytes(32);

  const sig = secp256k1.toDER(data);
  const msg = this.hash(this.output.sid, type, this.peerIdentity);

  const result = secp256k1.verify(msg, sig, this.peerIdentity);

  if (!result)
    return random.randomBytes(32);

  if (this.isAuthed()) {
    this.auth = true;
    this.emit('auth');
    return null;
  }

  assert(this.outbound, 'No challenge received before reply on inbound.');

  // authpropose
  return this.hash(this.input.sid, 'p', this.publicKey);
};

/**
 * Handle a received propose hash.
 * Returns an authchallenge hash.
 * @param {Buffer} hash
 * @returns {Buffer}
 */

BIP150.prototype.propose = function propose(hash) {
  assert(!this.outbound, 'Outbound peer tried to propose.');
  assert(!this.challengeSent, 'Unsolicited propose.');
  assert(!this.proposeReceived, 'Peer proposed twice.');
  this.proposeReceived = true;

  const match = this.findAuthorized(hash);

  if (!match)
    return encoding.ZERO_HASH;

  this.peerIdentity = match;

  // Add them in case we ever connect to them.
  this.db.addKnown(this.hostname, this.peerIdentity);

  this.challengeSent = true;

  // authchallenge
  return this.hash(this.output.sid, 'r', this.peerIdentity);
};

/**
 * Create initial authchallenge hash
 * for the peer. The peer's identity
 * key must be known.
 * @returns {AuthChallengePacket}
 */

BIP150.prototype.toChallenge = function toChallenge() {
  assert(this.bip151.handshake, 'No BIP151 handshake before challenge.');
  assert(this.outbound, 'Cannot challenge an inbound connection.');
  assert(this.peerIdentity, 'Cannot challenge without a peer identity.');

  const msg = this.hash(this.output.sid, 'i', this.peerIdentity);

  assert(!this.challengeSent, 'Cannot initiate challenge twice.');
  this.challengeSent = true;

  return new packets.AuthChallengePacket(msg);
};

/**
 * Derive new cipher keys based on
 * BIP150 data. This differs from
 * the regular key derivation of BIP151.
 * @param {Buffer} sid - Sesson ID
 * @param {Buffer} key - `k1` or `k2`
 * @param {Buffer} req - Requesting Identity Key
 * @param {Buffer} res - Response Identity Key
 * @returns {Buffer}
 */

BIP150.prototype.rekey = function rekey(sid, key, req, res) {
  const seed = Buffer.allocUnsafe(130);
  sid.copy(seed, 0);
  key.copy(seed, 32);
  req.copy(seed, 64);
  res.copy(seed, 97);
  return digest.hash256(seed);
};

/**
 * Rekey the BIP151 input stream
 * using BIP150-style derivation.
 */

BIP150.prototype.rekeyInput = function rekeyInput() {
  const stream = this.input;
  const req = this.peerIdentity;
  const res = this.publicKey;
  const k1 = this.rekey(stream.sid, stream.k1, req, res);
  const k2 = this.rekey(stream.sid, stream.k2, req, res);
  stream.rekey(k1, k2);
};

/**
 * Rekey the BIP151 output stream
 * using BIP150-style derivation.
 */

BIP150.prototype.rekeyOutput = function rekeyOutput() {
  const stream = this.output;
  const req = this.publicKey;
  const res = this.peerIdentity;
  const k1 = this.rekey(stream.sid, stream.k1, req, res);
  const k2 = this.rekey(stream.sid, stream.k2, req, res);
  stream.rekey(k1, k2);
};

/**
 * Create a hash using the session ID.
 * @param {Buffer} sid
 * @param {String} ch
 * @param {Buffer} key
 * @returns {Buffer}
 */

BIP150.prototype.hash = function hash(sid, ch, key) {
  const data = Buffer.allocUnsafe(66);
  sid.copy(data, 0);
  data[32] = ch.charCodeAt(0);
  key.copy(data, 33);
  return digest.hash256(data);
};

/**
 * Find an authorized peer in the Auth
 * DB based on a proposal hash. Note
 * that the hash to find is specific
 * to the state of BIP151. This results
 * in an O(n) search.
 * @param {Buffer} hash
 * @returns {Buffer|null}
 */

BIP150.prototype.findAuthorized = function findAuthorized(hash) {
  // Scary O(n) stuff.
  for (const key of this.db.authorized) {
    const msg = this.hash(this.output.sid, 'p', key);

    // XXX Do we really need a constant
    // time compare here? Do it just to
    // be safe I guess.
    if (ccmp(msg, hash))
      return key;
  }

  return null;
};

/**
 * Destroy the BIP150 stream and
 * any current running wait job.
 */

BIP150.prototype.destroy = function destroy() {
  if (!this.job)
    return;

  this.reject(new Error('BIP150 stream was destroyed.'));
};

/**
 * Cleanup wait job.
 * @private
 * @returns {Job}
 */

BIP150.prototype.cleanup = function cleanup() {
  const job = this.job;

  assert(!this.completed, 'Already completed.');
  assert(job, 'No completion job.');

  this.completed = true;
  this.job = null;

  if (this.timeout != null) {
    clearTimeout(this.timeout);
    this.timeout = null;
  }

  if (this.onAuth) {
    this.removeListener('auth', this.onAuth);
    this.onAuth = null;
  }

  return job;
};

/**
 * Resolve the current wait job.
 * @private
 * @param {Object} result
 */

BIP150.prototype.resolve = function resolve(result) {
  const job = this.cleanup();
  job.resolve(result);
};

/**
 * Reject the current wait job.
 * @private
 * @param {Error} err
 */

BIP150.prototype.reject = function reject(err) {
  const job = this.cleanup();
  job.reject(err);
};

/**
 * Wait for handshake to complete.
 * @param {Number} timeout
 * @returns {Promise}
 */

BIP150.prototype.wait = function wait(timeout) {
  return new Promise((resolve, reject) => {
    this._wait(timeout, resolve, reject);
  });
};

/**
 * Wait for handshake to complete.
 * @private
 * @param {Number} timeout
 * @param {Function} resolve
 * @param {Function} reject
 */

BIP150.prototype._wait = function _wait(timeout, resolve, reject) {
  assert(!this.auth, 'Cannot wait for init after handshake.');

  this.job = co.job(resolve, reject);

  if (this.outbound && !this.peerIdentity) {
    this.reject(new Error(`No identity for ${this.hostname}.`));
    return;
  }

  this.timeout = setTimeout(() => {
    this.reject(new Error('BIP150 handshake timed out.'));
  }, timeout);

  this.onAuth = this.resolve.bind(this);
  this.once('auth', this.onAuth);
};

/**
 * Serialize the peer's identity
 * key as a BIP150 "address".
 * @returns {Base58String}
 */

BIP150.prototype.getAddress = function getAddress() {
  assert(this.peerIdentity, 'Cannot serialize address.');
  return BIP150.address(this.peerIdentity);
};

/**
 * Serialize an identity key as a
 * BIP150 "address".
 * @returns {Base58String}
 */

BIP150.address = function address(key) {
  const bw = new StaticWriter(27);
  bw.writeU8(0x0f);
  bw.writeU16BE(0xff01);
  bw.writeBytes(digest.hash160(key));
  bw.writeChecksum();
  return base58.encode(bw.render());
};

/**
 * AuthDB
 * @alias module:net.AuthDB
 * @constructor
 */

function AuthDB(options) {
  if (!(this instanceof AuthDB))
    return new AuthDB(options);

  this.logger = Logger.global;
  this.resolve = dns.lookup;
  this.prefix = null;
  this.dnsKnown = [];

  this.known = new Map();
  this.authorized = [];

  this._init(options);
}

/**
 * Initialize authdb with options.
 * @param {Object} options
 */

AuthDB.prototype._init = function _init(options) {
  if (!options)
    return;

  if (options.logger != null) {
    assert(typeof options.logger === 'object');
    this.logger = options.logger.context('authdb');
  }

  if (options.resolve != null) {
    assert(typeof options.resolve === 'function');
    this.resolve = options.resolve;
  }

  if (options.knownPeers != null) {
    assert(typeof options.knownPeers === 'object');
    this.setKnown(options.knownPeers);
  }

  if (options.authPeers != null) {
    assert(Array.isArray(options.authPeers));
    this.setAuthorized(options.authPeers);
  }

  if (options.prefix != null) {
    assert(typeof options.prefix === 'string');
    this.prefix = options.prefix;
  }
};

/**
 * Open auth database (lookup known peers).
 * @method
 * @returns {Promise}
 */

AuthDB.prototype.open = async function open() {
  await this.readKnown();
  await this.readAuth();
  await this.lookup();
};

/**
 * Close auth database.
 * @method
 * @returns {Promise}
 */

AuthDB.prototype.close = async function close() {
  ;
};

/**
 * Add a known peer.
 * @param {String} host - Peer Hostname
 * @param {Buffer} key - Identity Key
 */

AuthDB.prototype.addKnown = function addKnown(host, key) {
  assert(typeof host === 'string',
    'Known host must be a string.');

  assert(Buffer.isBuffer(key) && key.length === 33,
    'Invalid public key for known peer.');

  const addr = IP.fromHostname(host);

  if (addr.type === IP.types.DNS) {
    // Defer this for resolution.
    this.dnsKnown.push([addr, key]);
    return;
  }

  this.known.set(host, key);
};

/**
 * Add an authorized peer.
 * @param {Buffer} key - Identity Key
 */

AuthDB.prototype.addAuthorized = function addAuthorized(key) {
  assert(Buffer.isBuffer(key) && key.length === 33,
    'Invalid public key for authorized peer.');
  this.authorized.push(key);
};

/**
 * Initialize known peers with a host->key map.
 * @param {Object} map
 */

AuthDB.prototype.setKnown = function setKnown(map) {
  this.known.clear();

  for (const host of Object.keys(map)) {
    const key = map[host];
    this.addKnown(host, key);
  }
};

/**
 * Initialize authorized peers with a list of keys.
 * @param {Buffer[]} keys
 */

AuthDB.prototype.setAuthorized = function setAuthorized(keys) {
  this.authorized.length = 0;

  for (const key of keys)
    this.addAuthorized(key);
};

/**
 * Get a known peer key by hostname.
 * @param {String} hostname
 * @returns {Buffer|null}
 */

AuthDB.prototype.getKnown = function getKnown(hostname) {
  const known = this.known.get(hostname);

  if (known)
    return known;

  const addr = IP.fromHostname(hostname);

  return this.known.get(addr.host);
};

/**
 * Lookup known peers.
 * @method
 * @returns {Promise}
 */

AuthDB.prototype.lookup = async function lookup() {
  const jobs = [];

  for (const [addr, key] of this.dnsKnown)
    jobs.push(this.populate(addr, key));

  await Promise.all(jobs);
};

/**
 * Populate known peers with hosts.
 * @method
 * @private
 * @param {Object} addr
 * @param {Buffer} key
 * @returns {Promise}
 */

AuthDB.prototype.populate = async function populate(addr, key) {
  assert(addr.type === IP.types.DNS, 'Resolved host passed.');

  this.logger.info('Resolving authorized hosts from: %s.', addr.host);

  let hosts;
  try {
    hosts = await this.resolve(addr.host);
  } catch (e) {
    this.logger.error(e);
    return;
  }

  for (let host of hosts) {
    if (addr.port !== 0)
      host = IP.toHostname(host, addr.port);

    this.known.set(host, key);
  }
};

/**
 * Parse known peers.
 * @param {String} text
 * @returns {Object}
 */

AuthDB.prototype.readKnown = async function readKnown() {
  if (fs.unsupported)
    return;

  if (!this.prefix)
    return;

  const file = path.join(this.prefix, 'known-peers');

  let text;
  try {
    text = await fs.readFile(file, 'utf8');
  } catch (e) {
    if (e.code === 'ENOENT')
      return;
    throw e;
  }

  this.parseKnown(text);
};

/**
 * Parse known peers.
 * @param {String} text
 * @returns {Object}
 */

AuthDB.prototype.parseKnown = function parseKnown(text) {
  assert(typeof text === 'string');

  if (text.charCodeAt(0) === 0xfeff)
    text = text.substring(1);

  text = text.replace(/\r\n/g, '\n');
  text = text.replace(/\r/g, '\n');

  let num = 0;

  for (const chunk of text.split('\n')) {
    const line = chunk.trim();

    num += 1;

    if (line.length === 0)
      continue;

    if (line[0] === '#')
      continue;

    const parts = line.split(/\s+/);

    if (parts.length < 2)
      throw new Error(`No key present on line ${num}: "${line}".`);

    const hosts = parts[0].split(',');

    let host, addr;
    if (hosts.length >= 2) {
      host = hosts[0];
      addr = hosts[1];
    } else {
      host = null;
      addr = hosts[0];
    }

    const key = Buffer.from(parts[1], 'hex');

    if (key.length !== 33)
      throw new Error(`Invalid key on line ${num}: "${parts[1]}".`);

    if (host && host.length > 0)
      this.addKnown(host, key);

    if (addr.length === 0)
      continue;

    this.addKnown(addr, key);
  }
};

/**
 * Parse known peers.
 * @param {String} text
 * @returns {Object}
 */

AuthDB.prototype.readAuth = async function readAuth() {
  if (fs.unsupported)
    return;

  if (!this.prefix)
    return;

  const file = path.join(this.prefix, 'authorized-peers');

  let text;
  try {
    text = await fs.readFile(file, 'utf8');
  } catch (e) {
    if (e.code === 'ENOENT')
      return;
    throw e;
  }

  this.parseAuth(text);
};

/**
 * Parse authorized peers.
 * @param {String} text
 * @returns {Buffer[]} keys
 */

AuthDB.prototype.parseAuth = function parseAuth(text) {
  assert(typeof text === 'string');

  if (text.charCodeAt(0) === 0xfeff)
    text = text.substring(1);

  text = text.replace(/\r\n/g, '\n');
  text = text.replace(/\r/g, '\n');

  let num = 0;

  for (const chunk of text.split('\n')) {
    const line = chunk.trim();

    num += 1;

    if (line.length === 0)
      continue;

    if (line[0] === '#')
      continue;

    const key = Buffer.from(line, 'hex');

    if (key.length !== 33)
      throw new Error(`Invalid key on line ${num}: "${line}".`);

    this.addAuthorized(key);
  }
};

/*
 * Expose
 */

exports = BIP150;

exports.BIP150 = BIP150;
exports.AuthDB = AuthDB;

module.exports = exports;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * bip151.js - peer-to-peer communication encryption.
 *
 * Resources:
 *   https://github.com/bitcoin/bips/blob/master/bip-0151.mediawiki
 *   https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.chacha20poly1305
 *   https://github.com/openssh/openssh-portable/blob/master/cipher-chachapoly.c
 *   https://github.com/openssh/openssh-portable/blob/master/cipher.c
 *   https://github.com/openssh/openssh-portable/blob/master/packet.c
 */



const assert = __webpack_require__(0);
const EventEmitter = __webpack_require__(10);
const util = __webpack_require__(1);
const co = __webpack_require__(17);
const digest = __webpack_require__(5);
const ChaCha20 = __webpack_require__(166);
const Poly1305 = __webpack_require__(167);
const AEAD = __webpack_require__(206);
const hkdf = __webpack_require__(207);
const secp256k1 = __webpack_require__(12);
const packets = __webpack_require__(60);
const StaticWriter = __webpack_require__(4);
const BufferReader = __webpack_require__(2);
const encoding = __webpack_require__(3);
const EncinitPacket = packets.EncinitPacket;
const EncackPacket = packets.EncackPacket;

/*
 * Constants
 */

const HKDF_SALT = Buffer.from('wmccecdh', 'ascii');
const INFO_KEY1 = Buffer.from('WMCCK1', 'ascii');
const INFO_KEY2 = Buffer.from('WMCCK2', 'ascii');
const INFO_SID = Buffer.from('WMCCSessionID', 'ascii');
const HIGH_WATERMARK = 1024 * (1 << 20);

/**
 * Represents a BIP151 input or output stream.
 * @alias module:net.BIP151Stream
 * @constructor
 * @param {Number} cipher
 * @property {Buffer} publicKey
 * @property {Buffer} privateKey
 * @property {Number} cipher
 * @property {Buffer} k1
 * @property {Buffer} k2
 * @property {Buffer} sid
 * @property {ChaCha20} chacha
 * @property {AEAD} aead
 * @property {Buffer} tag
 * @property {Number} seq
 * @property {Number} processed
 * @property {Number} lastKey
 */

function BIP151Stream(cipher) {
  if (!(this instanceof BIP151Stream))
    return new BIP151Stream(cipher);

  this.cipher = BIP151.ciphers.CHACHAPOLY;
  this.privateKey = secp256k1.generatePrivateKey();
  this.publicKey = null;
  this.k1 = null;
  this.k2 = null;
  this.sid = null;

  if (cipher != null) {
    assert(cipher === BIP151.ciphers.CHACHAPOLY, 'Unknown cipher type.');
    this.cipher = cipher;
  }

  this.chacha = new ChaCha20();
  this.aead = new AEAD();
  this.tag = null;
  this.seq = 0;
  this.iv = Buffer.allocUnsafe(8);
  this.iv.fill(0);

  this.processed = 0;
  this.lastRekey = 0;
}

/**
 * Initialize the stream with peer's public key.
 * Computes ecdh secret and chacha keys.
 * @param {Buffer} publicKey
 */

BIP151Stream.prototype.init = function init(publicKey) {
  assert(Buffer.isBuffer(publicKey));

  this.publicKey = publicKey;

  const secret = secp256k1.ecdh(this.publicKey, this.privateKey);

  const bw = StaticWriter.pool(33);

  bw.writeBytes(secret);
  bw.writeU8(this.cipher);

  const data = bw.render();
  const prk = hkdf.extract(data, HKDF_SALT, 'sha256');

  this.k1 = hkdf.expand(prk, INFO_KEY1, 32, 'sha256');
  this.k2 = hkdf.expand(prk, INFO_KEY2, 32, 'sha256');
  this.sid = hkdf.expand(prk, INFO_SID, 32, 'sha256');

  this.seq = 0;

  this.update();

  this.chacha.init(this.k1, this.iv);
  this.aead.init(this.k2, this.iv);

  this.lastRekey = util.now();
};

/**
 * Add buffer size to `processed`,
 * check whether we need to rekey.
 * @param {Buffer} packet
 * @returns {Boolean}
 */

BIP151Stream.prototype.shouldRekey = function shouldRekey(packet) {
  const now = util.now();

  this.processed += packet.length;

  if (now >= this.lastRekey + 10
      || this.processed >= HIGH_WATERMARK) {
    this.lastRekey = now;
    this.processed = 0;
    return true;
  }

  return false;
};

/**
 * Generate new chacha keys with `key = HASH256(sid | key)`.
 * This will reinitialize the state of both ciphers.
 */

BIP151Stream.prototype.rekey = function rekey(k1, k2) {
  assert(this.sid, 'Cannot rekey before initialization.');

  if (!k1) {
    this.k1 = digest.root256(this.sid, this.k1);
    this.k2 = digest.root256(this.sid, this.k2);
  } else {
    this.k1 = k1;
    this.k2 = k2;
  }

  assert(this.k1);
  assert(this.k2);

  // All state is reinitialized
  // aside from the sequence number.
  this.chacha.init(this.k1, this.iv);
  this.aead.init(this.k2, this.iv);
};

/**
 * Increment packet sequence number and update IVs
 * (note, sequence number overflows after 2^64-1).
 * The IV will be updated without reinitializing
 * cipher state.
 */

BIP151Stream.prototype.sequence = function sequence() {
  // Wrap sequence number a la openssh.
  if (++this.seq === 0x100000000)
    this.seq = 0;

  this.update();

  // State of the ciphers is
  // unaltered aside from the iv.
  this.chacha.init(null, this.iv);
  this.aead.init(null, this.iv);
};

/**
 * Render the IV necessary for cipher streams.
 * @returns {Buffer}
 */

BIP151Stream.prototype.update = function update() {
  this.iv.writeUInt32LE(this.seq, 0, true);
  return this.iv;
};

/**
 * Get public key tied to private key
 * (not the same as BIP151Stream#publicKey).
 * @returns {Buffer}
 */

BIP151Stream.prototype.getPublicKey = function getPublicKey() {
  return secp256k1.publicKeyCreate(this.privateKey, true);
};

/**
 * Encrypt a payload size with k1.
 * @param {Buffer} data
 * @returns {Buffer}
 */

BIP151Stream.prototype.encryptSize = function encryptSize(data) {
  return this.chacha.encrypt(data.slice(0, 4));
};

/**
 * Decrypt payload size with k1.
 * @param {Buffer} data
 * @returns {Number}
 */

BIP151Stream.prototype.decryptSize = function decryptSize(data) {
  this.chacha.encrypt(data);
  return data.readUInt32LE(0, true);
};

/**
 * Encrypt payload with AEAD (update cipher and mac).
 * @param {Buffer} data
 * @returns {Buffer} data
 */

BIP151Stream.prototype.encrypt = function encrypt(data) {
  return this.aead.encrypt(data);
};

/**
 * Decrypt payload with AEAD (update cipher only).
 * @param {Buffer} data
 * @returns {Buffer} data
 */

BIP151Stream.prototype.decrypt = function decrypt(data) {
  return this.aead.chacha20.encrypt(data);
};

/**
 * Authenticate payload with AEAD (update mac only).
 * @param {Buffer} data
 * @returns {Buffer} data
 */

BIP151Stream.prototype.auth = function auth(data) {
  return this.aead.auth(data);
};

/**
 * Finalize AEAD and compute MAC.
 * @returns {Buffer}
 */

BIP151Stream.prototype.finish = function finish() {
  this.tag = this.aead.finish();
  return this.tag;
};

/**
 * Verify tag against mac in constant time.
 * @param {Buffer} tag
 * @returns {Boolean}
 */

BIP151Stream.prototype.verify = function verify(tag) {
  return Poly1305.verify(this.tag, tag);
};

/**
 * Represents a BIP151 input and output stream.
 * Holds state for peer communication.
 * @alias module:net.BIP151
 * @constructor
 * @param {Number} cipher
 * @property {BIP151Stream} input
 * @property {BIP151Stream} output
 * @property {Boolean} initReceived
 * @property {Boolean} ackReceived
 * @property {Boolean} initSent
 * @property {Boolean} ackSent
 * @property {Object} timeout
 * @property {Job} job
 * @property {Boolean} completed
 * @property {Boolean} handshake
 */

function BIP151(cipher) {
  if (!(this instanceof BIP151))
    return new BIP151(cipher);

  EventEmitter.call(this);

  this.input = new BIP151Stream(cipher);
  this.output = new BIP151Stream(cipher);

  this.initReceived = false;
  this.ackReceived = false;
  this.initSent = false;
  this.ackSent = false;
  this.completed = false;
  this.handshake = false;

  this.pending = [];
  this.total = 0;
  this.waiting = 4;
  this.hasSize = false;

  this.timeout = null;
  this.job = null;
  this.onShake = null;

  this.bip150 = null;
}

Object.setPrototypeOf(BIP151.prototype, EventEmitter.prototype);

/**
 * Cipher list.
 * @enum {Number}
 */

BIP151.ciphers = {
  CHACHAPOLY: 0
};

/**
 * Max message size.
 * @const {Number}
 * @default
 */

BIP151.MAX_MESSAGE = 12 * 1000 * 1000;

/**
 * Emit an error.
 * @param {...String} msg
 */

BIP151.prototype.error = function error() {
  const msg = util.fmt.apply(util, arguments);
  this.emit('error', new Error(msg));
};

/**
 * Test whether handshake has completed.
 * @returns {Boolean}
 */

BIP151.prototype.isReady = function isReady() {
  return this.initSent
    && this.ackReceived
    && this.initReceived
    && this.ackSent;
};

/**
 * Render an `encinit` packet. Contains the
 * input public key and cipher number.
 * @returns {Buffer}
 */

BIP151.prototype.toEncinit = function toEncinit() {
  assert(!this.initSent, 'Cannot init twice.');
  this.initSent = true;
  return new EncinitPacket(this.input.getPublicKey(), this.input.cipher);
};

/**
 * Render `encack` packet. Contains the
 * output stream public key.
 * @returns {Buffer}
 */

BIP151.prototype.toEncack = function toEncack() {
  assert(this.output.sid, 'Cannot ack before init.');
  assert(!this.ackSent, 'Cannot ack twice.');
  this.ackSent = true;

  if (this.isReady()) {
    assert(!this.completed, 'No encack after timeout.');
    this.handshake = true;
    this.emit('handshake');
  }

  return new EncackPacket(this.output.getPublicKey());
};

/**
 * Render `encack` packet with an all
 * zero public key, notifying of a rekey
 * for the output stream.
 * @returns {Buffer}
 */

BIP151.prototype.toRekey = function toRekey() {
  assert(this.handshake, 'Cannot rekey before handshake.');
  return new EncackPacket(encoding.ZERO_KEY);
};

/**
 * Handle `encinit` from remote peer.
 * @param {Buffer}
 */

BIP151.prototype.encinit = function encinit(publicKey, cipher) {
  assert(cipher === this.output.cipher, 'Cipher mismatch.');
  assert(!this.initReceived, 'Already initialized.');
  assert(!this.completed, 'No encinit after timeout.');
  this.initReceived = true;
  this.output.init(publicKey);
};

/**
 * Handle `encack` from remote peer.
 * @param {Buffer} data
 */

BIP151.prototype.encack = function encack(publicKey) {
  assert(this.initSent, 'Unsolicited ACK.');

  if (publicKey.equals(encoding.ZERO_KEY)) {
    assert(this.handshake, 'No initialization before rekey.');

    if (this.bip150 && this.bip150.auth) {
      this.bip150.rekeyInput();
      return;
    }

    this.input.rekey();

    return;
  }

  assert(!this.ackReceived, 'Already ACKed.');
  assert(!this.completed, 'No encack after timeout.');
  this.ackReceived = true;

  this.input.init(publicKey);

  if (this.isReady()) {
    this.handshake = true;
    this.emit('handshake');
  }
};

/**
 * Cleanup handshake job.
 * @returns {Job}
 */

BIP151.prototype.cleanup = function cleanup() {
  const job = this.job;

  assert(!this.completed, 'Already completed.');
  assert(job, 'No completion job.');

  this.completed = true;
  this.job = null;

  if (this.timeout != null) {
    clearTimeout(this.timeout);
    this.timeout = null;
  }

  if (this.onShake) {
    this.removeListener('handshake', this.onShake);
    this.onShake = null;
  }

  return job;
};

/**
 * Complete the timeout for handshake.
 * @param {Object} result
 */

BIP151.prototype.resolve = function resolve(result) {
  const job = this.cleanup();
  job.resolve(result);
};

/**
 * Complete the timeout for handshake with error.
 * @param {Error} err
 */

BIP151.prototype.reject = function reject(err) {
  const job = this.cleanup();
  job.reject(err);
};

/**
 * Set a timeout and wait for handshake to complete.
 * @param {Number} timeout - Timeout in ms.
 * @returns {Promise}
 */

BIP151.prototype.wait = function wait(timeout) {
  return new Promise((resolve, reject) => {
    this._wait(timeout, resolve, reject);
  });
};

/**
 * Set a timeout and wait for handshake to complete.
 * @private
 * @param {Number} timeout
 * @param {Function} resolve
 * @param {Function} reject
 */

BIP151.prototype._wait = function _wait(timeout, resolve, reject) {
  assert(!this.handshake, 'Cannot wait for init after handshake.');

  this.job = co.job(resolve, reject);

  this.timeout = setTimeout(() => {
    this.reject(new Error('BIP151 handshake timed out.'));
  }, timeout);

  this.onShake = this.resolve.bind(this);
  this.once('handshake', this.onShake);
};

/**
 * Destroy BIP151 state and streams.
 */

BIP151.prototype.destroy = function destroy() {
  if (!this.job)
    return;

  this.reject(new Error('BIP151 stream was destroyed.'));
};

/**
 * Add buffer size to `processed`,
 * check whether we need to rekey.
 * @param {Buffer} packet
 */

BIP151.prototype.maybeRekey = function maybeRekey(packet) {
  if (!this.output.shouldRekey(packet))
    return;

  this.emit('rekey');

  if (this.bip150 && this.bip150.auth) {
    this.bip150.rekeyOutput();
    return;
  }

  this.output.rekey();
};

/**
 * Calculate packet size.
 * @param {String} cmd
 * @param {Buffer} body
 * @returns {Number}
 */

BIP151.prototype.packetSize = function packetSize(cmd, body) {
  let size = 0;
  size += 4;
  size += encoding.sizeVarString(cmd, 'ascii');
  size += 4;
  size += body.length;
  size += 16;
  return size;
};

/**
 * Frame plaintext payload for the output stream.
 * @param {String} cmd
 * @param {Buffer} body
 * @returns {Buffer} Ciphertext payload
 */

BIP151.prototype.packet = function packet(cmd, body) {
  const size = this.packetSize(cmd, body);
  const bw = new StaticWriter(size);
  const payloadSize = size - 20;

  bw.writeU32(payloadSize);
  bw.writeVarString(cmd, 'ascii');
  bw.writeU32(body.length);
  bw.writeBytes(body);
  bw.seek(16);

  const msg = bw.render();
  const payload = msg.slice(4, 4 + payloadSize);

  this.maybeRekey(msg);

  this.output.encryptSize(msg);
  this.output.encrypt(payload);
  this.output.finish().copy(msg, 4 + payloadSize);
  this.output.sequence();

  return msg;
};

/**
 * Feed ciphertext payload chunk
 * to the input stream. Potentially
 * emits a `packet` event.
 * @param {Buffer} data
 */

BIP151.prototype.feed = function feed(data) {
  this.total += data.length;
  this.pending.push(data);

  while (this.total >= this.waiting) {
    const chunk = this.read(this.waiting);
    this.parse(chunk);
  }
};

/**
 * Read and consume a number of bytes
 * from the buffered stream.
 * @param {Number} size
 * @returns {Buffer}
 */

BIP151.prototype.read = function read(size) {
  assert(this.total >= size, 'Reading too much.');

  if (size === 0)
    return Buffer.alloc(0);

  const pending = this.pending[0];

  if (pending.length > size) {
    const chunk = pending.slice(0, size);
    this.pending[0] = pending.slice(size);
    this.total -= chunk.length;
    return chunk;
  }

  if (pending.length === size) {
    const chunk = this.pending.shift();
    this.total -= chunk.length;
    return chunk;
  }

  const chunk = Buffer.allocUnsafe(size);
  let off = 0;

  while (off < chunk.length) {
    const pending = this.pending[0];
    const len = pending.copy(chunk, off);
    if (len === pending.length)
      this.pending.shift();
    else
      this.pending[0] = pending.slice(len);
    off += len;
  }

  assert.strictEqual(off, chunk.length);

  this.total -= chunk.length;

  return chunk;
};

/**
 * Parse a ciphertext payload chunk.
 * Potentially emits a `packet` event.
 * @param {Buffer} data
 */

BIP151.prototype.parse = function parse(data) {
  if (!this.hasSize) {
    const size = this.input.decryptSize(data);

    assert(this.waiting === 4);
    assert(data.length === 4);

    // Allow 3 batched packets of max message size (12mb).
    // Not technically standard, but this protects us
    // from buffering tons of data due to either an
    // potential dos'er or a cipher state mismatch.
    // Note that 6 is the minimum size:
    // varint-cmdlen(1) str-cmd(1) u32-size(4) payload(0)
    if (size < 6 || size > BIP151.MAX_MESSAGE) {
      this.error('Bad packet size: %d.', util.mb(size));
      return;
    }

    this.hasSize = true;
    this.waiting = size + 16;

    return;
  }

  const payload = data.slice(0, this.waiting - 16);
  const tag = data.slice(this.waiting - 16, this.waiting);

  this.hasSize = false;
  this.waiting = 4;

  // Authenticate payload before decrypting.
  // This ensures the cipher state isn't altered
  // if the payload integrity has been compromised.
  this.input.auth(payload);
  this.input.finish();

  if (!this.input.verify(tag)) {
    this.input.sequence();
    this.error('Bad tag: %s.', tag.toString('hex'));
    return;
  }

  this.input.decrypt(payload);
  this.input.sequence();

  const br = new BufferReader(payload);

  while (br.left()) {
    let cmd, body;

    try {
      cmd = br.readVarString('ascii');
      body = br.readBytes(br.readU32());
    } catch (e) {
      this.emit('error', e);
      return;
    }

    this.emit('packet', cmd, body);
  }
};

/*
 * Expose
 */

module.exports = BIP151;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * tcp.js - tcp backend for wmcc_core.
 */

/* eslint prefer-arrow-callback: "off" */



const EventEmitter = __webpack_require__(10);
const net = __webpack_require__(176);
const socks = __webpack_require__(187);

/**
 * @exports net/tcp
 */

const tcp = exports;

/**
 * Create a TCP socket and connect.
 * @param {Number} port
 * @param {String} host
 * @param {String?} proxy
 * @returns {Object}
 */

tcp.createSocket = function createSocket(port, host, proxy) {
  if (proxy)
    return socks.connect(proxy, port, host);
  return net.connect(port, host);
};

/**
 * Create a TCP server.
 * @returns {Object}
 */

tcp.createServer = function createServer() {
  const server = new net.Server();
  const ee = new EventEmitter();

  ee.listen = function listen(port, host) {
    return new Promise((resolve, reject) => {
      server.once('error', reject);
      server.listen(port, host, () => {
        server.removeListener('error', reject);
        resolve();
      });
    });
  };

  ee.close = function close() {
    return new Promise((resolve, reject) => {
      server.close(wrap(resolve, reject));
    });
  };

  ee.address = function address() {
    return server.address();
  };

  Object.defineProperty(ee, 'maxConnections', {
    get() {
      return server.maxConnections;
    },
    set(value) {
      server.maxConnections = value;
      return server.maxConnections;
    }
  });

  server.on('listening', () => {
    ee.emit('listening');
  });

  server.on('connection', (socket) => {
    ee.emit('connection', socket);
  });

  server.on('error', (err) => {
    ee.emit('error', err);
  });

  return ee;
};

/*
 * Helpers
 */

function wrap(resolve, reject) {
  return function(err, result) {
    if (err) {
      reject(err);
      return;
    }
    resolve(result);
  };
}


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * pool.js - peer management for wmcc_core.
 */



const assert = __webpack_require__(0);
const EventEmitter = __webpack_require__(10);
const AsyncObject = __webpack_require__(31);
const util = __webpack_require__(1);
const IP = __webpack_require__(46);
const co = __webpack_require__(17);
const common = __webpack_require__(59);
const chainCommon = __webpack_require__(89);
const Address = __webpack_require__(11);
const BIP150 = __webpack_require__(119);
const BIP151 = __webpack_require__(120);
const BIP152 = __webpack_require__(96);
const Bloom = __webpack_require__(43);
const RollingFilter = __webpack_require__(118);
const secp256k1 = __webpack_require__(12);
const Lock = __webpack_require__(23);
const Network = __webpack_require__(6);
const Peer = __webpack_require__(188);
const external = __webpack_require__(242);
const List = __webpack_require__(91);
const tcp = __webpack_require__(121);
const dns = __webpack_require__(97);
const HostList = __webpack_require__(244);
const UPNP = __webpack_require__(246);
const InvItem = __webpack_require__(36);
const packets = __webpack_require__(60);
const services = common.services;
const invTypes = InvItem.types;
const packetTypes = packets.types;
const scores = HostList.scores;

/**
 * A pool of peers for handling all network activity.
 * @alias module:net.Pool
 * @constructor
 * @param {Object} options
 * @param {Chain} options.chain
 * @param {Mempool?} options.mempool
 * @param {Number?} [options.maxOutbound=8] - Maximum number of peers.
 * @param {Boolean?} options.spv - Do an SPV sync.
 * @param {Boolean?} options.noRelay - Whether to ask
 * for relayed transactions.
 * @param {Number?} [options.feeRate] - Fee filter rate.
 * @param {Number?} [options.invTimeout=60000] - Timeout for broadcasted
 * objects.
 * @param {Boolean?} options.listen - Whether to spin up a server socket
 * and listen for peers.
 * @param {Boolean?} options.selfish - A selfish pool. Will not serve blocks,
 * headers, hashes, utxos, or transactions to peers.
 * @param {Boolean?} options.broadcast - Whether to automatically broadcast
 * transactions accepted to our mempool.
 * @param {String[]} options.seeds
 * @param {Function?} options.createSocket - Custom function to create a socket.
 * Must accept (port, host) and return a node-like socket.
 * @param {Function?} options.createServer - Custom function to create a server.
 * Must return a node-like server.
 * @emits Pool#block
 * @emits Pool#tx
 * @emits Pool#peer
 * @emits Pool#open
 * @emits Pool#close
 * @emits Pool#error
 * @emits Pool#reject
 */

function Pool(options) {
  if (!(this instanceof Pool))
    return new Pool(options);

  AsyncObject.call(this);

  this.options = new PoolOptions(options);

  this.network = this.options.network;
  this.logger = this.options.logger.context('net');
  this.chain = this.options.chain;
  this.mempool = this.options.mempool;
  this.server = this.options.createServer();
  this.nonces = this.options.nonces;

  this.locker = new Lock(true);
  this.connected = false;
  this.disconnecting = false;
  this.syncing = false;
  this.spvFilter = null;
  this.txFilter = null;
  this.blockMap = new Set();
  this.txMap = new Set();
  this.compactBlocks = new Set();
  this.invMap = new Map();
  this.pendingFilter = null;
  this.pendingRefill = null;

  this.checkpoints = false;
  this.headerChain = new List();
  this.headerNext = null;
  this.headerTip = null;

  this.peers = new PeerList();
  this.authdb = new BIP150.AuthDB(this.options);
  this.hosts = new HostList(this.options);
  this.id = 0;

  if (this.options.spv)
    this.spvFilter = Bloom.fromRate(20000, 0.001, Bloom.flags.ALL);

  if (!this.options.mempool)
    this.txFilter = new RollingFilter(50000, 0.000001);

  this._init();
};

Object.setPrototypeOf(Pool.prototype, AsyncObject.prototype);

/**
 * Discovery interval for UPNP and DNS seeds.
 * @const {Number}
 * @default
 */

Pool.DISCOVERY_INTERVAL = 120000;

/**
 * Initialize the pool.
 * @private
 */

Pool.prototype._init = function _init() {
  this.server.on('error', (err) => {
    this.emit('error', err);
  });

  this.server.on('connection', (socket) => {
    this.handleSocket(socket);
    this.emit('connection', socket);
  });

  this.server.on('listening', () => {
    const data = this.server.address();
    this.logger.info(
      'Pool server listening on %s (port=%d).',
      data.address, data.port);
    this.emit('listening', data);
  });

  this.chain.on('block', (block, entry) => {
    this.emit('block', block, entry);
  });

  this.chain.on('reset', () => {
    if (this.checkpoints)
      this.resetChain();
    this.forceSync();
  });

  this.chain.on('full', () => {
    this.sync();
    this.emit('full');
    this.logger.info('Chain is fully synced (height=%d).', this.chain.height);
  });

  this.chain.on('bad orphan', (err, id) => {
    this.handleBadOrphan('block', err, id);
  });

  if (this.mempool) {
    this.mempool.on('tx', (tx) => {
      this.emit('tx', tx);
    });

    this.mempool.on('bad orphan', (err, id) => {
      this.handleBadOrphan('tx', err, id);
    });
  }

  if (!this.options.selfish && !this.options.spv) {
    if (this.mempool) {
      this.mempool.on('tx', (tx) => {
        this.announceTX(tx);
      });
    }

    // Normally we would also broadcast
    // competing chains, but we want to
    // avoid getting banned if an evil
    // miner sends us an invalid competing
    // chain that we can't connect and
    // verify yet.
    this.chain.on('block', (block) => {
      if (!this.chain.synced)
        return;
      this.announceBlock(block);
    });
  }
};

/**
 * Open the pool, wait for the chain to load.
 * @method
 * @alias Pool#open
 * @returns {Promise}
 */

Pool.prototype._open = async function _open() {
  if (this.mempool)
    await this.mempool.open();
  else
    await this.chain.open();

  this.logger.info('Pool loaded (maxpeers=%d).', this.options.maxOutbound);

  if (this.options.bip150) {
    const key = secp256k1.publicKeyCreate(this.options.identityKey, true);
    this.logger.info('Identity public key: %s.', key.toString('hex'));
    this.logger.info('Identity address: %s.', BIP150.address(key));
  }

  this.resetChain();
};

/**
 * Reset header chain.
 */

Pool.prototype.resetChain = function resetChain() {
  if (!this.options.checkpoints)
    return;

  this.checkpoints = false;
  this.headerTip = null;
  this.headerChain.reset();
  this.headerNext = null;

  const tip = this.chain.tip;

  if (tip.height < this.network.lastCheckpoint) {
    this.checkpoints = true;
    this.headerTip = this.getNextTip(tip.height);
    this.headerChain.push(new HeaderEntry(tip.hash, tip.height));
    this.logger.info(
      'Initialized header chain to height %d (checkpoint=%s).',
      tip.height, util.revHex(this.headerTip.hash));
  }
};

/**
 * Close and destroy the pool.
 * @method
 * @alias Pool#close
 * @returns {Promise}
 */

Pool.prototype._close = async function _close() {
  await this.disconnect();
};

/**
 * Connect to the network.
 * @method
 * @returns {Promise}
 */

Pool.prototype.connect = async function connect() {
  const unlock = await this.locker.lock();
  try {
    return await this._connect();
  } finally {
    unlock();
  }
};

/**
 * Connect to the network (no lock).
 * @method
 * @returns {Promise}
 */

Pool.prototype._connect = async function _connect() {
  assert(this.loaded, 'Pool is not loaded.');

  if (this.connected)
    return;

  await this.hosts.open();
  await this.authdb.open();

  await this.discoverGateway();
  await this.discoverExternal();
  await this.discoverSeeds();

  this.fillOutbound();

  await this.listen();

  this.startTimer();

  this.connected = true;
};

/**
 * Disconnect from the network.
 * @method
 * @returns {Promise}
 */

Pool.prototype.disconnect = async function disconnect() {
  const unlock = await this.locker.lock();
  try {
    return await this._disconnect();
  } finally {
    unlock();
  }
};

/**
 * Disconnect from the network.
 * @method
 * @returns {Promise}
 */

Pool.prototype._disconnect = async function _disconnect() {
  assert(this.loaded, 'Pool is not loaded.');

  if (!this.connected)
    return;

  this.disconnecting = true;

  for (const item of this.invMap.values())
    item.resolve();

  this.peers.destroy();

  this.blockMap.clear();
  this.txMap.clear();

  if (this.pendingFilter != null) {
    clearTimeout(this.pendingFilter);
    this.pendingFilter = null;
  }

  if (this.pendingRefill != null) {
    clearTimeout(this.pendingRefill);
    this.pendingRefill = null;
  }

  this.checkpoints = false;
  this.headerTip = null;
  this.headerChain.reset();
  this.headerNext = null;

  this.stopTimer();

  await this.authdb.close();
  await this.hosts.close();

  await this.unlisten();

  this.disconnecting = false;
  this.syncing = false;
  this.connected = false;
};

/**
 * Start listening on a server socket.
 * @method
 * @private
 * @returns {Promise}
 */

Pool.prototype.listen = async function listen() {
  assert(this.server);
  assert(!this.connected, 'Already listening.');

  if (!this.options.listen)
    return;

  this.server.maxConnections = this.options.maxInbound;

  await this.server.listen(this.options.port, this.options.host);
};

/**
 * Stop listening on server socket.
 * @method
 * @private
 * @returns {Promise}
 */

Pool.prototype.unlisten = async function unlisten() {
  assert(this.server);
  assert(this.connected, 'Not listening.');

  if (!this.options.listen)
    return;

  await this.server.close();
};

/**
 * Start discovery timer.
 * @private
 */

Pool.prototype.startTimer = function startTimer() {
  assert(this.timer == null, 'Timer already started.');
  this.timer = co.setInterval(this.discover, Pool.DISCOVERY_INTERVAL, this);
};

/**
 * Stop discovery timer.
 * @private
 */

Pool.prototype.stopTimer = function stopTimer() {
  assert(this.timer != null, 'Timer already stopped.');
  co.clearInterval(this.timer);
  this.timer = null;
};

/**
 * Rediscover seeds and internet gateway.
 * Attempt to add port mapping once again.
 * @returns {Promise}
 */

Pool.prototype.discover = async function discover() {
  await this.discoverGateway();
  await this.discoverSeeds(true);
};

/**
 * Attempt to add port mapping (i.e.
 * remote:8333->local:8333) via UPNP.
 * @returns {Promise}
 */

Pool.prototype.discoverGateway = async function discoverGateway() {
  const src = this.options.publicPort;
  const dest = this.options.port;

  // Pointless if we're not listening.
  if (!this.options.listen)
    return false;

  // UPNP is always optional, since
  // it's likely to not work anyway.
  if (!this.options.upnp)
    return false;

  let wan;
  try {
    this.logger.debug('Discovering internet gateway (upnp).');
    wan = await UPNP.discover();
  } catch (e) {
    this.logger.debug('Could not discover internet gateway (upnp).');
    this.logger.debug(e);
    return false;
  }

  let host;
  try {
    host = await wan.getExternalIP();
  } catch (e) {
    this.logger.debug('Could not find external IP (upnp).');
    this.logger.debug(e);
    return false;
  }

  if (this.hosts.addLocal(host, src, scores.UPNP))
    this.logger.info('External IP found (upnp): %s.', host);

  this.logger.debug(
    'Adding port mapping %d->%d.',
    src, dest);

  try {
    await wan.addPortMapping(host, src, dest);
  } catch (e) {
    this.logger.debug('Could not add port mapping (upnp).');
    this.logger.debug(e);
    return false;
  }

  return true;
};

/**
 * Attempt to resolve DNS seeds if necessary.
 * @param {Boolean} checkPeers
 * @returns {Promise}
 */

Pool.prototype.discoverSeeds = async function discoverSeeds(checkPeers) {
  if (this.hosts.dnsSeeds.length === 0)
    return;

  const max = Math.min(2, this.options.maxOutbound);
  const size = this.hosts.size();

  let total = 0;
  for (let peer = this.peers.head(); peer; peer = peer.next) {
    if (!peer.outbound)
      continue;

    if (peer.connected) {
      if (++total > max)
        break;
    }
  }

  if (size === 0 || (checkPeers && total < max)) {
    this.logger.warning('Could not find enough peers.');
    this.logger.warning('Hitting DNS seeds...');

    await this.hosts.discoverSeeds();

    this.logger.info(
      'Resolved %d hosts from DNS seeds.',
      this.hosts.size() - size);

    this.refill();
  }
};

/**
 * Attempt to discover external IP via HTTP.
 * @returns {Promise}
 */

Pool.prototype.discoverExternal = async function discoverExternal() {
  const port = this.options.publicPort;

  // Pointless if we're not listening.
  if (!this.options.listen)
    return;

  // Never hit an HTTP server if
  // we're using an outbound proxy.
  if (this.options.proxy)
    return;

  // Try not to hit this if we can avoid it.
  if (this.hosts.local.size > 0)
    return;

  let host4;
  try {
    host4 = await external.getIPv4();
  } catch (e) {
    this.logger.debug('Could not find external IPv4 (http).');
    this.logger.debug(e);
  }

  if (host4 && this.hosts.addLocal(host4, port, scores.HTTP))
    this.logger.info('External IPv4 found (http): %s.', host4);

  let host6;
  try {
    host6 = await external.getIPv6();
  } catch (e) {
    this.logger.debug('Could not find external IPv6 (http).');
    this.logger.debug(e);
  }

  if (host6 && this.hosts.addLocal(host6, port, scores.HTTP))
    this.logger.info('External IPv6 found (http): %s.', host6);
};

/**
 * Handle incoming connection.
 * @private
 * @param {net.Socket} socket
 */

Pool.prototype.handleSocket = function handleSocket(socket) {
  if (!socket.remoteAddress) {
    this.logger.debug('Ignoring disconnected peer.');
    socket.destroy();
    return;
  }

  const ip = IP.normalize(socket.remoteAddress);

  if (this.peers.inbound >= this.options.maxInbound) {
    this.logger.debug('Ignoring peer: too many inbound (%s).', ip);
    socket.destroy();
    return;
  }

  if (this.hosts.isBanned(ip)) {
    this.logger.debug('Ignoring banned peer (%s).', ip);
    socket.destroy();
    return;
  }

  const host = IP.toHostname(ip, socket.remotePort);

  assert(!this.peers.map[host], 'Port collision.');

  this.addInbound(socket);
};

/**
 * Add a loader peer. Necessary for
 * a sync to even begin.
 * @private
 */

Pool.prototype.addLoader = function addLoader() {
  if (!this.loaded)
    return;

  assert(!this.peers.load);

  for (let peer = this.peers.head(); peer; peer = peer.next) {
    if (!peer.outbound)
      continue;

    this.logger.info(
      'Repurposing peer for loader (%s).',
      peer.hostname());

    this.setLoader(peer);

    return;
  }

  const addr = this.getHost();

  if (!addr)
    return;

  const peer = this.createOutbound(addr);

  this.logger.info('Adding loader peer (%s).', peer.hostname());

  this.peers.add(peer);

  this.setLoader(peer);
};

/**
 * Add a loader peer. Necessary for
 * a sync to even begin.
 * @private
 */

Pool.prototype.setLoader = function setLoader(peer) {
  if (!this.loaded)
    return;

  assert(peer.outbound);
  assert(!this.peers.load);
  assert(!peer.loader);

  peer.loader = true;
  this.peers.load = peer;

  this.sendSync(peer);

  this.emit('loader', peer);
};

/**
 * Start the blockchain sync.
 */

Pool.prototype.startSync = function startSync() {
  if (!this.loaded)
    return;

  assert(this.connected, 'Pool is not connected!');

  this.syncing = true;
  this.resync(false);
};

/**
 * Force sending of a sync to each peer.
 */

Pool.prototype.forceSync = function forceSync() {
  if (!this.loaded)
    return;

  assert(this.connected, 'Pool is not connected!');

  this.resync(true);
};

/**
 * Send a sync to each peer.
 */

Pool.prototype.sync = function sync(force) {
  this.resync(false);
};

/**
 * Stop the sync.
 * @private
 */

Pool.prototype.stopSync = function stopSync() {
  if (!this.syncing)
    return;

  this.syncing = false;

  for (let peer = this.peers.head(); peer; peer = peer.next) {
    if (!peer.outbound)
      continue;

    if (!peer.syncing)
      continue;

    peer.syncing = false;
    peer.merkleBlock = null;
    peer.merkleTime = -1;
    peer.merkleMatches = 0;
    peer.merkleMap = null;
    peer.blockTime = -1;
    peer.blockMap.clear();
    peer.compactBlocks.clear();
  }

  this.blockMap.clear();
  this.compactBlocks.clear();
};

/**
 * Send a sync to each peer.
 * @private
 * @param {Boolean?} force
 * @returns {Promise}
 */

Pool.prototype.resync = async function resync(force) {
  if (!this.syncing)
    return;

  let locator;
  try {
    locator = await this.chain.getLocator();
  } catch (e) {
    this.emit('error', e);
    return;
  }

  for (let peer = this.peers.head(); peer; peer = peer.next) {
    if (!peer.outbound)
      continue;

    if (!force && peer.syncing)
      continue;

    this.sendLocator(locator, peer);
  }
};

/**
 * Test whether a peer is sync-worthy.
 * @param {Peer} peer
 * @returns {Boolean}
 */

Pool.prototype.isSyncable = function isSyncable(peer) {
  if (!this.syncing)
    return false;

  if (peer.destroyed)
    return false;

  if (!peer.handshake)
    return false;

  if (!(peer.services & services.NETWORK))
    return false;

  if (this.options.hasWitness() && !peer.hasWitness())
    return false;

  if (!peer.loader) {
    if (!this.chain.synced)
      return false;
  }

  return true;
};

/**
 * Start syncing from peer.
 * @method
 * @param {Peer} peer
 * @returns {Promise}
 */

Pool.prototype.sendSync = async function sendSync(peer) {
  if (peer.syncing)
    return false;

  if (!this.isSyncable(peer))
    return false;

  peer.syncing = true;
  peer.blockTime = util.ms();

  let locator;
  try {
    locator = await this.chain.getLocator();
  } catch (e) {
    peer.syncing = false;
    peer.blockTime = -1;
    this.emit('error', e);
    return false;
  }

  return this.sendLocator(locator, peer);
};

/**
 * Send a chain locator and start syncing from peer.
 * @method
 * @param {Hash[]} locator
 * @param {Peer} peer
 * @returns {Boolean}
 */

Pool.prototype.sendLocator = function sendLocator(locator, peer) {
  if (!this.isSyncable(peer))
    return false;

  // Ask for the mempool if we're synced.
  if (this.network.requestMempool) {
    if (peer.loader && this.chain.synced)
      peer.sendMempool();
  }

  peer.syncing = true;
  peer.blockTime = util.ms();

  if (this.checkpoints) {
    peer.sendGetHeaders(locator, this.headerTip.hash);
    return true;
  }

  peer.sendGetBlocks(locator);

  return true;
};

/**
 * Send `mempool` to all peers.
 */

Pool.prototype.sendMempool = function sendMempool() {
  for (let peer = this.peers.head(); peer; peer = peer.next)
    peer.sendMempool();
};

/**
 * Send `getaddr` to all peers.
 */

Pool.prototype.sendGetAddr = function sendGetAddr() {
  for (let peer = this.peers.head(); peer; peer = peer.next)
    peer.sendGetAddr();
};

/**
 * Request current header chain blocks.
 * @private
 * @param {Peer} peer
 */

Pool.prototype.resolveHeaders = function resolveHeaders(peer) {
  const items = [];

  for (let node = this.headerNext; node; node = node.next) {
    this.headerNext = node.next;

    items.push(node.hash);

    if (items.length === 50000)
      break;
  }

  this.getBlock(peer, items);
};

/**
 * Update all peer heights by their best hash.
 * @param {Hash} hash
 * @param {Number} height
 */

Pool.prototype.resolveHeight = function resolveHeight(hash, height) {
  let total = 0;

  for (let peer = this.peers.head(); peer; peer = peer.next) {
    if (peer.bestHash !== hash)
      continue;

    if (peer.bestHeight !== height) {
      peer.bestHeight = height;
      total++;
    }
  }

  if (total > 0)
    this.logger.debug('Resolved height for %d peers.', total);
};

/**
 * Find the next checkpoint.
 * @private
 * @param {Number} height
 * @returns {Object}
 */

Pool.prototype.getNextTip = function getNextTip(height) {
  for (const next of this.network.checkpoints) {
    if (next.height > height)
      return new HeaderEntry(next.hash, next.height);
  }

  throw new Error('Next checkpoint not found.');
};

/**
 * Announce broadcast list to peer.
 * @param {Peer} peer
 */

Pool.prototype.announceList = function announceList(peer) {
  const blocks = [];
  const txs = [];

  for (const item of this.invMap.values()) {
    switch (item.type) {
      case invTypes.BLOCK:
        blocks.push(item.msg);
        break;
      case invTypes.TX:
        txs.push(item.msg);
        break;
      default:
        assert(false, 'Bad item type.');
        break;
    }
  }

  if (blocks.length > 0)
    peer.announceBlock(blocks);

  if (txs.length > 0)
    peer.announceTX(txs);
};

/**
 * Get a block/tx from the broadcast map.
 * @private
 * @param {Peer} peer
 * @param {InvItem} item
 * @returns {Promise}
 */

Pool.prototype.getBroadcasted = function getBroadcasted(peer, item) {
  const type = item.isTX() ? invTypes.TX : invTypes.BLOCK;
  const entry = this.invMap.get(item.hash);

  if (!entry)
    return null;

  if (type !== entry.type) {
    this.logger.debug(
      'Peer requested item with the wrong type (%s).',
      peer.hostname());
    return null;
  }

  this.logger.debug(
    'Peer requested %s %s as a %s packet (%s).',
    item.isTX() ? 'tx' : 'block',
    item.rhash(),
    item.hasWitness() ? 'witness' : 'normal',
    peer.hostname());

  entry.handleAck(peer);

  return entry.msg;
};

/**
 * Get a block/tx either from the broadcast map, mempool, or blockchain.
 * @method
 * @private
 * @param {Peer} peer
 * @param {InvItem} item
 * @returns {Promise}
 */

Pool.prototype.getItem = async function getItem(peer, item) {
  const entry = this.getBroadcasted(peer, item);

  if (entry)
    return entry;

  if (this.options.selfish)
    return null;

  if (item.isTX()) {
    if (!this.mempool)
      return null;
    return this.mempool.getTX(item.hash);
  }

  if (this.chain.options.spv)
    return null;

  if (this.chain.options.prune)
    return null;

  return await this.chain.getBlock(item.hash);
};

/**
 * Send a block from the broadcast list or chain.
 * @method
 * @private
 * @param {Peer} peer
 * @param {InvItem} item
 * @returns {Boolean}
 */

Pool.prototype.sendBlock = async function sendBlock(peer, item, witness) {
  const broadcasted = this.getBroadcasted(peer, item);

  // Check for a broadcasted item first.
  if (broadcasted) {
    peer.send(new packets.BlockPacket(broadcasted, witness));
    return true;
  }

  if (this.options.selfish
      || this.chain.options.spv
      || this.chain.options.prune) {
    return false;
  }

  // If we have the same serialization, we
  // can write the raw binary to the socket.
  if (witness || !this.options.hasWitness()) {
    const block = await this.chain.getRawBlock(item.hash);

    if (block) {
      peer.sendRaw('block', block);
      return true;
    }

    return false;
  }

  const block = await this.chain.getBlock(item.hash);

  if (block) {
    peer.send(new packets.BlockPacket(block, witness));
    return true;
  }

  return false;
};

/**
 * Create an outbound peer with no special purpose.
 * @private
 * @param {NetAddress} addr
 * @returns {Peer}
 */

Pool.prototype.createOutbound = function createOutbound(addr) {
  const cipher = BIP151.ciphers.CHACHAPOLY;
  const identity = this.options.identityKey;
  const peer = Peer.fromOutbound(this.options, addr);

  this.hosts.markAttempt(addr.hostname);

  if (this.options.bip151)
    peer.setCipher(cipher);

  if (this.options.bip150)
    peer.setAuth(this.authdb, identity);

  this.bindPeer(peer);

  this.logger.debug('Connecting to %s.', peer.hostname());

  peer.tryOpen();

  return peer;
};

/**
 * Accept an inbound socket.
 * @private
 * @param {net.Socket} socket
 * @returns {Peer}
 */

Pool.prototype.createInbound = function createInbound(socket) {
  const cipher = BIP151.ciphers.CHACHAPOLY;
  const identity = this.options.identityKey;
  const peer = Peer.fromInbound(this.options, socket);

  if (this.options.bip151)
    peer.setCipher(cipher);

  if (this.options.bip150)
    peer.setAuth(this.authdb, identity);

  this.bindPeer(peer);

  peer.tryOpen();

  return peer;
};

/**
 * Allocate new peer id.
 * @returns {Number}
 */

Pool.prototype.uid = function uid() {
  const MAX = Number.MAX_SAFE_INTEGER;

  if (this.id >= MAX - this.peers.size() - 1)
    this.id = 0;

  // Once we overflow, there's a chance
  // of collisions. Unlikely to happen
  // unless we have tried to connect 9
  // quadrillion times, but still
  // account for it.
  do {
    this.id += 1;
  } while (this.peers.find(this.id));

  return this.id;
};

/**
 * Bind to peer events.
 * @private
 * @param {Peer} peer
 */

Pool.prototype.bindPeer = function bindPeer(peer) {
  peer.id = this.uid();

  peer.onPacket = (packet) => {
    return this.handlePacket(peer, packet);
  };

  peer.on('error', (err) => {
    this.logger.debug(err);
  });

  peer.once('connect', () => {
    this.handleConnect(peer);
  });

  peer.once('open', () => {
    this.handleOpen(peer);
  });

  peer.once('close', (connected) => {
    this.handleClose(peer, connected);
  });

  peer.once('ban', () => {
    this.handleBan(peer);
  });
};

/**
 * Handle peer packet event.
 * @method
 * @private
 * @param {Peer} peer
 * @param {Packet} packet
 * @returns {Promise}
 */

Pool.prototype.handlePacket = async function handlePacket(peer, packet) {
  switch (packet.type) {
    case packetTypes.VERSION:
      await this.handleVersion(peer, packet);
      break;
    case packetTypes.VERACK:
      await this.handleVerack(peer, packet);
      break;
    case packetTypes.PING:
      await this.handlePing(peer, packet);
      break;
    case packetTypes.PONG:
      await this.handlePong(peer, packet);
      break;
    case packetTypes.GETADDR:
      await this.handleGetAddr(peer, packet);
      break;
    case packetTypes.ADDR:
      await this.handleAddr(peer, packet);
      break;
    case packetTypes.INV:
      await this.handleInv(peer, packet);
      break;
    case packetTypes.GETDATA:
      await this.handleGetData(peer, packet);
      break;
    case packetTypes.NOTFOUND:
      await this.handleNotFound(peer, packet);
      break;
    case packetTypes.GETBLOCKS:
      await this.handleGetBlocks(peer, packet);
      break;
    case packetTypes.GETHEADERS:
      await this.handleGetHeaders(peer, packet);
      break;
    case packetTypes.HEADERS:
      await this.handleHeaders(peer, packet);
      break;
    case packetTypes.SENDHEADERS:
      await this.handleSendHeaders(peer, packet);
      break;
    case packetTypes.BLOCK:
      await this.handleBlock(peer, packet);
      break;
    case packetTypes.TX:
      await this.handleTX(peer, packet);
      break;
    case packetTypes.REJECT:
      await this.handleReject(peer, packet);
      break;
    case packetTypes.MEMPOOL:
      await this.handleMempool(peer, packet);
      break;
    case packetTypes.FILTERLOAD:
      await this.handleFilterLoad(peer, packet);
      break;
    case packetTypes.FILTERADD:
      await this.handleFilterAdd(peer, packet);
      break;
    case packetTypes.FILTERCLEAR:
      await this.handleFilterClear(peer, packet);
      break;
    case packetTypes.MERKLEBLOCK:
      await this.handleMerkleBlock(peer, packet);
      break;
    case packetTypes.FEEFILTER:
      await this.handleFeeFilter(peer, packet);
      break;
    case packetTypes.SENDCMPCT:
      await this.handleSendCmpct(peer, packet);
      break;
    case packetTypes.CMPCTBLOCK:
      await this.handleCmpctBlock(peer, packet);
      break;
    case packetTypes.GETBLOCKTXN:
      await this.handleGetBlockTxn(peer, packet);
      break;
    case packetTypes.BLOCKTXN:
      await this.handleBlockTxn(peer, packet);
      break;
    case packetTypes.ENCINIT:
      await this.handleEncinit(peer, packet);
      break;
    case packetTypes.ENCACK:
      await this.handleEncack(peer, packet);
      break;
    case packetTypes.AUTHCHALLENGE:
      await this.handleAuthChallenge(peer, packet);
      break;
    case packetTypes.AUTHREPLY:
      await this.handleAuthReply(peer, packet);
      break;
    case packetTypes.AUTHPROPOSE:
      await this.handleAuthPropose(peer, packet);
      break;
    case packetTypes.UNKNOWN:
      await this.handleUnknown(peer, packet);
      break;
    default:
      assert(false, 'Bad packet type.');
      break;
  }

  this.emit('packet', packet, peer);
};

/**
 * Handle peer connect event.
 * @method
 * @private
 * @param {Peer} peer
 */

Pool.prototype.handleConnect = async function handleConnect(peer) {
  this.logger.info('Connected to %s.', peer.hostname());

  if (peer.outbound)
    this.hosts.markSuccess(peer.hostname());

  this.emit('peer connect', peer);
};

/**
 * Handle peer open event.
 * @method
 * @private
 * @param {Peer} peer
 */

Pool.prototype.handleOpen = async function handleOpen(peer) {
  // Advertise our address.
  if (!this.options.selfish && this.options.listen) {
    const addr = this.hosts.getLocal(peer.address);
    if (addr)
      peer.send(new packets.AddrPacket([addr]));
  }

  // We want compact blocks!
  if (this.options.compact)
    peer.sendCompact(this.options.blockMode);

  // Find some more peers.
  if (!this.hosts.isFull())
    peer.sendGetAddr();

  // Relay our spv filter if we have one.
  if (this.spvFilter)
    peer.sendFilterLoad(this.spvFilter);

  // Announce our currently broadcasted items.
  this.announceList(peer);

  // Set a fee rate filter.
  if (this.options.feeRate !== -1)
    peer.sendFeeRate(this.options.feeRate);

  // Start syncing the chain.
  if (peer.outbound)
    this.sendSync(peer);

  if (peer.outbound) {
    this.hosts.markAck(peer.hostname(), peer.services);

    // If we don't have an ack'd
    // loader yet consider it dead.
    if (!peer.loader) {
      if (this.peers.load && !this.peers.load.handshake) {
        assert(this.peers.load.loader);
        this.peers.load.loader = false;
        this.peers.load = null;
      }
    }

    // If we do not have a loader,
    // use this peer.
    if (!this.peers.load)
      this.setLoader(peer);
  }

  this.emit('peer open', peer);
};

/**
 * Handle peer close event.
 * @method
 * @private
 * @param {Peer} peer
 * @param {Boolean} connected
 */

Pool.prototype.handleClose = async function handleClose(peer, connected) {
  const outbound = peer.outbound;
  const loader = peer.loader;
  const size = peer.blockMap.size;

  this.removePeer(peer);

  if (loader) {
    this.logger.info('Removed loader peer (%s).', peer.hostname());
    if (this.checkpoints)
      this.resetChain();
  }

  this.nonces.remove(peer.hostname());

  this.emit('peer close', peer, connected);

  if (!this.loaded)
    return;

  if (this.disconnecting)
    return;

  if (this.chain.synced && size > 0) {
    this.logger.warning('Peer disconnected with requested blocks.');
    this.logger.warning('Resending sync...');
    this.forceSync();
  }

  if (!outbound)
    return;

  this.refill();
};

/**
 * Handle ban event.
 * @method
 * @private
 * @param {Peer} peer
 */

Pool.prototype.handleBan = async function handleBan(peer) {
  this.ban(peer.address);
  this.emit('ban', peer);
};

/**
 * Handle peer version event.
 * @method
 * @private
 * @param {Peer} peer
 * @param {VersionPacket} packet
 */

Pool.prototype.handleVersion = async function handleVersion(peer, packet) {
  this.logger.info(
    'Received version (%s): version=%d height=%d services=%s agent=%s',
    peer.hostname(),
    packet.version,
    packet.height,
    packet.services.toString(2),
    packet.agent);

  this.network.time.add(peer.hostname(), packet.time);
  this.nonces.remove(peer.hostname());

  if (!peer.outbound && packet.remote.isRoutable())
    this.hosts.markLocal(packet.remote);
};

/**
 * Handle `verack` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {VerackPacket} packet
 */

Pool.prototype.handleVerack = async function handleVerack(peer, packet) {
  ;
};

/**
 * Handle `ping` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {PingPacket} packet
 */

Pool.prototype.handlePing = async function handlePing(peer, packet) {
  ;
};

/**
 * Handle `pong` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {PongPacket} packet
 */

Pool.prototype.handlePong = async function handlePong(peer, packet) {
  ;
};

/**
 * Handle `getaddr` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {GetAddrPacket} packet
 */

Pool.prototype.handleGetAddr = async function handleGetAddr(peer, packet) {
  if (this.options.selfish)
    return;

  if (peer.sentAddr) {
    this.logger.debug(
      'Ignoring repeated getaddr (%s).',
      peer.hostname());
    return;
  }

  peer.sentAddr = true;

  const addrs = this.hosts.toArray();
  const items = [];

  for (const addr of addrs) {
    if (!peer.addrFilter.added(addr.hostname, 'ascii'))
      continue;

    items.push(addr);

    if (items.length === 1000)
      break;
  }

  if (items.length === 0)
    return;

  this.logger.debug(
    'Sending %d addrs to peer (%s)',
    items.length,
    peer.hostname());

  peer.send(new packets.AddrPacket(items));
};

/**
 * Handle peer addr event.
 * @method
 * @private
 * @param {Peer} peer
 * @param {AddrPacket} packet
 */

Pool.prototype.handleAddr = async function handleAddr(peer, packet) {
  const addrs = packet.items;
  const now = this.network.now();
  const services = this.options.getRequiredServices();

  for (const addr of addrs) {
    peer.addrFilter.add(addr.hostname, 'ascii');

    if (!addr.isRoutable())
      continue;

    if (!addr.hasServices(services))
      continue;

    if (addr.time <= 100000000 || addr.time > now + 10 * 60)
      addr.time = now - 5 * 24 * 60 * 60;

    if (addr.port === 0)
      continue;

    this.hosts.add(addr, peer.address);
  }

  this.logger.info(
    'Received %d addrs (hosts=%d, peers=%d) (%s).',
    addrs.length,
    this.hosts.size(),
    this.peers.size(),
    peer.hostname());

  this.fillOutbound();
};

/**
 * Handle `inv` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {InvPacket} packet
 */

Pool.prototype.handleInv = async function handleInv(peer, packet) {
  const unlock = await this.locker.lock();
  try {
    return await this._handleInv(peer, packet);
  } finally {
    unlock();
  }
};

/**
 * Handle `inv` packet (without a lock).
 * @method
 * @private
 * @param {Peer} peer
 * @param {InvPacket} packet
 */

Pool.prototype._handleInv = async function _handleInv(peer, packet) {
  const items = packet.items;

  if (items.length > 50000) {
    peer.increaseBan(100);
    return;
  }

  const blocks = [];
  const txs = [];
  let unknown = -1;

  for (const item of items) {
    switch (item.type) {
      case invTypes.BLOCK:
        blocks.push(item.hash);
        break;
      case invTypes.TX:
        txs.push(item.hash);
        break;
      default:
        unknown = item.type;
        continue;
    }
    peer.invFilter.add(item.hash, 'hex');
  }

  this.logger.spam(
    'Received inv packet with %d items: blocks=%d txs=%d (%s).',
    items.length, blocks.length, txs.length, peer.hostname());

  if (unknown !== -1) {
    this.logger.warning(
      'Peer sent an unknown inv type: %d (%s).',
      unknown, peer.hostname());
  }

  if (blocks.length > 0)
    await this.handleBlockInv(peer, blocks);

  if (txs.length > 0)
    await this.handleTXInv(peer, txs);
};

/**
 * Handle `inv` packet from peer (containing only BLOCK types).
 * @method
 * @private
 * @param {Peer} peer
 * @param {Hash[]} hashes
 * @returns {Promise}
 */

Pool.prototype.handleBlockInv = async function handleBlockInv(peer, hashes) {
  assert(hashes.length > 0);

  if (!this.syncing)
    return;

  // Always keep track of the peer's best hash.
  if (!peer.loader || this.chain.synced) {
    const hash = hashes[hashes.length - 1];
    peer.bestHash = hash;
  }

  // Ignore for now if we're still syncing
  if (!this.chain.synced && !peer.loader)
    return;

  if (this.options.hasWitness() && !peer.hasWitness())
    return;

  // Request headers instead.
  if (this.checkpoints)
    return;

  this.logger.debug(
    'Received %s block hashes from peer (%s).',
    hashes.length,
    peer.hostname());

  const items = [];
  //let exists;
  let exists = null;

  for (let i = 0; i < hashes.length; i++) {
    const hash = hashes[i];

    // Resolve orphan chain.
    if (this.chain.hasOrphan(hash)) {
      this.logger.debug('Received known orphan hash (%s).', peer.hostname());
      await this.resolveOrphan(peer, hash);
      continue;
    }

    // Request the block if we don't have it.
    if (!await this.hasBlock(hash)) {
      items.push(hash);
      continue;
    }

    exists = hash;

    // Normally we request the hashContinue.
    // In the odd case where we already have
    // it, we can do one of two things: either
    // force re-downloading of the block to
    // continue the sync, or do a getblocks
    // from the last hash (this will reset
    // the hashContinue on the remote node).
    if (i === hashes.length - 1) {
      this.logger.debug('Received existing hash (%s).', peer.hostname());
      await this.getBlocks(peer, hash);
    }
  }

  // Attempt to update the peer's best height
  // with the last existing hash we know of.
  if (exists && this.chain.synced) {
    const height = await this.chain.getHeight(exists);
    if (height !== -1)
      peer.bestHeight = height;
  }

  this.getBlock(peer, items);
};

/**
 * Handle peer inv packet (txs).
 * @method
 * @private
 * @param {Peer} peer
 * @param {Hash[]} hashes
 */

Pool.prototype.handleTXInv = async function handleTXInv(peer, hashes) {
  assert(hashes.length > 0);

  if (this.syncing && !this.chain.synced)
    return;

  this.ensureTX(peer, hashes);
};

/**
 * Handle `getdata` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {GetDataPacket} packet
 */

Pool.prototype.handleGetData = async function handleGetData(peer, packet) {
  const items = packet.items;

  if (items.length > 50000) {
    this.logger.warning('Peer sent inv with >50k items (%s).', peer.hostname());
    peer.increaseBan(100);
    peer.destroy();
    return;
  }

  const notFound = [];
  let txs = 0;
  let blocks = 0;
  let compact = 0;
  let unknown = -1;

  for (const item of items) {
    if (item.isTX()) {
      const tx = await this.getItem(peer, item);

      if (!tx) {
        notFound.push(item);
        continue;
      }

      // Coinbases are an insta-ban from any node.
      // This should technically never happen, but
      // it's worth keeping here just in case. A
      // 24-hour ban from any node is rough.
      if (tx.isCoinbase()) {
        notFound.push(item);
        this.logger.warning('Failsafe: tried to relay a coinbase.');
        continue;
      }

      peer.send(new packets.TXPacket(tx, item.hasWitness()));

      txs++;

      continue;
    }

    switch (item.type) {
      case invTypes.BLOCK:
      case invTypes.WITNESS_BLOCK: {
        const result = await this.sendBlock(peer, item, item.hasWitness());
        if (!result) {
          notFound.push(item);
          continue;
        }
        blocks++;
        break;
      }
      case invTypes.FILTERED_BLOCK:
      case invTypes.WITNESS_FILTERED_BLOCK: {
        if (!this.options.bip37) {
          this.logger.debug(
            'Peer requested a merkleblock without bip37 enabled (%s).',
            peer.hostname());
          peer.destroy();
          return;
        }

        if (!peer.spvFilter) {
          notFound.push(item);
          continue;
        }

        const block = await this.getItem(peer, item);

        if (!block) {
          notFound.push(item);
          continue;
        }

        const merkle = block.toMerkle(peer.spvFilter);

        peer.send(new packets.MerkleBlockPacket(merkle));

        for (const tx of merkle.txs) {
          peer.send(new packets.TXPacket(tx, item.hasWitness()));
          txs++;
        }

        blocks++;

        break;
      }
      case invTypes.CMPCT_BLOCK: {
        const height = await this.chain.getHeight(item.hash);

        // Fallback to full block.
        if (height < this.chain.tip.height - 10) {
          const result = await this.sendBlock(peer, item, peer.compactWitness);
          if (!result) {
            notFound.push(item);
            continue;
          }
          blocks++;
          break;
        }

        const block = await this.getItem(peer, item);

        if (!block) {
          notFound.push(item);
          continue;
        }

        peer.sendCompactBlock(block);

        blocks++;
        compact++;

        break;
      }
      default: {
        unknown = item.type;
        notFound.push(item);
        continue;
      }
    }

    if (item.hash === peer.hashContinue) {
      peer.sendInv([new InvItem(invTypes.BLOCK, this.chain.tip.hash)]);
      peer.hashContinue = null;
    }

    // Wait for the peer to read
    // before we pull more data
    // out of the database.
    await peer.drain();
  }

  if (notFound.length > 0)
    peer.send(new packets.NotFoundPacket(notFound));

  if (txs > 0) {
    this.logger.debug(
      'Served %d txs with getdata (notfound=%d) (%s).',
      txs, notFound.length, peer.hostname());
  }

  if (blocks > 0) {
    this.logger.debug(
      'Served %d blocks with getdata (notfound=%d, cmpct=%d) (%s).',
      blocks, notFound.length, compact, peer.hostname());
  }

  if (unknown !== -1) {
    this.logger.warning(
      'Peer sent an unknown getdata type: %s (%d).',
      unknown, peer.hostname());
  }
};

/**
 * Handle peer notfound packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {NotFoundPacket} packet
 */

Pool.prototype.handleNotFound = async function handleNotFound(peer, packet) {
  const items = packet.items;

  for (const item of items) {
    if (!this.resolveItem(peer, item)) {
      this.logger.warning(
        'Peer sent notfound for unrequested item: %s (%s).',
        item.hash, peer.hostname());
      peer.destroy();
      return;
    }
  }
};

/**
 * Handle `getblocks` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {GetBlocksPacket} packet
 */

Pool.prototype.handleGetBlocks = async function handleGetBlocks(peer, packet) {
  if (!this.chain.synced)
    return;

  if (this.options.selfish)
    return;

  if (this.chain.options.spv)
    return;

  if (this.chain.options.prune)
    return;

  let hash = await this.chain.findLocator(packet.locator);

  if (hash)
    hash = await this.chain.getNextHash(hash);

  const blocks = [];

  while (hash) {
    blocks.push(new InvItem(invTypes.BLOCK, hash));

    if (hash === packet.stop)
      break;

    if (blocks.length === 500) {
      peer.hashContinue = hash;
      break;
    }

    hash = await this.chain.getNextHash(hash);
  }

  peer.sendInv(blocks);
};

/**
 * Handle `getheaders` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {GetHeadersPacket} packet
 */

Pool.prototype.handleGetHeaders = async function handleGetHeaders(peer, packet) {
  if (!this.chain.synced)
    return;

  if (this.options.selfish)
    return;

  if (this.chain.options.spv)
    return;

  if (this.chain.options.prune)
    return;

  let hash;
  if (packet.locator.length > 0) {
    hash = await this.chain.findLocator(packet.locator);
    if (hash)
      hash = await this.chain.getNextHash(hash);
  } else {
    hash = packet.stop;
  }

  let entry;
  if (hash)
    entry = await this.chain.getEntry(hash);

  const headers = [];

  while (entry) {
    headers.push(entry.toHeaders());

    if (entry.hash === packet.stop)
      break;

    if (headers.length === 2000)
      break;

    entry = await this.chain.getNext(entry);
  }

  peer.sendHeaders(headers);
};

/**
 * Handle `headers` packet from a given peer.
 * @method
 * @private
 * @param {Peer} peer
 * @param {HeadersPacket} packet
 * @returns {Promise}
 */

Pool.prototype.handleHeaders = async function handleHeaders(peer, packet) {
  const unlock = await this.locker.lock();
  try {
    return await this._handleHeaders(peer, packet);
  } finally {
    unlock();
  }
};

/**
 * Handle `headers` packet from
 * a given peer without a lock.
 * @method
 * @private
 * @param {Peer} peer
 * @param {HeadersPacket} packet
 * @returns {Promise}
 */

Pool.prototype._handleHeaders = async function _handleHeaders(peer, packet) {
  const headers = packet.items;

  if (!this.checkpoints)
    return;

  if (!this.syncing)
    return;

  if (!peer.loader)
    return;

  if (headers.length === 0)
    return;

  if (headers.length > 2000) {
    peer.increaseBan(100);
    return;
  }

  assert(this.headerChain.size > 0);

  let checkpoint = false;
  let node = null;

  for (const header of headers) {
    const last = this.headerChain.tail;
    const hash = header.hash('hex');
    const height = last.height + 1;

    if (!header.verify()) {
      this.logger.warning(
        'Peer sent an invalid header (%s).',
        peer.hostname());
      peer.increaseBan(100);
      peer.destroy();
      return;
    }

    if (header.prevBlock !== last.hash) {
      this.logger.warning(
        'Peer sent a bad header chain (%s).',
        peer.hostname());
      peer.destroy();
      return;
    }

    node = new HeaderEntry(hash, height);

    if (node.height === this.headerTip.height) {
      if (node.hash !== this.headerTip.hash) {
        this.logger.warning(
          'Peer sent an invalid checkpoint (%s).',
          peer.hostname());
        peer.destroy();
        return;
      }
      checkpoint = true;
    }

    if (!this.headerNext)
      this.headerNext = node;

    this.headerChain.push(node);
  }

  this.logger.debug(
    'Received %s headers from peer (%s).',
    headers.length,
    peer.hostname());

  // If we received a valid header
  // chain, consider this a "block".
  peer.blockTime = util.ms();

  // Request the blocks we just added.
  if (checkpoint) {
    this.headerChain.shift();
    this.resolveHeaders(peer);
    return;
  }

  // Request more headers.
  peer.sendGetHeaders([node.hash], this.headerTip.hash);
};

/**
 * Handle `sendheaders` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {SendHeadersPacket} packet
 * @returns {Promise}
 */

Pool.prototype.handleSendHeaders = async function handleSendHeaders(peer, packet) {
  ;
};

/**
 * Handle `block` packet. Attempt to add to chain.
 * @method
 * @private
 * @param {Peer} peer
 * @param {BlockPacket} packet
 * @returns {Promise}
 */

Pool.prototype.handleBlock = async function handleBlock(peer, packet) {
  const flags = chainCommon.flags.DEFAULT_FLAGS;

  if (this.options.spv) {
    this.logger.warning(
      'Peer sent unsolicited block (%s).',
      peer.hostname());
    return;
  }

  await this.addBlock(peer, packet.block, flags);
};

/**
 * Attempt to add block to chain.
 * @method
 * @private
 * @param {Peer} peer
 * @param {Block} block
 * @returns {Promise}
 */

Pool.prototype.addBlock = async function addBlock(peer, block, flags) {
  const hash = block.hash('hex');
  const unlock = await this.locker.lock(hash);
  try {
    return await this._addBlock(peer, block, flags);
  } finally {
    unlock();
  }
};

/**
 * Attempt to add block to chain (without a lock).
 * @method
 * @private
 * @param {Peer} peer
 * @param {Block} block
 * @returns {Promise}
 */

Pool.prototype._addBlock = async function _addBlock(peer, block, flags) {
  if (!this.syncing)
    return;

  const hash = block.hash('hex');

  if (!this.resolveBlock(peer, hash)) {
    this.logger.warning(
      'Received unrequested block: %s (%s).',
      block.rhash(), peer.hostname());
    peer.destroy();
    return;
  }

  peer.blockTime = util.ms();

  let entry;
  try {
    entry = await this.chain.add(block, flags, peer.id);
  } catch (err) {
    if (err.type === 'VerifyError') {
      peer.reject('block', err);
      this.logger.warning(err);
      return;
    }
    throw err;
  }

  // Block was orphaned.
  if (!entry) {
    if (this.checkpoints) {
      this.logger.warning(
        'Peer sent orphan block with getheaders (%s).',
        peer.hostname());
      return;
    }

    // During a getblocks sync, peers send
    // their best tip frequently. We can grab
    // the height commitment from the coinbase.
    const height = block.getCoinbaseHeight();

    if (height !== -1) {
      peer.bestHash = hash;
      peer.bestHeight = height;
      this.resolveHeight(hash, height);
    }

    this.logger.debug('Peer sent an orphan block. Resolving.');

    await this.resolveOrphan(peer, hash);

    return;
  }

  if (this.chain.synced) {
    peer.bestHash = entry.hash;
    peer.bestHeight = entry.height;
    this.resolveHeight(entry.hash, entry.height);
  }

  this.logStatus(block);

  await this.resolveChain(peer, hash);
};

/**
 * Resolve header chain.
 * @method
 * @private
 * @param {Peer} peer
 * @param {Hash} hash
 * @returns {Promise}
 */

Pool.prototype.resolveChain = async function resolveChain(peer, hash) {
  if (!this.checkpoints)
    return;

  if (!peer.loader)
    return;

  if (peer.destroyed)
    throw new Error('Peer was destroyed (header chain resolution).');

  const node = this.headerChain.head;

  assert(node);

  if (hash !== node.hash) {
    this.logger.warning(
      'Header hash mismatch %s != %s (%s).',
      util.revHex(hash),
      util.revHex(node.hash),
      peer.hostname());

    peer.destroy();

    return;
  }

  if (node.height < this.network.lastCheckpoint) {
    if (node.height === this.headerTip.height) {
      this.logger.info(
        'Received checkpoint %s (%d).',
        util.revHex(node.hash), node.height);

      this.headerTip = this.getNextTip(node.height);

      peer.sendGetHeaders([hash], this.headerTip.hash);

      return;
    }

    this.headerChain.shift();
    this.resolveHeaders(peer);

    return;
  }

  this.logger.info(
    'Switching to getblocks (%s).',
    peer.hostname());

  await this.switchSync(peer, hash);
};

/**
 * Switch to getblocks.
 * @method
 * @private
 * @param {Peer} peer
 * @param {Hash} hash
 * @returns {Promise}
 */

Pool.prototype.switchSync = async function switchSync(peer, hash) {
  assert(this.checkpoints);

  this.checkpoints = false;
  this.headerTip = null;
  this.headerChain.reset();
  this.headerNext = null;

  await this.getBlocks(peer, hash);
};

/**
 * Handle bad orphan.
 * @method
 * @private
 * @param {String} msg
 * @param {VerifyError} err
 * @param {Number} id
 */

Pool.prototype.handleBadOrphan = function handleBadOrphan(msg, err, id) {
  const peer = this.peers.find(id);

  if (!peer) {
    this.logger.warning(
      'Could not find offending peer for orphan: %s (%d).',
      util.revHex(err.hash), id);
    return;
  }

  this.logger.debug(
    'Punishing peer for sending a bad orphan (%s).',
    peer.hostname());

  // Punish the original peer who sent this.
  peer.reject(msg, err);
};

/**
 * Log sync status.
 * @private
 * @param {Block} block
 */

Pool.prototype.logStatus = function logStatus(block) {
  if (this.chain.height % 20 === 0) {
    this.logger.debug('Status:'
      + ' time=%s height=%d progress=%s'
      + ' orphans=%d active=%d'
      + ' target=%s peers=%d',
      util.date(block.time),
      this.chain.height,
      (this.chain.getProgress() * 100).toFixed(2) + '%',
      this.chain.orphanMap.size,
      this.blockMap.size,
      block.bits,
      this.peers.size());
  }

  if (this.chain.height % 2000 === 0) {
    this.logger.info(
      'Received 2000 more blocks (height=%d, hash=%s).',
      this.chain.height,
      block.rhash());
  }
};

/**
 * Handle a transaction. Attempt to add to mempool.
 * @method
 * @private
 * @param {Peer} peer
 * @param {TXPacket} packet
 * @returns {Promise}
 */

Pool.prototype.handleTX = async function handleTX(peer, packet) {
  const hash = packet.tx.hash('hex');
  const unlock = await this.locker.lock(hash);
  try {
    return await this._handleTX(peer, packet);
  } finally {
    unlock();
  }
};

/**
 * Handle a transaction. Attempt to add to mempool (without a lock).
 * @method
 * @private
 * @param {Peer} peer
 * @param {TXPacket} packet
 * @returns {Promise}
 */

Pool.prototype._handleTX = async function _handleTX(peer, packet) {
  const tx = packet.tx;
  const hash = tx.hash('hex');
  const flags = chainCommon.flags.VERIFY_NONE;
  const block = peer.merkleBlock;

  if (block) {
    assert(peer.merkleMatches > 0);
    assert(peer.merkleMap);

    if (block.hasTX(hash)) {
      if (peer.merkleMap.has(hash)) {
        this.logger.warning(
          'Peer sent duplicate merkle tx: %s (%s).',
          tx.txid(), peer.hostname());
        peer.increaseBan(100);
        return;
      }

      peer.merkleMap.add(hash);

      block.txs.push(tx);

      if (--peer.merkleMatches === 0) {
        peer.merkleBlock = null;
        peer.merkleTime = -1;
        peer.merkleMatches = 0;
        peer.merkleMap = null;
        await this._addBlock(peer, block, flags);
      }

      return;
    }
  }

  if (!this.resolveTX(peer, hash)) {
    this.logger.warning(
      'Peer sent unrequested tx: %s (%s).',
      tx.txid(), peer.hostname());
    peer.destroy();
    return;
  }

  if (!this.mempool) {
    this.emit('tx', tx);
    return;
  }

  let missing;
  try {
    missing = await this.mempool.addTX(tx, peer.id);
  } catch (err) {
    if (err.type === 'VerifyError') {
      peer.reject('tx', err);
      this.logger.info(err);
      return;
    }
    throw err;
  }

  if (missing && missing.length > 0) {
    this.logger.debug(
      'Requesting %d missing transactions (%s).',
      missing.length, peer.hostname());

    this.ensureTX(peer, missing);
  }
};

/**
 * Handle peer reject event.
 * @method
 * @private
 * @param {Peer} peer
 * @param {RejectPacket} packet
 */

Pool.prototype.handleReject = async function handleReject(peer, packet) {
  this.logger.warning(
    'Received reject (%s): msg=%s code=%s reason=%s hash=%s.',
    peer.hostname(),
    packet.message,
    packet.getCode(),
    packet.reason,
    packet.rhash());

  if (!packet.hash)
    return;

  const entry = this.invMap.get(packet.hash);

  if (!entry)
    return;

  entry.handleReject(peer);
};

/**
 * Handle `mempool` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {MempoolPacket} packet
 */

Pool.prototype.handleMempool = async function handleMempool(peer, packet) {
  if (!this.mempool)
    return;

  if (!this.chain.synced)
    return;

  if (this.options.selfish)
    return;

  if (!this.options.bip37) {
    this.logger.debug(
      'Peer requested mempool without bip37 enabled (%s).',
      peer.hostname());
    peer.destroy();
    return;
  }

  const items = [];

  for (const hash of this.mempool.map.keys())
    items.push(new InvItem(invTypes.TX, hash));

  this.logger.debug(
    'Sending mempool snapshot (%s).',
    peer.hostname());

  peer.queueInv(items);
};

/**
 * Handle `filterload` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {FilterLoadPacket} packet
 */

Pool.prototype.handleFilterLoad = async function handleFilterLoad(peer, packet) {
  ;
};

/**
 * Handle `filteradd` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {FilterAddPacket} packet
 */

Pool.prototype.handleFilterAdd = async function handleFilterAdd(peer, packet) {
  ;
};

/**
 * Handle `filterclear` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {FilterClearPacket} packet
 */

Pool.prototype.handleFilterClear = async function handleFilterClear(peer, packet) {
  ;
};

/**
 * Handle `merkleblock` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {MerkleBlockPacket} block
 */

Pool.prototype.handleMerkleBlock = async function handleMerkleBlock(peer, packet) {
  const hash = packet.block.hash('hex');
  const unlock = await this.locker.lock(hash);
  try {
    return await this._handleMerkleBlock(peer, packet);
  } finally {
    unlock();
  }
};

/**
 * Handle `merkleblock` packet (without a lock).
 * @method
 * @private
 * @param {Peer} peer
 * @param {MerkleBlockPacket} block
 */

Pool.prototype._handleMerkleBlock = async function _handleMerkleBlock(peer, packet) {
  if (!this.syncing)
    return;

  // Potential DoS.
  if (!this.options.spv) {
    this.logger.warning(
      'Peer sent unsolicited merkleblock (%s).',
      peer.hostname());
    peer.increaseBan(100);
    return;
  }

  const block = packet.block;
  const hash = block.hash('hex');

  if (!peer.blockMap.has(hash)) {
    this.logger.warning(
      'Peer sent an unrequested merkleblock (%s).',
      peer.hostname());
    peer.destroy();
    return;
  }

  if (peer.merkleBlock) {
    this.logger.warning(
      'Peer sent a merkleblock prematurely (%s).',
      peer.hostname());
    peer.increaseBan(100);
    return;
  }

  if (!block.verify()) {
    this.logger.warning(
      'Peer sent an invalid merkleblock (%s).',
      peer.hostname());
    peer.increaseBan(100);
    return;
  }

  const tree = block.getTree();

  if (tree.matches.length === 0) {
    const flags = chainCommon.flags.VERIFY_NONE;
    await this._addBlock(peer, block, flags);
    return;
  }

  peer.merkleBlock = block;
  peer.merkleTime = util.ms();
  peer.merkleMatches = tree.matches.length;
  peer.merkleMap = new Set();
};

/**
 * Handle `sendcmpct` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {FeeFilterPacket} packet
 */

Pool.prototype.handleFeeFilter = async function handleFeeFilter(peer, packet) {
  ;
};

/**
 * Handle `sendcmpct` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {SendCmpctPacket} packet
 */

Pool.prototype.handleSendCmpct = async function handleSendCmpct(peer, packet) {
  ;
};

/**
 * Handle `cmpctblock` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {CompactBlockPacket} packet
 */

Pool.prototype.handleCmpctBlock = async function handleCmpctBlock(peer, packet) {
  const block = packet.block;
  const hash = block.hash('hex');
  const witness = peer.compactWitness;

  if (!this.syncing)
    return;

  if (!this.options.compact) {
    this.logger.info(
      'Peer sent unsolicited cmpctblock (%s).',
      peer.hostname());
    this.destroy();
    return;
  }

  if (!peer.hasCompactSupport() || !peer.hasCompact()) {
    this.logger.info(
      'Peer sent unsolicited cmpctblock (%s).',
      peer.hostname());
    this.destroy();
    return;
  }

  if (peer.compactBlocks.has(hash)) {
    this.logger.debug(
      'Peer sent us a duplicate compact block (%s).',
      peer.hostname());
    return;
  }

  if (this.compactBlocks.has(hash)) {
    this.logger.debug(
      'Already waiting for compact block %s (%s).',
      hash, peer.hostname());
    return;
  }

  if (!peer.blockMap.has(hash)) {
    if (this.options.blockMode !== 1) {
      this.logger.warning(
        'Peer sent us an unrequested compact block (%s).',
        peer.hostname());
      peer.destroy();
      return;
    }
    peer.blockMap.set(hash, util.ms());
    assert(!this.blockMap.has(hash));
    this.blockMap.add(hash);
  }

  if (!this.mempool) {
    this.logger.warning('Requesting compact blocks without a mempool!');
    return;
  }

  if (!block.verify()) {
    this.logger.debug(
      'Peer sent an invalid compact block (%s).',
      peer.hostname());
    peer.increaseBan(100);
    return;
  }

  let result;
  try {
    result = block.init();
  } catch (e) {
    this.logger.debug(
      'Peer sent an invalid compact block (%s).',
      peer.hostname());
    peer.increaseBan(100);
    return;
  }

  if (!result) {
    this.logger.warning(
      'Siphash collision for %s. Requesting full block (%s).',
      block.rhash(), peer.hostname());
    peer.getFullBlock(hash);
    peer.increaseBan(10);
    return;
  }

  const full = block.fillMempool(witness, this.mempool);

  if (full) {
    this.logger.debug(
      'Received full compact block %s (%s).',
      block.rhash(), peer.hostname());
    const flags = chainCommon.flags.VERIFY_BODY;
    await this.addBlock(peer, block.toBlock(), flags);
    return;
  }

  if (this.options.blockMode === 1) {
    if (peer.compactBlocks.size >= 15) {
      this.logger.warning('Compact block DoS attempt (%s).', peer.hostname());
      peer.destroy();
      return;
    }
  }

  block.now = util.ms();

  assert(!peer.compactBlocks.has(hash));
  peer.compactBlocks.set(hash, block);

  this.compactBlocks.add(hash);

  this.logger.debug(
    'Received non-full compact block %s tx=%d/%d (%s).',
    block.rhash(), block.count, block.totalTX, peer.hostname());

  peer.send(new packets.GetBlockTxnPacket(block.toRequest()));
};

/**
 * Handle `getblocktxn` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {GetBlockTxnPacket} packet
 */

Pool.prototype.handleGetBlockTxn = async function handleGetBlockTxn(peer, packet) {
  const req = packet.request;

  if (this.chain.options.spv)
    return;

  if (this.chain.options.prune)
    return;

  if (this.options.selfish)
    return;

  const item = new InvItem(invTypes.BLOCK, req.hash);

  const block = await this.getItem(peer, item);

  if (!block) {
    this.logger.debug(
      'Peer sent getblocktxn for non-existent block (%s).',
      peer.hostname());
    peer.increaseBan(100);
    return;
  }

  const height = await this.chain.getHeight(req.hash);

  if (height < this.chain.tip.height - 15) {
    this.logger.debug(
      'Peer sent a getblocktxn for a block > 15 deep (%s)',
      peer.hostname());
    return;
  }

  this.logger.debug(
    'Sending blocktxn for %s to peer (%s).',
    block.rhash(),
    peer.hostname());

  const res = BIP152.TXResponse.fromBlock(block, req);

  peer.send(new packets.BlockTxnPacket(res, peer.compactWitness));
};

/**
 * Handle `blocktxn` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {BlockTxnPacket} packet
 */

Pool.prototype.handleBlockTxn = async function handleBlockTxn(peer, packet) {
  const res = packet.response;
  const block = peer.compactBlocks.get(res.hash);
  const flags = chainCommon.flags.VERIFY_BODY;

  if (!block) {
    this.logger.debug(
      'Peer sent unsolicited blocktxn (%s).',
      peer.hostname());
    return;
  }

  peer.compactBlocks.delete(res.hash);

  assert(this.compactBlocks.has(res.hash));
  this.compactBlocks.delete(res.hash);

  if (!block.fillMissing(res)) {
    this.logger.warning(
      'Peer sent non-full blocktxn for %s. Requesting full block (%s).',
      block.rhash(),
      peer.hostname());
    peer.getFullBlock(res.hash);
    peer.increaseBan(10);
    return;
  }

  this.logger.debug(
    'Filled compact block %s (%s).',
    block.rhash(), peer.hostname());

  await this.addBlock(peer, block.toBlock(), flags);
};

/**
 * Handle `encinit` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {EncinitPacket} packet
 */

Pool.prototype.handleEncinit = async function handleEncinit(peer, packet) {
  ;
};

/**
 * Handle `encack` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {EncackPacket} packet
 */

Pool.prototype.handleEncack = async function handleEncack(peer, packet) {
  ;
};

/**
 * Handle `authchallenge` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {AuthChallengePacket} packet
 */

Pool.prototype.handleAuthChallenge = async function handleAuthChallenge(peer, packet) {
  ;
};

/**
 * Handle `authreply` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {AuthReplyPacket} packet
 */

Pool.prototype.handleAuthReply = async function handleAuthReply(peer, packet) {
  ;
};

/**
 * Handle `authpropose` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {AuthProposePacket} packet
 */

Pool.prototype.handleAuthPropose = async function handleAuthPropose(peer, packet) {
  ;
};

/**
 * Handle `unknown` packet.
 * @method
 * @private
 * @param {Peer} peer
 * @param {UnknownPacket} packet
 */

Pool.prototype.handleUnknown = async function handleUnknown(peer, packet) {
  this.logger.warning(
    'Unknown packet: %s (%s).',
    packet.cmd, peer.hostname());
};

/**
 * Create an inbound peer from an existing socket.
 * @private
 * @param {net.Socket} socket
 */

Pool.prototype.addInbound = function addInbound(socket) {
  if (!this.loaded) {
    socket.destroy();
    return;
  }

  const peer = this.createInbound(socket);

  this.logger.info('Added inbound peer (%s).', peer.hostname());

  this.peers.add(peer);
};

/**
 * Allocate a host from the host list.
 * @returns {NetAddress}
 */

Pool.prototype.getHost = function getHost() {
  for (const addr of this.hosts.nodes) {
    if (this.peers.has(addr.hostname))
      continue;

    return addr;
  }

  const services = this.options.getRequiredServices();
  const now = this.network.now();

  for (let i = 0; i < 100; i++) {
    const entry = this.hosts.getHost();

    if (!entry)
      break;

    const addr = entry.addr;

    if (this.peers.has(addr.hostname))
      continue;

    if (!addr.isValid())
      continue;

    if (!addr.hasServices(services))
      continue;

    if (!this.options.onion && addr.isOnion())
      continue;

    if (i < 30 && now - entry.lastAttempt < 600)
      continue;

    if (i < 50 && addr.port !== this.network.port)
      continue;

    if (i < 95 && this.hosts.isBanned(addr.host))
      continue;

    return entry.addr;
  }

  return null;
};

/**
 * Create an outbound non-loader peer. These primarily
 * exist for transaction relaying.
 * @private
 */

Pool.prototype.addOutbound = function addOutbound() {
  if (!this.loaded)
    return;

  if (this.peers.outbound >= this.options.maxOutbound)
    return;

  // Hang back if we don't
  // have a loader peer yet.
  if (!this.peers.load)
    return;

  const addr = this.getHost();

  if (!addr)
    return;

  const peer = this.createOutbound(addr);

  this.peers.add(peer);

  this.emit('peer', peer);
};

/**
 * Attempt to refill the pool with peers (no lock).
 * @private
 */

Pool.prototype.fillOutbound = function fillOutbound() {
  const need = this.options.maxOutbound - this.peers.outbound;

  if (!this.peers.load)
    this.addLoader();

  if (need <= 0)
    return;

  this.logger.debug('Refilling peers (%d/%d).',
    this.peers.outbound,
    this.options.maxOutbound);

  for (let i = 0; i < need; i++)
    this.addOutbound();
};

/**
 * Attempt to refill the pool with peers (no lock).
 * @private
 */

Pool.prototype.refill = function refill() {
  if (this.pendingRefill != null)
    return;

  this.pendingRefill = setTimeout(() => {
    this.pendingRefill = null;
    this.fillOutbound();
  }, 3000);
};

/**
 * Remove a peer from any list. Drop all load requests.
 * @private
 * @param {Peer} peer
 */

Pool.prototype.removePeer = function removePeer(peer) {
  this.peers.remove(peer);

  for (const hash of peer.blockMap.keys())
    this.resolveBlock(peer, hash);

  for (const hash of peer.txMap.keys())
    this.resolveTX(peer, hash);

  for (const hash of peer.compactBlocks.keys()) {
    assert(this.compactBlocks.has(hash));
    this.compactBlocks.delete(hash);
  }

  peer.compactBlocks.clear();
};

/**
 * Ban peer.
 * @param {NetAddress} addr
 */

Pool.prototype.ban = function ban(addr) {
  const peer = this.peers.get(addr.hostname);

  this.logger.debug('Banning peer (%s).', addr.hostname);

  this.hosts.ban(addr.host);
  this.hosts.remove(addr.hostname);

  if (peer)
    peer.destroy();
};

/**
 * Unban peer.
 * @param {NetAddress} addr
 */

Pool.prototype.unban = function unban(addr) {
  this.hosts.unban(addr.host);
};

/**
 * Set the spv filter.
 * @param {Bloom} filter
 * @param {String?} enc
 */

Pool.prototype.setFilter = function setFilter(filter) {
  if (!this.options.spv)
    return;

  this.spvFilter = filter;
  this.queueFilterLoad();
};

/**
 * Watch a an address hash (filterload, SPV-only).
 * @param {Buffer|Hash} data
 * @param {String?} enc
 */

Pool.prototype.watch = function watch(data, enc) {
  if (!this.options.spv)
    return;

  this.spvFilter.add(data, enc);
  this.queueFilterLoad();
};

/**
 * Reset the spv filter (filterload, SPV-only).
 */

Pool.prototype.unwatch = function unwatch() {
  if (!this.options.spv)
    return;

  this.spvFilter.reset();
  this.queueFilterLoad();
};

/**
 * Queue a resend of the bloom filter.
 */

Pool.prototype.queueFilterLoad = function queueFilterLoad() {
  if (!this.options.spv)
    return;

  if (this.pendingFilter != null)
    return;

  this.pendingFilter = setTimeout(() => {
    this.pendingFilter = null;
    this.sendFilterLoad();
  }, 100);
};

/**
 * Resend the bloom filter to peers.
 */

Pool.prototype.sendFilterLoad = function sendFilterLoad() {
  if (!this.options.spv)
    return;

  assert(this.spvFilter);

  for (let peer = this.peers.head(); peer; peer = peer.next)
    peer.sendFilterLoad(this.spvFilter);
};

/**
 * Add an address to the bloom filter (SPV-only).
 * @param {Address|Base58Address} address
 */

Pool.prototype.watchAddress = function watchAddress(address) {
  const hash = Address.getHash(address);
  this.watch(hash);
};

/**
 * Add an outpoint to the bloom filter (SPV-only).
 * @param {Outpoint} outpoint
 */

Pool.prototype.watchOutpoint = function watchOutpoint(outpoint) {
  this.watch(outpoint.toRaw());
};

/**
 * Send `getblocks` to peer after building
 * locator and resolving orphan root.
 * @method
 * @param {Peer} peer
 * @param {Hash} orphan - Orphan hash to resolve.
 * @returns {Promise}
 */

Pool.prototype.resolveOrphan = async function resolveOrphan(peer, orphan) {
  const locator = await this.chain.getLocator();
  const root = this.chain.getOrphanRoot(orphan);

  assert(root);

  peer.sendGetBlocks(locator, root);
};

/**
 * Send `getheaders` to peer after building locator.
 * @method
 * @param {Peer} peer
 * @param {Hash} tip - Tip to build chain locator from.
 * @param {Hash?} stop
 * @returns {Promise}
 */

Pool.prototype.getHeaders = async function getHeaders(peer, tip, stop) {
  const locator = await this.chain.getLocator(tip);
  peer.sendGetHeaders(locator, stop);
};

/**
 * Send `getblocks` to peer after building locator.
 * @method
 * @param {Peer} peer
 * @param {Hash} tip - Tip hash to build chain locator from.
 * @param {Hash?} stop
 * @returns {Promise}
 */

Pool.prototype.getBlocks = async function getBlocks(peer, tip, stop) {
  const locator = await this.chain.getLocator(tip);
  peer.sendGetBlocks(locator, stop);
};

/**
 * Queue a `getdata` request to be sent.
 * @param {Peer} peer
 * @param {Hash[]} hashes
 */

Pool.prototype.getBlock = function getBlock(peer, hashes) {
  if (!this.loaded)
    return;

  if (!peer.handshake)
    throw new Error('Peer handshake not complete (getdata).');

  if (peer.destroyed)
    throw new Error('Peer is destroyed (getdata).');

  let now = util.ms();
  const items = [];

  for (const hash of hashes) {
    if (this.blockMap.has(hash))
      continue;

    this.blockMap.add(hash);
    peer.blockMap.set(hash, now);

    if (this.chain.synced)
      now += 100;

    items.push(hash);
  }

  if (items.length === 0)
    return;

  this.logger.debug(
    'Requesting %d/%d blocks from peer with getdata (%s).',
    items.length,
    this.blockMap.size,
    peer.hostname());

  peer.getBlock(items);
};

/**
 * Queue a `getdata` request to be sent.
 * @param {Peer} peer
 * @param {Hash[]} hashes
 */

Pool.prototype.getTX = function getTX(peer, hashes) {
  if (!this.loaded)
    return;

  if (!peer.handshake)
    throw new Error('Peer handshake not complete (getdata).');

  if (peer.destroyed)
    throw new Error('Peer is destroyed (getdata).');

  let now = util.ms();
  const items = [];

  for (const hash of hashes) {
    if (this.txMap.has(hash))
      continue;

    this.txMap.add(hash);
    peer.txMap.set(hash, now);

    now += 50;

    items.push(hash);
  }

  if (items.length === 0)
    return;

  this.logger.debug(
    'Requesting %d/%d txs from peer with getdata (%s).',
    items.length,
    this.txMap.size,
    peer.hostname());

  peer.getTX(items);
};

/**
 * Test whether the chain has or has seen an item.
 * @method
 * @param {Hash} hash
 * @returns {Promise} - Returns Boolean.
 */

Pool.prototype.hasBlock = async function hasBlock(hash) {
  // Check the lock.
  if (this.locker.has(hash))
    return true;

  // Check the chain.
  if (await this.chain.has(hash))
    return true;

  return false;
};

/**
 * Test whether the mempool has or has seen an item.
 * @param {Hash} hash
 * @returns {Boolean}
 */

Pool.prototype.hasTX = function hasTX(hash) {
  // Check the lock queue.
  if (this.locker.has(hash))
    return true;

  if (!this.mempool) {
    // Check the TX filter if
    // we don't have a mempool.
    if (!this.txFilter.added(hash, 'hex'))
      return true;
  } else {
    // Check the mempool.
    if (this.mempool.has(hash))
      return true;

    // If we recently rejected this item. Ignore.
    if (this.mempool.hasReject(hash)) {
      this.logger.spam('Saw known reject of %s.', util.revHex(hash));
      return true;
    }
  }

  return false;
};

/**
 * Queue a `getdata` request to be sent.
 * Check tx existence before requesting.
 * @param {Peer} peer
 * @param {Hash[]} hashes
 */

Pool.prototype.ensureTX = function ensureTX(peer, hashes) {
  const items = [];

  for (const hash of hashes) {
    if (this.hasTX(hash))
      continue;

    items.push(hash);
  }

  this.getTX(peer, items);
};

/**
 * Fulfill a requested tx.
 * @param {Peer} peer
 * @param {Hash} hash
 * @returns {Boolean}
 */

Pool.prototype.resolveTX = function resolveTX(peer, hash) {
  if (!peer.txMap.has(hash))
    return false;

  peer.txMap.delete(hash);

  assert(this.txMap.has(hash));
  this.txMap.delete(hash);

  return true;
};

/**
 * Fulfill a requested block.
 * @param {Peer} peer
 * @param {Hash} hash
 * @returns {Boolean}
 */

Pool.prototype.resolveBlock = function resolveBlock(peer, hash) {
  if (!peer.blockMap.has(hash))
    return false;

  peer.blockMap.delete(hash);

  assert(this.blockMap.has(hash));
  this.blockMap.delete(hash);

  return true;
};

/**
 * Fulfill a requested item.
 * @param {Peer} peer
 * @param {InvItem} item
 * @returns {Boolean}
 */

Pool.prototype.resolveItem = function resolveItem(peer, item) {
  if (item.isBlock())
    return this.resolveBlock(peer, item.hash);

  if (item.isTX())
    return this.resolveTX(peer, item.hash);

  return false;
};

/**
 * Broadcast a transaction or block.
 * @param {TX|Block} msg
 * @returns {Promise}
 */

Pool.prototype.broadcast = function broadcast(msg) {
  const hash = msg.hash('hex');
  let item = this.invMap.get(hash);

  if (item) {
    item.refresh();
    item.announce();
  } else {
    item = new BroadcastItem(this, msg);
    item.start();
    item.announce();
  }

  return new Promise((resolve, reject) => {
    item.addJob(resolve, reject);
  });
};

/**
 * Announce a block to all peers.
 * @param {Block} tx
 */

Pool.prototype.announceBlock = function announceBlock(msg) {
  for (let peer = this.peers.head(); peer; peer = peer.next)
    peer.announceBlock(msg);
};

/**
 * Announce a transaction to all peers.
 * @param {TX} tx
 */

Pool.prototype.announceTX = function announceTX(msg) {
  for (let peer = this.peers.head(); peer; peer = peer.next)
    peer.announceTX(msg);
};

/**
 * PoolOptions
 * @alias module:net.PoolOptions
 * @constructor
 */

function PoolOptions(options) {
  if (!(this instanceof PoolOptions))
    return new PoolOptions(options);

  this.network = Network.primary;
  this.logger = null;
  this.chain = null;
  this.mempool = null;

  this.nonces = new NonceList();

  this.prefix = null;
  this.checkpoints = true;
  this.spv = false;
  this.bip37 = false;
  this.listen = false;
  this.compact = true;
  this.noRelay = false;
  this.host = '0.0.0.0';
  this.port = this.network.port;
  this.publicHost = '0.0.0.0';
  this.publicPort = this.network.port;
  this.maxOutbound = 32;
  this.maxInbound = 128;
  this.createSocket = this._createSocket.bind(this);
  this.createServer = tcp.createServer;
  this.resolve = this._resolve.bind(this);
  this.proxy = null;
  this.onion = false;
  this.upnp = false;
  this.selfish = false;
  this.version = common.PROTOCOL_VERSION;
  this.agent = common.USER_AGENT;
  this.bip151 = false;
  this.bip150 = false;
  this.authPeers = [];
  this.knownPeers = {};
  this.identityKey = secp256k1.generatePrivateKey();
  this.banScore = common.BAN_SCORE;
  this.banTime = common.BAN_TIME;
  this.feeRate = -1;
  this.seeds = this.network.seeds;
  this.nodes = [];
  this.invTimeout = 60000;
  this.blockMode = 0;
  this.services = common.LOCAL_SERVICES;
  this.requiredServices = common.REQUIRED_SERVICES;
  this.persistent = false;

  this.fromOptions(options);
}

/**
 * Inject properties from object.
 * @private
 * @param {Object} options
 * @returns {PoolOptions}
 */

PoolOptions.prototype.fromOptions = function fromOptions(options) {
  assert(options, 'Pool requires options.');
  assert(options.chain && typeof options.chain === 'object',
    'Pool options require a blockchain.');

  this.chain = options.chain;
  this.network = options.chain.network;
  this.logger = options.chain.logger;

  this.port = this.network.port;
  this.seeds = this.network.seeds;
  this.port = this.network.port;
  this.publicPort = this.network.port;

  if (options.logger != null) {
    assert(typeof options.logger === 'object');
    this.logger = options.logger;
  }

  if (options.mempool != null) {
    assert(typeof options.mempool === 'object');
    this.mempool = options.mempool;
  }

  if (options.prefix != null) {
    assert(typeof options.prefix === 'string');
    this.prefix = options.prefix;
  }

  if (options.checkpoints != null) {
    assert(typeof options.checkpoints === 'boolean');
    assert(options.checkpoints === this.chain.options.checkpoints);
    this.checkpoints = options.checkpoints;
  } else {
    this.checkpoints = this.chain.options.checkpoints;
  }

  if (options.spv != null) {
    assert(typeof options.spv === 'boolean');
    assert(options.spv === this.chain.options.spv);
    this.spv = options.spv;
  } else {
    this.spv = this.chain.options.spv;
  }

  if (options.bip37 != null) {
    assert(typeof options.bip37 === 'boolean');
    this.bip37 = options.bip37;
  }

  if (options.listen != null) {
    assert(typeof options.listen === 'boolean');
    this.listen = options.listen;
  }

  if (options.compact != null) {
    assert(typeof options.compact === 'boolean');
    this.compact = options.compact;
  }

  if (options.noRelay != null) {
    assert(typeof options.noRelay === 'boolean');
    this.noRelay = options.noRelay;
  }

  if (options.host != null) {
    assert(typeof options.host === 'string');
    const raw = IP.toBuffer(options.host);
    this.host = IP.toString(raw);
    if (IP.isRoutable(raw))
      this.publicHost = this.host;
  }

  if (options.port != null) {
    assert(util.isU16(options.port));
    this.port = options.port;
    this.publicPort = options.port;
  }

  if (options.publicHost != null) {
    assert(typeof options.publicHost === 'string');
    this.publicHost = IP.normalize(options.publicHost);
  }

  if (options.publicPort != null) {
    assert(util.isU16(options.publicPort));
    this.publicPort = options.publicPort;
  }

  if (options.maxOutbound != null) {
    assert(typeof options.maxOutbound === 'number');
    assert(options.maxOutbound > 0);
    this.maxOutbound = options.maxOutbound;
  }

  if (options.maxInbound != null) {
    assert(typeof options.maxInbound === 'number');
    this.maxInbound = options.maxInbound;
  }

  if (options.createSocket) {
    assert(typeof options.createSocket === 'function');
    this.createSocket = options.createSocket;
  }

  if (options.createServer) {
    assert(typeof options.createServer === 'function');
    this.createServer = options.createServer;
  }

  if (options.resolve) {
    assert(typeof options.resolve === 'function');
    this.resolve = options.resolve;
  }

  if (options.proxy) {
    assert(typeof options.proxy === 'string');
    this.proxy = options.proxy;
  }

  if (options.onion != null) {
    assert(typeof options.onion === 'boolean');
    this.onion = options.onion;
  }

  if (options.upnp != null) {
    assert(typeof options.upnp === 'boolean');
    this.upnp = options.upnp;
  }

  if (options.selfish) {
    assert(typeof options.selfish === 'boolean');
    this.selfish = options.selfish;
  }

  if (options.version) {
    assert(typeof options.version === 'number');
    this.version = options.version;
  }

  if (options.agent) {
    assert(typeof options.agent === 'string');
    assert(options.agent.length <= 255);
    this.agent = options.agent;
  }

  if (options.bip151 != null) {
    assert(typeof options.bip151 === 'boolean');
    this.bip151 = options.bip151;
  }

  if (options.bip150 != null) {
    assert(typeof options.bip150 === 'boolean');
    assert(!options.bip150 || this.bip151,
      'Cannot enable bip150 without bip151.');

    if (options.knownPeers) {
      assert(typeof options.knownPeers === 'object');
      assert(!Array.isArray(options.knownPeers));
      this.knownPeers = options.knownPeers;
    }

    if (options.authPeers) {
      assert(Array.isArray(options.authPeers));
      this.authPeers = options.authPeers;
    }

    if (options.identityKey) {
      assert(Buffer.isBuffer(options.identityKey),
        'Identity key must be a buffer.');
      assert(secp256k1.privateKeyVerify(options.identityKey),
        'Invalid identity key.');
      this.identityKey = options.identityKey;
    }
  }

  if (options.banScore != null) {
    assert(typeof this.options.banScore === 'number');
    this.banScore = this.options.banScore;
  }

  if (options.banTime != null) {
    assert(typeof this.options.banTime === 'number');
    this.banTime = this.options.banTime;
  }

  if (options.feeRate != null) {
    assert(typeof this.options.feeRate === 'number');
    this.feeRate = this.options.feeRate;
  }

  if (options.seeds) {
    assert(Array.isArray(options.seeds));
    this.seeds = options.seeds;
  }

  if (options.nodes) {
    assert(Array.isArray(options.nodes));
    this.nodes = options.nodes;
  }

  if (options.only != null) {
    assert(Array.isArray(options.only));
    if (options.only.length > 0) {
      this.nodes = options.only;
      this.maxOutbound = options.only.length;
    }
  }

  if (options.invTimeout != null) {
    assert(typeof options.invTimeout === 'number');
    this.invTimeout = options.invTimeout;
  }

  if (options.blockMode != null) {
    assert(typeof options.blockMode === 'number');
    this.blockMode = options.blockMode;
  }

  if (options.persistent != null) {
    assert(typeof options.persistent === 'boolean');
    this.persistent = options.persistent;
  }

  if (this.spv) {
    this.requiredServices |= common.services.BLOOM;
    this.services &= ~common.services.NETWORK;
    this.noRelay = true;
    this.checkpoints = true;
    this.compact = false;
    this.bip37 = false;
    this.listen = false;
  }

  if (this.selfish) {
    this.services &= ~common.services.NETWORK;
    this.bip37 = false;
  }

  if (this.bip37)
    this.services |= common.services.BLOOM;

  if (this.proxy)
    this.listen = false;

  if (options.services != null) {
    assert(util.isU32(options.services));
    this.services = options.services;
  }

  if (options.requiredServices != null) {
    assert(util.isU32(options.requiredServices));
    this.requiredServices = options.requiredServices;
  }

  return this;
};

/**
 * Instantiate options from object.
 * @param {Object} options
 * @returns {PoolOptions}
 */

PoolOptions.fromOptions = function fromOptions(options) {
  return new PoolOptions().fromOptions(options);
};

/**
 * Get the chain height.
 * @private
 * @returns {Number}
 */

PoolOptions.prototype.getHeight = function getHeight() {
  return this.chain.height;
};

/**
 * Test whether the chain is synced.
 * @private
 * @returns {Boolean}
 */

PoolOptions.prototype.isFull = function isFull() {
  return this.chain.synced;
};

/**
 * Get required services for outbound peers.
 * @private
 * @returns {Number}
 */

PoolOptions.prototype.getRequiredServices = function getRequiredServices() {
  let services = this.requiredServices;
  if (this.hasWitness())
    services |= common.services.WITNESS;
  return services;
};

/**
 * Whether segwit is enabled.
 * @private
 * @returns {Boolean}
 */

PoolOptions.prototype.hasWitness = function hasWitness() {
  return this.chain.state.hasWitness();
};

/**
 * Create a version packet nonce.
 * @private
 * @param {String} hostname
 * @returns {Buffer}
 */

PoolOptions.prototype.createNonce = function createNonce(hostname) {
  return this.nonces.alloc(hostname);
};

/**
 * Test whether version nonce is ours.
 * @private
 * @param {Buffer} nonce
 * @returns {Boolean}
 */

PoolOptions.prototype.hasNonce = function hasNonce(nonce) {
  return this.nonces.has(nonce);
};

/**
 * Get fee rate for txid.
 * @private
 * @param {Hash} hash
 * @returns {Rate}
 */

PoolOptions.prototype.getRate = function getRate(hash) {
  if (!this.mempool)
    return -1;

  const entry = this.mempool.getEntry(hash);

  if (!entry)
    return -1;

  return entry.getRate();
};

/**
 * Default createSocket call.
 * @private
 * @param {Number} port
 * @param {String} host
 * @returns {net.Socket}
 */

PoolOptions.prototype._createSocket = function _createSocket(port, host) {
  return tcp.createSocket(port, host, this.proxy);
};

/**
 * Default resolve call.
 * @private
 * @param {String} name
 * @returns {String[]}
 */

PoolOptions.prototype._resolve = function _resolve(name) {
  if (this.onion)
    return dns.lookup(name, this.proxy);

  return dns.lookup(name);
};

/**
 * Peer List
 * @alias module:net.PeerList
 * @constructor
 * @param {Object} options
 */

function PeerList() {
  this.map = new Map();
  this.ids = new Map();
  this.list = new List();
  this.load = null;
  this.inbound = 0;
  this.outbound = 0;
}

/**
 * Get the list head.
 * @returns {Peer}
 */

PeerList.prototype.head = function head() {
  return this.list.head;
};

/**
 * Get the list tail.
 * @returns {Peer}
 */

PeerList.prototype.tail = function tail() {
  return this.list.tail;
};

/**
 * Get list size.
 * @returns {Number}
 */

PeerList.prototype.size = function size() {
  return this.list.size;
};

/**
 * Add peer to list.
 * @param {Peer} peer
 */

PeerList.prototype.add = function add(peer) {
  assert(this.list.push(peer));

  assert(!this.map.has(peer.hostname()));
  this.map.set(peer.hostname(), peer);

  assert(!this.ids.has(peer.id));
  this.ids.set(peer.id, peer);

  if (peer.outbound)
    this.outbound++;
  else
    this.inbound++;
};

/**
 * Remove peer from list.
 * @param {Peer} peer
 */

PeerList.prototype.remove = function remove(peer) {
  assert(this.list.remove(peer));

  assert(this.ids.has(peer.id));
  this.ids.delete(peer.id);

  assert(this.map.has(peer.hostname()));
  this.map.delete(peer.hostname());

  if (peer === this.load) {
    assert(peer.loader);
    peer.loader = false;
    this.load = null;
  }

  if (peer.outbound)
    this.outbound--;
  else
    this.inbound--;
};

/**
 * Get peer by hostname.
 * @param {String} hostname
 * @returns {Peer}
 */

PeerList.prototype.get = function get(hostname) {
  return this.map.get(hostname);
};

/**
 * Test whether a peer exists.
 * @param {String} hostname
 * @returns {Boolean}
 */

PeerList.prototype.has = function has(hostname) {
  return this.map.has(hostname);
};

/**
 * Get peer by ID.
 * @param {Number} id
 * @returns {Peer}
 */

PeerList.prototype.find = function find(id) {
  return this.ids.get(id);
};

/**
 * Destroy peer list (kills peers).
 */

PeerList.prototype.destroy = function destroy() {
  let next;

  for (let peer = this.list.head; peer; peer = next) {
    next = peer.next;
    peer.destroy();
  }
};

/**
 * Represents an item that is broadcasted via an inv/getdata cycle.
 * @alias module:net.BroadcastItem
 * @constructor
 * @private
 * @param {Pool} pool
 * @param {TX|Block} msg
 * @emits BroadcastItem#ack
 * @emits BroadcastItem#reject
 * @emits BroadcastItem#timeout
 */

function BroadcastItem(pool, msg) {
  if (!(this instanceof BroadcastItem))
    return new BroadcastItem(pool, msg);

  assert(!msg.mutable, 'Cannot broadcast mutable item.');

  const item = msg.toInv();

  this.pool = pool;
  this.hash = item.hash;
  this.type = item.type;
  this.msg = msg;
  this.jobs = [];
}

Object.setPrototypeOf(BroadcastItem.prototype, EventEmitter.prototype);

/**
 * Add a job to be executed on ack, timeout, or reject.
 * @returns {Promise}
 */

BroadcastItem.prototype.addJob = function addJob(resolve, reject) {
  this.jobs.push(co.job(resolve, reject));
};

/**
 * Start the broadcast.
 */

BroadcastItem.prototype.start = function start() {
  assert(!this.timeout, 'Already started.');
  assert(!this.pool.invMap.has(this.hash), 'Already started.');

  this.pool.invMap.set(this.hash, this);

  this.refresh();

  return this;
};

/**
 * Refresh the timeout on the broadcast.
 */

BroadcastItem.prototype.refresh = function refresh() {
  if (this.timeout != null) {
    clearTimeout(this.timeout);
    this.timeout = null;
  }

  this.timeout = setTimeout(() => {
    this.emit('timeout');
    this.reject(new Error('Timed out.'));
  }, this.pool.options.invTimeout);
};

/**
 * Announce the item.
 */

BroadcastItem.prototype.announce = function announce() {
  switch (this.type) {
    case invTypes.TX:
      this.pool.announceTX(this.msg);
      break;
    case invTypes.BLOCK:
      this.pool.announceBlock(this.msg);
      break;
    default:
      assert(false, 'Bad type.');
      break;
  }
};

/**
 * Finish the broadcast.
 */

BroadcastItem.prototype.cleanup = function cleanup() {
  assert(this.timeout != null, 'Already finished.');
  assert(this.pool.invMap.has(this.hash), 'Already finished.');

  clearTimeout(this.timeout);
  this.timeout = null;

  this.pool.invMap.delete(this.hash);
};

/**
 * Finish the broadcast, return with an error.
 * @param {Error} err
 */

BroadcastItem.prototype.reject = function reject(err) {
  this.cleanup();

  for (const job of this.jobs)
    job.reject(err);

  this.jobs.length = 0;
};

/**
 * Finish the broadcast successfully.
 */

BroadcastItem.prototype.resolve = function resolve() {
  this.cleanup();

  for (const job of this.jobs)
    job.resolve(false);

  this.jobs.length = 0;
};

/**
 * Handle an ack from a peer.
 * @param {Peer} peer
 */

BroadcastItem.prototype.handleAck = function handleAck(peer) {
  setTimeout(() => {
    this.emit('ack', peer);

    for (const job of this.jobs)
      job.resolve(true);

    this.jobs.length = 0;
  }, 1000);
};

/**
 * Handle a reject from a peer.
 * @param {Peer} peer
 */

BroadcastItem.prototype.handleReject = function handleReject(peer) {
  this.emit('reject', peer);

  for (const job of this.jobs)
    job.resolve(false);

  this.jobs.length = 0;
};

/**
 * Inspect the broadcast item.
 * @returns {String}
 */

BroadcastItem.prototype.inspect = function inspect() {
  const type = this.type === invTypes.TX ? 'tx' : 'block';
  const hash = util.revHex(this.hash);
  return `<BroadcastItem: type=${type} hash=${hash}>`;
};

/**
 * NonceList
 * @constructor
 * @ignore
 */

function NonceList() {
  this.map = new Map();
  this.hosts = new Map();
}

NonceList.prototype.alloc = function alloc(hostname) {
  for (;;) {
    const nonce = util.nonce();
    const key = nonce.toString('hex');

    if (this.map.has(key))
      continue;

    this.map.set(key, hostname);

    assert(!this.hosts.has(hostname));
    this.hosts.set(hostname, key);

    return nonce;
  }
};

NonceList.prototype.has = function has(nonce) {
  const key = nonce.toString('hex');
  return this.map.has(key);
};

NonceList.prototype.remove = function remove(hostname) {
  const key = this.hosts.get(hostname);

  if (!key)
    return false;

  this.hosts.delete(hostname);

  assert(this.map.has(key));
  this.map.delete(key);

  return true;
};

/**
 * HeaderEntry
 * @constructor
 * @ignore
 */

function HeaderEntry(hash, height) {
  this.hash = hash;
  this.height = height;
  this.prev = null;
  this.next = null;
}

/*
 * Expose
 */

module.exports = Pool;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * config.js - configuration parsing for wmcc_core.
 */



const assert = __webpack_require__(0);
const Path = __webpack_require__(25);
const os = __webpack_require__(116);
const fs = __webpack_require__(58);
const util = __webpack_require__(1);
const HOME = os.homedir ? os.homedir() : '/';

/**
 * Config Parser
 * @alias module:node.Config
 * @constructor
 * @param {String} module - Module name (e.g. `wmcc`).
 */

function Config(module) {
  if (!(this instanceof Config))
    return new Config(module);

  assert(typeof module === 'string');
  assert(module.length > 0);

  this.module = module;
  this.network = 'mainnet';
  this.prefix = Path.join(HOME, `.${module}`);

  this.options = Object.create(null);
  this.data = Object.create(null);
  this.env = Object.create(null);
  this.args = Object.create(null);
  this.argv = [];
  this.pass = [];
  this.query = Object.create(null);
  this.hash = Object.create(null);
}

/**
 * Option name aliases.
 * @const {Object}
 */

Config.alias = {
  'seed': 'seeds',
  'node': 'nodes',
  'n': 'network'
};

/**
 * Default options.
 * @const {Object}
 */

Config.default = {
  
};

/**
 * Inject options.
 * @param {Object} options
 */

Config.prototype.inject = function inject(options) {
  for (const key of Object.keys(options)) {
    const value = options[key];

    switch (key) {
      case 'hash':
      case 'query':
      case 'env':
      case 'argv':
      case 'config':
        continue;
    }

    this.set(key, value);
  }
};

/**
 * Load options from hash, query, env, or args.
 * @param {Object} options
 */

Config.prototype.load = function load(options) {
  if (options.hash)
    this.parseHash(options.hash);

  if (options.query)
    this.parseQuery(options.query);

  if (options.env)
    this.parseEnv(options.env);

  if (options.argv)
    this.parseArg(options.argv);

  this.network = this.getNetwork();
  this.prefix = this.getPrefix();
};

/**
 * Open a config file.
 * @param {String} file - e.g. `wmcc.conf`.
 * @throws on IO error
 */

Config.prototype.open = function open(file) {
  if (fs.unsupported)
    return;

  const path = this.getFile(file);

  let text;
  try {
    text = fs.readFileSync(path, 'utf8');
  } catch (e) {
    if (e.code === 'ENOENT')
      return;
    throw e;
  }

  this.parseConfig(text);

  this.network = this.getNetwork();
  this.prefix = this.getPrefix();
};

/**
 * Set default option.
 * @param {String} key
 * @param {Object} value
 */

Config.prototype.set = function set(key, value) {
  assert(typeof key === 'string', 'Key must be a string.');

  if (value == null)
    return;

  key = key.replace(/-/g, '');
  key = key.toLowerCase();

  this.options[key] = value;
};

/**
 * Test whether a config option is present.
 * @param {String} key
 * @returns {Boolean}
 */

Config.prototype.has = function has(key) {
  if (typeof key === 'number') {
    assert(key >= 0, 'Index must be positive.');
    if (key >= this.argv.length)
      return false;
    return true;
  }

  assert(typeof key === 'string', 'Key must be a string.');

  key = key.replace(/-/g, '');
  key = key.toLowerCase();

  if (this.hash[key] != null)
    return true;

  if (this.query[key] != null)
    return true;

  if (this.args[key] != null)
    return true;

  if (this.env[key] != null)
    return true;

  if (this.data[key] != null)
    return true;

  if (this.options[key] != null)
    return true;

  return false;
};

/**
 * Get a config option.
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Object|null}
 */

Config.prototype.get = function get(key, fallback) {
  if (fallback === undefined)
    fallback = null;

  if (Array.isArray(key)) {
    const keys = key;
    for (const key of keys) {
      const value = this.get(key);
      if (value !== null)
        return value;
    }
    return fallback;
  }

  if (typeof key === 'number') {
    assert(key >= 0, 'Index must be positive.');

    if (key >= this.argv.length)
      return fallback;

    if (this.argv[key] != null)
      return this.argv[key];

    return fallback;
  }

  assert(typeof key === 'string', 'Key must be a string.');

  key = key.replace(/-/g, '');
  key = key.toLowerCase();

  if (this.hash[key] != null)
    return this.hash[key];

  if (this.query[key] != null)
    return this.query[key];

  if (this.args[key] != null)
    return this.args[key];

  if (this.env[key] != null)
    return this.env[key];

  if (this.data[key] != null)
    return this.data[key];

  if (this.options[key] != null)
    return this.options[key];

  return fallback;
};

/**
 * Get a value's type.
 * @param {String} key
 * @returns {String}
 */

Config.prototype.typeOf = function typeOf(key) {
  const value = this.get(key);

  if (value === null)
    return 'null';

  return typeof value;
};

/**
 * Get a config option (as a string).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {String|null}
 */

Config.prototype.str = function str(key, fallback) {
  const value = this.get(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (typeof value !== 'string')
    throw new Error(`${fmt(key)} must be a string.`);

  return value;
};

/**
 * Get a config option (as an integer).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Config.prototype.int = function int(key, fallback) {
  let value = this.get(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (typeof value !== 'string') {
    if (typeof value !== 'number')
      throw new Error(`${fmt(key)} must be an int.`);

    if (!Number.isSafeInteger(value))
      throw new Error(`${fmt(key)} must be an int.`);

    return value;
  }

  if (!/^\-?\d+$/.test(value))
    throw new Error(`${fmt(key)} must be an int.`);

  value = parseInt(value, 10);

  if (!Number.isSafeInteger(value))
    throw new Error(`${fmt(key)} must be an int.`);

  return value;
};

/**
 * Get a config option (as a unsigned integer).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Config.prototype.uint = function uint(key, fallback) {
  const value = this.int(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (value < 0)
    throw new Error(`${fmt(key)} must be a uint.`);

  return value;
};

/**
 * Get a config option (as a float).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Config.prototype.float = function float(key, fallback) {
  let value = this.get(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (typeof value !== 'string') {
    if (typeof value !== 'number')
      throw new Error(`${fmt(key)} must be a float.`);

    if (!isFinite(value))
      throw new Error(`${fmt(key)} must be a float.`);

    return value;
  }

  if (!/^\-?\d*(?:\.\d*)?$/.test(value))
    throw new Error(`${fmt(key)} must be a float.`);

  if (!/\d/.test(value))
    throw new Error(`${fmt(key)} must be a float.`);

  value = parseFloat(value);

  if (!isFinite(value))
    throw new Error(`${fmt(key)} must be a float.`);

  return value;
};

/**
 * Get a config option (as a positive float).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Config.prototype.ufloat = function ufloat(key, fallback) {
  const value = this.float(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (value < 0)
    throw new Error(`${fmt(key)} must be a positive float.`);

  return value;
};

/**
 * Get a value (as a fixed number).
 * @param {String} key
 * @param {Number?} exp
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Config.prototype.fixed = function fixed(key, exp, fallback) {
  const value = this.float(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  try {
    return util.fromFloat(value, exp || 0);
  } catch (e) {
    throw new Error(`${fmt(key)} must be a fixed number.`);
  }
};

/**
 * Get a value (as a positive fixed number).
 * @param {String} key
 * @param {Number?} exp
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Config.prototype.ufixed = function ufixed(key, exp, fallback) {
  const value = this.fixed(key, exp);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (value < 0)
    throw new Error(`${fmt(key)} must be a positive fixed number.`);

  return value;
};

/**
 * Get a config option (as a boolean).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Boolean|null}
 */

Config.prototype.bool = function bool(key, fallback) {
  const value = this.get(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  // WMCoin Core compat.
  if (typeof value === 'number') {
    if (value === 1)
      return true;

    if (value === 0)
      return false;
  }

  if (typeof value !== 'string') {
    if (typeof value !== 'boolean')
      throw new Error(`${fmt(key)} must be a boolean.`);
    return value;
  }

  if (value === 'true' || value === '1')
    return true;

  if (value === 'false' || value === '0')
    return false;

  throw new Error(`${fmt(key)} must be a boolean.`);
};

/**
 * Get a config option (as a buffer).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Buffer|null}
 */

Config.prototype.buf = function buf(key, fallback, enc) {
  const value = this.get(key);

  if (!enc)
    enc = 'hex';

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (typeof value !== 'string') {
    if (!Buffer.isBuffer(value))
      throw new Error(`${fmt(key)} must be a buffer.`);
    return value;
  }

  const data = Buffer.from(value, enc);

  if (data.length !== Buffer.byteLength(value, enc))
    throw new Error(`${fmt(key)} must be a ${enc} string.`);

  return data;
};

/**
 * Get a config option (as an array of strings).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {String[]|null}
 */

Config.prototype.array = function array(key, fallback) {
  const value = this.get(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (typeof value !== 'string') {
    if (!Array.isArray(value))
      throw new Error(`${fmt(key)} must be an array.`);
    return value;
  }

  const parts = value.trim().split(/\s*,\s*/);
  const result = [];

  for (const part of parts) {
    if (part.length === 0)
      continue;

    result.push(part);
  }

  return result;
};

/**
 * Get a config option (as an object).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Object|null}
 */

Config.prototype.obj = function obj(key, fallback) {
  const value = this.get(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (typeof value !== 'object')
    throw new Error(`${fmt(key)} must be an object.`);

  return value;
};

/**
 * Get a config option (as a function).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Function|null}
 */

Config.prototype.func = function func(key, fallback) {
  const value = this.get(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  if (typeof value !== 'function')
    throw new Error(`${fmt(key)} must be a function.`);

  return value;
};

/**
 * Get a config option (as a string).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {String|null}
 */

Config.prototype.path = function path(key, fallback) {
  let value = this.str(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  switch (value[0]) {
    case '~': // home dir
      value = Path.join(HOME, value.substring(1));
      break;
    case '@': // prefix
      value = Path.join(this.prefix, value.substring(1));
      break;
    default: // cwd
      break;
  }

  return Path.normalize(value);
};

/**
 * Get a config option (in MB).
 * @param {String} key
 * @param {Object?} fallback
 * @returns {Number|null}
 */

Config.prototype.mb = function mb(key, fallback) {
  const value = this.uint(key);

  if (fallback === undefined)
    fallback = null;

  if (value === null)
    return fallback;

  return value * 1024 * 1024;
};

/**
 * Grab network type from config data.
 * @private
 * @returns {String}
 */

Config.prototype.getNetwork = function getNetwork() {
  let network = this.str('network');

  if (!network)
    network = 'mainnet';

  assert(isAlpha(network), 'Bad network.');

  return network;
};

/**
 * Grab prefix from config data.
 * @private
 * @returns {String}
 */

Config.prototype.getPrefix = function getPrefix() {
  let prefix = this.str('prefix');

  if (prefix) {
    if (prefix[0] === '~')
      prefix = Path.join(HOME, prefix.substring(1));
    return prefix;
  }

  prefix = Path.join(HOME, `.${this.module}`);

  const network = this.str('network');

  if (network) {
    assert(isAlpha(network), 'Bad network.');
    if (network !== 'mainnet')
      prefix = Path.join(prefix, network);
  }

  return Path.normalize(prefix);
};

/**
 * Grab config filename from config data.
 * @private
 * @param {String} file
 * @returns {String}
 */

Config.prototype.getFile = function getFile(file) {
  const name = this.str('config');

  if (name)
    return name;

  return Path.join(this.prefix, file);
};

/**
 * Ensure prefix.
 * @returns {Promise}
 */

Config.prototype.ensure = function ensure() {
  if (fs.unsupported)
    return Promise.resolve();

  return fs.mkdirp(this.prefix);
};

/**
 * Create a file path using `prefix`.
 * @param {String} file
 * @returns {String}
 */

Config.prototype.location = function location(file) {
  return Path.join(this.prefix, file);
};

/**
 * Parse config text.
 * @private
 * @param {String} text
 */

Config.prototype.parseConfig = function parseConfig(text) {
  assert(typeof text === 'string', 'Config must be text.');

  if (text.charCodeAt(0) === 0xfeff)
    text = text.substring(1);

  text = text.replace(/\r\n/g, '\n');
  text = text.replace(/\r/g, '\n');
  text = text.replace(/\\\n/g, '');

  let colons = true;
  let seen = false;
  let num = 0;

  for (const chunk of text.split('\n')) {
    const line = chunk.trim();

    num += 1;

    if (line.length === 0)
      continue;

    if (line[0] === '#')
      continue;

    const equal = line.indexOf('=');
    const colon = line.indexOf(':');

    let index = -1;

    if (colon !== -1 && (colon < equal || equal === -1)) {
      if (seen && !colons)
        throw new Error(`Expected '=' on line ${num}: "${line}".`);

      index = colon;
      seen = true;
      colons = true;
    } else if (equal !== -1) {
      if (seen && colons)
        throw new Error(`Expected ':' on line ${num}: "${line}".`);

      index = equal;
      seen = true;
      colons = false;
    } else {
      const symbol = colons ? ':' : '=';
      throw new Error(`Expected '${symbol}' on line ${num}: "${line}".`);
    }

    let key = line.substring(0, index).trim();

    key = key.replace(/\-/g, '');

    if (!isLowerKey(key))
      throw new Error(`Invalid option on line ${num}: ${key}.`);

    const value = line.substring(index + 1).trim();

    if (value.length === 0)
      continue;

    const alias = Config.alias[key];

    if (alias)
      key = alias;

    this.data[key] = value;
  }
};

/**
 * Parse arguments.
 * @private
 * @param {Array?} argv
 */

Config.prototype.parseArg = function parseArg(argv) {
  if (!argv || typeof argv !== 'object')
    argv = process.argv;

  assert(Array.isArray(argv));

  let last = null;
  let pass = false;

  for (let i = 2; i < argv.length; i++) {
    const arg = argv[i];

    assert(typeof arg === 'string');

    if (arg === '--') {
      pass = true;
      continue;
    }

    if (pass) {
      this.pass.push(arg);
      continue;
    }

    if (arg.length === 0) {
      last = null;
      continue;
    }

    if (arg.indexOf('--') === 0) {
      const index = arg.indexOf('=');

      let key = null;
      let value = null;
      let empty = false;

      if (index !== -1) {
        // e.g. --opt=val
        key = arg.substring(2, index);
        value = arg.substring(index + 1);
        last = null;
        empty = false;
      } else {
        // e.g. --opt
        key = arg.substring(2);
        value = 'true';
        last = null;
        empty = true;
      }

      key = key.replace(/\-/g, '');

      if (!isLowerKey(key))
        throw new Error(`Invalid argument: --${key}.`);

      if (value.length === 0)
        continue;

      // Do not allow one-letter aliases.
      if (key.length > 1) {
        const alias = Config.alias[key];
        if (alias)
          key = alias;
      }

      this.args[key] = value;

      if (empty)
        last = key;

      continue;
    }

    if (arg[0] === '-') {
      // e.g. -abc
      last = null;

      for (let j = 1; j < arg.length; j++) {
        let key = arg[j];

        if ((key < 'a' || key > 'z')
            && (key < 'A' || key > 'Z')
            && (key < '0' || key > '9')
            && key !== '?') {
          throw new Error(`Invalid argument: -${key}.`);
        }

        const alias = Config.alias[key];

        if (alias)
          key = alias;

        this.args[key] = 'true';

        last = key;
      }

      continue;
    }

    // e.g. foo
    const value = arg;

    if (value.length === 0) {
      last = null;
      continue;
    }

    if (last) {
      this.args[last] = value;
      last = null;
    } else {
      this.argv.push(value);
    }
  }
};

/**
 * Parse environment variables.
 * @private
 * @param {Object?} env
 * @returns {Object}
 */

Config.prototype.parseEnv = function parseEnv(env) {
  let prefix = this.module;

  prefix = prefix.toUpperCase();
  prefix = prefix.replace(/-/g, '_');
  prefix += '_';

  if (!env || typeof env !== 'object')
    env = process.env;

  assert(env && typeof env === 'object');

  for (let key of Object.keys(env)) {
    const value = env[key];

    assert(typeof value === 'string');

    if (!util.startsWith(key, prefix))
      continue;

    key = key.substring(prefix.length);
    key = key.replace(/_/g, '');

    if (!isUpperKey(key))
      continue;

    if (value.length === 0)
      continue;

    key = key.toLowerCase();

    // Do not allow one-letter aliases.
    if (key.length > 1) {
      const alias = Config.alias[key];
      if (alias)
        key = alias;
    }

    this.env[key] = value;
  }
};

/**
 * Parse uri querystring variables.
 * @private
 * @param {String} query
 */

Config.prototype.parseQuery = function parseQuery(query) {
  if (typeof query !== 'string') {
    if (!global.location)
      return {};

    query = global.location.search;

    if (typeof query !== 'string')
      return {};
  }

  return this.parseForm(query, this.query);
};

/**
 * Parse uri hash variables.
 * @private
 * @param {String} hash
 */

Config.prototype.parseHash = function parseHash(hash) {
  if (typeof hash !== 'string') {
    if (!global.location)
      return {};

    hash = global.location.hash;

    if (typeof hash !== 'string')
      return {};
  }

  return this.parseForm(hash, this.hash);
};

/**
 * Parse form-urlencoded variables.
 * @private
 * @param {String} query
 */

Config.prototype.parseForm = function parseForm(query, map) {
  assert(typeof query === 'string');

  if (query.length === 0)
    return;

  let ch = '?';

  if (map === this.hash)
    ch = '#';

  if (query[0] === ch)
    query = query.substring(1);

  for (const pair of query.split('&')) {
    const index = pair.indexOf('=');

    let key, value;
    if (index !== -1) {
      key = pair.substring(0, index);
      value = pair.substring(index + 1);
    } else {
      key = pair;
      value = 'true';
    }

    key = unescape(key);
    key = key.replace(/\-/g, '');

    if (!isLowerKey(key))
      continue;

    value = unescape(value);

    if (value.length === 0)
      continue;

    const alias = Config.alias[key];

    if (alias)
      key = alias;

    map[key] = value;
  }
};

/*
 * Helpers
 */

function fmt(key) {
  if (Array.isArray(key))
    key = key[0];

  if (typeof key === 'number')
    return `Argument #${key}`;

  return key;
}

function unescape(str) {
  try {
    str = decodeURIComponent(str);
    str = str.replace(/\+/g, ' ');
  } catch (e) {
    ;
  }
  str = str.replace(/\0/g, '');
  return str;
}

function isAlpha(str) {
  return /^[a-z0-9]+$/.test(str);
}

function isKey(key) {
  return /^[a-zA-Z0-9]+$/.test(key);
}

function isLowerKey(key) {
  if (!isKey(key))
    return false;

  return !/[A-Z]/.test(key);
}

function isUpperKey(key) {
  if (!isKey(key))
    return false;

  return !/[a-z]/.test(key);
}

/*
 * Expose
 */

module.exports = Config;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * workerpool.js - worker processes for wmcc_core.
 */

/* eslint no-nested-ternary: "off" */



const assert = __webpack_require__(0);
const EventEmitter = __webpack_require__(10);
const os = __webpack_require__(116);
const util = __webpack_require__(1);
const co = __webpack_require__(17);
const Network = __webpack_require__(6);
const Child = __webpack_require__(317);
const jobs = __webpack_require__(125);
const Parser = __webpack_require__(126);
const Framer = __webpack_require__(127);
const packets = __webpack_require__(53);

/**
 * A worker pool.
 * @alias module:workers.WorkerPool
 * @constructor
 * @param {Object} options
 * @param {Number} [options.size=num-cores] - Max pool size.
 * @param {Number} [options.timeout=120000] - Execution timeout.
 * @property {Number} size
 * @property {Number} timeout
 * @property {Map} children
 * @property {Number} uid
 */

function WorkerPool(options) {
  if (!(this instanceof WorkerPool))
    return new WorkerPool(options);

  EventEmitter.call(this);

  this.enabled = false;
  this.size = getCores();
  this.timeout = 120000;
  this.file = "wmcc-worker.js" || 'worker.js';

  this.children = new Map();
  this.uid = 0;

  this.set(options);
}

Object.setPrototypeOf(WorkerPool.prototype, EventEmitter.prototype);

/**
 * Set worker pool options.
 * @param {Object} options
 */

WorkerPool.prototype.set = function set(options) {
  if (!options)
    return;

  if (options.enabled != null) {
    assert(typeof options.enabled === 'boolean');
    this.enabled = options.enabled;
  }

  if (options.size != null) {
    assert(util.isU32(options.size));
    assert(options.size > 0);
    this.size = options.size;
  }

  if (options.timeout != null) {
    assert(util.isInt(options.timeout));
    assert(options.timeout >= -1);
    this.timeout = options.timeout;
  }

  if (options.file != null) {
    assert(typeof options.file === 'string');
    this.file = options.file;
  }
};

/**
 * Open worker pool.
 * @returns {Promise}
 */

WorkerPool.prototype.open = async function open() {
  ;
};

/**
 * Close worker pool.
 * @returns {Promise}
 */

WorkerPool.prototype.close = async function close() {
  this.destroy();
};

/**
 * Spawn a new worker.
 * @param {Number} id - Worker ID.
 * @returns {Worker}
 */

WorkerPool.prototype.spawn = function spawn(id) {
  const child = new Worker(this.file);

  child.id = id;

  child.on('error', (err) => {
    this.emit('error', err, child);
  });

  child.on('exit', (code) => {
    this.emit('exit', code, child);

    if (this.children.get(id) === child)
      this.children.delete(id);
  });

  child.on('event', (items) => {
    this.emit('event', items, child);
    this.emit(...items);
  });

  child.on('log', (text) => {
    this.emit('log', text, child);
  });

  this.emit('spawn', child);

  return child;
};

/**
 * Allocate a new worker, will not go above `size` option
 * and will automatically load balance the workers.
 * @returns {Worker}
 */

WorkerPool.prototype.alloc = function alloc() {
  const id = this.uid++ % this.size;

  if (!this.children.has(id))
    this.children.set(id, this.spawn(id));

  return this.children.get(id);
};

/**
 * Emit an event on the worker side (all workers).
 * @param {String} event
 * @param {...Object} arg
 * @returns {Boolean}
 */

WorkerPool.prototype.sendEvent = function sendEvent() {
  let result = true;

  for (const child of this.children.values()) {
    if (!child.sendEvent.apply(child, arguments))
      result = false;
  }

  return result;
};

/**
 * Destroy all workers.
 */

WorkerPool.prototype.destroy = function destroy() {
  for (const child of this.children.values())
    child.destroy();
};

/**
 * Call a method for a worker to execute.
 * @param {Packet} packet
 * @param {Number} timeout
 * @returns {Promise}
 */

WorkerPool.prototype.execute = function execute(packet, timeout) {
  if (!this.enabled || !Child.hasSupport()) {
    return new Promise((resolve, reject) => {
      setImmediate(() => {
        let result;
        try {
          result = jobs.handle(packet);
        } catch (e) {
          reject(e);
          return;
        }
        resolve(result);
      });
    });
  }

  if (!timeout)
    timeout = this.timeout;

  const child = this.alloc();

  return child.execute(packet, timeout);
};

/**
 * Execute the tx check job (default timeout).
 * @method
 * @param {TX} tx
 * @param {CoinView} view
 * @param {VerifyFlags} flags
 * @returns {Promise}
 */

WorkerPool.prototype.check = async function check(tx, view, flags) {
  const packet = new packets.CheckPacket(tx, view, flags);
  const result = await this.execute(packet, -1);

  if (result.error)
    throw result.error;

  return null;
};

/**
 * Execute the tx signing job (default timeout).
 * @method
 * @param {MTX} tx
 * @param {KeyRing[]} ring
 * @param {SighashType} type
 * @returns {Promise}
 */

WorkerPool.prototype.sign = async function sign(tx, ring, type) {
  let rings = ring;

  if (!Array.isArray(rings))
    rings = [rings];

  const packet = new packets.SignPacket(tx, rings, type);
  const result = await this.execute(packet, -1);

  result.inject(tx);

  return result.total;
};

/**
 * Execute the tx input check job (default timeout).
 * @method
 * @param {TX} tx
 * @param {Number} index
 * @param {Coin|Output} coin
 * @param {VerifyFlags} flags
 * @returns {Promise}
 */

WorkerPool.prototype.checkInput = async function checkInput(tx, index, coin, flags) {
  const packet = new packets.CheckInputPacket(tx, index, coin, flags);
  const result = await this.execute(packet, -1);

  if (result.error)
    throw result.error;

  return null;
};

/**
 * Execute the tx input signing job (default timeout).
 * @method
 * @param {MTX} tx
 * @param {Number} index
 * @param {Coin|Output} coin
 * @param {KeyRing} ring
 * @param {SighashType} type
 * @returns {Promise}
 */

WorkerPool.prototype.signInput = async function signInput(tx, index, coin, ring, type) {
  const packet = new packets.SignInputPacket(tx, index, coin, ring, type);
  const result = await this.execute(packet, -1);
  result.inject(tx);
  return result.value;
};

/**
 * Execute the secp256k1 verify job (no timeout).
 * @method
 * @param {Buffer} msg
 * @param {Buffer} sig - DER formatted.
 * @param {Buffer} key
 * @returns {Promise}
 */

WorkerPool.prototype.ecVerify = async function ecVerify(msg, sig, key) {
  const packet = new packets.ECVerifyPacket(msg, sig, key);
  const result = await this.execute(packet, -1);
  return result.value;
};

/**
 * Execute the secp256k1 signing job (no timeout).
 * @method
 * @param {Buffer} msg
 * @param {Buffer} key
 * @returns {Promise}
 */

WorkerPool.prototype.ecSign = async function ecSign(msg, key) {
  const packet = new packets.ECSignPacket(msg, key);
  const result = await this.execute(packet, -1);
  return result.sig;
};

/**
 * Execute the mining job (no timeout).
 * @method
 * @param {Buffer} data
 * @param {Buffer} target
 * @param {Number} min
 * @param {Number} max
 * @returns {Promise} - Returns {Number}.
 */

WorkerPool.prototype.mine = async function mine(data, target, min, max) {
  const packet = new packets.MinePacket(data, target, min, max);
  const result = await this.execute(packet, -1);
  return result.nonce;
};

/**
 * Execute scrypt job (no timeout).
 * @method
 * @param {Buffer} passwd
 * @param {Buffer} salt
 * @param {Number} N
 * @param {Number} r
 * @param {Number} p
 * @param {Number} len
 * @returns {Promise}
 */

WorkerPool.prototype.scrypt = async function scrypt(passwd, salt, N, r, p, len) {
  const packet = new packets.ScryptPacket(passwd, salt, N, r, p, len);
  const result = await this.execute(packet, -1);
  return result.key;
};

/**
 * Represents a worker.
 * @alias module:workers.Worker
 * @constructor
 * @param {String} file
 */

function Worker(file) {
  if (!(this instanceof Worker))
    return new Worker(file);

  EventEmitter.call(this);

  this.id = -1;
  this.framer = new Framer();
  this.parser = new Parser();
  this.pending = new Map();

  this.child = new Child(file);

  this.init();
}

Object.setPrototypeOf(Worker.prototype, EventEmitter.prototype);

/**
 * Initialize worker. Bind to events.
 * @private
 */

Worker.prototype.init = function init() {
  this.child.on('data', (data) => {
    this.parser.feed(data);
  });

  this.child.on('exit', (code, signal) => {
    this.emit('exit', code, signal);
  });

  this.child.on('error', (err) => {
    this.emit('error', err);
  });

  this.parser.on('error', (err) => {
    this.emit('error', err);
  });

  this.parser.on('packet', (packet) => {
    this.emit('packet', packet);
  });

  this.listen();
};

/**
 * Listen for packets.
 * @private
 */

Worker.prototype.listen = function listen() {
  this.on('exit', (code, signal) => {
    this.killJobs();
  });

  this.on('error', (err) => {
    this.killJobs();
  });

  this.on('packet', (packet) => {
    try {
      this.handlePacket(packet);
    } catch (e) {
      this.emit('error', e);
    }
  });

  this.sendEnv({
    WMCC_WORKER_NETWORK: Network.type,
    WMCC_WORKER_ISTTY: process.stdout
      ? (process.stdout.isTTY ? '1' : '0')
      : '0'
  });
};

/**
 * Handle packet.
 * @private
 * @param {Packet} packet
 */

Worker.prototype.handlePacket = function handlePacket(packet) {
  switch (packet.cmd) {
    case packets.types.EVENT:
      this.emit('event', packet.items);
      this.emit(...packet.items);
      break;
    case packets.types.LOG:
      this.emit('log', packet.text);
      break;
    case packets.types.ERROR:
      this.emit('error', packet.error);
      break;
    case packets.types.ERRORRESULT:
      this.rejectJob(packet.id, packet.error);
      break;
    default:
      this.resolveJob(packet.id, packet);
      break;
  }
};

/**
 * Send data to worker.
 * @param {Buffer} data
 * @returns {Boolean}
 */

Worker.prototype.write = function write(data) {
  return this.child.write(data);
};

/**
 * Frame and send a packet.
 * @param {Packet} packet
 * @returns {Boolean}
 */

Worker.prototype.send = function send(packet) {
  return this.write(this.framer.packet(packet));
};

/**
 * Send environment.
 * @param {Object} env
 * @returns {Boolean}
 */

Worker.prototype.sendEnv = function sendEnv(env) {
  return this.send(new packets.EnvPacket(env));
};

/**
 * Emit an event on the worker side.
 * @param {String} event
 * @param {...Object} arg
 * @returns {Boolean}
 */

Worker.prototype.sendEvent = function sendEvent(...items) {
  return this.send(new packets.EventPacket(items));
};

/**
 * Destroy the worker.
 */

Worker.prototype.destroy = function destroy() {
  return this.child.destroy();
};

/**
 * Call a method for a worker to execute.
 * @param {Packet} packet
 * @param {Number} timeout
 * @returns {Promise}
 */

Worker.prototype.execute = function execute(packet, timeout) {
  return new Promise((resolve, reject) => {
    this._execute(packet, timeout, resolve, reject);
  });
};

/**
 * Call a method for a worker to execute.
 * @private
 * @param {Packet} packet
 * @param {Number} timeout
 * @param {Function} resolve
 * @param {Function} reject
 * the worker method specifies.
 */

Worker.prototype._execute = function _execute(packet, timeout, resolve, reject) {
  const job = new PendingJob(this, packet.id, resolve, reject);

  assert(!this.pending.has(packet.id), 'ID overflow.');

  this.pending.set(packet.id, job);

  job.start(timeout);

  this.send(packet);
};

/**
 * Resolve a job.
 * @param {Number} id
 * @param {Packet} result
 */

Worker.prototype.resolveJob = function resolveJob(id, result) {
  const job = this.pending.get(id);

  if (!job)
    throw new Error(`Job ${id} is not in progress.`);

  job.resolve(result);
};

/**
 * Reject a job.
 * @param {Number} id
 * @param {Error} err
 */

Worker.prototype.rejectJob = function rejectJob(id, err) {
  const job = this.pending.get(id);

  if (!job)
    throw new Error(`Job ${id} is not in progress.`);

  job.reject(err);
};

/**
 * Kill all jobs associated with worker.
 */

Worker.prototype.killJobs = function killJobs() {
  for (const job of this.pending.values())
    job.destroy();
};

/**
 * Pending Job
 * @constructor
 * @ignore
 * @param {Worker} worker
 * @param {Number} id
 * @param {Function} resolve
 * @param {Function} reject
 */

function PendingJob(worker, id, resolve, reject) {
  this.worker = worker;
  this.id = id;
  this.job = co.job(resolve, reject);
  this.timer = null;
}

/**
 * Start the timer.
 * @param {Number} timeout
 */

PendingJob.prototype.start = function start(timeout) {
  if (!timeout || timeout <= 0)
    return;

  this.timer = setTimeout(() => {
    this.reject(new Error('Worker timed out.'));
  }, timeout);
};

/**
 * Destroy the job with an error.
 */

PendingJob.prototype.destroy = function destroy() {
  this.reject(new Error('Job was destroyed.'));
};

/**
 * Cleanup job state.
 * @returns {Job}
 */

PendingJob.prototype.cleanup = function cleanup() {
  const job = this.job;

  assert(job, 'Already finished.');

  this.job = null;

  if (this.timer != null) {
    clearTimeout(this.timer);
    this.timer = null;
  }

  assert(this.worker.pending.has(this.id));
  this.worker.pending.delete(this.id);

  return job;
};

/**
 * Complete job with result.
 * @param {Object} result
 */

PendingJob.prototype.resolve = function resolve(result) {
  const job = this.cleanup();
  job.resolve(result);
};

/**
 * Complete job with error.
 * @param {Error} err
 */

PendingJob.prototype.reject = function reject(err) {
  const job = this.cleanup();
  job.reject(err);
};

/*
 * Helpers
 */

function getCores() {
  return Math.max(2, os.cpus().length);
}

/*
 * Expose
 */

module.exports = WorkerPool;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * jobs.js - worker jobs for wmcc_core.
 */



const secp256k1 = __webpack_require__(12);
const {derive} = __webpack_require__(45);
const hashcash = __webpack_require__(95);
const packets = __webpack_require__(53);

/**
 * @exports workers/jobs
 */

const jobs = exports;

/**
 * Execute a job on the worker.
 * @param {String} cmd
 * @param {Array} args
 * @returns {Object}
 * @throws on unknown command
 */

jobs.execute = function execute(p) {
  try {
    return jobs.handle(p);
  } catch (e) {
    return new packets.ErrorResultPacket(e);
  }
};

/**
 * Execute a job on the worker.
 * @param {String} cmd
 * @param {Array} args
 * @returns {Object}
 * @throws on unknown command
 */

jobs.handle = function handle(p) {
  switch (p.cmd) {
    case packets.types.CHECK:
      return jobs.check(p.tx, p.view, p.flags);
    case packets.types.CHECKINPUT:
      return jobs.checkInput(p.tx, p.index, p.coin, p.flags);
    case packets.types.SIGN:
      return jobs.sign(p.tx, p.rings, p.type);
    case packets.types.SIGNINPUT:
      return jobs.signInput(p.tx, p.index, p.coin, p.ring, p.type);
    case packets.types.ECVERIFY:
      return jobs.ecVerify(p.msg, p.sig, p.key);
    case packets.types.ECSIGN:
      return jobs.ecSign(p.msg, p.key);
    case packets.types.MINE:
      return jobs.mine(p.data, p.target, p.min, p.max);
    case packets.types.SCRYPT:
      return jobs.scrypt(p.passwd, p.salt, p.N, p.r, p.p, p.len);
    default:
      throw new Error(`Unknown command: "${p.cmd}".`);
  }
};

/**
 * Execute tx.check() on worker.
 * @see TX#check
 * @param {TX} tx
 * @param {CoinView} view
 * @param {VerifyFlags} flags
 * @returns {CheckResultPacket}
 */

jobs.check = function check(tx, view, flags) {
  try {
    tx.check(view, flags);
  } catch (err) {
    if (err.type === 'ScriptError')
      return new packets.CheckResultPacket(err);
    throw err;
  }
  return new packets.CheckResultPacket();
};

/**
 * Execute tx.checkInput() on worker.
 * @see TX#checkInput
 * @param {TX} tx
 * @param {Number} index
 * @param {Output} coin
 * @param {VerifyFlags} flags
 * @returns {CheckInputResultPacket}
 */

jobs.checkInput = function checkInput(tx, index, coin, flags) {
  try {
    tx.checkInput(index, coin, flags);
  } catch (err) {
    if (err.type === 'ScriptError')
      return new packets.CheckInputResultPacket(err);
    throw err;
  }
  return new packets.CheckInputResultPacket();
};

/**
 * Execute tx.sign() on worker.
 * @see MTX#sign
 * @param {MTX} tx
 * @param {KeyRing[]} ring
 * @param {SighashType} type
 */

jobs.sign = function sign(tx, ring, type) {
  const total = tx.sign(ring, type);
  return packets.SignResultPacket.fromTX(tx, total);
};

/**
 * Execute tx.signInput() on worker.
 * @see MTX#signInput
 * @param {MTX} tx
 * @param {Number} index
 * @param {Output} coin
 * @param {KeyRing} ring
 * @param {SighashType} type
 */

jobs.signInput = function signInput(tx, index, coin, ring, type) {
  const result = tx.signInput(tx, index, coin, ring, type);
  return packets.SignInputResultPacket.fromTX(tx, index, result);
};

/**
 * Execute secp256k1.verify() on worker.
 * @see secp256k1.verify
 * @param {TX} tx
 * @param {VerifyFlags} flags
 * @returns {Boolean}
 */

jobs.ecVerify = function ecVerify(msg, sig, key) {
  const result = secp256k1.verify(msg, sig, key);
  return new packets.ECVerifyResultPacket(result);
};

/**
 * Execute secp256k1.sign() on worker.
 * @see secp256k1.sign
 * @param {TX} tx
 * @param {Number} index
 * @param {VerifyFlags} flags
 * @returns {Boolean}
 */

jobs.ecSign = function ecSign(msg, key) {
  const sig = secp256k1.sign(msg, key);
  return new packets.ECSignResultPacket(sig);
};

/**
 * Mine a block on worker.
 * @param {Buffer} data
 * @param {Buffer} target
 * @param {Number} min
 * @param {Number} max
 * @returns {Number}
 */

jobs.mine = function mine(data, target, min, max) {
  const nonce = hashcash(data, target, min, max);
  return new packets.MineResultPacket(nonce);
};

/**
 * Execute scrypt() on worker.
 * @see scrypt
 * @param {Buffer} passwd
 * @param {Buffer} salt
 * @param {Number} N
 * @param {Number} r
 * @param {Number} p
 * @param {Number} len
 * @returns {Buffer}
 */

jobs.scrypt = function scrypt(passwd, salt, N, r, p, len) {
  const key = derive(passwd, salt, N, r, p, len);
  return new packets.ScryptResultPacket(key);
};


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * workers.js - worker processes for wmcc_core.
 */



const assert = __webpack_require__(0);
const EventEmitter = __webpack_require__(10);
const packets = __webpack_require__(53);

/**
 * Parser
 * @alias module:workers.Parser
 * @constructor
 */

function Parser() {
  if (!(this instanceof Parser))
    return new Parser();

  EventEmitter.call(this);

  this.waiting = 9;
  this.header = null;
  this.pending = [];
  this.total = 0;
}

Object.setPrototypeOf(Parser.prototype, EventEmitter.prototype);

Parser.prototype.feed = function feed(data) {
  this.total += data.length;
  this.pending.push(data);

  while (this.total >= this.waiting) {
    const chunk = this.read(this.waiting);
    this.parse(chunk);
  }
};

Parser.prototype.read = function read(size) {
  assert(this.total >= size, 'Reading too much.');

  if (size === 0)
    return Buffer.alloc(0);

  const pending = this.pending[0];

  if (pending.length > size) {
    const chunk = pending.slice(0, size);
    this.pending[0] = pending.slice(size);
    this.total -= chunk.length;
    return chunk;
  }

  if (pending.length === size) {
    const chunk = this.pending.shift();
    this.total -= chunk.length;
    return chunk;
  }

  const chunk = Buffer.allocUnsafe(size);
  let off = 0;

  while (off < chunk.length) {
    const pending = this.pending[0];
    const len = pending.copy(chunk, off);
    if (len === pending.length)
      this.pending.shift();
    else
      this.pending[0] = pending.slice(len);
    off += len;
  }

  assert.strictEqual(off, chunk.length);

  this.total -= chunk.length;

  return chunk;
};

Parser.prototype.parse = function parse(data) {
  let header = this.header;

  if (!header) {
    try {
      header = this.parseHeader(data);
    } catch (e) {
      this.emit('error', e);
      return;
    }

    this.header = header;
    this.waiting = header.size + 1;

    return;
  }

  this.waiting = 9;
  this.header = null;

  let packet;
  try {
    packet = this.parsePacket(header, data);
  } catch (e) {
    this.emit('error', e);
    return;
  }

  if (data[data.length - 1] !== 0x0a) {
    this.emit('error', new Error('No trailing newline.'));
    return;
  }

  packet.id = header.id;

  this.emit('packet', packet);
};

Parser.prototype.parseHeader = function parseHeader(data) {
  const id = data.readUInt32LE(0, true);
  const cmd = data.readUInt8(4, true);
  const size = data.readUInt32LE(5, true);
  return new Header(id, cmd, size);
};

Parser.prototype.parsePacket = function parsePacket(header, data) {
  switch (header.cmd) {
    case packets.types.ENV:
      return packets.EnvPacket.fromRaw(data);
    case packets.types.EVENT:
      return packets.EventPacket.fromRaw(data);
    case packets.types.LOG:
      return packets.LogPacket.fromRaw(data);
    case packets.types.ERROR:
      return packets.ErrorPacket.fromRaw(data);
    case packets.types.ERRORRESULT:
      return packets.ErrorResultPacket.fromRaw(data);
    case packets.types.CHECK:
      return packets.CheckPacket.fromRaw(data);
    case packets.types.CHECKRESULT:
      return packets.CheckResultPacket.fromRaw(data);
    case packets.types.SIGN:
      return packets.SignPacket.fromRaw(data);
    case packets.types.SIGNRESULT:
      return packets.SignResultPacket.fromRaw(data);
    case packets.types.CHECKINPUT:
      return packets.CheckInputPacket.fromRaw(data);
    case packets.types.CHECKINPUTRESULT:
      return packets.CheckInputResultPacket.fromRaw(data);
    case packets.types.SIGNINPUT:
      return packets.SignInputPacket.fromRaw(data);
    case packets.types.SIGNINPUTRESULT:
      return packets.SignInputResultPacket.fromRaw(data);
    case packets.types.ECVERIFY:
      return packets.ECVerifyPacket.fromRaw(data);
    case packets.types.ECVERIFYRESULT:
      return packets.ECVerifyResultPacket.fromRaw(data);
    case packets.types.ECSIGN:
      return packets.ECSignPacket.fromRaw(data);
    case packets.types.ECSIGNRESULT:
      return packets.ECSignResultPacket.fromRaw(data);
    case packets.types.MINE:
      return packets.MinePacket.fromRaw(data);
    case packets.types.MINERESULT:
      return packets.MineResultPacket.fromRaw(data);
    case packets.types.SCRYPT:
      return packets.ScryptPacket.fromRaw(data);
    case packets.types.SCRYPTRESULT:
      return packets.ScryptResultPacket.fromRaw(data);
    default:
      throw new Error('Unknown packet.');
  }
};

/**
 * Header
 * @constructor
 * @ignore
 */

function Header(id, cmd, size) {
  this.id = id;
  this.cmd = cmd;
  this.size = size;
}

/*
 * Expose
 */

module.exports = Parser;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * workers.js - worker processes for wmcc_core.
 */



const StaticWriter = __webpack_require__(4);

/**
 * Framer
 * @alias module:workers.Framer
 * @constructor
 */

function Framer() {
  if (!(this instanceof Framer))
    return new Framer();
}

Framer.prototype.packet = function packet(payload) {
  const size = 10 + payload.getSize();
  const bw = new StaticWriter(size);

  bw.writeU32(payload.id);
  bw.writeU8(payload.cmd);
  bw.seek(4);

  payload.toWriter(bw);

  bw.writeU8(0x0a);

  const msg = bw.render();
  msg.writeUInt32LE(msg.length - 10, 5, true);

  return msg;
};

/*
 * Expose
 */

module.exports = Framer;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * walletkey.js - walletkey object for wmcc_core.
 */



const Address = __webpack_require__(11);
const KeyRing = __webpack_require__(47);
const Path = __webpack_require__(76);

/**
 * Represents a key ring which amounts to an address.
 * @alias module:wallet.WalletKey
 * @constructor
 * @param {Object} options
 */

function WalletKey(options, network) {
  if (!(this instanceof WalletKey))
    return new WalletKey(options, network);

  KeyRing.call(this, options, network);

  this.keyType = Path.types.HD;

  this.id = null;
  this.wid = -1;
  this.name = null;
  this.account = -1;
  this.branch = -1;
  this.index = -1;
}

Object.setPrototypeOf(WalletKey.prototype, KeyRing.prototype);

/**
 * Instantiate key ring from options.
 * @param {Object} options
 * @returns {WalletKey}
 */

WalletKey.fromOptions = function fromOptions(options) {
  return new WalletKey().fromOptions(options);
};

/**
 * Instantiate wallet key from a private key.
 * @param {Buffer} key
 * @param {Boolean?} compressed
 * @param {(NetworkType|Network)} network
 * @returns {WalletKey}
 */

WalletKey.fromPrivate = function fromPrivate(key, compressed, network) {
  return new WalletKey().fromPrivate(key, compressed, network);
};

/**
 * Generate a wallet key.
 * @param {(Network|NetworkType)?} network
 * @returns {WalletKey}
 */

WalletKey.generate = function generate(compressed, network) {
  return new WalletKey().generate(compressed, network);
};

/**
 * Instantiate wallet key from a public key.
 * @param {Buffer} publicKey
 * @param {(NetworkType|Network)} network
 * @returns {WalletKey}
 */

WalletKey.fromPublic = function fromPublic(key, network) {
  return new WalletKey().fromPublic(key, network);
};

/**
 * Instantiate wallet key from a public key.
 * @param {Buffer} publicKey
 * @param {(NetworkType|Network)} network
 * @returns {WalletKey}
 */

WalletKey.fromKey = function fromKey(key, compressed, network) {
  return new WalletKey().fromKey(key, compressed, network);
};

/**
 * Instantiate wallet key from script.
 * @param {Buffer} key
 * @param {Script} script
 * @param {(NetworkType|Network)} network
 * @returns {WalletKey}
 */

WalletKey.fromScript = function fromScript(key, script, compressed, network) {
  return new WalletKey().fromScript(key, script, compressed, network);
};

/**
 * Instantiate a wallet key from a serialized CBitcoinSecret.
 * @param {Base58String} secret
 * @param {Network?} network
 * @returns {WalletKey}
 */

WalletKey.fromSecret = function fromSecret(data, network) {
  return new WalletKey().fromSecret(data, network);
};

/**
 * Convert an WalletKey to a more json-friendly object.
 * @returns {Object}
 */

WalletKey.prototype.toJSON = function toJSON() {
  return {
    network: this.network.type,
    wid: this.wid,
    id: this.id,
    name: this.name,
    account: this.account,
    branch: this.branch,
    index: this.index,
    witness: this.witness,
    nested: this.nested,
    publicKey: this.publicKey.toString('hex'),
    script: this.script ? this.script.toRaw().toString('hex') : null,
    program: this.witness ? this.getProgram().toRaw().toString('hex') : null,
    type: Address.typesByVal[this.getType()].toLowerCase(),
    address: this.getAddress('string')
  };
};

/**
 * Instantiate an WalletKey from a jsonified transaction object.
 * @param {Object} json - The jsonified transaction object.
 * @returns {WalletKey}
 */

WalletKey.fromJSON = function fromJSON(json) {
  return new WalletKey().fromJSON(json);
};

/**
 * Instantiate a wallet key from serialized data.
 * @param {Buffer} data
 * @returns {WalletKey}
 */

WalletKey.fromRaw = function fromRaw(data) {
  return new WalletKey().fromRaw(data);
};

/**
 * Inject properties from hd key.
 * @private
 * @param {Account} account
 * @param {HDPrivateKey|HDPublicKey} key
 * @param {Number} branch
 * @param {Number} index
 * @returns {WalletKey}
 */

WalletKey.prototype.fromHD = function fromHD(account, key, branch, index) {
  this.keyType = Path.types.HD;
  this.id = account.id;
  this.wid = account.wid;
  this.name = account.name;
  this.account = account.accountIndex;
  this.branch = branch;
  this.index = index;
  this.witness = account.witness;
  this.nested = branch === 2;

  if (key.privateKey)
    return this.fromPrivate(key.privateKey, account.network);

  return this.fromPublic(key.publicKey, account.network);
};

/**
 * Instantiate a wallet key from hd key.
 * @param {Account} account
 * @param {HDPrivateKey|HDPublicKey} key
 * @param {Number} branch
 * @param {Number} index
 * @returns {WalletKey}
 */

WalletKey.fromHD = function fromHD(account, key, branch, index) {
  return new WalletKey().fromHD(account, key, branch, index);
};

/**
 * Inject properties from imported data.
 * @private
 * @param {Account} account
 * @param {Buffer} data
 * @returns {WalletKey}
 */

WalletKey.prototype.fromImport = function fromImport(account, data) {
  this.keyType = Path.types.KEY;
  this.id = account.id;
  this.wid = account.wid;
  this.name = account.name;
  this.account = account.accountIndex;
  this.witness = account.witness;
  return this.fromRaw(data, account.network);
};

/**
 * Instantiate a wallet key from imported data.
 * @param {Account} account
 * @param {Buffer} data
 * @returns {WalletKey}
 */

WalletKey.fromImport = function fromImport(account, data) {
  return new WalletKey().fromImport(account, data);
};

/**
 * Inject properties from key.
 * @private
 * @param {Account} account
 * @param {KeyRing} ring
 * @returns {WalletKey}
 */

WalletKey.prototype.fromRing = function fromRing(account, ring) {
  this.keyType = Path.types.KEY;
  this.id = account.id;
  this.wid = account.wid;
  this.name = account.name;
  this.account = account.accountIndex;
  this.witness = account.witness;
  return this.fromOptions(ring, ring.network);
};

/**
 * Instantiate a wallet key from regular key.
 * @param {Account} account
 * @param {KeyRing} ring
 * @returns {WalletKey}
 */

WalletKey.fromRing = function fromRing(account, ring) {
  return new WalletKey().fromRing(account, ring);
};

/**
 * Convert wallet key to a path.
 * @returns {Path}
 */

WalletKey.prototype.toPath = function toPath() {
  const path = new Path();

  path.id = this.id;
  path.wid = this.wid;
  path.name = this.name;
  path.account = this.account;

  switch (this.keyType) {
    case Path.types.HD:
      path.branch = this.branch;
      path.index = this.index;
      break;
    case Path.types.KEY:
      path.data = this.toRaw();
      break;
  }

  path.keyType = this.keyType;

  path.version = this.getVersion();
  path.type = this.getType();
  path.hash = this.getHash('hex');

  return path;
};

/**
 * Test whether an object is a WalletKey.
 * @param {Object} obj
 * @returns {Boolean}
 */

WalletKey.isWalletKey = function isWalletKey(obj) {
  return obj instanceof WalletKey;
};

/*
 * Expose
 */

module.exports = WalletKey;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * records.js - walletdb records.
 */



/**
 * @module wallet/records
 */

const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const encoding = __webpack_require__(3);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const TX = __webpack_require__(16);

/**
 * Chain State
 * @constructor
 */

function ChainState() {
  if (!(this instanceof ChainState))
    return new ChainState();

  this.startHeight = -1;
  this.startHash = encoding.NULL_HASH;
  this.height = -1;
  this.marked = false;
}

/**
 * Clone the state.
 * @returns {ChainState}
 */

ChainState.prototype.clone = function clone() {
  const state = new ChainState();
  state.startHeight = this.startHeight;
  state.startHash = this.startHash;
  state.height = this.height;
  state.marked = this.marked;
  return state;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

ChainState.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data);

  this.startHeight = br.readU32();
  this.startHash = br.readHash('hex');
  this.height = br.readU32();
  this.marked = true;

  if (br.left() > 0)
    this.marked = br.readU8() === 1;

  return this;
};

/**
 * Instantiate chain state from serialized data.
 * @param {Hash} hash
 * @param {Buffer} data
 * @returns {ChainState}
 */

ChainState.fromRaw = function fromRaw(data) {
  return new ChainState().fromRaw(data);
};

/**
 * Serialize the chain state.
 * @returns {Buffer}
 */

ChainState.prototype.toRaw = function toRaw() {
  const bw = new StaticWriter(41);

  bw.writeU32(this.startHeight);
  bw.writeHash(this.startHash);
  bw.writeU32(this.height);
  bw.writeU8(this.marked ? 1 : 0);

  return bw.render();
};

/**
 * Block Meta
 * @constructor
 * @param {Hash} hash
 * @param {Number} height
 * @param {Number} time
 */

function BlockMeta(hash, height, time) {
  if (!(this instanceof BlockMeta))
    return new BlockMeta(hash, height, time);

  this.hash = hash || encoding.NULL_HASH;
  this.height = height != null ? height : -1;
  this.time = time || 0;
}

/**
 * Clone the block.
 * @returns {BlockMeta}
 */

BlockMeta.prototype.clone = function clone() {
  return new BlockMeta(this.hash, this.height, this.time);
};

/**
 * Get block meta hash as a buffer.
 * @returns {Buffer}
 */

BlockMeta.prototype.toHash = function toHash() {
  return Buffer.from(this.hash, 'hex');
};

/**
 * Instantiate block meta from chain entry.
 * @private
 * @param {ChainEntry} entry
 */

BlockMeta.prototype.fromEntry = function fromEntry(entry) {
  this.hash = entry.hash;
  this.height = entry.height;
  this.time = entry.time;
  return this;
};

/**
 * Instantiate block meta from json object.
 * @private
 * @param {Object} json
 */

BlockMeta.prototype.fromJSON = function fromJSON(json) {
  this.hash = util.revHex(json.hash);
  this.height = json.height;
  this.time = json.time;
  return this;
};

/**
 * Instantiate block meta from serialized tip data.
 * @private
 * @param {Buffer} data
 */

BlockMeta.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data);
  this.hash = br.readHash('hex');
  this.height = br.readU32();
  this.time = br.readU32();
  return this;
};

/**
 * Instantiate block meta from chain entry.
 * @param {ChainEntry} entry
 * @returns {BlockMeta}
 */

BlockMeta.fromEntry = function fromEntry(entry) {
  return new BlockMeta().fromEntry(entry);
};

/**
 * Instantiate block meta from json object.
 * @param {Object} json
 * @returns {BlockMeta}
 */

BlockMeta.fromJSON = function fromJSON(json) {
  return new BlockMeta().fromJSON(json);
};

/**
 * Instantiate block meta from serialized data.
 * @param {Hash} hash
 * @param {Buffer} data
 * @returns {BlockMeta}
 */

BlockMeta.fromRaw = function fromRaw(data) {
  return new BlockMeta().fromRaw(data);
};

/**
 * Serialize the block meta.
 * @returns {Buffer}
 */

BlockMeta.prototype.toRaw = function toRaw() {
  const bw = new StaticWriter(42);
  bw.writeHash(this.hash);
  bw.writeU32(this.height);
  bw.writeU32(this.time);
  return bw.render();
};

/**
 * Convert the block meta to a more json-friendly object.
 * @returns {Object}
 */

BlockMeta.prototype.toJSON = function toJSON() {
  return {
    hash: util.revHex(this.hash),
    height: this.height,
    time: this.time
  };
};

/**
 * Wallet Block
 * @constructor
 * @param {Hash} hash
 * @param {Number} height
 */

function BlockMapRecord(height) {
  if (!(this instanceof BlockMapRecord))
    return new BlockMapRecord(height);

  this.height = height != null ? height : -1;
  this.txs = new Map();
}

/**
 * Instantiate wallet block from serialized data.
 * @private
 * @param {Hash} hash
 * @param {Buffer} data
 */

BlockMapRecord.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data);
  const count = br.readU32();

  for (let i = 0; i < count; i++) {
    const hash = br.readHash('hex');
    const tx = TXMapRecord.fromReader(hash, br);
    this.txs.set(tx.hash, tx);
  }

  return this;
};

/**
 * Instantiate wallet block from serialized data.
 * @param {Hash} hash
 * @param {Buffer} data
 * @returns {BlockMapRecord}
 */

BlockMapRecord.fromRaw = function fromRaw(height, data) {
  return new BlockMapRecord(height).fromRaw(data);
};

/**
 * Calculate serialization size.
 * @returns {Number}
 */

BlockMapRecord.prototype.getSize = function getSize() {
  let size = 0;

  size += 4;

  for (const tx of this.txs.values()) {
    size += 32;
    size += tx.getSize();
  }

  return size;
};

/**
 * Serialize the wallet block as a block.
 * Contains matching transaction hashes.
 * @returns {Buffer}
 */

BlockMapRecord.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  const bw = new StaticWriter(size);

  bw.writeU32(this.txs.size);

  for (const [hash, tx] of this.txs) {
    bw.writeHash(hash);
    tx.toWriter(bw);
  }

  return bw.render();
};

/**
 * Add a hash and wid pair to the block.
 * @param {Hash} hash
 * @param {WalletID} wid
 * @returns {Boolean}
 */

BlockMapRecord.prototype.add = function add(hash, wid) {
  let tx = this.txs.get(hash);

  if (!tx) {
    tx = new TXMapRecord(hash);
    this.txs.set(hash, tx);
  }

  return tx.add(wid);
};

/**
 * Remove a hash and wid pair from the block.
 * @param {Hash} hash
 * @param {WalletID} wid
 * @returns {Boolean}
 */

BlockMapRecord.prototype.remove = function remove(hash, wid) {
  const tx = this.txs.get(hash);

  if (!tx)
    return false;

  if (!tx.remove(wid))
    return false;

  if (tx.wids.size === 0)
    this.txs.delete(tx.hash);

  return true;
};

/**
 * Convert tx map to an array.
 * @returns {Array}
 */

BlockMapRecord.prototype.toArray = function toArray() {
  const txs = [];

  for (const tx of this.txs.values())
    txs.push(tx);

  return txs;
};

/**
 * TX Hash
 * @constructor
 */

function TXMapRecord(hash, wids) {
  this.hash = hash || encoding.NULL_HASH;
  this.wids = wids || new Set();
}

TXMapRecord.prototype.add = function add(wid) {
  if (this.wids.has(wid))
    return false;

  this.wids.add(wid);
  return true;
};

TXMapRecord.prototype.remove = function remove(wid) {
  return this.wids.delete(wid);
};

TXMapRecord.prototype.toWriter = function toWriter(bw) {
  return serializeWallets(bw, this.wids);
};

TXMapRecord.prototype.getSize = function getSize() {
  return sizeWallets(this.wids);
};

TXMapRecord.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

TXMapRecord.prototype.fromReader = function fromReader(br) {
  this.wids = parseWallets(br);
  return this;
};

TXMapRecord.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

TXMapRecord.fromReader = function fromReader(hash, br) {
  return new TXMapRecord(hash).fromReader(br);
};

TXMapRecord.fromRaw = function fromRaw(hash, data) {
  return new TXMapRecord(hash).fromRaw(data);
};

/**
 * Outpoint Map
 * @constructor
 */

function OutpointMapRecord(hash, index, wids) {
  this.hash = hash || encoding.NULL_HASH;
  this.index = index != null ? index : -1;
  this.wids = wids || new Set();
}

OutpointMapRecord.prototype.add = function add(wid) {
  if (this.wids.has(wid))
    return false;

  this.wids.add(wid);
  return true;
};

OutpointMapRecord.prototype.remove = function remove(wid) {
  return this.wids.delete(wid);
};

OutpointMapRecord.prototype.toWriter = function toWriter(bw) {
  return serializeWallets(bw, this.wids);
};

OutpointMapRecord.prototype.getSize = function getSize() {
  return sizeWallets(this.wids);
};

OutpointMapRecord.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

OutpointMapRecord.prototype.fromReader = function fromReader(br) {
  this.wids = parseWallets(br);
  return this;
};

OutpointMapRecord.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

OutpointMapRecord.fromReader = function fromReader(hash, index, br) {
  return new OutpointMapRecord(hash, index).fromReader(br);
};

OutpointMapRecord.fromRaw = function fromRaw(hash, index, data) {
  return new OutpointMapRecord(hash, index).fromRaw(data);
};

/**
 * Path Record
 * @constructor
 */

function PathMapRecord(hash, wids) {
  this.hash = hash || encoding.NULL_HASH;
  this.wids = wids || new Set();
}

PathMapRecord.prototype.add = function add(wid) {
  if (this.wids.has(wid))
    return false;

  this.wids.add(wid);
  return true;
};

PathMapRecord.prototype.remove = function remove(wid) {
  return this.wids.delete(wid);
};

PathMapRecord.prototype.toWriter = function toWriter(bw) {
  return serializeWallets(bw, this.wids);
};

PathMapRecord.prototype.getSize = function getSize() {
  return sizeWallets(this.wids);
};

PathMapRecord.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

PathMapRecord.prototype.fromReader = function fromReader(br) {
  this.wids = parseWallets(br);
  return this;
};

PathMapRecord.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

PathMapRecord.fromReader = function fromReader(hash, br) {
  return new PathMapRecord(hash).fromReader(br);
};

PathMapRecord.fromRaw = function fromRaw(hash, data) {
  return new PathMapRecord(hash).fromRaw(data);
};

/**
 * TXRecord
 * @constructor
 * @param {TX} tx
 * @param {BlockMeta?} block
 */

function TXRecord(tx, block) {
  if (!(this instanceof TXRecord))
    return new TXRecord(tx, block);

  this.tx = null;
  this.hash = null;
  this.mtime = util.now();
  this.height = -1;
  this.block = null;
  this.index = -1;
  this.time = 0;

  if (tx)
    this.fromTX(tx, block);
}

/**
 * Inject properties from tx and block.
 * @private
 * @param {TX} tx
 * @param {Block?} block
 * @returns {TXRecord}
 */

TXRecord.prototype.fromTX = function fromTX(tx, block) {
  this.tx = tx;
  this.hash = tx.hash('hex');

  if (block)
    this.setBlock(block);

  return this;
};

/**
 * Instantiate tx record from tx and block.
 * @param {TX} tx
 * @param {Block?} block
 * @returns {TXRecord}
 */

TXRecord.fromTX = function fromTX(tx, block) {
  return new TXRecord().fromTX(tx, block);
};

/**
 * Set block data (confirm).
 * @param {BlockMeta} block
 */

TXRecord.prototype.setBlock = function setBlock(block) {
  this.height = block.height;
  this.block = block.hash;
  this.time = block.time;
};

/**
 * Unset block (unconfirm).
 */

TXRecord.prototype.unsetBlock = function unsetBlock() {
  this.height = -1;
  this.block = null;
  this.time = 0;
};

/**
 * Convert tx record to a block meta.
 * @returns {BlockMeta}
 */

TXRecord.prototype.getBlock = function getBlock() {
  if (this.height === -1)
    return null;

  return new BlockMeta(this.block, this.height, this.time);
};

/**
 * Calculate current number of transaction confirmations.
 * @param {Number} height - Current chain height.
 * @returns {Number} confirmations
 */

TXRecord.prototype.getDepth = function getDepth(height) {
  assert(typeof height === 'number', 'Must pass in height.');

  if (this.height === -1)
    return 0;

  if (height < this.height)
    return 0;

  return height - this.height + 1;
};

/**
 * Get serialization size.
 * @returns {Number}
 */

TXRecord.prototype.getSize = function getSize() {
  let size = 0;

  size += this.tx.getSize();
  size += 4;

  if (this.block) {
    size += 1;
    size += 32;
    size += 4 * 3;
  } else {
    size += 1;
  }

  return size;
};

/**
 * Serialize a transaction to "extended format".
 * @returns {Buffer}
 */

TXRecord.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  const bw = new StaticWriter(size);
  let index = this.index;

  this.tx.toWriter(bw);

  bw.writeU32(this.mtime);

  if (this.block) {
    if (index === -1)
      index = 0x7fffffff;

    bw.writeU8(1);
    bw.writeHash(this.block);
    bw.writeU32(this.height);
    bw.writeU32(this.time);
    bw.writeU32(index);
  } else {
    bw.writeU8(0);
  }

  return bw.render();
};

/**
 * Inject properties from "extended" format.
 * @private
 * @param {Buffer} data
 */

TXRecord.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data);

  this.tx = new TX();
  this.tx.fromReader(br);

  this.hash = this.tx.hash('hex');
  this.mtime = br.readU32();

  if (br.readU8() === 1) {
    this.block = br.readHash('hex');
    this.height = br.readU32();
    this.time = br.readU32();
    this.index = br.readU32();
    if (this.index === 0x7fffffff)
      this.index = -1;
  }

  return this;
};

/**
 * Instantiate a transaction from a buffer
 * in "extended" serialization format.
 * @param {Buffer} data
 * @returns {TX}
 */

TXRecord.fromRaw = function fromRaw(data) {
  return new TXRecord().fromRaw(data);
};

/*
 * Helpers
 */

function parseWallets(br) {
  const count = br.readU32();
  const wids = new Set();

  for (let i = 0; i < count; i++)
    wids.add(br.readU32());

  return wids;
}

function sizeWallets(wids) {
  return 4 + wids.size * 4;
}

function serializeWallets(bw, wids) {
  bw.writeU32(wids.size);

  for (const wid of wids)
    bw.writeU32(wid);

  return bw;
}

/*
 * Expose
 */

exports.ChainState = ChainState;
exports.BlockMeta = BlockMeta;
exports.BlockMapRecord = BlockMapRecord;
exports.TXMapRecord = TXMapRecord;
exports.OutpointMapRecord = OutpointMapRecord;
exports.PathMapRecord = PathMapRecord;
exports.TXRecord = TXRecord;

module.exports = exports;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * walletdb.js - storage for wallets.
 */



const assert = __webpack_require__(0);
const path = __webpack_require__(25);
const fs = __webpack_require__(64);
const AsyncObject = __webpack_require__(31);
const util = __webpack_require__(1);
const Lock = __webpack_require__(23);
const MappedLock = __webpack_require__(190);
const LRU = __webpack_require__(56);
const encoding = __webpack_require__(3);
const ccmp = __webpack_require__(52);
const aes = __webpack_require__(106);
const Network = __webpack_require__(6);
const Path = __webpack_require__(76);
const common = __webpack_require__(61);
const Wallet = __webpack_require__(255);
const Account = __webpack_require__(191);
const LDB = __webpack_require__(88);
const Bloom = __webpack_require__(43);
const Logger = __webpack_require__(34);
const Outpoint = __webpack_require__(21);
const layouts = __webpack_require__(192);
const records = __webpack_require__(129);
const HTTPServer = __webpack_require__(252);
const RPC = __webpack_require__(257);
const layout = layouts.walletdb;
const ChainState = records.ChainState;
const BlockMapRecord = records.BlockMapRecord;
const BlockMeta = records.BlockMeta;
const PathMapRecord = records.PathMapRecord;
const OutpointMapRecord = records.OutpointMapRecord;
const TXRecord = records.TXRecord;
const U32 = encoding.U32;

/**
 * WalletDB
 * @alias module:wallet.WalletDB
 * @constructor
 * @param {Object} options
 * @param {String?} options.name - Database name.
 * @param {String?} options.location - Database file location.
 * @param {String?} options.db - Database backend (`"leveldb"` by default).
 * @param {Boolean?} options.verify - Verify transactions as they
 * come in (note that this will not happen on the worker pool).
 * @property {Boolean} loaded
 */

function WalletDB(options) {
  if (!(this instanceof WalletDB))
    return new WalletDB(options);

  AsyncObject.call(this);

  this.options = new WalletOptions(options);

  this.network = this.options.network;
  this.logger = this.options.logger.context('wallet');
  this.workers = this.options.workers;

  this.client = this.options.client;
  this.feeRate = this.options.feeRate;

  this.db = LDB(this.options);
  this.rpc = new RPC(this);
  this.primary = null;
  this.http = null;

  if (!HTTPServer.unsupported) {
    this.http = new HTTPServer({
      walletdb: this,
      network: this.network,
      logger: this.logger,
      prefix: this.options.prefix,
      apiKey: this.options.apiKey,
      walletAuth: this.options.walletAuth,
      noAuth: this.options.noAuth,
      host: this.options.host,
      port: this.options.port,
      ssl: this.options.ssl
    });
  }

  this.state = new ChainState();
  this.wallets = new Map();
  this.depth = 0;
  this.rescanning = false;
  this.bound = false;

  this.readLock = new MappedLock();
  this.writeLock = new Lock();
  this.txLock = new Lock();
  this.locker = new Lock();

  this.widCache = new LRU(10000);
  this.pathMapCache = new LRU(100000);

  this.filter = new Bloom();

  this._init();
}

Object.setPrototypeOf(WalletDB.prototype, AsyncObject.prototype);

/**
 * Database layout.
 * @type {Object}
 */

WalletDB.layout = layout;

/**
 * Initialize walletdb.
 * @private
 */

WalletDB.prototype._init = function _init() {
  let items = 1000000;
  let flag = -1;

  // Highest number of items with an
  // FPR of 0.001. We have to do this
  // by hand because Bloom.fromRate's
  // policy limit enforcing is fairly
  // naive.
  if (this.options.spv) {
    items = 20000;
    flag = Bloom.flags.ALL;
  }

  this.filter = Bloom.fromRate(items, 0.001, flag);
};

/**
 * Open the walletdb, wait for the database to load.
 * @alias WalletDB#open
 * @returns {Promise}
 */

WalletDB.prototype._open = async function _open() {
  if (this.options.listen)
    await this.logger.open();

  await this.db.open();
  await this.db.checkVersion('V', 6);

  this.depth = await this.getDepth();

  if (this.options.wipeNoReally)
    await this.wipe();

  await this.load();

  this.logger.info(
    'WalletDB loaded (depth=%d, height=%d, start=%d).',
    this.depth,
    this.state.height,
    this.state.startHeight);
/*
  const wallet = await this.ensure({
    id: 'primary'
  });

  this.logger.info(
    'Loaded primary wallet (id=%s, wid=%d, address=%s)',
    wallet.id, wallet.wid, wallet.getAddress());

  this.primary = wallet;
  this.rpc.wallet = wallet;
*/
  if (this.http && this.options.listen)
    await this.http.open();
};

/**
 * Set a wallet and set as primary.
 * @method
 * @returns {Promise}
 */

WalletDB.prototype.set = async function set(options) {
  const unlock = await this.locker.lock();
  try {
    return await this._set(options);
  } finally {
    unlock();
  }
};

/**
 * Set a wallet and set as primary.
 * @alias WalletDB#set
 * @returns {Promise}
 */

WalletDB.prototype._set = async function _set(options) {
  assert(typeof options.id === 'string');
  assert(typeof options.hsm === 'object');
  const wallet = await this.ensure({
    id: options.id,
    hsm: options.hsm
  });

  this.logger.info(
    'Loaded primary wallet (id=%s, wid=%d, address=%s)',
    wallet.id, wallet.wid, wallet.getAddress());

  this.primary = wallet;
  this.rpc.wallet = wallet;
};

/**
 * Close the walletdb, wait for the database to close.
 * @alias WalletDB#close
 * @returns {Promise}
 */

WalletDB.prototype._close = async function _close() {
  await this.disconnect();

  if (this.http && this.options.listen)
    await this.http.close();

  for (const wallet of this.wallets.values())
    await wallet.destroy();

  await this.db.close();

  if (this.options.listen)
    await this.logger.close();
};

/**
 * Load the walletdb.
 * @returns {Promise}
 */

WalletDB.prototype.load = async function load() {
  const unlock = await this.txLock.lock();
  try {
    await this.connect();
    await this.init();
    await this.watch();
    if (!this._skipSync)
      await this.sync();
    else this._skipSync = false;
    await this.resend();
  } finally {
    unlock();
  }
};

/**
 * To skip sycn once.
 */

WalletDB.prototype.skipSync = function skipSync() {
  this._skipSync = true;
};

/**
 * Bind to node events.
 * @private
 */

WalletDB.prototype.bind = function bind() {
  if (!this.client)
    return;

  if (this.bound)
    return;

  this.bound = true;

  this.client.on('error', (err) => {
    this.emit('error', err);
  });

  this.client.on('block connect', async (entry, txs) => {
    try {
      await this.addBlock(entry, txs);
    } catch (e) {
      this.emit('error', e);
    }
  });

  this.client.on('block disconnect', async (entry) => {
    try {
      await this.removeBlock(entry);
    } catch (e) {
      this.emit('error', e);
    }
  });

  this.client.hook('block rescan', async (entry, txs) => {
    try {
      await this.rescanBlock(entry, txs);
    } catch (e) {
      this.emit('error', e);
    }
  });

  this.client.on('tx', async (tx) => {
    try {
      await this.addTX(tx);
    } catch (e) {
      this.emit('error', e);
    }
  });

  this.client.on('chain reset', async (tip) => {
    try {
      await this.resetChain(tip);
    } catch (e) {
      this.emit('error', e);
    }
  });
};

/**
 * Unind from node events.
 * @private
 */

WalletDB.prototype.unbind = function unbind() {
  if (!this.client)
    return;

  this.client.removeAllListeners();
  this.client.unhook('block rescan');
};

/**
 * Connect to the node server (client required).
 * @returns {Promise}
 */

WalletDB.prototype.connect = async function connect() {
  if (!this.client)
    return;

  this.bind();

  await this.client.open();
  await this.setFilter();
};

/**
 * Disconnect from node server (client required).
 * @returns {Promise}
 */

WalletDB.prototype.disconnect = async function disconnect() {
  if (!this.client)
    return;

  await this.client.close();
};

/**
 * Initialize and write initial sync state.
 * @returns {Promise}
 */

WalletDB.prototype.init = async function init() {
  const state = await this.getState();
  const startHeight = this.options.startHeight;

  if (state) {
    this.state = state;
    return;
  }

  let tip;
  if (this.client) {
    if (startHeight != null) {
      tip = await this.client.getEntry(startHeight);
      if (!tip)
        throw new Error('WDB: Could not find start block.');
    } else {
      tip = await this.client.getTip();
    }
    tip = BlockMeta.fromEntry(tip);
  } else {
    tip = BlockMeta.fromEntry(this.network.genesis);
  }

  this.logger.info(
    'Initializing WalletDB chain state at %s (%d).',
    util.revHex(tip.hash), tip.height);

  await this.resetState(tip, false);
};

/**
 * Watch addresses and outpoints.
 * @private
 * @returns {Promise}
 */

WalletDB.prototype.watch = async function watch() {
  let iter = this.db.iterator({
    gte: layout.p(encoding.NULL_HASH),
    lte: layout.p(encoding.HIGH_HASH)
  });

  let hashes = 0;
  let outpoints = 0;

  for (;;) {
    const item = await iter.next();

    if (!item)
      break;

    try {
      const data = layout.pp(item.key);
      this.filter.add(data, 'hex');
    } catch (e) {
      await iter.end();
      throw e;
    }

    hashes++;
  }

  iter = this.db.iterator({
    gte: layout.o(encoding.NULL_HASH, 0),
    lte: layout.o(encoding.HIGH_HASH, 0xffffffff)
  });

  for (;;) {
    const item = await iter.next();

    if (!item)
      break;

    try {
      const [hash, index] = layout.oo(item.key);
      const outpoint = new Outpoint(hash, index);
      const data = outpoint.toRaw();
      this.filter.add(data);
    } catch (e) {
      await iter.end();
      throw e;
    }

    outpoints++;
  }

  this.logger.info('Added %d hashes to WalletDB filter.', hashes);
  this.logger.info('Added %d outpoints to WalletDB filter.', outpoints);

  await this.setFilter();
};

/**
 * Connect and sync with the chain server.
 * @private
 * @returns {Promise}
 */

WalletDB.prototype.sync = async function sync() {
  if (!this.client)
    return;

  let height = this.state.height;
  let entry;

  while (height >= 0) {
    const tip = await this.getBlock(height);

    if (!tip)
      break;

    entry = await this.client.getEntry(tip.hash);

    if (entry)
      break;

    height--;
  }

  if (!entry) {
    height = this.state.startHeight;
    entry = await this.client.getEntry(this.state.startHash);

    if (!entry)
      height = 0;
  }

  await this.scan(height);
};

/**
 * Rescan blockchain from a given height.
 * @private
 * @param {Number?} height
 * @returns {Promise}
 */

WalletDB.prototype.scan = async function scan(height) {
  if (!this.client)
    return;

  if (height == null)
    height = this.state.startHeight;

  assert(util.isU32(height), 'WDB: Must pass in a height.');

  await this.rollback(height);

  this.logger.info(
    'WalletDB is scanning %d blocks.',
    this.state.height - height + 1);

  const tip = await this.getTip();

  try {
    this.rescanning = true;
    await this.client.rescan(tip.hash);
  } finally {
    this.rescanning = false;
  }
};

/**
 * Force a rescan.
 * @param {Number} height
 * @returns {Promise}
 */

WalletDB.prototype.rescan = async function rescan(height) {
  const unlock = await this.txLock.lock();
  try {
    return await this._rescan(height);
  } finally {
    unlock();
  }
};

/**
 * Force a rescan (without a lock).
 * @private
 * @param {Number} height
 * @returns {Promise}
 */

WalletDB.prototype._rescan = async function _rescan(height) {
  return await this.scan(height);
};

/**
 * Broadcast a transaction via chain server.
 * @param {TX} tx
 * @returns {Promise}
 */

WalletDB.prototype.send = async function send(tx) {
  if (!this.client) {
    this.emit('send', tx);
    return;
  }

  await this.client.send(tx);
};

/**
 * Estimate smart fee from chain server.
 * @param {Number} blocks
 * @returns {Promise}
 */

WalletDB.prototype.estimateFee = async function estimateFee(blocks) {
  if (this.feeRate > 0)
    return this.feeRate;

  if (!this.client)
    return this.network.feeRate;

  const rate = await this.client.estimateFee(blocks);

  if (rate < this.network.feeRate)
    return this.network.feeRate;

  if (rate > this.network.maxFeeRate)
    return this.network.maxFeeRate;

  return rate;
};

/**
 * Send filter to the remote node.
 * @private
 * @returns {Promise}
 */

WalletDB.prototype.setFilter = function setFilter() {
  if (!this.client) {
    this.emit('set filter', this.filter);
    return Promise.resolve();
  }

  return this.client.setFilter(this.filter);
};

/**
 * Add data to remote filter.
 * @private
 * @param {Buffer} data
 * @returns {Promise}
 */

WalletDB.prototype.addFilter = function addFilter(data) {
  if (!this.client) {
    this.emit('add filter', data);
    return Promise.resolve();
  }

  return this.client.addFilter(data);
};

/**
 * Reset remote filter.
 * @private
 * @returns {Promise}
 */

WalletDB.prototype.resetFilter = function resetFilter() {
  if (!this.client) {
    this.emit('reset filter');
    return Promise.resolve();
  }

  return this.client.resetFilter();
};

/**
 * Backup the wallet db.
 * @param {String} path
 * @returns {Promise}
 */

WalletDB.prototype.backup = function backup(path) {
  return this.db.backup(path);
};

/**
 * Set suffix.
 * @param {String} wid-suffix
 * @returns {String|Path} location
 */

WalletDB.prototype.suffix = function suffix(suffix) {
  assert(typeof suffix === 'string');
  const options = Object.assign({}, this.options);
  options.location = path.join(this.options.prefix, 'walletdb', suffix);
  this._suffix = suffix;
  this.db = LDB(options);
  return options.location;
};

/**
 * Get suffix.
 * @returns {String} suffix
 */

WalletDB.prototype.getSuffix = function getSuffix() {
  return this._suffix;
};

/**
 * List all walletdb path.
 * @param {String} wid
 * @returns {String|Path} location[]
 */

WalletDB.prototype.list = function list() {
  const location = path.join(this.options.prefix, 'walletdb');
  try {
    return fs.readdirSync(location).filter(function (file) {
      return fs.statSync(path.join(location, file)).isDirectory();
    });
  } catch (e) {
    return [];
  }
};

/**
 * Wipe the txdb - NEVER USE.
 * @returns {Promise}
 */

WalletDB.prototype.wipe = async function wipe() {
  this.logger.warning('Wiping WalletDB TXDB...');
  this.logger.warning('I hope you know what you\'re doing.');

  const iter = this.db.iterator({
    gte: Buffer.from([0x00]),
    lte: Buffer.from([0xff])
  });

  const batch = this.db.batch();
  let total = 0;

  for (;;) {
    const item = await iter.next();

    if (!item)
      break;

    try {
      switch (item.key[0]) {
        case 0x62: // b
        case 0x63: // c
        case 0x65: // e
        case 0x74: // t
        case 0x6f: // o
        case 0x68: // h
        case 0x52: // R
          batch.del(item.key);
          total++;
          break;
      }
    } catch (e) {
      await iter.end();
      throw e;
    }
  }

  this.logger.warning('Wiped %d txdb records.', total);

  await batch.write();
};

/**
 * Get current wallet wid depth.
 * @private
 * @returns {Promise}
 */

WalletDB.prototype.getDepth = async function getDepth() {
  // This may seem like a strange way to do
  // this, but updating a global state when
  // creating a new wallet is actually pretty
  // damn tricky. There would be major atomicity
  // issues if updating a global state inside
  // a "scoped" state. So, we avoid all the
  // nonsense of adding a global lock to
  // walletdb.create by simply seeking to the
  // highest wallet wid.
  const iter = this.db.iterator({
    gte: layout.w(0x00000000),
    lte: layout.w(0xffffffff),
    reverse: true,
    limit: 1
  });

  const item = await iter.next();

  if (!item)
    return 1;

  await iter.end();

  const depth = layout.ww(item.key);

  return depth + 1;
};

/**
 * Start batch.
 * @private
 * @param {WalletID} wid
 */

WalletDB.prototype.start = function start(wallet) {
  assert(!wallet.current, 'WDB: Batch already started.');
  wallet.current = this.db.batch();
  wallet.accountCache.start();
  wallet.pathCache.start();
  return wallet.current;
};

/**
 * Drop batch.
 * @private
 * @param {WalletID} wid
 */

WalletDB.prototype.drop = function drop(wallet) {
  const batch = this.batch(wallet);
  wallet.current = null;
  wallet.accountCache.drop();
  wallet.pathCache.drop();
  batch.clear();
};

/**
 * Clear batch.
 * @private
 * @param {WalletID} wid
 */

WalletDB.prototype.clear = function clear(wallet) {
  const batch = this.batch(wallet);
  wallet.accountCache.clear();
  wallet.pathCache.clear();
  batch.clear();
};

/**
 * Get batch.
 * @private
 * @param {WalletID} wid
 * @returns {Leveldown.Batch}
 */

WalletDB.prototype.batch = function batch(wallet) {
  assert(wallet.current, 'WDB: Batch does not exist.');
  return wallet.current;
};

/**
 * Save batch.
 * @private
 * @param {WalletID} wid
 * @returns {Promise}
 */

WalletDB.prototype.commit = async function commit(wallet) {
  const batch = this.batch(wallet);

  try {
    await batch.write();
  } catch (e) {
    wallet.current = null;
    wallet.accountCache.drop();
    wallet.pathCache.drop();
    throw e;
  }

  wallet.current = null;
  wallet.accountCache.commit();
  wallet.pathCache.commit();
};

/**
 * Test the bloom filter against a tx or address hash.
 * @private
 * @param {Hash} hash
 * @returns {Boolean}
 */

WalletDB.prototype.testFilter = function testFilter(data) {
  return this.filter.test(data, 'hex');
};

/**
 * Add hash to local and remote filters.
 * @private
 * @param {Hash} hash
 */

WalletDB.prototype.addHash = function addHash(hash) {
  this.filter.add(hash, 'hex');
  return this.addFilter(hash);
};

/**
 * Add outpoint to local filter.
 * @private
 * @param {Hash} hash
 * @param {Number} index
 */

WalletDB.prototype.addOutpoint = function addOutpoint(hash, index) {
  const outpoint = new Outpoint(hash, index);
  this.filter.add(outpoint.toRaw());
};

/**
 * Dump database (for debugging).
 * @returns {Promise} - Returns Object.
 */

WalletDB.prototype.dump = function dump() {
  return this.db.dump();
};

/**
 * Register an object with the walletdb.
 * @param {Object} object
 */

WalletDB.prototype.register = function register(wallet) {
  assert(!this.wallets.has(wallet.wid));
  this.wallets.set(wallet.wid, wallet);
};

/**
 * Unregister a object with the walletdb.
 * @param {Object} object
 * @returns {Boolean}
 */

WalletDB.prototype.unregister = function unregister(wallet) {
  assert(this.wallets.has(wallet.wid));
  this.wallets.delete(wallet.wid);
};

/**
 * Map wallet id to wid.
 * @param {String} id
 * @returns {Promise} - Returns {WalletID}.
 */

WalletDB.prototype.getWalletID = async function getWalletID(id) {
  if (!id)
    return null;

  if (typeof id === 'number')
    return id;

  const cache = this.widCache.get(id);

  if (cache)
    return cache;

  const data = await this.db.get(layout.l(id));

  if (!data)
    return null;

  const wid = data.readUInt32LE(0, true);

  this.widCache.set(id, wid);

  return wid;
};

/**
 * Get a wallet from the database, setup watcher.
 * @param {WalletID} wid
 * @returns {Promise} - Returns {@link Wallet}.
 */

WalletDB.prototype.get = async function get(id) {
  const wid = await this.getWalletID(id);

  if (!wid)
    return null;

  const unlock = await this.readLock.lock(wid);

  try {
    return await this._get(wid);
  } finally {
    unlock();
  }
};

/**
 * Get a wallet from the database without a lock.
 * @private
 * @param {WalletID} wid
 * @returns {Promise} - Returns {@link Wallet}.
 */

WalletDB.prototype._get = async function _get(wid) {
  const cache = this.wallets.get(wid);

  if (cache)
    return cache;

  const data = await this.db.get(layout.w(wid));

  if (!data)
    return null;

  const wallet = Wallet.fromRaw(this, data);

  await wallet.open();

  this.register(wallet);

  return wallet;
};

/**
 * Save a wallet to the database.
 * @param {Wallet} wallet
 */

WalletDB.prototype.save = function save(wallet) {
  const wid = wallet.wid;
  const id = wallet.id;
  const batch = this.batch(wallet);

  this.widCache.set(id, wid);

  batch.put(layout.w(wid), wallet.toRaw());
  batch.put(layout.l(id), U32(wid));
};

/**
 * Rename a wallet.
 * @param {Wallet} wallet
 * @param {String} id
 * @returns {Promise}
 */

WalletDB.prototype.rename = async function rename(wallet, id) {
  const unlock = await this.writeLock.lock();
  try {
    return await this._rename(wallet, id);
  } finally {
    unlock();
  }
};

/**
 * Rename a wallet without a lock.
 * @private
 * @param {Wallet} wallet
 * @param {String} id
 * @returns {Promise}
 */

WalletDB.prototype._rename = async function _rename(wallet, id) {
  const old = wallet.id;

  if (!common.isName(id))
    throw new Error('WDB: Bad wallet ID.');

  if (await this.has(id))
    throw new Error('WDB: ID not available.');

  const batch = this.start(wallet);
  batch.del(layout.l(old));

  wallet.id = id;

  this.save(wallet);

  await this.commit(wallet);

  this.widCache.remove(old);

  const paths = wallet.pathCache.values();

  for (const path of paths)
    path.id = id;
};

/**
 * Rename an account.
 * @param {Account} account
 * @param {String} name
 */

WalletDB.prototype.renameAccount = function renameAccount(account, name) {
  const wallet = account.wallet;
  const batch = this.batch(wallet);

  // Remove old wid/name->account index.
  batch.del(layout.i(account.wid, account.name));

  account.name = name;

  this.saveAccount(account);
};

/**
 * Get a wallet with token auth first.
 * @param {WalletID} wid
 * @param {String|Buffer} token
 * @returns {Promise} - Returns {@link Wallet}.
 */

WalletDB.prototype.auth = async function auth(wid, token) {
  const wallet = await this.get(wid);

  if (!wallet)
    return null;

  if (typeof token === 'string') {
    if (!util.isHex256(token))
      throw new Error('WDB: Authentication error.');
    token = Buffer.from(token, 'hex');
  }

  // Compare in constant time:
  if (!ccmp(token, wallet.token))
    throw new Error('WDB: Authentication error.');

  return wallet;
};

/**
 * Create a new wallet, save to database, setup watcher.
 * @param {Object} options - See {@link Wallet}.
 * @returns {Promise} - Returns {@link Wallet}.
 */

WalletDB.prototype.create = async function create(options) {
  const unlock = await this.writeLock.lock();

  if (!options)
    options = {};

  try {
    return await this._create(options);
  } finally {
    unlock();
  }
};

/**
 * Create a new wallet, save to database without a lock.
 * @private
 * @param {Object} options - See {@link Wallet}.
 * @returns {Promise} - Returns {@link Wallet}.
 */

WalletDB.prototype._create = async function _create(options) {
  const exists = await this.has(options.id);

  if (exists)
    throw new Error('WDB: Wallet already exists.');

  const wallet = Wallet.fromOptions(this, options);
  wallet.wid = this.depth++;

  await wallet.init(options);

  this.register(wallet);

  this.logger.info('Created wallet %s in WalletDB.', wallet.id);

  return wallet;
};

/**
 * Test for the existence of a wallet.
 * @param {WalletID} id
 * @returns {Promise}
 */

WalletDB.prototype.has = async function has(id) {
  const wid = await this.getWalletID(id);
  return wid != null;
};

/**
 * Attempt to create wallet, return wallet if already exists.
 * @param {Object} options - See {@link Wallet}.
 * @returns {Promise}
 */

WalletDB.prototype.ensure = async function ensure(options) {
  const wallet = await this.get(options.id);

  if (wallet)
    return wallet;

  return await this.create(options);
};

/**
 * Get an account from the database by wid.
 * @private
 * @param {WalletID} wid
 * @param {Number} index - Account index.
 * @returns {Promise} - Returns {@link Wallet}.
 */

WalletDB.prototype.getAccount = async function getAccount(wid, index) {
  const data = await this.db.get(layout.a(wid, index));

  if (!data)
    return null;

  return Account.fromRaw(this, data);
};

/**
 * List account names and indexes from the db.
 * @param {WalletID} wid
 * @returns {Promise} - Returns Array.
 */

WalletDB.prototype.getAccounts = function getAccounts(wid) {
  return this.db.values({
    gte: layout.n(wid, 0x00000000),
    lte: layout.n(wid, 0xffffffff),
    parse: data => data.toString('ascii')
  });
};

/**
 * Lookup the corresponding account name's index.
 * @param {WalletID} wid
 * @param {String} name - Account name/index.
 * @returns {Promise} - Returns Number.
 */

WalletDB.prototype.getAccountIndex = async function getAccountIndex(wid, name) {
  const index = await this.db.get(layout.i(wid, name));

  if (!index)
    return -1;

  return index.readUInt32LE(0, true);
};

/**
 * Lookup the corresponding account index's name.
 * @param {WalletID} wid
 * @param {Number} index
 * @returns {Promise} - Returns Number.
 */

WalletDB.prototype.getAccountName = async function getAccountName(wid, index) {
  const name = await this.db.get(layout.n(wid, index));

  if (!name)
    return null;

  return name.toString('ascii');
};

/**
 * Save an account to the database.
 * @param {Account} account
 * @returns {Promise}
 */

WalletDB.prototype.saveAccount = function saveAccount(account) {
  const wid = account.wid;
  const wallet = account.wallet;
  const index = account.accountIndex;
  const name = account.name;
  const batch = this.batch(wallet);

  // Account data
  batch.put(layout.a(wid, index), account.toRaw());

  // Name->Index lookups
  batch.put(layout.i(wid, name), U32(index));

  // Index->Name lookups
  batch.put(layout.n(wid, index), Buffer.from(name, 'ascii'));

  wallet.accountCache.push(index, account);
};

/**
 * Test for the existence of an account.
 * @param {WalletID} wid
 * @param {String|Number} acct
 * @returns {Promise} - Returns Boolean.
 */

WalletDB.prototype.hasAccount = function hasAccount(wid, index) {
  return this.db.has(layout.a(wid, index));
};

/**
 * Lookup the corresponding account name's index.
 * @param {WalletID} wid
 * @param {String|Number} name - Account name/index.
 * @returns {Promise} - Returns Number.
 */

WalletDB.prototype.getPathMap = async function getPathMap(hash) {
  const cache = this.pathMapCache.get(hash);

  if (cache)
    return cache;

  const data = await this.db.get(layout.p(hash));

  if (!data)
    return null;

  const map = PathMapRecord.fromRaw(hash, data);

  this.pathMapCache.set(hash, map);

  return map;
};

/**
 * Save an address to the path map.
 * @param {Wallet} wallet
 * @param {WalletKey} ring
 * @returns {Promise}
 */

WalletDB.prototype.saveKey = function saveKey(wallet, ring) {
  return this.savePath(wallet, ring.toPath());
};

/**
 * Save a path to the path map.
 *
 * The path map exists in the form of:
 *   - `p[address-hash] -> wid map`
 *   - `P[wid][address-hash] -> path data`
 *   - `r[wid][account-index][address-hash] -> dummy`
 *
 * @param {Wallet} wallet
 * @param {Path} path
 * @returns {Promise}
 */

WalletDB.prototype.savePath = async function savePath(wallet, path) {
  const wid = wallet.wid;
  const hash = path.hash;
  const batch = this.batch(wallet);

  await this.addHash(hash);

  let map = await this.getPathMap(hash);

  if (!map)
    map = new PathMapRecord(hash);

  if (!map.add(wid))
    return;

  this.pathMapCache.set(hash, map);
  wallet.pathCache.push(hash, path);

  // Address Hash -> Wallet Map
  batch.put(layout.p(hash), map.toRaw());

  // Wallet ID + Address Hash -> Path Data
  batch.put(layout.P(wid, hash), path.toRaw());

  // Wallet ID + Account Index + Address Hash -> Dummy
  batch.put(layout.r(wid, path.account, hash), null);
};

/**
 * Retrieve path by hash.
 * @param {WalletID} wid
 * @param {Hash} hash
 * @returns {Promise}
 */

WalletDB.prototype.getPath = async function getPath(wid, hash) {
  const data = await this.db.get(layout.P(wid, hash));

  if (!data)
    return null;

  const path = Path.fromRaw(data);
  path.wid = wid;
  path.hash = hash;

  return path;
};

/**
 * Test whether a wallet contains a path.
 * @param {WalletID} wid
 * @param {Hash} hash
 * @returns {Promise}
 */

WalletDB.prototype.hasPath = function hasPath(wid, hash) {
  return this.db.has(layout.P(wid, hash));
};

/**
 * Get all address hashes.
 * @returns {Promise}
 */

WalletDB.prototype.getHashes = function getHashes() {
  return this.db.keys({
    gte: layout.p(encoding.NULL_HASH),
    lte: layout.p(encoding.HIGH_HASH),
    parse: layout.pp
  });
};

/**
 * Get all outpoints.
 * @returns {Promise}
 */

WalletDB.prototype.getOutpoints = function getOutpoints() {
  return this.db.keys({
    gte: layout.o(encoding.NULL_HASH, 0),
    lte: layout.o(encoding.HIGH_HASH, 0xffffffff),
    parse: (key) => {
      const [hash, index] = layout.oo(key);
      return new Outpoint(hash, index);
    }
  });
};

/**
 * Get all address hashes.
 * @param {WalletID} wid
 * @returns {Promise}
 */

WalletDB.prototype.getWalletHashes = function getWalletHashes(wid) {
  return this.db.keys({
    gte: layout.P(wid, encoding.NULL_HASH),
    lte: layout.P(wid, encoding.HIGH_HASH),
    parse: layout.Pp
  });
};

/**
 * Get all account address hashes.
 * @param {WalletID} wid
 * @param {Number} account
 * @returns {Promise}
 */

WalletDB.prototype.getAccountHashes = function getAccountHashes(wid, account) {
  return this.db.keys({
    gte: layout.r(wid, account, encoding.NULL_HASH),
    lte: layout.r(wid, account, encoding.HIGH_HASH),
    parse: layout.rr
  });
};

/**
 * Get all paths for a wallet.
 * @param {WalletID} wid
 * @returns {Promise}
 */

WalletDB.prototype.getWalletPaths = async function getWalletPaths(wid) {
  const items = await this.db.range({
    gte: layout.P(wid, encoding.NULL_HASH),
    lte: layout.P(wid, encoding.HIGH_HASH)
  });

  const paths = [];

  for (const item of items) {
    const hash = layout.Pp(item.key);
    const path = Path.fromRaw(item.value);

    path.hash = hash;
    path.wid = wid;

    paths.push(path);
  }

  return paths;
};

/**
 * Get all wallet ids.
 * @returns {Promise}
 */

WalletDB.prototype.getWallets = function getWallets() {
  return this.db.keys({
    gte: layout.l('\x00'),
    lte: layout.l('\xff'),
    parse: layout.ll
  });
};

/**
 * Encrypt all imported keys for a wallet.
 * @param {WalletID} wid
 * @param {Buffer} key
 * @returns {Promise}
 */

WalletDB.prototype.encryptKeys = async function encryptKeys(wallet, key) {
  const wid = wallet.wid;
  const paths = await wallet.getPaths();
  const batch = this.batch(wallet);

  for (let path of paths) {
    if (!path.data)
      continue;

    assert(!path.encrypted);

    const hash = Buffer.from(path.hash, 'hex');
    const iv = hash.slice(0, 16);

    path = path.clone();
    path.data = aes.encipher(path.data, key, iv);
    path.encrypted = true;

    wallet.pathCache.push(path.hash, path);

    batch.put(layout.P(wid, path.hash), path.toRaw());
  }
};

/**
 * Decrypt all imported keys for a wallet.
 * @param {WalletID} wid
 * @param {Buffer} key
 * @returns {Promise}
 */

WalletDB.prototype.decryptKeys = async function decryptKeys(wallet, key) {
  const wid = wallet.wid;
  const paths = await wallet.getPaths();
  const batch = this.batch(wallet);

  for (let path of paths) {
    if (!path.data)
      continue;

    assert(path.encrypted);

    const hash = Buffer.from(path.hash, 'hex');
    const iv = hash.slice(0, 16);

    path = path.clone();
    path.data = aes.decipher(path.data, key, iv);
    path.encrypted = false;

    wallet.pathCache.push(path.hash, path);

    batch.put(layout.P(wid, path.hash), path.toRaw());
  }
};

/**
 * Resend all pending transactions.
 * @returns {Promise}
 */

WalletDB.prototype.resend = async function resend() {
  const keys = await this.db.keys({
    gte: layout.w(0x00000000),
    lte: layout.w(0xffffffff)
  });

  for (const key of keys) {
    const wid = layout.ww(key);
    await this.resendPending(wid);
  }
};

/**
 * Resend all pending transactions for a specific wallet.
 * @private
 * @param {WalletID} wid
 * @returns {Promise}
 */

WalletDB.prototype.resendPending = async function resendPending(wid) {
  const layout = layouts.txdb;

  const keys = await this.db.keys({
    gte: layout.prefix(wid, layout.p(encoding.NULL_HASH)),
    lte: layout.prefix(wid, layout.p(encoding.HIGH_HASH))
  });

  if (keys.length === 0)
    return;

  this.logger.info(
    'Rebroadcasting %d transactions for %d.',
    keys.length,
    wid);

  const txs = [];

  for (const key of keys) {
    const hash = layout.pp(key);
    const tkey = layout.prefix(wid, layout.t(hash));
    const data = await this.db.get(tkey);

    if (!data)
      continue;

    const wtx = TXRecord.fromRaw(data);

    if (wtx.tx.isCoinbase())
      continue;

    txs.push(wtx.tx);
  }

  const sorted = common.sortDeps(txs);

  for (const tx of sorted)
    await this.send(tx);
};

/**
 * Get all wallet ids by output addresses and outpoints.
 * @param {Hash[]} hashes
 * @returns {Promise}
 */

WalletDB.prototype.getWalletsByTX = async function getWalletsByTX(tx) {
  const hashes = tx.getOutputHashes('hex');
  const result = new Set();

  if (!tx.isCoinbase()) {
    for (const input of tx.inputs) {
      const prevout = input.prevout;

      if (!this.testFilter(prevout.toRaw()))
        continue;

      const map = await this.getOutpointMap(prevout.hash, prevout.index);

      if (!map)
        continue;

      for (const wid of map.wids)
        result.add(wid);
    }
  }

  for (const hash of hashes) {
    if (!this.testFilter(hash))
      continue;

    const map = await this.getPathMap(hash);

    if (!map)
      continue;

    for (const wid of map.wids)
      result.add(wid);
  }

  if (result.size === 0)
    return null;

  return result;
};

/**
 * Get the best block hash.
 * @returns {Promise}
 */

WalletDB.prototype.getState = async function getState() {
  const data = await this.db.get(layout.R);

  if (!data)
    return null;

  return ChainState.fromRaw(data);
};

/**
 * Reset the chain state to a tip/start-block.
 * @param {BlockMeta} tip
 * @returns {Promise}
 */

WalletDB.prototype.resetState = async function resetState(tip, marked) {
  const batch = this.db.batch();
  const state = this.state.clone();

  const iter = this.db.iterator({
    gte: layout.h(0),
    lte: layout.h(0xffffffff),
    values: false
  });

  for (;;) {
    const item = await iter.next();

    if (!item)
      break;

    try {
      batch.del(item.key);
    } catch (e) {
      await iter.end();
      throw e;
    }
  }

  state.startHeight = tip.height;
  state.startHash = tip.hash;
  state.height = tip.height;
  state.marked = marked;

  batch.put(layout.h(tip.height), tip.toHash());
  batch.put(layout.R, state.toRaw());

  await batch.write();

  this.state = state;
};

/**
 * Sync the current chain state to tip.
 * @param {BlockMeta} tip
 * @returns {Promise}
 */

WalletDB.prototype.syncState = async function syncState(tip) {
  const batch = this.db.batch();
  const state = this.state.clone();

  if (tip.height < state.height) {
    // Hashes ahead of our new tip
    // that we need to delete.
    let height = state.height;
    let blocks = height - tip.height;

    if (blocks > this.options.keepBlocks)
      blocks = this.options.keepBlocks;

    for (let i = 0; i < blocks; i++) {
      batch.del(layout.h(height));
      height--;
    }
  } else if (tip.height > state.height) {
    // Prune old hashes.
    const height = tip.height - this.options.keepBlocks;

    assert(tip.height === state.height + 1, 'Bad chain sync.');

    if (height >= 0)
      batch.del(layout.h(height));
  }

  state.height = tip.height;

  // Save tip and state.
  batch.put(layout.h(tip.height), tip.toHash());
  batch.put(layout.R, state.toRaw());

  await batch.write();

  this.state = state;
};

/**
 * Mark the start block once a confirmed tx is seen.
 * @param {BlockMeta} tip
 * @returns {Promise}
 */

WalletDB.prototype.maybeMark = async function maybeMark(tip) {
  if (this.state.marked)
    return;

  this.logger.info('Marking WalletDB start block at %s (%d).',
    util.revHex(tip.hash), tip.height);

  await this.resetState(tip, true);
};

/**
 * Get a block->wallet map.
 * @param {Number} height
 * @returns {Promise}
 */

WalletDB.prototype.getBlockMap = async function getBlockMap(height) {
  const data = await this.db.get(layout.b(height));

  if (!data)
    return null;

  return BlockMapRecord.fromRaw(height, data);
};

/**
 * Add block to the global block map.
 * @param {Wallet} wallet
 * @param {Number} height
 * @param {BlockMapRecord} block
 */

WalletDB.prototype.writeBlockMap = function writeBlockMap(wallet, height, block) {
  const batch = this.batch(wallet);
  batch.put(layout.b(height), block.toRaw());
};

/**
 * Remove a block from the global block map.
 * @param {Wallet} wallet
 * @param {Number} height
 */

WalletDB.prototype.unwriteBlockMap = function unwriteBlockMap(wallet, height) {
  const batch = this.batch(wallet);
  batch.del(layout.b(height));
};

/**
 * Get a Unspent->Wallet map.
 * @param {Hash} hash
 * @param {Number} index
 * @returns {Promise}
 */

WalletDB.prototype.getOutpointMap = async function getOutpointMap(hash, index) {
  const data = await this.db.get(layout.o(hash, index));

  if (!data)
    return null;

  return OutpointMapRecord.fromRaw(hash, index, data);
};

/**
 * Add an outpoint to global unspent map.
 * @param {Wallet} wallet
 * @param {Hash} hash
 * @param {Number} index
 * @param {OutpointMapRecord} map
 */

WalletDB.prototype.writeOutpointMap = function writeOutpointMap(wallet, hash, index, map) {
  const batch = this.batch(wallet);

  this.addOutpoint(hash, index);

  batch.put(layout.o(hash, index), map.toRaw());
};

/**
 * Remove an outpoint from global unspent map.
 * @param {Wallet} wallet
 * @param {Hash} hash
 * @param {Number} index
 */

WalletDB.prototype.unwriteOutpointMap = function unwriteOutpointMap(wallet, hash, index) {
  const batch = this.batch(wallet);
  batch.del(layout.o(hash, index));
};

/**
 * Get a wallet block meta.
 * @param {Hash} hash
 * @returns {Promise}
 */

WalletDB.prototype.getBlock = async function getBlock(height) {
  const data = await this.db.get(layout.h(height));

  if (!data)
    return null;

  const block = new BlockMeta();
  block.hash = data.toString('hex');
  block.height = height;

  return block;
};

/**
 * Get wallet tip.
 * @param {Hash} hash
 * @returns {Promise}
 */

WalletDB.prototype.getTip = async function getTip() {
  const tip = await this.getBlock(this.state.height);

  if (!tip)
    throw new Error('WDB: Tip not found!');

  return tip;
};

/**
 * Sync with chain height.
 * @param {Number} height
 * @returns {Promise}
 */

WalletDB.prototype.rollback = async function rollback(height) {
  if (height > this.state.height)
    throw new Error('WDB: Cannot rollback to the future.');

  if (height === this.state.height) {
    this.logger.debug('Rolled back to same height (%d).', height);
    return true;
  }

  this.logger.info(
    'Rolling back %d WalletDB blocks to height %d.',
    this.state.height - height, height);

  let tip = await this.getBlock(height);
  let marked = false;

  if (tip) {
    await this.revert(tip.height);
    await this.syncState(tip);
    return true;
  }

  tip = new BlockMeta();

  if (height >= this.state.startHeight) {
    tip.height = this.state.startHeight;
    tip.hash = this.state.startHash;
    marked = this.state.marked;

    this.logger.warning(
      'Rolling back WalletDB to start block (%d).',
      tip.height);
  } else {
    tip.height = 0;
    tip.hash = this.network.genesis.hash;
    marked = false;

    this.logger.warning('Rolling back WalletDB to genesis block.');
  }

  await this.revert(tip.height);
  await this.resetState(tip, marked);

  return false;
};

/**
 * Revert TXDB to an older state.
 * @param {Number} target
 * @returns {Promise}
 */

WalletDB.prototype.revert = async function revert(target) {
  const iter = this.db.iterator({
    gte: layout.b(target + 1),
    lte: layout.b(0xffffffff),
    reverse: true,
    values: true
  });

  let total = 0;

  for (;;) {
    const item = await iter.next();

    if (!item)
      break;

    try {
      const height = layout.bb(item.key);
      const block = BlockMapRecord.fromRaw(height, item.value);
      const txs = block.toArray();

      total += txs.length;

      for (let i = txs.length - 1; i >= 0; i--) {
        const tx = txs[i];
        await this._unconfirm(tx);
      }
    } catch (e) {
      await iter.end();
      throw e;
    }
  }

  this.logger.info('Rolled back %d WalletDB transactions.', total);
};

/**
 * Add a block's transactions and write the new best hash.
 * @param {ChainEntry} entry
 * @returns {Promise}
 */

WalletDB.prototype.addBlock = async function addBlock(entry, txs) {
  const unlock = await this.txLock.lock();
  try {
    return await this._addBlock(entry, txs);
  } finally {
    unlock();
  }
};

/**
 * Add a block's transactions without a lock.
 * @private
 * @param {ChainEntry} entry
 * @param {TX[]} txs
 * @returns {Promise}
 */

WalletDB.prototype._addBlock = async function _addBlock(entry, txs) {
  const tip = BlockMeta.fromEntry(entry);
  let total = 0;

  if (tip.height < this.state.height) {
    this.logger.warning(
      'WalletDB is connecting low blocks (%d).',
      tip.height);
    return total;
  }

  if (tip.height === this.state.height) {
    // We let blocks of the same height
    // through specifically for rescans:
    // we always want to rescan the last
    // block since the state may have
    // updated before the block was fully
    // processed (in the case of a crash).
    this.logger.warning('Already saw WalletDB block (%d).', tip.height);
  } else if (tip.height !== this.state.height + 1) {
    throw new Error('WDB: Bad connection (height mismatch).');
  }

  // Sync the state to the new tip.
  await this.syncState(tip);

  if (this.options.checkpoints) {
    if (tip.height <= this.network.lastCheckpoint)
      return total;
  }

  for (const tx of txs) {
    if (await this._insert(tx, tip))
      total++;
  }

  if (total > 0) {
    this.logger.info('Connected WalletDB block %s (tx=%d).',
      util.revHex(tip.hash), total);
  }

  return total;
};

/**
 * Unconfirm a block's transactions
 * and write the new best hash (SPV version).
 * @param {ChainEntry} entry
 * @returns {Promise}
 */

WalletDB.prototype.removeBlock = async function removeBlock(entry) {
  const unlock = await this.txLock.lock();
  try {
    return await this._removeBlock(entry);
  } finally {
    unlock();
  }
};

/**
 * Unconfirm a block's transactions.
 * @private
 * @param {ChainEntry} entry
 * @returns {Promise}
 */

WalletDB.prototype._removeBlock = async function _removeBlock(entry) {
  const tip = BlockMeta.fromEntry(entry);

  if (tip.height > this.state.height) {
    this.logger.warning(
      'WalletDB is disconnecting high blocks (%d).',
      tip.height);
    return 0;
  }

  if (tip.height !== this.state.height)
    throw new Error('WDB: Bad disconnection (height mismatch).');

  const prev = await this.getBlock(tip.height - 1);

  if (!prev)
    throw new Error('WDB: Bad disconnection (no previous block).');

  // Get the map of txids->wids.
  const block = await this.getBlockMap(tip.height);

  if (!block) {
    await this.syncState(prev);
    return 0;
  }

  const txs = block.toArray();

  for (let i = txs.length - 1; i >= 0; i--) {
    const tx = txs[i];
    await this._unconfirm(tx);
  }

  // Sync the state to the previous tip.
  await this.syncState(prev);

  this.logger.warning('Disconnected wallet block %s (tx=%d).',
    util.revHex(tip.hash), block.txs.size);

  return block.txs.size;
};

/**
 * Rescan a block.
 * @private
 * @param {ChainEntry} entry
 * @param {TX[]} txs
 * @returns {Promise}
 */

WalletDB.prototype.rescanBlock = async function rescanBlock(entry, txs) {
  if (!this.rescanning) {
    this.logger.warning('Unsolicited rescan block: %s.', entry.height);
    return;
  }

  try {
    await this._addBlock(entry, txs);
  } catch (e) {
    this.emit('error', e);
    throw e;
  }
};

/**
 * Add a transaction to the database, map addresses
 * to wallet IDs, potentially store orphans, resolve
 * orphans, or confirm a transaction.
 * @param {TX} tx
 * @returns {Promise}
 */

WalletDB.prototype.addTX = async function addTX(tx) {
  const unlock = await this.txLock.lock();

  try {
    return await this._insert(tx);
  } finally {
    unlock();
  }
};

/**
 * Add a transaction to the database without a lock.
 * @private
 * @param {TX} tx
 * @param {BlockMeta} block
 * @returns {Promise}
 */

WalletDB.prototype._insert = async function _insert(tx, block) {
  const wids = await this.getWalletsByTX(tx);
  let result = false;

  assert(!tx.mutable, 'WDB: Cannot add mutable TX.');

  if (!wids)
    return null;

  this.logger.info(
    'Incoming transaction for %d wallets in WalletDB (%s).',
    wids.size, tx.txid());

  // If this is our first transaction
  // in a block, set the start block here.
  if (block)
    await this.maybeMark(block);

  // Insert the transaction
  // into every matching wallet.
  for (const wid of wids) {
    const wallet = await this.get(wid);

    assert(wallet);

    if (await wallet.add(tx, block)) {
      this.logger.info(
        'Added transaction to wallet in WalletDB: %s (%d).',
        wallet.id, wid);
      result = true;
    }
  }

  if (!result)
    return null;

  this.emit('hook balance');

  return wids;
};

/**
 * Unconfirm a transaction from all
 * relevant wallets without a lock.
 * @private
 * @param {TXMapRecord} tx
 * @returns {Promise}
 */

WalletDB.prototype._unconfirm = async function _unconfirm(tx) {
  for (const wid of tx.wids) {
    const wallet = await this.get(wid);
    assert(wallet);
    await wallet.unconfirm(tx.hash);
  }
};

/**
 * Handle a chain reset.
 * @param {ChainEntry} entry
 * @returns {Promise}
 */

WalletDB.prototype.resetChain = async function resetChain(entry) {
  const unlock = await this.txLock.lock();
  try {
    return await this._resetChain(entry);
  } finally {
    unlock();
  }
};

/**
 * Handle a chain reset without a lock.
 * @private
 * @param {ChainEntry} entry
 * @returns {Promise}
 */

WalletDB.prototype._resetChain = async function _resetChain(entry) {
  if (entry.height > this.state.height)
    throw new Error('WDB: Bad reset height.');

  // Try to rollback.
  if (await this.rollback(entry.height))
    return;

  // If we rolled back to the
  // start block, we need a rescan.
  await this.scan();
};

/**
 * WalletOptions
 * @alias module:wallet.WalletOptions
 * @constructor
 * @param {Object} options
 */

function WalletOptions(options) {
  if (!(this instanceof WalletOptions))
    return new WalletOptions(options);

  this.network = Network.primary;
  this.logger = Logger.global;
  this.workers = null;
  this.client = null;
  this.feeRate = 0;

  this.prefix = null;
  this.location = null;
  this.db = 'memory';
  this.maxFiles = 64;
  this.cacheSize = 16 << 20;
  this.compression = true;
  this.bufferKeys = layout.binary;

  this.spv = false;
  // this.witness = false; cfc
  this.witness = true; // ctl
  this.checkpoints = false;
  this.startHeight = 0;
  this.keepBlocks = this.network.block.keepBlocks;
  this.wipeNoReally = false;
  this.apiKey = null;
  this.walletAuth = false;
  this.noAuth = false;
  this.ssl = false;
  this.host = '127.0.0.1';
  this.port = this.network.rpcPort + 2;
  this.listen = false;

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from object.
 * @private
 * @param {Object} options
 * @returns {WalletOptions}
 */

WalletOptions.prototype.fromOptions = function fromOptions(options) {
  if (options.network != null) {
    this.network = Network.get(options.network);
    this.keepBlocks = this.network.block.keepBlocks;
    this.port = this.network.rpcPort + 2;
  }

  if (options.logger != null) {
    assert(typeof options.logger === 'object');
    this.logger = options.logger;
  }

  if (options.workers != null) {
    assert(typeof options.workers === 'object');
    this.workers = options.workers;
  }

  if (options.client != null) {
    assert(typeof options.client === 'object');
    this.client = options.client;
  }

  if (options.feeRate != null) {
    assert(util.isU64(options.feeRate));
    this.feeRate = options.feeRate;
  }

  if (options.prefix != null) {
    assert(typeof options.prefix === 'string');
    this.prefix = options.prefix;
    this.location = path.join(this.prefix, 'walletdb');
  }

  if (options.location != null) {
    assert(typeof options.location === 'string');
    this.location = options.location;
  }

  if (options.db != null) {
    assert(typeof options.db === 'string');
    this.db = options.db;
  }

  if (options.maxFiles != null) {
    assert(util.isU32(options.maxFiles));
    this.maxFiles = options.maxFiles;
  }

  if (options.cacheSize != null) {
    assert(util.isU64(options.cacheSize));
    this.cacheSize = options.cacheSize;
  }

  if (options.compression != null) {
    assert(typeof options.compression === 'boolean');
    this.compression = options.compression;
  }

  if (options.spv != null) {
    assert(typeof options.spv === 'boolean');
    this.spv = options.spv;
  }

  if (options.witness != null) {
    assert(typeof options.witness === 'boolean');
    this.witness = options.witness;
  }

  if (options.checkpoints != null) {
    assert(typeof options.checkpoints === 'boolean');
    this.checkpoints = options.checkpoints;
  }

  if (options.startHeight != null) {
    assert(typeof options.startHeight === 'number');
    assert(options.startHeight >= 0);
    this.startHeight = options.startHeight;
  }

  if (options.wipeNoReally != null) {
    assert(typeof options.wipeNoReally === 'boolean');
    this.wipeNoReally = options.wipeNoReally;
  }

  if (options.apiKey != null) {
    assert(typeof options.apiKey === 'string');
    this.apiKey = options.apiKey;
  }

  if (options.walletAuth != null) {
    assert(typeof options.walletAuth === 'boolean');
    this.walletAuth = options.walletAuth;
  }

  if (options.noAuth != null) {
    assert(typeof options.noAuth === 'boolean');
    this.noAuth = options.noAuth;
  }

  if (options.ssl != null) {
    assert(typeof options.ssl === 'boolean');
    this.ssl = options.ssl;
  }

  if (options.host != null) {
    assert(typeof options.host === 'string');
    this.host = options.host;
  }

  if (options.port != null) {
    assert(typeof options.port === 'number');
    this.port = options.port;
  }

  if (options.listen != null) {
    assert(typeof options.listen === 'boolean');
    this.listen = options.listen;
  }

  return this;
};

/**
 * Instantiate chain options from object.
 * @param {Object} options
 * @returns {WalletOptions}
 */

WalletOptions.fromOptions = function fromOptions(options) {
  return new WalletOptions().fromOptions(options);
};

/*
 * Expose
 */

module.exports = WalletDB;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * int64.js - int64 object for javascript.
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/n64
 */



/*
 * N64 (abstract)
 */

function N64(sign) {
  enforce(this instanceof N64, 'this', 'N64');
  enforce(sign === 0 || sign === 1, 'sign', 'bit');

  this.hi = 0;
  this.lo = 0;
  this.sign = sign;
}

/*
 * Addition
 */

N64.prototype._add = function _add(bhi, blo) {
  const ahi = this.hi;
  const alo = this.lo;

  // Credit to @indutny for this method.
  const lo = (alo + blo) | 0;

  const s = lo >> 31;
  const as = alo >> 31;
  const bs = blo >> 31;

  const c = ((as & bs) | (~s & (as ^ bs))) & 1;

  const hi = ((ahi + bhi) | 0) + c;

  this.hi = hi | 0;
  this.lo = lo;

  return this;
};

N64.prototype.iadd = function iadd(b) {
  enforce(N64.isN64(b), 'operand', 'int64');
  return this._add(b.hi, b.lo);
};

N64.prototype.iaddn = function iaddn(num) {
  enforce(isNumber(num), 'operand', 'number');
  return this._add((num >> 31) & -this.sign, num | 0);
};

N64.prototype.add = function add(b) {
  return this.clone().iadd(b);
};

N64.prototype.addn = function addn(num) {
  return this.clone().iaddn(num);
};

/*
 * Subtraction
 */

N64.prototype._sub = function _sub(bhi, blo) {
  bhi = ~bhi;
  blo = ~blo;

  if (blo === -1) {
    blo = 0;
    bhi += 1;
    bhi |= 0;
  } else {
    blo += 1;
  }

  return this._add(bhi, blo);
};

N64.prototype.isub = function isub(b) {
  enforce(N64.isN64(b), 'operand', 'int64');
  return this._sub(b.hi, b.lo);
};

N64.prototype.isubn = function isubn(num) {
  enforce(isNumber(num), 'operand', 'number');
  return this._sub((num >> 31) & -this.sign, num | 0);
};

N64.prototype.sub = function sub(b) {
  return this.clone().isub(b);
};

N64.prototype.subn = function subn(num) {
  return this.clone().isubn(num);
};

/*
 * Multiplication
 */

N64.prototype._mul = function _mul(bhi, blo) {
  const ahi = this.hi;
  const alo = this.lo;

  const a48 = ahi >>> 16;
  const a32 = ahi & 0xffff;
  const a16 = alo >>> 16;
  const a00 = alo & 0xffff;

  const b48 = bhi >>> 16;
  const b32 = bhi & 0xffff;
  const b16 = blo >>> 16;
  const b00 = blo & 0xffff;

  let c48 = 0;
  let c32 = 0;
  let c16 = 0;
  let c00 = 0;

  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 0xffff;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 0xffff;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 0xffff;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 0xffff;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 0xffff;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 0xffff;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 0xffff;

  const hi = (c48 << 16) | c32;
  const lo = (c16 << 16) | c00;

  this.hi = hi;
  this.lo = lo;

  return this;
};

N64.prototype.imul = function imul(b) {
  enforce(N64.isN64(b), 'multiplicand', 'int64');
  return this._mul(b.hi, b.lo);
};

N64.prototype.imuln = function imuln(num) {
  enforce(isNumber(num), 'multiplicand', 'number');
  return this._mul((num >> 31) & -this.sign, num | 0);
};

N64.prototype.mul = function mul(b) {
  return this.clone().imul(b);
};

N64.prototype.muln = function muln(num) {
  return this.clone().imuln(num);
};

/*
 * Division
 */

N64.prototype.idiv = function idiv(b) {
  let a = this;

  enforce(N64.isN64(b), 'divisor', 'int64');

  if (b.isZero())
    throw new Error('Cannot divide by zero.');

  if (a.isZero())
    return a;

  if (a.eq(b))
    return a.set(1);

  if (a.isSafe() && b.isSafe()) {
    const n = a.toDouble();
    const d = b.toDouble();
    const q = floor(n / d);
    return a.set(q);
  }

  let neg = false;

  if (a.sign) {
    if (a.hi < 0) {
      if (b.hi < 0) {
        a = a.ineg();
        b = b.neg();
      } else {
        a = a.ineg();
        neg = true;
      }
    } else if (b.hi < 0) {
      b = b.neg();
      neg = true;
    }
  }

  const n = a.toU64();
  const d = b.toU64();

  if (n.lt(d))
    return a.set(0);

  if (n.ushrn(1).lt(d))
    return a.set(neg ? -1 : 1);

  const q = new U64();
  const r = new U64();

  let bit = n.bitLength();

  while (bit--) {
    r.ishln(1);
    r.lo |= n.testn(bit);
    if (r.gte(d)) {
      r.isub(d);
      q.setn(bit, 1);
    }
  }

  a.hi = q.hi;
  a.lo = q.lo;

  if (neg)
    a.ineg();

  return a;
};

N64.prototype.idivn = function idivn(num) {
  enforce(isNumber(num), 'divisor', 'number');
  return this.idiv(this._small(num));
};

N64.prototype.div = function div(b) {
  return this.clone().idiv(b);
};

N64.prototype.divn = function divn(num) {
  return this.clone().idivn(num);
};

/*
 * Modulo
 */

N64.prototype.imod = function imod(b) {
  const a = this;

  enforce(N64.isN64(b), 'divisor', 'int64');

  if (b.isZero())
    throw new Error('Cannot divide by zero.');

  if (a.isZero())
    return a;

  if (a.eq(b))
    return a.set(0);

  if (a.isSafe() && b.isSafe()) {
    const n = a.toDouble();
    const d = b.toDouble();
    const r = n % d;
    return a.set(r);
  }

  return a.isub(a.div(b).imul(b));
};

N64.prototype.imodn = function imodn(num) {
  enforce(isNumber(num), 'divisor', 'number');
  return this.imod(this._small(num));
};

N64.prototype.mod = function mod(b) {
  return this.clone().imod(b);
};

N64.prototype.modn = function modn(num) {
  return this.clone().imodn(num);
};

/*
 * Exponentiation
 */

N64.prototype.ipow = function ipow(b) {
  enforce(N64.isN64(b), 'exponent', 'int64');
  return this.ipown(b.lo);
};

N64.prototype.ipown = function ipown(num) {
  enforce(isNumber(num), 'exponent', 'number');

  if (this.isZero())
    return this;

  const x = this.clone();
  const n = this;

  let y = num >>> 0;

  n.set(1);

  while (y > 0) {
    if (y & 1)
      n.imul(x);
    y >>>= 1;
    x.imul(x);
  }

  return n;
};

N64.prototype.pow = function pow(b) {
  return this.clone().ipow(b);
};

N64.prototype.pown = function pown(num) {
  return this.clone().ipown(num);
};

N64.prototype.sqr = function sqr() {
  return this.mul(this);
};

N64.prototype.isqr = function isqr() {
  return this.imul(this);
};

/*
 * AND
 */

N64.prototype.iand = function iand(b) {
  enforce(N64.isN64(b), 'operand', 'int64');
  this.hi &= b.hi;
  this.lo &= b.lo;
  return this;
};

N64.prototype.iandn = function iandn(num) {
  enforce(isNumber(num), 'operand', 'number');
  this.hi &= (num >> 31) & -this.sign;
  this.lo &= num | 0;
  return this;
};

N64.prototype.and = function and(b) {
  return this.clone().iand(b);
};

N64.prototype.andn = function andn(num) {
  return this.clone().iandn(num);
};

/*
 * OR
 */

N64.prototype.ior = function ior(b) {
  enforce(N64.isN64(b), 'operand', 'int64');
  this.hi |= b.hi;
  this.lo |= b.lo;
  return this;
};

N64.prototype.iorn = function iorn(num) {
  enforce(isNumber(num), 'operand', 'number');
  this.hi |= (num >> 31) & -this.sign;
  this.lo |= num | 0;
  return this;
};

N64.prototype.or = function or(b) {
  return this.clone().ior(b);
};

N64.prototype.orn = function orn(num) {
  return this.clone().iorn(num);
};

/*
 * XOR
 */

N64.prototype.ixor = function ixor(b) {
  enforce(N64.isN64(b), 'operand', 'int64');
  this.hi ^= b.hi;
  this.lo ^= b.lo;
  return this;
};

N64.prototype.ixorn = function ixorn(num) {
  enforce(isNumber(num), 'operand', 'number');
  this.hi ^= (num >> 31) & -this.sign;
  this.lo ^= num | 0;
  return this;
};

N64.prototype.xor = function xor(b) {
  return this.clone().ixor(b);
};

N64.prototype.xorn = function xorn(num) {
  return this.clone().ixorn(num);
};

/*
 * NOT
 */

N64.prototype.inot = function inot() {
  this.hi = ~this.hi;
  this.lo = ~this.lo;
  return this;
};

N64.prototype.not = function not() {
  return this.clone().inot();
};

/*
 * Left Shift
 */

N64.prototype.ishl = function ishl(b) {
  enforce(N64.isN64(b), 'bits', 'int64');
  return this.ishln(b.lo);
};

N64.prototype.ishln = function ishln(bits) {
  enforce(isNumber(bits), 'bits', 'number');

  bits &= 63;

  if (bits === 0)
    return this;

  let hi = this.hi;
  let lo = this.lo;

  if (bits < 32) {
    hi <<= bits;
    hi |= lo >>> (32 - bits);
    lo <<= bits;
  } else {
    hi = lo << (bits - 32);
    lo = 0;
  }

  this.hi = hi;
  this.lo = lo;

  return this;
};

N64.prototype.shl = function shl(b) {
  return this.clone().ishl(b);
};

N64.prototype.shln = function shln(bits) {
  return this.clone().ishln(bits);
};

/*
 * Right Shift
 */

N64.prototype.ishr = function ishr(b) {
  enforce(N64.isN64(b), 'bits', 'int64');
  return this.ishrn(b.lo);
};

N64.prototype.ishrn = function ishrn(bits) {
  if (!this.sign)
    return this.iushrn(bits);

  enforce(isNumber(bits), 'bits', 'number');

  bits &= 63;

  if (bits === 0)
    return this;

  let hi = this.hi;
  let lo = this.lo;

  if (bits < 32) {
    lo >>>= bits;
    lo |= hi << (32 - bits);
    hi >>= bits;
  } else {
    lo = hi >> (bits - 32);
    hi = hi >> 31;
  }

  this.hi = hi;
  this.lo = lo;

  return this;
};

N64.prototype.shr = function shr(b) {
  return this.clone().ishr(b);
};

N64.prototype.shrn = function shrn(bits) {
  return this.clone().ishrn(bits);
};

/*
 * Unsigned Right Shift
 */

N64.prototype.iushr = function iushr(b) {
  enforce(N64.isN64(b), 'bits', 'int64');
  return this.iushrn(b.lo);
};

N64.prototype.iushrn = function iushrn(bits) {
  enforce(isNumber(bits), 'bits', 'number');

  bits &= 63;

  if (bits === 0)
    return this;

  let hi = this.hi;
  let lo = this.lo;

  if (bits < 32) {
    lo >>>= bits;
    lo |= hi << (32 - bits);
    hi >>>= bits;
  } else {
    lo = hi >>> (bits - 32);
    hi = 0;
  }

  this.hi = hi | 0;
  this.lo = lo | 0;

  return this;
};

N64.prototype.ushr = function ushr(b) {
  return this.clone().iushr(b);
};

N64.prototype.ushrn = function ushrn(bits) {
  return this.clone().iushrn(bits);
};

/*
 * Bit Manipulation
 */

N64.prototype.setn = function setn(bit, val) {
  enforce(isNumber(bit), 'bit', 'number');

  bit &= 63;

  if (bit < 32) {
    if (val)
      this.lo |= (1 << bit);
    else
      this.lo &= ~(1 << bit);
  } else {
    if (val)
      this.hi |= (1 << (bit - 32));
    else
      this.hi &= ~(1 << (bit - 32));
  }

  return this;
};

N64.prototype.testn = function testn(bit) {
  enforce(isNumber(bit), 'bit', 'number');

  bit &= 63;

  if (bit < 32)
    return (this.lo >>> bit) & 1;

  return (this.hi >>> (bit - 32)) & 1;
};

N64.prototype.setb = function setb(pos, ch) {
  enforce(isNumber(pos), 'pos', 'number');
  enforce(isNumber(ch), 'ch', 'number');

  pos &= 7;
  ch &= 0xff;

  if (pos < 4) {
    this.lo &= ~(0xff << (pos * 8));
    this.lo |= ch << (pos * 8);
  } else {
    this.hi &= ~(0xff << ((pos - 4) * 8));
    this.hi |= ch << ((pos - 4) * 8);
  }

  return this;
};

N64.prototype.orb = function orb(pos, ch) {
  enforce(isNumber(pos), 'pos', 'number');
  enforce(isNumber(ch), 'ch', 'number');

  pos &= 7;
  ch &= 0xff;

  if (pos < 4)
    this.lo |= ch << (pos * 8);
  else
    this.hi |= ch << ((pos - 4) * 8);

  return this;
};

N64.prototype.getb = function getb(pos) {
  enforce(isNumber(pos), 'pos', 'number');

  pos &= 7;

  if (pos < 4)
    return (this.lo >> (pos * 8)) & 0xff;

  return (this.hi >> ((pos - 4) * 8)) & 0xff;
};

N64.prototype.imaskn = function imaskn(bit) {
  enforce(isNumber(bit), 'bit', 'number');

  bit &= 63;

  if (bit < 32) {
    this.hi = 0;
    this.lo &= (1 << bit) - 1;
  } else {
    this.hi &= (1 << (bit - 32)) - 1;
    this.lo &= 0xffffffff;
  }

  return this;
};

N64.prototype.maskn = function maskn(bit) {
  return this.clone().imaskn(bit);
};

N64.prototype.andln = function andln(num) {
  enforce(isNumber(num), 'operand', 'number');
  return this.lo & num;
};

/*
 * Negation
 */

N64.prototype.ineg = function ineg() {
  let hi = ~this.hi;
  let lo = ~this.lo;

  if (lo === -1) {
    lo = 0;
    hi += 1;
    hi |= 0;
  } else {
    lo += 1;
  }

  this.hi = hi;
  this.lo = lo;

  return this;
};

N64.prototype.neg = function neg() {
  return this.clone().ineg();
};

N64.prototype.iabs = function iabs() {
  if (this.isNeg())
    this.ineg();
  return this;
};

N64.prototype.abs = function abs() {
  return this.clone().iabs();
};

/*
 * Comparison
 */

N64.prototype._cmp = function _cmp(bhi, blo) {
  const a = this;

  let ahi = a.hi;
  let alo = a.lo;

  if (ahi === bhi && alo === blo)
    return 0;

  let neg = false;

  if (a.sign) {
    const x = ahi < 0;
    const y = bhi < 0;

    if (x && !y)
      return -1;

    if (!x && y)
      return 1;

    neg = x;
  }

  if (!neg) {
    ahi >>>= 0;
    bhi >>>= 0;
  }

  if (ahi < bhi)
    return -1;

  if (ahi > bhi)
    return 1;

  alo >>>= 0;
  blo >>>= 0;

  if (alo < blo)
    return -1;

  return 1;
};

N64.prototype.cmp = function cmp(b) {
  enforce(N64.isN64(b), 'value', 'int64');
  return this._cmp(b.hi, b.lo);
};

N64.prototype.cmpn = function cmpn(num) {
  enforce(isNumber(num), 'value', 'number');
  return this._cmp((num >> 31) & -this.sign, num | 0);
};

N64.prototype.eq = function eq(b) {
  enforce(N64.isN64(b), 'value', 'int64');
  return this.hi === b.hi && this.lo === b.lo;
};

N64.prototype.eqn = function eqn(num) {
  enforce(isNumber(num), 'value', 'number');
  return this.hi === ((num >> 31) & -this.sign) && this.lo === (num | 0);
};

N64.prototype.gt = function gt(b) {
  return this.cmp(b) > 0;
};

N64.prototype.gtn = function gtn(num) {
  return this.cmpn(num) > 0;
};

N64.prototype.gte = function gte(b) {
  return this.cmp(b) >= 0;
};

N64.prototype.gten = function gten(num) {
  return this.cmpn(num) >= 0;
};

N64.prototype.lt = function lt(b) {
  return this.cmp(b) < 0;
};

N64.prototype.ltn = function ltn(num) {
  return this.cmpn(num) < 0;
};

N64.prototype.lte = function lte(b) {
  return this.cmp(b) <= 0;
};

N64.prototype.lten = function lten(num) {
  return this.cmpn(num) <= 0;
};

N64.prototype.isZero = function isZero() {
  return this.hi === 0 && this.lo === 0;
};

N64.prototype.isNeg = function isNeg() {
  return this.sign === 1 && this.hi < 0;
};

N64.prototype.isOdd = function isOdd() {
  return (this.lo & 1) === 1;
};

N64.prototype.isEven = function isEven() {
  return (this.lo & 1) === 0;
};

/*
 * Helpers
 */

N64.prototype.clone = function clone() {
  const n = new this.constructor();
  n.hi = this.hi;
  n.lo = this.lo;
  return n;
};

N64.prototype.inject = function inject(b) {
  enforce(N64.isN64(b), 'value', 'int64');
  this.hi = b.hi;
  this.lo = b.lo;
  return this;
};

N64.prototype.set = function set(num) {
  enforce(isSafeInteger(num), 'number', 'integer');

  let neg = false;

  if (num < 0) {
    num = -num;
    neg = true;
  }

  this.hi = (num * (1 / 0x100000000)) | 0;
  this.lo = num | 0;

  if (neg)
    this.ineg();

  return this;
};

N64.prototype.join = function join(hi, lo) {
  enforce(isNumber(hi), 'hi', 'number');
  enforce(isNumber(lo), 'lo', 'number');
  this.hi = hi | 0;
  this.lo = lo | 0;
  return this;
};

N64.prototype._small = function _small(num) {
  const n = new this.constructor();
  n.hi = (num >> 31) & -this.sign;
  n.lo = num | 0;
  return n;
};

N64.prototype.bitLength = function bitLength() {
  let a = this;

  if (this.isNeg())
    a = this.neg();

  if (a.hi === 0)
    return countBits(a.lo);

  return countBits(a.hi) + 32;
};

N64.prototype.byteLength = function byteLength() {
  return Math.ceil(this.bitLength() / 8);
};

N64.prototype.isSafe = function isSafe() {
  let hi = this.hi;

  if (this.isNeg()) {
    hi = ~hi;
    if (this.lo === 0)
      hi += 1;
  }

  return (hi & 0xffe00000) === 0;
};

N64.prototype.inspect = function inspect() {
  let prefix = 'I64';

  if (!this.sign)
    prefix = 'U64';

  return `<${prefix}: ${this.toString(10)}>`;
};

/*
 * Encoding
 */

N64.prototype.readLE = function readLE(data, off) {
  enforce(data && typeof data.length === 'number', 'data', 'arraylike');
  enforce((off >> 0) === off, 'offset', 'integer');
  enforce(off + 8 <= data.length, 'offset', 'valid offset');
  this.lo = readI32LE(data, off);
  this.hi = readI32LE(data, off + 4);
  return off + 8;
};

N64.prototype.readBE = function readBE(data, off) {
  enforce(data && typeof data.length === 'number', 'data', 'arraylike');
  enforce((off >> 0) === off, 'offset', 'integer');
  enforce(off + 8 <= data.length, 'offset', 'valid offset');
  this.hi = readI32BE(data, off);
  this.lo = readI32BE(data, off + 4);
  return off + 8;
};

N64.prototype.readRaw = function readRaw(data, off) {
  return this.readLE(data, off);
};

N64.prototype.writeLE = function writeLE(data, off) {
  enforce(data && typeof data.length === 'number', 'data', 'arraylike');
  enforce((off >> 0) === off, 'offset', 'integer');
  enforce(off + 8 <= data.length, 'offset', 'valid offset');
  writeI32LE(data, this.lo, off);
  writeI32LE(data, this.hi, off + 4);
  return off + 8;
};

N64.prototype.writeBE = function writeBE(data, off) {
  enforce(data && typeof data.length === 'number', 'data', 'arraylike');
  enforce((off >> 0) === off, 'offset', 'integer');
  enforce(off + 8 <= data.length, 'offset', 'valid offset');
  writeI32BE(data, this.hi, off);
  writeI32BE(data, this.lo, off + 4);
  return off + 8;
};

N64.prototype.writeRaw = function writeRaw(data, off) {
  return this.writeLE(data, off);
};

/*
 * Conversion
 */

N64.prototype.toU64 = function toU64() {
  const n = new U64();
  n.hi = this.hi;
  n.lo = this.lo;
  return n;
};

N64.prototype.toI64 = function toI64() {
  const n = new I64();
  n.hi = this.hi;
  n.lo = this.lo;
  return n;
};

N64.prototype.toNumber = function toNumber() {
  if (!this.isSafe())
    throw new Error('Number exceeds 53 bits.');

  return this.toDouble();
};

N64.prototype.toDouble = function toDouble() {
  let hi = this.hi;

  if (!this.sign)
    hi >>>= 0;

  return hi * 0x100000000 + (this.lo >>> 0);
};

N64.prototype.toInt = function toInt() {
  return this.sign ? this.lo : this.lo >>> 0;
};

N64.prototype.toBool = function toBool() {
  return !this.isZero();
};

N64.prototype.toBits = function toBits() {
  return [this.hi, this.lo];
};

N64.prototype.toObject = function toObject() {
  return { hi: this.hi, lo: this.lo };
};

N64.prototype.toString = function toString(base, pad) {
  base = getBase(base);

  if (pad == null)
    pad = 0;

  enforce((base >>> 0) === base, 'base', 'integer');
  enforce((pad >>> 0) === pad, 'pad', 'integer');

  if (base < 2 || base > 16)
    throw new Error('Base ranges between 2 and 16.');

  if (pad > 64)
    throw new Error('Maximum padding is 64 characters.');

  let n = this;
  let neg = false;

  if (n.isNeg()) {
    n = n.neg();
    neg = true;
  }

  let hi = n.hi >>> 0;
  let lo = n.lo >>> 0;
  let str = '';

  do {
    const mhi = hi % base;
    hi -= mhi;
    hi /= base;
    lo += mhi * 0x100000000;

    const mlo = lo % base;
    lo -= mlo;
    lo /= base;

    let ch = mlo;

    if (ch < 10)
      ch += 0x30;
    else
      ch += 0x61 - 10;

    str = String.fromCharCode(ch) + str;
  } while (lo > 0 || hi > 0);

  while (str.length < pad)
    str = '0' + str;

  if (neg)
    str = '-' + str;

  return str;
};

N64.prototype.toJSON = function toJSON() {
  return this.toString(16, 16);
};

N64.prototype.toBN = function toBN(BN) {
  const neg = this.isNeg();

  let hi = this.hi;
  let lo = this.lo;

  if (neg) {
    hi = ~hi;
    lo = ~lo;
    if (lo === -1) {
      lo = 0;
      hi += 1;
      hi |= 0;
    } else {
      lo += 1;
    }
  }

  hi >>>= 0;
  lo >>>= 0;

  const num = new BN(hi);
  num.ishln(32);
  num.iadd(new BN(lo));

  if (neg)
    num.ineg();

  return num;
};

N64.prototype.toLE = function toLE(ArrayLike) {
  enforce(typeof ArrayLike === 'function', 'ArrayLike', 'constructor');
  const data = alloc(ArrayLike, 8);
  this.writeLE(data, 0);
  return data;
};

N64.prototype.toBE = function toBE(ArrayLike) {
  enforce(typeof ArrayLike === 'function', 'ArrayLike', 'constructor');
  const data = alloc(ArrayLike, 8);
  this.writeBE(data, 0);
  return data;
};

N64.prototype.toRaw = function toRaw(ArrayLike) {
  return this.toLE(ArrayLike);
};

/*
 * Instantiation
 */

N64.prototype.fromNumber = function fromNumber(num) {
  return this.set(num);
};

N64.prototype.fromInt = function fromInt(num) {
  enforce(isNumber(num), 'integer', 'number');
  return this.join((num >> 31) & -this.sign, num);
};

N64.prototype.fromBool = function fromBool(value) {
  enforce(typeof value === 'boolean', 'value', 'boolean');
  this.hi = 0;
  this.lo = value ? 1 : 0;
  return this;
};

N64.prototype.fromBits = function fromBits(hi, lo) {
  return this.join(hi, lo);
};

N64.prototype.fromObject = function fromObject(num) {
  enforce(num && typeof num === 'object', 'number', 'object');
  return this.fromBits(num.hi, num.lo);
};

N64.prototype.fromString = function fromString(str, base) {
  base = getBase(base);

  enforce(typeof str === 'string', 'string', 'string');
  enforce((base >>> 0) === base, 'base', 'integer');

  if (base < 2 || base > 16)
    throw new Error('Base ranges between 2 and 16.');

  let neg = false;
  let i = 0;

  if (str.length > 0 && str[0] === '-') {
    i += 1;
    neg = true;
  }

  if (str.length === i || str.length > i + 64)
    throw new Error('Invalid string (bad length).');

  let hi = 0;
  let lo = 0;

  for (; i < str.length; i++) {
    let ch = str.charCodeAt(i);

    if (ch >= 0x30 && ch <= 0x39)
      ch -= 0x30;
    else if (ch >= 0x41 && ch <= 0x5a)
      ch -= 0x41 - 10;
    else if (ch >= 0x61 && ch <= 0x7a)
      ch -= 0x61 - 10;
    else
      ch = base;

    if (ch >= base)
      throw new Error('Invalid string (parse error).');

    lo *= base;
    lo += ch;

    hi *= base;

    if (lo > 0xffffffff) {
      ch = lo % 0x100000000;
      hi += (lo - ch) / 0x100000000;
      lo = ch;
    }

    if (hi > 0xffffffff)
      throw new Error('Invalid string (overflow).');
  }

  this.hi = hi | 0;
  this.lo = lo | 0;

  if (neg)
    this.ineg();

  return this;
};

N64.prototype.fromJSON = function fromJSON(json) {
  return this.fromString(json, 16);
};

N64.prototype.fromBN = function fromBN(num) {
  enforce(num && isArray(num.words), 'number', 'big number');

  const a = this;
  const b = num.clone();
  const neg = b.isNeg();

  if (a.sign && b.testn(63))
    throw new Error('Big number overflow.');

  let i = 0;

  while (!b.isZero()) {
    if (i === 8)
      throw new Error('Big number overflow.');

    a.orb(i, b.andln(0xff));
    b.iushrn(8);
    i++;
  }

  if (neg)
    a.ineg();

  return a;
};

N64.prototype.fromLE = function fromLE(data) {
  this.readLE(data, 0);
  return this;
};

N64.prototype.fromBE = function fromBE(data) {
  this.readBE(data, 0);
  return this;
};

N64.prototype.fromRaw = function fromRaw(data) {
  return this.fromLE(data);
};

N64.prototype.from = function from(num, base) {
  if (num == null)
    return this;

  if (typeof num === 'number') {
    if (typeof base === 'number')
      return this.fromBits(num, base);
    return this.fromNumber(num);
  }

  if (typeof num === 'string')
    return this.fromString(num, base);

  if (typeof num === 'object') {
    if (isArray(num.words))
      return this.fromBN(num);

    if (typeof num.length === 'number')
      return this.fromRaw(num);

    return this.fromObject(num);
  }

  if (typeof num === 'boolean')
    return this.fromBool(num);

  throw new TypeError('Non-numeric object passed to N64.');
};

/*
 * Static Methods
 */

N64.min = function min(a, b) {
  return a.cmp(b) < 0 ? a : b;
};

N64.max = function max(a, b) {
  return a.cmp(b) > 0 ? a : b;
};

N64.random = function random() {
  const n = new this();
  n.hi = (Math.random() * 0x100000000) | 0;
  n.lo = (Math.random() * 0x100000000) | 0;
  return n;
};

N64.pow = function pow(num, exp) {
  return new this().fromInt(num).ipown(exp);
};

N64.shift = function shift(num, bits) {
  return new this().fromInt(num).ishln(bits);
};

N64.readLE = function readLE(data, off) {
  const n = new this();
  n.readLE(data, off);
  return n;
};

N64.readBE = function readBE(data, off) {
  const n = new this();
  n.readBE(data, off);
  return n;
};

N64.readRaw = function readRaw(data, off) {
  const n = new this();
  n.readRaw(data, off);
  return n;
};

N64.fromNumber = function fromNumber(num) {
  return new this().fromNumber(num);
};

N64.fromInt = function fromInt(num) {
  return new this().fromInt(num);
};

N64.fromBool = function fromBool(value) {
  return new this().fromBool(value);
};

N64.fromBits = function fromBits(hi, lo) {
  return new this().fromBits(hi, lo);
};

N64.fromObject = function fromObject(obj) {
  return new this().fromObject(obj);
};

N64.fromString = function fromString(str, base) {
  return new this().fromString(str, base);
};

N64.fromJSON = function fromJSON(json) {
  return new this().fromJSON(json);
};

N64.fromBN = function fromBN(num) {
  return new this().fromBN(num);
};

N64.fromLE = function fromLE(data) {
  return new this().fromLE(data);
};

N64.fromBE = function fromBE(data) {
  return new this().fromBE(data);
};

N64.fromRaw = function fromRaw(data) {
  return new this().fromRaw(data);
};

N64.from = function from(num, base) {
  return new this().from(num, base);
};

N64.isN64 = function isN64(obj) {
  return obj instanceof N64;
};

N64.isU64 = function isU64(obj) {
  return obj instanceof U64;
};

N64.isI64 = function isI64(obj) {
  return obj instanceof I64;
};

/*
 * U64
 */

function U64(num, base) {
  if (!(this instanceof U64))
    return new U64(num, base);

  N64.call(this, 0);

  this.from(num, base);
}

U64.__proto__ = N64;
U64.prototype.__proto__ = N64.prototype;

/*
 * Constants
 */

U64.ULONG_MIN = 0x00000000;
U64.ULONG_MAX = 0xffffffff;

U64.UINT32_MIN = U64(0x00000000, 0x00000000);
U64.UINT32_MAX = U64(0x00000000, 0xffffffff);

U64.UINT64_MIN = U64(0x00000000, 0x00000000);
U64.UINT64_MAX = U64(0xffffffff, 0xffffffff);

/*
 * I64
 */

function I64(num, base) {
  if (!(this instanceof I64))
    return new I64(num, base);

  N64.call(this, 1);

  this.from(num, base);
}

I64.__proto__ = N64;
I64.prototype.__proto__ = N64.prototype;

/*
 * Constants
 */

I64.LONG_MIN = -0x80000000;
I64.LONG_MAX = 0x7fffffff;

I64.INT32_MIN = I64(0xffffffff, 0x80000000);
I64.INT32_MAX = I64(0x00000000, 0x7fffffff);

I64.INT64_MIN = I64(0x80000000, 0x00000000);
I64.INT64_MAX = I64(0x7fffffff, 0xffffffff);

/*
 * Helpers
 */

function getBase(base) {
  if (base == null)
    return 10;

  if (typeof base === 'number')
    return base;

  switch (base) {
    case 'bin':
      return 2;
    case 'oct':
      return 8;
    case 'dec':
      return 10;
    case 'hex':
      return 16;
  }

  return 0;
}

function countBits(word) {
  if (Math.clz32)
    return 32 - Math.clz32(word);

  let bit = 31;

  for (; bit >= 0; bit--) {
    if ((word & (1 << bit)) !== 0)
      break;
  }

  return bit + 1;
}

function floor(n) {
  if (n < 0)
    return -Math.floor(-n);
  return Math.floor(n);
}

function enforce(value, name, type) {
  if (!value)
    throw new TypeError(`'${name}' must be a(n) ${type}.`);
}

function isNumber(num) {
  return typeof num === 'number' && isFinite(num);
}

function isArray(num) {
  if (Array.isArray)
    return Array.isArray(num);

  return ({}).toString.call(num).slice(8, -1) === 'Array';
}

function isSafeInteger(num) {
  if (Number.isSafeInteger)
    return Number.isSafeInteger(num);

  return isNumber(num)
    && Math.floor(num) === num
    && num >= -0x001fffffffffffff
    && num <= 0x001fffffffffffff;
}

function alloc(ArrayLike, size) {
  if (ArrayLike.allocUnsafe)
    return ArrayLike.allocUnsafe(size);

  return new ArrayLike(size);
}

function readI32LE(data, off) {
  return data[off]
    | (data[off + 1] << 8)
    | (data[off + 2] << 16)
    | (data[off + 3] << 24);
}

function readI32BE(data, off) {
  return (data[off] << 24)
    | (data[off + 1] << 16)
    | (data[off + 2] << 8)
    | data[off + 3];
}

function writeI32LE(data, num, off) {
  data[off] = num & 0xff;
  data[off + 1] = (num >>> 8) & 0xff;
  data[off + 2] = (num >>> 16) & 0xff;
  data[off + 3] = (num >>> 24) & 0xff;
}

function writeI32BE(data, num, off) {
  data[off] = (num >>> 24) & 0xff;
  data[off + 1] = (num >>> 16) & 0xff;
  data[off + 2] = (num >>> 8) & 0xff;
  data[off + 3] = num & 0xff;
}

/*
 * Expose
 */

exports.N64 = N64;
exports.U64 = U64;
exports.I64 = I64;


/***/ }),
/* 132 */
/***/ (function(module, exports) {

module.exports = require("wmcc-native");

/***/ }),
/* 133 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 134 */
/***/ (function(module, exports) {

module.exports = require("buffer");

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = __webpack_require__(136)('secp256k1')


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var fs = __webpack_require__(64)
  , path = __webpack_require__(25)
  , join = path.join
  , dirname = path.dirname
  , exists = ((fs.accessSync && function (path) { try { fs.accessSync(path); } catch (e) { return false; } return true; })
      || fs.existsSync || path.existsSync)
  , defaults = {
        arrow: process.env.NODE_BINDINGS_ARROW || '  '
      , compiled: process.env.NODE_BINDINGS_COMPILED_DIR || 'compiled'
      , platform: process.platform
      , arch: process.arch
      , version: process.versions.node
      , bindings: 'bindings.node'
      , try: [
          // node-gyp's linked version in the "build" dir
          [ 'module_root', 'build', 'bindings' ]
          // node-waf and gyp_addon (a.k.a node-gyp)
        , [ 'module_root', 'build', 'Debug', 'bindings' ]
        , [ 'module_root', 'build', 'Release', 'bindings' ]
          // Debug files, for development (legacy behavior, remove for node v0.9)
        , [ 'module_root', 'out', 'Debug', 'bindings' ]
        , [ 'module_root', 'Debug', 'bindings' ]
          // Release files, but manually compiled (legacy behavior, remove for node v0.9)
        , [ 'module_root', 'out', 'Release', 'bindings' ]
        , [ 'module_root', 'Release', 'bindings' ]
          // Legacy from node-waf, node <= 0.4.x
        , [ 'module_root', 'build', 'default', 'bindings' ]
          // Production "Release" buildtype binary (meh...)
        , [ 'module_root', 'compiled', 'version', 'platform', 'arch', 'bindings' ]
        ]
    }

/**
 * The main `bindings()` function loads the compiled bindings for a given module.
 * It uses V8's Error API to determine the parent filename that this function is
 * being invoked from, which is then used to find the root directory.
 */

function bindings (opts) {

  // Argument surgery
  if (typeof opts == 'string') {
    opts = { bindings: opts }
  } else if (!opts) {
    opts = {}
  }

  // maps `defaults` onto `opts` object
  Object.keys(defaults).map(function(i) {
    if (!(i in opts)) opts[i] = defaults[i];
  });

  // Get the module root
  if (!opts.module_root) {
    opts.module_root = exports.getRoot(exports.getFileName())
  }

  // Ensure the given bindings name ends with .node
  if (path.extname(opts.bindings) != '.node') {
    opts.bindings += '.node'
  }

  // https://github.com/webpack/webpack/issues/4175#issuecomment-342931035
  var requireFunc =  true ? require : require

  var tries = []
    , i = 0
    , l = opts.try.length
    , n
    , b
    , err

  for (; i<l; i++) {
    n = join.apply(null, opts.try[i].map(function (p) {
      return opts[p] || p
    }))
    tries.push(n)
    try {
      b = opts.path ? requireFunc.resolve(n) : requireFunc(n)
      if (!opts.path) {
        b.path = n
      }
      return b
    } catch (e) {
      if (!/not find/i.test(e.message)) {
        throw e
      }
    }
  }

  err = new Error('Could not locate the bindings file. Tried:\n'
    + tries.map(function (a) { return opts.arrow + a }).join('\n'))
  err.tries = tries
  throw err
}
module.exports = exports = bindings


/**
 * Gets the filename of the JavaScript file that invokes this function.
 * Used to help find the root directory of a module.
 * Optionally accepts an filename argument to skip when searching for the invoking filename
 */

exports.getFileName = function getFileName (calling_file) {
  var origPST = Error.prepareStackTrace
    , origSTL = Error.stackTraceLimit
    , dummy = {}
    , fileName

  Error.stackTraceLimit = 10

  Error.prepareStackTrace = function (e, st) {
    for (var i=0, l=st.length; i<l; i++) {
      fileName = st[i].getFileName()
      if (fileName !== __filename) {
        if (calling_file) {
            if (fileName !== calling_file) {
              return
            }
        } else {
          return
        }
      }
    }
  }

  // run the 'prepareStackTrace' function above
  Error.captureStackTrace(dummy)
  dummy.stack

  // cleanup
  Error.prepareStackTrace = origPST
  Error.stackTraceLimit = origSTL

  return fileName
}

/**
 * Gets the root directory of a module, given an arbitrary filename
 * somewhere in the module tree. The "root directory" is the directory
 * containing the `package.json` file.
 *
 *   In:  /home/nate/node-native-module/lib/index.js
 *   Out: /home/nate/node-native-module
 */

exports.getRoot = function getRoot (file) {
  var dir = dirname(file)
    , prev
  while (true) {
    if (dir === '.') {
      // Avoids an infinite loop in rare cases, like the REPL
      dir = process.cwd()
    }
    if (exists(join(dir, 'package.json')) || exists(join(dir, 'node_modules'))) {
      // Found the 'package.json' file or 'node_modules' dir; we're done
      return dir
    }
    if (prev === dir) {
      // Got to the top
      throw new Error('Could not find module root given file: "' + file
                    + '". Do you have a `package.json` file? ')
    }
    // Try the parent dir next
    prev = dir
    dir = join(dir, '..')
  }
}


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * secp256k1-native.js - wrapper for secp256k1-node.
 */



const assert = __webpack_require__(0);
const secp256k1 = __webpack_require__(138);
const random = __webpack_require__(29);

/**
 * @exports crypto/secp256k1
 */

const ec = exports;

/*
 * Constants
 */

const ZERO_S = Buffer.from(
  '0000000000000000000000000000000000000000000000000000000000000000',
  'hex'
);

const HALF_ORDER = Buffer.from(
  '7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0',
  'hex');

/**
 * Whether we're using native bindings.
 * @const {Boolean}
 * @private
 */

ec.binding = true;

/**
 * Generate a private key.
 * @returns {Buffer} Private key.
 */

ec.generatePrivateKey = function generatePrivateKey() {
  let priv;

  do {
    priv = random.randomBytes(32);
  } while (!secp256k1.privateKeyVerify(priv));

  return priv;
};

/**
 * Create a public key from a private key.
 * @param {Buffer} priv
 * @param {Boolean?} compress
 * @returns {Buffer}
 */

ec.publicKeyCreate = function publicKeyCreate(priv, compress) {
  assert(Buffer.isBuffer(priv));
  return secp256k1.publicKeyCreate(priv, compress);
};

/**
 * Compress or decompress public key.
 * @param {Buffer} pub
 * @returns {Buffer}
 */

ec.publicKeyConvert = function publicKeyConvert(key, compress) {
  return secp256k1.publicKeyConvert(key, compress);
};

/**
 * ((tweak + key) % n)
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @returns {Buffer} privateKey
 */

ec.privateKeyTweakAdd = function privateKeyTweakAdd(privateKey, tweak) {
  return secp256k1.privateKeyTweakAdd(privateKey, tweak);
};

/**
 * ((g * tweak) + key)
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @returns {Buffer} publicKey
 */

ec.publicKeyTweakAdd = function publicKeyTweakAdd(publicKey, tweak, compress) {
  return secp256k1.publicKeyTweakAdd(publicKey, tweak, compress);
};

/**
 * Create an ecdh.
 * @param {Buffer} pub
 * @param {Buffer} priv
 * @returns {Buffer}
 */

ec.ecdh = function ecdh(pub, priv) {
  const point = secp256k1.ecdhUnsafe(pub, priv, true);
  return point.slice(1, 33);
};

/**
 * Recover a public key.
 * @param {Buffer} msg
 * @param {Buffer} sig
 * @param {Number?} j
 * @param {Boolean?} compress
 * @returns {Buffer[]|Buffer|null}
 */

ec.recover = function recover(msg, sig, j, compress) {
  let key;

  if (!j)
    j = 0;

  try {
    sig = secp256k1.signatureImport(sig);
  } catch (e) {
    return null;
  }

  try {
    key = secp256k1.recover(msg, sig, j, compress);
  } catch (e) {
    return null;
  }

  return key;
};

/**
 * Verify a signature.
 * @param {Buffer} msg
 * @param {Buffer} sig - DER formatted.
 * @param {Buffer} key
 * @returns {Boolean}
 */

ec.verify = function verify(msg, sig, key) {
  assert(Buffer.isBuffer(msg));
  assert(Buffer.isBuffer(sig));
  assert(Buffer.isBuffer(key));

  if (sig.length === 0)
    return false;

  if (key.length === 0)
    return false;

  try {
    sig = secp256k1.signatureImportLax(sig);
    sig = secp256k1.signatureNormalize(sig);
    return secp256k1.verify(msg, sig, key);
  } catch (e) {
    return false;
  }
};

/**
 * Validate a public key.
 * @param {Buffer} key
 * @returns {Boolean} True if buffer is a valid public key.
 */

ec.publicKeyVerify = function publicKeyVerify(key) {
  return secp256k1.publicKeyVerify(key);
};

/**
 * Validate a private key.
 * @param {Buffer} key
 * @returns {Boolean} True if buffer is a valid private key.
 */

ec.privateKeyVerify = function privateKeyVerify(key) {
  return secp256k1.privateKeyVerify(key);
};

/**
 * Sign a message.
 * @param {Buffer} msg
 * @param {Buffer} key - Private key.
 * @returns {Buffer} DER-formatted signature.
 */

ec.sign = function sign(msg, key) {
  assert(Buffer.isBuffer(msg));
  assert(Buffer.isBuffer(key));

  // Sign message
  let sig = secp256k1.sign(msg, key);

  // Ensure low S value
  sig = secp256k1.signatureNormalize(sig.signature);

  // Convert to DER
  return secp256k1.signatureExport(sig);
};

/**
 * Convert DER signature to R/S.
 * @param {Buffer} sig
 * @returns {Buffer} R/S-formatted signature.
 */

ec.fromDER = function fromDER(sig) {
  assert(Buffer.isBuffer(sig));
  return secp256k1.signatureImport(sig);
};

/**
 * Convert R/S signature to DER.
 * @param {Buffer} sig
 * @returns {Buffer} DER-formatted signature.
 */

ec.toDER = function toDER(sig) {
  assert(Buffer.isBuffer(sig));
  return secp256k1.signatureExport(sig);
};

/**
 * Test whether a signature has a low S value.
 * @param {Buffer} sig
 * @returns {Boolean}
 */

ec.isLowS = function isLowS(sig) {
  let s;

  try {
    const rs = secp256k1.signatureImport(sig);
    s = rs.slice(32, 64);
  } catch (e) {
    return false;
  }

  if (s.equals(ZERO_S))
    return false;

  // If S is greater than half the order,
  // it's too high.
  if (s.compare(HALF_ORDER) > 0)
    return false;

  return true;
};


/***/ }),
/* 138 */
/***/ (function(module, exports) {

module.exports = require("secp256k1");

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * secp256k1-elliptic.js - wrapper for elliptic.
 */



const assert = __webpack_require__(0);
const elliptic = __webpack_require__(9);
const secp256k1 = elliptic.ec('secp256k1');
const Signature = __webpack_require__(65);
const BN = __webpack_require__(27);
const curve = secp256k1.curve;

/**
 * @exports crypto/secp256k1-elliptic
 * @ignore
 */

const ec = exports;

/**
 * Whether we're using native bindings.
 * @const {Boolean}
 */

ec.binding = false;

/**
 * Generate a private key.
 * @returns {Buffer} Private key.
 */

ec.generatePrivateKey = function generatePrivateKey() {
  const key = secp256k1.genKeyPair();
  return key.getPrivate().toArrayLike(Buffer, 'be', 32);
};

/**
 * Create a public key from a private key.
 * @param {Buffer} priv
 * @param {Boolean?} compress
 * @returns {Buffer}
 */

ec.publicKeyCreate = function publicKeyCreate(priv, compress) {
  assert(Buffer.isBuffer(priv));

  if (compress == null)
    compress = true;

  const key = secp256k1.keyPair({ priv: priv });

  return Buffer.from(key.getPublic(compress, 'array'));
};

/**
 * Compress or decompress public key.
 * @param {Buffer} pub
 * @returns {Buffer}
 */

ec.publicKeyConvert = function publicKeyConvert(key, compress) {
  const point = curve.decodePoint(key);

  if (compress == null)
    compress = true;

  return Buffer.from(point.encode('array', compress));
};

/**
 * ((tweak + key) % n)
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @returns {Buffer} privateKey
 */

ec.privateKeyTweakAdd = function privateKeyTweakAdd(privateKey, tweak) {
  const key = new BN(tweak)
    .add(new BN(privateKey))
    .mod(curve.n)
    .toArrayLike(Buffer, 'be', 32);

  // Only a 1 in 2^127 chance of happening.
  if (!ec.privateKeyVerify(key))
    throw new Error('Private key is invalid.');

  return key;
};

/**
 * ((g * tweak) + key)
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @returns {Buffer} publicKey
 */

ec.publicKeyTweakAdd = function publicKeyTweakAdd(publicKey, tweak, compress) {
  const key = curve.decodePoint(publicKey);
  const point = curve.g.mul(new BN(tweak)).add(key);

  if (compress == null)
    compress = true;

  const pub = Buffer.from(point.encode('array', compress));

  if (!ec.publicKeyVerify(pub))
    throw new Error('Public key is invalid.');

  return pub;
};

/**
 * Create an ecdh.
 * @param {Buffer} pub
 * @param {Buffer} priv
 * @returns {Buffer}
 */

ec.ecdh = function ecdh(pub, priv) {
  priv = secp256k1.keyPair({ priv: priv });
  pub = secp256k1.keyPair({ pub: pub });
  return priv.derive(pub.getPublic()).toArrayLike(Buffer, 'be', 32);
};

/**
 * Recover a public key.
 * @param {Buffer} msg
 * @param {Buffer} sig
 * @param {Number?} j
 * @param {Boolean?} compress
 * @returns {Buffer[]|Buffer|null}
 */

ec.recover = function recover(msg, sig, j, compress) {
  if (!j)
    j = 0;

  if (compress == null)
    compress = true;

  let point;
  try {
    point = secp256k1.recoverPubKey(msg, sig, j);
  } catch (e) {
    return null;
  }

  return Buffer.from(point.encode('array', compress));
};

/**
 * Verify a signature.
 * @param {Buffer} msg
 * @param {Buffer} sig - DER formatted.
 * @param {Buffer} key
 * @returns {Boolean}
 */

ec.verify = function verify(msg, sig, key) {
  assert(Buffer.isBuffer(msg));
  assert(Buffer.isBuffer(sig));
  assert(Buffer.isBuffer(key));

  if (sig.length === 0)
    return false;

  if (key.length === 0)
    return false;

  // Attempt to normalize the signature
  // length before passing to elliptic.
  // https://github.com/indutny/elliptic/issues/78
  sig = normalizeLength(sig);

  try {
    return secp256k1.verify(msg, sig, key);
  } catch (e) {
    return false;
  }
};

/**
 * Validate a public key.
 * @param {Buffer} key
 * @returns {Boolean} True if buffer is a valid public key.
 */

ec.publicKeyVerify = function publicKeyVerify(key) {
  try {
    const pub = secp256k1.keyPair({ pub: key });
    return pub.validate();
  } catch (e) {
    return false;
  }
};

/**
 * Validate a private key.
 * @param {Buffer} key
 * @returns {Boolean} True if buffer is a valid private key.
 */

ec.privateKeyVerify = function privateKeyVerify(key) {
  if (key.length !== 32)
    return false;

  key = new BN(key);

  return key.cmpn(0) !== 0 && key.cmp(curve.n) < 0;
};

/**
 * Sign a message.
 * @param {Buffer} msg
 * @param {Buffer} key - Private key.
 * @returns {Buffer} DER-formatted signature.
 */

ec.sign = function sign(msg, key) {
  assert(Buffer.isBuffer(msg));
  assert(Buffer.isBuffer(key));

  // Sign message and ensure low S value
  const sig = secp256k1.sign(msg, key, { canonical: true });

  // Convert to DER
  return Buffer.from(sig.toDER());
};

/**
 * Convert DER signature to R/S.
 * @param {Buffer} raw
 * @returns {Buffer} R/S-formatted signature.
 */

ec.fromDER = function fromDER(raw) {
  assert(Buffer.isBuffer(raw));

  const sig = new Signature(raw);
  const out = Buffer.allocUnsafe(64);

  sig.r.toArrayLike(Buffer, 'be', 32).copy(out, 0);
  sig.s.toArrayLike(Buffer, 'be', 32).copy(out, 32);

  return out;
};

/**
 * Convert R/S signature to DER.
 * @param {Buffer} sig
 * @returns {Buffer} DER-formatted signature.
 */

ec.toDER = function toDER(raw) {
  assert(Buffer.isBuffer(raw));

  const sig = new Signature({
    r: new BN(raw.slice(0, 32), 'be'),
    s: new BN(raw.slice(32, 64), 'be')
  });

  return Buffer.from(sig.toDER());
};

/**
 * Test whether a signature has a low S value.
 * @param {Buffer} sig
 * @returns {Boolean}
 */

ec.isLowS = function isLowS(raw) {
  let sig;
  try {
    sig = new Signature(raw);
  } catch (e) {
    return false;
  }

  if (sig.s.cmpn(0) === 0)
    return false;

  // If S is greater than half the order,
  // it's too high.
  if (sig.s.cmp(secp256k1.nh) > 0)
    return false;

  return true;
};

/*
 * Helpers
 */

function normalizeLength(sig) {
  let data = sig;
  let pos = 0;
  let len;

  if (data[pos++] !== 0x30)
    return sig;

  [len, pos] = getLength(data, pos);

  if (data.length > len + pos)
    data = data.slice(0, len + pos);

  if (data[pos++] !== 0x02)
    return sig;

  // R length.
  [len, pos] = getLength(data, pos);

  pos += len;

  if (data[pos++] !== 0x02)
    return sig;

  // S length.
  [len, pos] = getLength(data, pos);

  if (data.length > len + pos)
    data = data.slice(0, len + pos);

  return data;
}

function getLength(buf, pos) {
  const initial = buf[pos++];

  if (!(initial & 0x80))
    return [initial, pos];

  const len = initial & 0xf;
  let val = 0;

  for (let i = 0; i < len; i++) {
    val <<= 8;
    val |= buf[pos++];
  }

  return [val, pos];
}


/***/ }),
/* 140 */
/***/ (function(module, exports) {

module.exports = {"_from":"elliptic@^6.4.0","_id":"elliptic@6.4.1","_inBundle":false,"_integrity":"sha512-BsXLz5sqX8OHcsh7CqBMztyXARmGQ3LWPtGjJi6DiJHq5C/qvi9P3OqgswKSDftbu8+IoI/QDTAm2fFnQ9SZSQ==","_location":"/elliptic","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"elliptic@^6.4.0","name":"elliptic","escapedName":"elliptic","rawSpec":"^6.4.0","saveSpec":null,"fetchSpec":"^6.4.0"},"_requiredBy":["#DEV:/","/browserify-sign","/create-ecdh","/secp256k1"],"_resolved":"https://registry.npmjs.org/elliptic/-/elliptic-6.4.1.tgz","_shasum":"c2d0b7776911b86722c632c3c06c60f2f819939a","_spec":"elliptic@^6.4.0","_where":"C:\\Users\\pakru\\Desktop\\asdasdasd\\wmcc-core","author":{"name":"Fedor Indutny","email":"fedor@indutny.com"},"bugs":{"url":"https://github.com/indutny/elliptic/issues"},"bundleDependencies":false,"dependencies":{"bn.js":"^4.4.0","brorand":"^1.0.1","hash.js":"^1.0.0","hmac-drbg":"^1.0.0","inherits":"^2.0.1","minimalistic-assert":"^1.0.0","minimalistic-crypto-utils":"^1.0.0"},"deprecated":false,"description":"EC cryptography","devDependencies":{"brfs":"^1.4.3","coveralls":"^2.11.3","grunt":"^0.4.5","grunt-browserify":"^5.0.0","grunt-cli":"^1.2.0","grunt-contrib-connect":"^1.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^1.0.1","grunt-mocha-istanbul":"^3.0.1","grunt-saucelabs":"^8.6.2","istanbul":"^0.4.2","jscs":"^2.9.0","jshint":"^2.6.0","mocha":"^2.1.0"},"files":["lib"],"homepage":"https://github.com/indutny/elliptic","keywords":["EC","Elliptic","curve","Cryptography"],"license":"MIT","main":"lib/elliptic.js","name":"elliptic","repository":{"type":"git","url":"git+ssh://git@github.com/indutny/elliptic.git"},"scripts":{"jscs":"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js","jshint":"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js","lint":"npm run jscs && npm run jshint","test":"npm run lint && npm run unit","unit":"istanbul test _mocha --reporter=spec test/index.js","version":"grunt dist && git add dist/"},"version":"6.4.1"}

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;
var BN = __webpack_require__(14);
var minAssert = __webpack_require__(22);
var minUtils = __webpack_require__(82);

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w) {
  var naf = [];
  var ws = 1 << (w + 1);
  var k = num.clone();
  while (k.cmpn(1) >= 0) {
    var z;
    if (k.isOdd()) {
      var mod = k.andln(ws - 1);
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }
    naf.push(z);

    // Optimization, shift by word if possible
    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
    for (var i = 1; i < shift; i++)
      naf.push(0);
    k.iushrn(shift);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    []
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      var m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      var m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
           this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
                                     bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;



/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = __webpack_require__(24);
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(14);
var elliptic = __webpack_require__(9);
var utils = elliptic.utils;
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  for (var j = 0; j < naf.length; j += doubles.step) {
    var nafW = 0;
    for (var k = j + doubles.step - 1; k >= j; k--)
      nafW = (nafW << 1) + naf[k];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (var j = 0; j < repr.length; j++) {
      var nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var k = 0; i >= 0 && naf[i] === 0; i--)
      k++;
    if (i >= 0)
      k++;
    acc = acc.dblp(k);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                       points,
                                                       coeffs,
                                                       len,
                                                       jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  for (var i = 0; i < len; i++) {
    var p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (var i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a]);
      naf[b] = getNAF(coeffs[b], wndWidth[b]);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b] /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (var j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (var i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (var j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (var j = 0; j < len; j++) {
      var z = tmp[j];
      var p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (var i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
                          bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(39);
var elliptic = __webpack_require__(9);
var BN = __webpack_require__(14);
var inherits = __webpack_require__(40);
var Base = curve.base;

var assert = elliptic.utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();

    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

  // Clean-up references to points and coefficients
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);

  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (var i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (var i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};


/***/ }),
/* 145 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(39);
var BN = __webpack_require__(14);
var inherits = __webpack_require__(40);
var Base = curve.base;

var elliptic = __webpack_require__(9);
var utils = elliptic.utils;

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(39);
var elliptic = __webpack_require__(9);
var BN = __webpack_require__(14);
var inherits = __webpack_require__(40);
var Base = curve.base;

var assert = elliptic.utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  if (this.curve.twisted) {
    // E = a * C
    var e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      var h = this.z.redSqr();
      // J = F - 2 * H
      var j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    var e = c.redAdd(d);
    // H = (c * Z1)^2
    var h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    var j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
                          this.y,
                          this.z,
                          this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curves = exports;

var hash = __webpack_require__(54);
var elliptic = __webpack_require__(9);

var assert = elliptic.utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new elliptic.curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new elliptic.curve.edwards(options);
  else
    this.curve = new elliptic.curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
  ]
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
  ]
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
  ]
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
  ]
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650'
  ]
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9'
  ]
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658'
  ]
});

var pre;
try {
  pre = __webpack_require__(155);
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre
  ]
});


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.sha1 = __webpack_require__(150);
exports.sha224 = __webpack_require__(151);
exports.sha256 = __webpack_require__(84);
exports.sha384 = __webpack_require__(152);
exports.sha512 = __webpack_require__(85);


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(15);
var common = __webpack_require__(32);
var shaCommon = __webpack_require__(83);

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(15);
var SHA256 = __webpack_require__(84);

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};



/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(15);

var SHA512 = __webpack_require__(85);

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(15);
var common = __webpack_require__(32);

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(15);
var assert = __webpack_require__(22);

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};


/***/ }),
/* 155 */
/***/ (function(module, exports) {

module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
      ]
    ]
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
      ]
    ]
  }
};


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(14);
var HmacDRBG = __webpack_require__(157);
var elliptic = __webpack_require__(9);
var utils = elliptic.utils;
var assert = utils.assert;

var KeyPair = __webpack_require__(158);
var Signature = __webpack_require__(65);

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);

    options = elliptic.curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof elliptic.curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray()
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  do {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  } while (true);
};

EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8'
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; true; iter++) {
    var k = options.k ?
        options.k(iter) :
        new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);

  if (!this.curve._maxwellTrick) {
    var p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  var p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(54);
var utils = __webpack_require__(82);
var assert = __webpack_require__(22);

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(14);
var elliptic = __webpack_require__(9);
var utils = elliptic.utils;
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(54);
var elliptic = __webpack_require__(9);
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = __webpack_require__(160);
var Signature = __webpack_require__(161);

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  var curve = elliptic.curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
               .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = __webpack_require__(9);
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(14);
var elliptic = __webpack_require__(9);
var utils = elliptic.utils;
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength)
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * paymentdetails.js - BIP70 paymentdetails for wmcc_core.
 */
 


const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const Output = __webpack_require__(13);
const ProtoReader = __webpack_require__(77);
const ProtoWriter = __webpack_require__(78);

/**
 * Represents BIP70 payment details.
 * @alias module:bip70.PaymentDetails
 * @constructor
 * @param {Object?} options
 * @property {String|null} network
 * @property {Output[]} outputs
 * @property {Number} time
 * @property {Number} expires
 * @property {String|null} memo
 * @property {String|null} paymentUrl
 * @property {Buffer|null} merchantData
 */

function PaymentDetails(options) {
  if (!(this instanceof PaymentDetails))
    return new PaymentDetails(options);

  this.network = null;
  this.outputs = [];
  this.time = util.now();
  this.expires = -1;
  this.memo = null;
  this.paymentUrl = null;
  this.merchantData = null;

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from options.
 * @private
 * @param {Object} options
 * @returns {PaymentDetails}
 */

PaymentDetails.prototype.fromOptions = function fromOptions(options) {
  if (options.network != null) {
    assert(typeof options.network === 'string');
    this.network = options.network;
  }

  if (options.outputs) {
    assert(Array.isArray(options.outputs));
    for (const item of options.outputs) {
      const output = new Output(item);
      this.outputs.push(output);
    }
  }

  if (options.time != null) {
    assert(util.isInt(options.time));
    this.time = options.time;
  }

  if (options.expires != null) {
    assert(util.isInt(options.expires));
    this.expires = options.expires;
  }

  if (options.memo != null) {
    assert(typeof options.memo === 'string');
    this.memo = options.memo;
  }

  if (options.paymentUrl != null) {
    assert(typeof options.paymentUrl === 'string');
    this.paymentUrl = options.paymentUrl;
  }

  if (options.merchantData)
    this.setData(options.merchantData);

  return this;
};

/**
 * Instantiate payment details from options.
 * @param {Object} options
 * @returns {PaymentDetails}
 */

PaymentDetails.fromOptions = function fromOptions(options) {
  return new PaymentDetails().fromOptions(options);
};

/**
 * Test whether the payment is expired.
 * @returns {Boolean}
 */

PaymentDetails.prototype.isExpired = function isExpired() {
  if (this.expires === -1)
    return false;
  return util.now() > this.expires;
};

/**
 * Set payment details.
 * @param {Object} data
 * @param {String?} enc
 */

PaymentDetails.prototype.setData = function setData(data, enc) {
  if (data == null || Buffer.isBuffer(data)) {
    this.merchantData = data;
    return;
  }

  if (typeof data !== 'string') {
    assert(!enc || enc === 'json');
    this.merchantData = Buffer.from(JSON.stringify(data), 'utf8');
    return;
  }

  this.merchantData = Buffer.from(data, enc);
};

/**
 * Get payment details.
 * @param {String?} enc
 * @returns {String|Object|null}
 */

PaymentDetails.prototype.getData = function getData(enc) {
  let data = this.merchantData;

  if (!data)
    return null;

  if (!enc)
    return data;

  if (enc === 'json') {
    data = data.toString('utf8');
    try {
      data = JSON.parse(data);
    } catch (e) {
      return null;
    }
    return data;
  }

  return data.toString(enc);
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 * @returns {PaymentDetails}
 */

PaymentDetails.prototype.fromRaw = function fromRaw(data) {
  const br = new ProtoReader(data);

  this.network = br.readFieldString(1, true);

  while (br.nextTag() === 2) {
    const op = new ProtoReader(br.readFieldBytes(2));
    const output = new Output();
    output.value = op.readFieldU64(1, true);
    output.script.fromRaw(op.readFieldBytes(2, true));
    this.outputs.push(output);
  }

  this.time = br.readFieldU64(3);
  this.expires = br.readFieldU64(4, true);
  this.memo = br.readFieldString(5, true);
  this.paymentUrl = br.readFieldString(6, true);
  this.merchantData = br.readFieldBytes(7, true);

  return this;
};

/**
 * Instantiate payment details from serialized data.
 * @param {Buffer} data
 * @returns {PaymentDetails}
 */

PaymentDetails.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new PaymentDetails().fromRaw(data);
};

/**
 * Serialize the payment details (protobuf).
 * @returns {Buffer}
 */

PaymentDetails.prototype.toRaw = function toRaw() {
  const bw = new ProtoWriter();

  if (this.network != null)
    bw.writeFieldString(1, this.network);

  for (const output of this.outputs) {
    const op = new ProtoWriter();
    op.writeFieldU64(1, output.value);
    op.writeFieldBytes(2, output.script.toRaw());
    bw.writeFieldBytes(2, op.render());
  }

  bw.writeFieldU64(3, this.time);

  if (this.expires !== -1)
    bw.writeFieldU64(4, this.expires);

  if (this.memo != null)
    bw.writeFieldString(5, this.memo);

  if (this.paymentUrl != null)
    bw.writeFieldString(6, this.paymentUrl);

  if (this.merchantData)
    bw.writeFieldString(7, this.merchantData);

  return bw.render();
};

/*
 * Expose
 */

module.exports = PaymentDetails;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * chaindb.js - blockchain data management for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const EventEmitter = __webpack_require__(10);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const Amount = __webpack_require__(20);
const encoding = __webpack_require__(3);
const Network = __webpack_require__(6);
const CoinView = __webpack_require__(30);
//const Coins = require('../coins/coins');
const UndoCoins = __webpack_require__(87);
const LDB = __webpack_require__(88);
const layout = __webpack_require__(204);
const LRU = __webpack_require__(56);
const Block = __webpack_require__(51);
const Outpoint = __webpack_require__(21);
const Address = __webpack_require__(11);
const ChainEntry = __webpack_require__(103);
const TXMeta = __webpack_require__(165);
const CoinEntry = __webpack_require__(50);
const U8 = encoding.U8;
const U32 = encoding.U32;

/**
 * The database backend for the {@link Chain} object.
 * @alias module:blockchain.ChainDB
 * @constructor
 * @param {Boolean?} options.prune - Whether to prune the chain.
 * @param {Boolean?} options.spv - SPV-mode, will not save block
 * data, only entries.
 * @param {String?} options.name - Database name
 * @param {String?} options.location - Database location
 * @param {String?} options.db - Database backend name
 * @property {Boolean} prune
 * @emits ChainDB#open
 * @emits ChainDB#error
 */

function ChainDB(options) {
  if (!(this instanceof ChainDB))
    return new ChainDB(options);

  EventEmitter.call(this);

  this.options = options;
  this.network = this.options.network;
  this.logger = this.options.logger.context('chaindb');

  this.db = LDB(this.options);
  this.stateCache = new StateCache(this.network);
  this.state = new ChainState();

  this.pending = null;
  this.current = null;

  this.coinCache = new LRU(this.options.coinCache, getSize);
  this.cacheHash = new LRU(this.options.entryCache);
  this.cacheHeight = new LRU(this.options.entryCache);
}

Object.setPrototypeOf(ChainDB.prototype, EventEmitter.prototype);

/**
 * Database layout.
 * @type {Object}
 */

ChainDB.layout = layout;

/**
 * Open the chain db, wait for the database to load.
 * @returns {Promise}
 */

ChainDB.prototype.open = async function open() {
  this.logger.info('Opening ChainDB...');

  await this.db.open();
  await this.db.checkVersion('V', 3);

  const state = await this.getState();

  if (state) {
    // Checking genesis block
    await this.checkGenesis();

    // Verify options have not changed.
    await this.verifyFlags(state);

    // Verify deployment params have not changed.
    await this.verifyDeployments();

    // Load state caches.
    this.stateCache = await this.getStateCache();

    // Grab the chainstate if we have one.
    this.state = state;

    this.logger.info('ChainDB successfully loaded.');
  } else {
    // Database is fresh.
    // Write initial state.
    await this.saveFlags();
    await this.saveDeployments();
    await this.saveGenesis();

    this.logger.info('ChainDB successfully initialized.');
  }

  this.logger.info(
    'Chain State: hash=%s tx=%d coin=%d value=%s.',
    this.state.rhash(),
    this.state.tx,
    this.state.coin,
    Amount.wmcc(this.state.value));
};

/**
 * Close the chain db, wait for the database to close.
 * @returns {Promise}
 */

ChainDB.prototype.close = function close() {
  return this.db.close();
};

/**
 * Start a batch.
 * @returns {Batch}
 */

ChainDB.prototype.start = function start() {
  assert(!this.current);
  assert(!this.pending);

  this.current = this.db.batch();
  this.pending = this.state.clone();

  this.coinCache.start();
  this.cacheHash.start();
  this.cacheHeight.start();

  return this.current;
};

/**
 * Put key and value to current batch.
 * @param {String} key
 * @param {Buffer} value
 */

ChainDB.prototype.put = function put(key, value) {
  assert(this.current);
  this.current.put(key, value);
};

/**
 * Delete key from current batch.
 * @param {String} key
 */

ChainDB.prototype.del = function del(key) {
  assert(this.current);
  this.current.del(key);
};

/**
 * Get current batch.
 * @returns {Batch}
 */

ChainDB.prototype.batch = function batch() {
  assert(this.current);
  return this.current;
};

/**
 * Drop current batch.
 * @returns {Batch}
 */

ChainDB.prototype.drop = function drop() {
  const batch = this.current;

  assert(this.current);
  assert(this.pending);

  this.current = null;
  this.pending = null;

  this.coinCache.drop();
  this.cacheHash.drop();
  this.cacheHeight.drop();
  this.stateCache.drop();

  batch.clear();
};

/**
 * Commit current batch.
 * @returns {Promise}
 */

ChainDB.prototype.commit = async function commit() {
  assert(this.current);
  assert(this.pending);

  try {
    await this.current.write();
  } catch (e) {
    this.current = null;
    this.pending = null;
    this.coinCache.drop();
    this.cacheHash.drop();
    this.cacheHeight.drop();
    throw e;
  }

  // Overwrite the entire state
  // with our new best state
  // only if it is committed.
  // Note that alternate chain
  // tips do not commit anything.
  if (this.pending.committed)
    this.state = this.pending;

  this.current = null;
  this.pending = null;

  this.coinCache.commit();
  this.cacheHash.commit();
  this.cacheHeight.commit();
  this.stateCache.commit();
};

/**
 * Test the cache for a present entry hash or height.
 * @param {Hash|Number} block - Hash or height.
 */

ChainDB.prototype.hasCache = function hasCache(block) {
  if (typeof block === 'number')
    return this.cacheHeight.has(block);

  assert(typeof block === 'string');

  return this.cacheHash.has(block);
};

/**
 * Get an entry directly from the LRU cache.
 * @param {Hash|Number} block - Hash or height.
 */

ChainDB.prototype.getCache = function getCache(block) {
  if (typeof block === 'number')
    return this.cacheHeight.get(block);

  assert(typeof block === 'string');

  return this.cacheHash.get(block);
};

/**
 * Get the height of a block by hash.
 * @param {Hash} hash
 * @returns {Promise} - Returns Number.
 */

ChainDB.prototype.getHeight = async function getHeight(hash) {
  if (typeof hash === 'number')
    return hash;

  assert(typeof hash === 'string');

  if (hash === encoding.NULL_HASH)
    return -1;

  const entry = this.cacheHash.get(hash);

  if (entry)
    return entry.height;

  const height = await this.db.get(layout.h(hash));

  if (!height)
    return -1;

  return height.readUInt32LE(0, true);
};

/**
 * Get the hash of a block by height. Note that this
 * will only return hashes in the main chain.
 * @param {Number} height
 * @returns {Promise} - Returns {@link Hash}.
 */

ChainDB.prototype.getHash = async function getHash(height) {
  if (typeof height === 'string')
    return height;

  assert(typeof height === 'number');

  if (height < 0)
    return null;

  const entry = this.cacheHeight.get(height);

  if (entry)
    return entry.hash;

  const hash = await this.db.get(layout.H(height));

  if (!hash)
    return null;

  return hash.toString('hex');
};

/**
 * Retrieve a chain entry by height.
 * @param {Number} height
 * @returns {Promise} - Returns {@link ChainEntry}.
 */

ChainDB.prototype.getEntryByHeight = async function getEntryByHeight(height) {
  assert(typeof height === 'number');

  if (height < 0)
    return null;

  const cache = this.cacheHeight.get(height);

  if (cache)
    return cache;

  const data = await this.db.get(layout.H(height));

  if (!data)
    return null;

  const hash = data.toString('hex');

  const state = this.state;
  const entry = await this.getEntryByHash(hash);

  if (!entry)
    return null;

  // By the time getEntry has completed,
  // a reorg may have occurred. This entry
  // may not be on the main chain anymore.
  if (this.state === state)
    this.cacheHeight.set(entry.height, entry);

  return entry;
};

/**
 * Retrieve a chain entry by hash.
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link ChainEntry}.
 */

ChainDB.prototype.getEntryByHash = async function getEntryByHash(hash) {
  assert(typeof hash === 'string');

  if (hash === encoding.NULL_HASH)
    return null;

  const cache = this.cacheHash.get(hash);

  if (cache)
    return cache;

  const raw = await this.db.get(layout.e(hash));

  if (!raw)
    return null;

  const entry = ChainEntry.fromRaw(raw);

  // There's no efficient way to check whether
  // this is in the main chain or not, so
  // don't add it to the height cache.
  this.cacheHash.set(entry.hash, entry);

  return entry;
};

/**
 * Retrieve a chain entry.
 * @param {Number|Hash} block - Height or hash.
 * @returns {Promise} - Returns {@link ChainEntry}.
 */

ChainDB.prototype.getEntry = function getEntry(block) {
  if (typeof block === 'number')
    return this.getEntryByHeight(block);
  return this.getEntryByHash(block);
};

/**
 * Test whether the chain contains a block.
 * @param {Hash} hash
 * @returns {Promise} - Returns Boolean.
 */

ChainDB.prototype.hasEntry = async function hasEntry(hash) {
  const height = await this.getHeight(hash);
  return height !== -1;
};

/**
 * Get ancestor by `height`.
 * @param {ChainEntry} entry
 * @param {Number} height
 * @returns {Promise} - Returns ChainEntry.
 */

ChainDB.prototype.getAncestor = async function getAncestor(entry, height) {
  if (height < 0)
    return null;

  assert(height >= 0);
  assert(height <= entry.height);

  if (await this.isMainChain(entry))
    return await this.getEntryByHeight(height);

  while (entry.height !== height) {
    const cache = this.getPrevCache(entry);

    if (cache)
      entry = cache;
    else
      entry = await this.getPrevious(entry);

    assert(entry);
  }

  return entry;
};

/**
 * Get previous entry.
 * @param {ChainEntry} entry
 * @returns {Promise} - Returns ChainEntry.
 */

ChainDB.prototype.getPrevious = function getPrevious(entry) {
  return this.getEntryByHash(entry.prevBlock);
};

/**
 * Get previous cached entry.
 * @param {ChainEntry} entry
 * @returns {ChainEntry|null}
 */

ChainDB.prototype.getPrevCache = function getPrevCache(entry) {
  return this.cacheHash.get(entry.prevBlock) || null;
};

/**
 * Get next entry.
 * @param {ChainEntry} entry
 * @returns {Promise} - Returns ChainEntry.
 */

ChainDB.prototype.getNext = async function getNext(entry) {
  const hash = await this.getNextHash(entry.hash);

  if (!hash)
    return null;

  return await this.getEntryByHash(hash);
};

/**
 * Get next entry.
 * @param {ChainEntry} entry
 * @returns {Promise} - Returns ChainEntry.
 */

ChainDB.prototype.getNextEntry = async function getNextEntry(entry) {
  const next = await this.getEntryByHeight(entry.height + 1);

  if (!next)
    return null;

  // Not on main chain.
  if (next.prevBlock !== entry.hash)
    return null;

  return next;
};

/**
 * Retrieve the tip entry from the tip record.
 * @returns {Promise} - Returns {@link ChainEntry}.
 */

ChainDB.prototype.getTip = function getTip() {
  return this.getEntryByHash(this.state.tip);
};

/**
 * Retrieve the tip entry from the tip record.
 * @returns {Promise} - Returns {@link ChainState}.
 */

ChainDB.prototype.getState = async function getState() {
  const data = await this.db.get(layout.R);

  if (!data)
    return null;

  return ChainState.fromRaw(data);
};

/**
 * Write genesis block to database.
 * @returns {Promise}
 */

ChainDB.prototype.saveGenesis = async function saveGenesis() {
  const genesis = this.network.genesisBlock;
  const block = Block.fromRaw(genesis, 'hex');
  const entry = ChainEntry.fromBlock(block);

  this.logger.info('Writing genesis block to ChainDB.');

  await this.save(entry, block, this.verifyGenesis(block));
};

/**
 * Check genesis block txns.
 * @private
 * @param {Block} block
 * @returns {CoinView}.
 */

ChainDB.prototype.verifyGenesis = function verifyGenesis(block) {
  const view = new CoinView();

  if (block.txs.length > 1)
    throw new Error('Invalid number of transactions.');

  const tx = block.txs[0];
  view.addTX(tx, 0);

  return view;
};

/**
 * Check genesis block in database.
 * @returns {Promise}
 */

ChainDB.prototype.checkGenesis = async function checkGenesis() {
  const genesis = this.network.genesisBlock;
  const block = Block.fromRaw(genesis, 'hex');
  const entry = ChainEntry.fromBlock(block);
  const tx = await this.getTX(block.txs[0].hash('hex'));

  if (!tx)
    await this.putGenesis(block, entry);
};

/**
 * Write genesis block to database.
 * @returns {Promise}
 */

ChainDB.prototype.putGenesis = async function putGenesis(block, entry) {
  this.start();
  try {
    await this._putGenesis(block, entry);
  } catch (e) {
    this.drop();
    throw e;
  }
  await this.commit();
};

/**
 * Write genesis block to database without a batch.
 * @returns {Promise}
 */

ChainDB.prototype._putGenesis = async function _putGenesis(block, entry) {
  const view = this.verifyGenesis(block);

  this.logger.info('Rewriting genesis block to ChainDB.');

  // Connect block and save data.
  await this.saveBlock(entry, block, view);

  this.emit('rescan');
};

/**
 * Retrieve the database flags.
 * @returns {Promise} - Returns {@link ChainFlags}.
 */

ChainDB.prototype.getFlags = async function getFlags() {
  const data = await this.db.get(layout.O);

  if (!data)
    return null;

  return ChainFlags.fromRaw(data);
};

/**
 * Verify current options against db options.
 * @param {ChainState} state
 * @returns {Promise}
 */

ChainDB.prototype.verifyFlags = async function verifyFlags(state) {
  const options = this.options;
  const flags = await this.getFlags();
  let needsSave = false;
  let needsPrune = false;

  if (!flags)
    throw new Error('No flags found.');

  if (options.network !== flags.network)
    throw new Error('Network mismatch for chain.');

  if (options.spv && !flags.spv)
    throw new Error('Cannot retroactively enable SPV.');

  if (!options.spv && flags.spv)
    throw new Error('Cannot retroactively disable SPV.');

  if (!flags.witness) {
    if (!options.forceFlags)
      throw new Error('Cannot retroactively enable witness.');
    needsSave = true;
  }

  if (options.bip91 !== flags.bip91) {
    if (!options.forceFlags)
      throw new Error('Cannot retroactively alter BIP91 flag.');
    needsSave = true;
  }

  if (options.bip148 !== flags.bip148) {
    if (!options.forceFlags)
      throw new Error('Cannot retroactively alter BIP148 flag.');
    needsSave = true;
  }

  if (options.prune && !flags.prune) {
    if (!options.forceFlags)
      throw new Error('Cannot retroactively prune.');
    needsPrune = true;
  }

  if (!options.prune && flags.prune)
    throw new Error('Cannot retroactively unprune.');

  if (options.indexTX && !flags.indexTX)
    throw new Error('Cannot retroactively enable TX indexing.');

  if (!options.indexTX && flags.indexTX)
    throw new Error('Cannot retroactively disable TX indexing.');

  if (options.indexAddress && !flags.indexAddress)
    throw new Error('Cannot retroactively enable address indexing.');

  if (!options.indexAddress && flags.indexAddress)
    throw new Error('Cannot retroactively disable address indexing.');

  if (needsSave) {
    await this.logger.info('Rewriting chain flags.');
    await this.saveFlags();
  }

  if (needsPrune) {
    await this.logger.info('Retroactively pruning chain.');
    await this.prune(state.tip);
  }
};

/**
 * Get state caches.
 * @returns {Promise} - Returns {@link StateCache}.
 */

ChainDB.prototype.getStateCache = async function getStateCache() {
  const stateCache = new StateCache(this.network);

  const items = await this.db.range({
    gte: layout.v(0, encoding.ZERO_HASH),
    lte: layout.v(255, encoding.MAX_HASH),
    values: true
  });

  for (const item of items) {
    const [bit, hash] = layout.vv(item.key);
    const state = item.value[0];
    stateCache.insert(bit, hash, state);
  }

  return stateCache;
};

/**
 * Save deployment table.
 * @returns {Promise}
 */

ChainDB.prototype.saveDeployments = function saveDeployments() {
  const batch = this.db.batch();
  this.writeDeployments(batch);
  return batch.write();
};

/**
 * Save deployment table.
 * @returns {Promise}
 */

ChainDB.prototype.writeDeployments = function writeDeployments(batch) {
  const bw = new StaticWriter(1 + 17 * this.network.deploys.length);

  bw.writeU8(this.network.deploys.length);

  for (const deployment of this.network.deploys) {
    bw.writeU8(deployment.bit);
    bw.writeU32(deployment.startTime);
    bw.writeU32(deployment.timeout);
    bw.writeI32(deployment.threshold);
    bw.writeI32(deployment.window);
  }

  batch.put(layout.V, bw.render());
};

/**
 * Check for outdated deployments.
 * @private
 * @returns {Promise}
 */

ChainDB.prototype.checkDeployments = async function checkDeployments() {
  const raw = await this.db.get(layout.V);

  assert(raw, 'No deployment table found.');

  const br = new BufferReader(raw);
  const count = br.readU8();
  const invalid = [];

  for (let i = 0; i < count; i++) {
    const bit = br.readU8();
    const start = br.readU32();
    const timeout = br.readU32();
    const threshold = br.readI32();
    const window = br.readI32();
    const deployment = this.network.byBit(bit);

    if (deployment
        && start === deployment.startTime
        && timeout === deployment.timeout
        && threshold === deployment.threshold
        && window === deployment.window) {
      continue;
    }

    invalid.push(bit);
  }

  return invalid;
};

/**
 * Potentially invalidate state cache.
 * @returns {Promise}
 */

ChainDB.prototype.verifyDeployments = async function verifyDeployments() {
  let invalid;

  try {
    invalid = await this.checkDeployments();
  } catch (e) {
    if (e.type !== 'EncodingError')
      throw e;
    invalid = [];
    for (let i = 0; i < 32; i++)
      invalid.push(i);
  }

  if (invalid.length === 0)
    return true;

  const batch = this.db.batch();

  for (const bit of invalid) {
    this.logger.warning('Versionbit deployment params modified.');
    this.logger.warning('Invalidating cache for bit %d.', bit);
    await this.invalidateCache(bit, batch);
  }

  this.writeDeployments(batch);

  await batch.write();

  return false;
};

/**
 * Invalidate state cache.
 * @private
 * @returns {Promise}
 */

ChainDB.prototype.invalidateCache = async function invalidateCache(bit, batch) {
  const keys = await this.db.keys({
    gte: layout.v(bit, encoding.ZERO_HASH),
    lte: layout.v(bit, encoding.MAX_HASH)
  });

  for (const key of keys)
    batch.del(key);
};

/**
 * Retroactively prune the database.
 * @returns {Promise}
 */

ChainDB.prototype.prune = async function prune() {
  const options = this.options;
  const keepBlocks = this.network.block.keepBlocks;
  const pruneAfter = this.network.block.pruneAfterHeight;

  const flags = await this.getFlags();

  if (flags.prune)
    throw new Error('Chain is already pruned.');

  const height = await this.getHeight(this.state.tip);

  if (height <= pruneAfter + keepBlocks)
    return false;

  const start = pruneAfter + 1;
  const end = height - keepBlocks;
  const batch = this.db.batch();

  for (let i = start; i <= end; i++) {
    const hash = await this.getHash(i);

    if (!hash)
      throw new Error(`Cannot find hash for ${i}.`);

    batch.del(layout.b(hash));
    batch.del(layout.u(hash));
  }

  try {
    options.prune = true;

    const flags = ChainFlags.fromOptions(options);
    assert(flags.prune);

    batch.put(layout.O, flags.toRaw());

    await batch.write();
  } catch (e) {
    options.prune = false;
    throw e;
  }

  await this.db.compactRange();

  return true;
};

/**
 * Get the _next_ block hash (does not work by height).
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link Hash}.
 */

ChainDB.prototype.getNextHash = async function getNextHash(hash) {
  const data = await this.db.get(layout.n(hash));

  if (!data)
    return null;

  return data.toString('hex');
};

/**
 * Check to see if a block is on the main chain.
 * @param {Hash} hash
 * @returns {Promise} - Returns Boolean.
 */

ChainDB.prototype.isMainHash = async function isMainHash(hash) {
  assert(typeof hash === 'string');

  if (hash === encoding.NULL_HASH)
    return false;

  if (hash === this.network.genesis.hash)
    return true;

  if (hash === this.state.tip)
    return true;

  const cacheHash = this.cacheHash.get(hash);

  if (cacheHash) {
    const cacheHeight = this.cacheHeight.get(cacheHash.height);
    if (cacheHeight)
      return cacheHeight.hash === hash;
  }

  if (await this.getNextHash(hash))
    return true;

  return false;
};

/**
 * Test whether the entry is in the main chain.
 * @param {ChainEntry} entry
 * @returns {Promise} - Returns Boolean.
 */

ChainDB.prototype.isMainChain = async function isMainChain(entry) {
  if (entry.isGenesis())
    return true;

  if (entry.hash === this.state.tip)
    return true;

  const cache = this.getCache(entry.height);

  if (cache)
    return entry.hash === cache.hash;

  if (await this.getNextHash(entry.hash))
    return true;

  return false;
};

/**
 * Get all entries.
 * @returns {Promise} - Returns {@link ChainEntry}[].
 */

ChainDB.prototype.getEntries = function getEntries() {
  return this.db.values({
    gte: layout.e(encoding.ZERO_HASH),
    lte: layout.e(encoding.MAX_HASH),
    parse: value => ChainEntry.fromRaw(value)
  });
};

/**
 * Get all tip hashes.
 * @returns {Promise} - Returns {@link Hash}[].
 */

ChainDB.prototype.getTips = function getTips() {
  return this.db.keys({
    gte: layout.p(encoding.ZERO_HASH),
    lte: layout.p(encoding.MAX_HASH),
    parse: layout.pp
  });
};

/**
 * Get a coin (unspents only).
 * @private
 * @param {Outpoint} prevout
 * @returns {Promise} - Returns {@link CoinEntry}.
 */

ChainDB.prototype.readCoin = async function readCoin(prevout) {
  if (this.options.spv)
    return null;

  const {hash, index} = prevout;
  const key = prevout.toKey();
  const state = this.state;

  const cache = this.coinCache.get(key);

  if (cache)
    return CoinEntry.fromRaw(cache);

  const raw = await this.db.get(layout.c(hash, index));

  if (!raw)
    return null;

  if (state === this.state)
    this.coinCache.set(key, raw);

  return CoinEntry.fromRaw(raw);
};

/**
 * Get a coin (unspents only).
 * @param {Hash} hash
 * @param {Number} index
 * @returns {Promise} - Returns {@link Coin}.
 */

ChainDB.prototype.getCoin = async function getCoin(hash, index) {
  const prevout = new Outpoint(hash, index);
  const coin = await this.readCoin(prevout);

  if (!coin)
    return null;

  return coin.toCoin(prevout);
};

/**
 * Check whether coins are still unspent. Necessary for bip30.
 * @see https://bitcointalk.org/index.php?topic=67738.0
 * @param {TX} tx
 * @returns {Promise} - Returns Boolean.
 */

ChainDB.prototype.hasCoins = async function hasCoins(tx) {
  for (let i = 0; i < tx.outputs.length; i++) {
    const key = layout.c(tx.hash(), i);
    if (await this.db.has(key))
      return true;
  }
  return false;
};

/**
 * Get coin viewpoint.
 * @param {TX} tx
 * @returns {Promise} - Returns {@link CoinView}.
 */

ChainDB.prototype.getCoinView = async function getCoinView(tx) {
  const view = new CoinView();

  for (const {prevout} of tx.inputs) {
    const coin = await this.readCoin(prevout);

    /*if (!coin) {
      const coins = new Coins();
      view.add(prevout.hash, coins);
      continue;
    }

    view.addEntry(prevout, coin);*/
    if (coin)
      view.addEntry(prevout, coin);
  }

  return view;
};

/**
 * Get coin viewpoint (historical).
 * @param {TX} tx
 * @returns {Promise} - Returns {@link CoinView}.
 */

ChainDB.prototype.getSpentView = async function getSpentView(tx) {
  const view = await this.getCoinView(tx);

  //for (const [hash, coins] of view.map) {
    //if (!coins.isEmpty())
  for (const {prevout} of tx.inputs) {
    if (view.hasEntry(prevout))
      continue;

    const {hash, index} = prevout;
    const meta = await this.getMeta(hash);

    if (!meta)
      continue;

    //view.addTX(meta.tx, meta.height);
    const {tx, height} = meta;

    if (index < tx.outputs.length)
      view.addIndex(tx, index, height);
  }

  return view;
};

/**
 * Get coins necessary to be resurrected during a reorg.
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link Coin}[].
 */

ChainDB.prototype.getUndoCoins = async function getUndoCoins(hash) {
  const data = await this.db.get(layout.u(hash));

  if (!data)
    return new UndoCoins();

  return UndoCoins.fromRaw(data);
};

/**
 * Retrieve a block from the database (not filled with coins).
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link Block}.
 */

ChainDB.prototype.getBlock = async function getBlock(hash) {
  const data = await this.getRawBlock(hash);

  if (!data)
    return null;

  return Block.fromRaw(data);
};

/**
 * Retrieve a block from the database (not filled with coins).
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link Block}.
 */

ChainDB.prototype.getRawBlock = async function getRawBlock(block) {
  if (this.options.spv)
    return null;

  const hash = await this.getHash(block);

  if (!hash)
    return null;

  return await this.db.get(layout.b(hash));
};

/**
 * Get a historical block coin viewpoint.
 * @param {Block} hash
 * @returns {Promise} - Returns {@link CoinView}.
 */

ChainDB.prototype.getBlockView = async function getBlockView(block) {
  const view = new CoinView();
  const undo = await this.getUndoCoins(block.hash());

  if (undo.isEmpty())
    return view;

  for (let i = block.txs.length - 1; i > 0; i--) {
    const tx = block.txs[i];

    for (let j = tx.inputs.length - 1; j >= 0; j--) {
      const input = tx.inputs[j];
      undo.apply(view, input.prevout);
    }
  }

  // Undo coins should be empty.
  assert(undo.isEmpty(), 'Undo coins data inconsistency.');

  return view;
};

/**
 * Get a transaction with metadata.
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link TXMeta}.
 */

ChainDB.prototype.getMeta = async function getMeta(hash) {
  if (!this.options.indexTX)
    return null;

  const data = await this.db.get(layout.t(hash));

  if (!data)
    return null;

  return TXMeta.fromRaw(data);
};

/**
 * Retrieve a transaction.
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link TX}.
 */

ChainDB.prototype.getTX = async function getTX(hash) {
  const meta = await this.getMeta(hash);

  if (!meta)
    return null;

  return meta.tx;
};

/**
 * @param {Hash} hash
 * @returns {Promise} - Returns Boolean.
 */

ChainDB.prototype.hasTX = async function hasTX(hash) {
  if (!this.options.indexTX)
    return false;

  return await this.db.has(layout.t(hash));
};

/**
 * Get all coins pertinent to an address.
 * @param {Address[]} addrs
 * @param {Number} height after
 * @returns {Promise} - Returns {@link Coin}[].
 */

ChainDB.prototype.getCoinsByAddress = async function getCoinsByAddress(addrs, after) {
  if (!this.options.indexAddress)
    return [];

  if (!Array.isArray(addrs))
    addrs = [addrs];

  const coins = [];

  for (const addr of addrs) {
    const hash = Address.getHash(addr);

    const keys = await this.db.keys({
      gte: layout.C(hash, encoding.ZERO_HASH, 0),
      lte: layout.C(hash, encoding.MAX_HASH, 0xffffffff),
      parse: layout.Cc
    });

    for (const [hash, index] of keys) {
      const coin = await this.getCoin(hash, index);
      assert(coin);
      if (after) {
        assert(typeof after === 'number');
        if (coin.height <= after)
          continue;
      }

      coins.push(coin);
    }
  }

  return coins;
};

/**
 * Get all transaction hashes to an address.
 * @param {Address[]} addrs
 * @returns {Promise} - Returns {@link Hash}[].
 */

ChainDB.prototype.getHashesByAddress = async function getHashesByAddress(addrs) {
  if (!this.options.indexTX || !this.options.indexAddress)
    return [];

  const hashes = Object.create(null);

  for (const addr of addrs) {
    const hash = Address.getHash(addr);

    await this.db.keys({
      gte: layout.T(hash, encoding.ZERO_HASH),
      lte: layout.T(hash, encoding.MAX_HASH),
      parse: (key) => {
        const hash = layout.Tt(key);
        hashes[hash] = true;
      }
    });
  }

  return Object.keys(hashes);
};

/**
 * Get all transactions pertinent to an address.
 * @param {Address[]} addrs
 * @returns {Promise} - Returns {@link TX}[].
 */

ChainDB.prototype.getTXByAddress = async function getTXByAddress(addrs) {
  const mtxs = await this.getMetaByAddress(addrs);
  const out = [];

  for (const mtx of mtxs)
    out.push(mtx.tx);

  return out;
};

/**
 * Get all transactions pertinent to an address.
 * @param {Address[]} addrs
 * @returns {Promise} - Returns {@link TXMeta}[].
 */

ChainDB.prototype.getMetaByAddress = async function getMetaByAddress(addrs) {
  if (!this.options.indexTX || !this.options.indexAddress)
    return [];

  if (!Array.isArray(addrs))
    addrs = [addrs];

  const hashes = await this.getHashesByAddress(addrs);
  const txs = [];

  for (const hash of hashes) {
    const tx = await this.getMeta(hash);
    assert(tx);
    txs.push(tx);
  }

  return txs;
};

/**
 * Scan the blockchain for transactions containing specified address hashes.
 * @param {Hash} start - Block hash to start at.
 * @param {Bloom} filter - Bloom filter containing tx and address hashes.
 * @param {Function} iter - Iterator.
 * @returns {Promise}
 */

ChainDB.prototype.scan = async function scan(start, filter, iter) {
  if (start == null)
    start = this.network.genesis.hash;

  if (typeof start === 'number')
    this.logger.info('Scanning from height %d.', start);
  else
    this.logger.info('Scanning from block %s.', util.revHex(start));

  let entry = await this.getEntry(start);

  if (!entry)
    return;

  if (!await this.isMainChain(entry))
    throw new Error('Cannot rescan an alternate chain.');

  let total = 0;

  while (entry) {
    const block = await this.getBlock(entry.hash);
    const txs = [];

    total++;

    if (!block) {
      if (!this.options.spv && !this.options.prune)
        throw new Error('Block not found.');
      await iter(entry, txs);
      entry = await this.getNext(entry);
      continue;
    }

    this.emit('block scan', entry.rhash(), entry.height);

    this.logger.info(
      'Scanning block %s (%d).',
      entry.rhash(), entry.height);

    for (let i = 0; i < block.txs.length; i++) {
      const tx = block.txs[i];
      let found = false;

      for (let j = 0; j < tx.outputs.length; j++) {
        const output = tx.outputs[j];
        const hash = output.getHash();

        if (!hash)
          continue;

        if (filter.test(hash)) {
          const prevout = Outpoint.fromTX(tx, j);
          filter.add(prevout.toRaw());
          found = true;
        }
      }

      if (found) {
        txs.push(tx);
        continue;
      }

      if (i === 0)
        continue;

      for (const {prevout} of tx.inputs) {
        if (filter.test(prevout.toRaw())) {
          txs.push(tx);
          break;
        }
      }
    }

    await iter(entry, txs);

    entry = await this.getNext(entry);
  }

  this.logger.info('Finished scanning %d blocks.', total);
};

/**
 * Save an entry to the database and optionally
 * connect it as the tip. Note that this method
 * does _not_ perform any verification which is
 * instead performed in {@link Chain#add}.
 * @param {ChainEntry} entry
 * @param {Block} block
 * @param {CoinView?} view - Will not connect if null.
 * @returns {Promise}
 */

ChainDB.prototype.save = async function save(entry, block, view) {
  this.start();
  try {
    await this._save(entry, block, view);
  } catch (e) {
    this.drop();
    throw e;
  }
  await this.commit();
};

/**
 * Save an entry without a batch.
 * @private
 * @param {ChainEntry} entry
 * @param {Block} block
 * @param {CoinView?} view
 * @returns {Promise}
 */

ChainDB.prototype._save = async function _save(entry, block, view) {
  const hash = block.hash();

  // Hash->height index.
  this.put(layout.h(hash), U32(entry.height));

  // Entry data.
  this.put(layout.e(hash), entry.toRaw());
  this.cacheHash.push(entry.hash, entry);

  // Tip index.
  this.del(layout.p(entry.prevBlock));
  this.put(layout.p(hash), null);

  // Update state caches.
  this.saveUpdates();

  if (!view) {
    // Save block data.
    await this.saveBlock(entry, block);
    return;
  }

  // Hash->next-block index.
  if (!entry.isGenesis())
    this.put(layout.n(entry.prevBlock), hash);

  // Height->hash index.
  this.put(layout.H(entry.height), hash);
  this.cacheHeight.push(entry.height, entry);

  // Connect block and save data.
  await this.saveBlock(entry, block, view);

  // Commit new chain state.
  this.put(layout.R, this.pending.commit(hash));
};

/**
 * Reconnect the block to the chain.
 * @param {ChainEntry} entry
 * @param {Block} block
 * @param {CoinView} view
 * @returns {Promise}
 */

ChainDB.prototype.reconnect = async function reconnect(entry, block, view) {
  this.start();
  try {
    await this._reconnect(entry, block, view);
  } catch (e) {
    this.drop();
    throw e;
  }
  await this.commit();
};

/**
 * Reconnect block without a batch.
 * @private
 * @param {ChainEntry} entry
 * @param {Block} block
 * @param {CoinView} view
 * @returns {Promise}
 */

ChainDB.prototype._reconnect = async function _reconnect(entry, block, view) {
  const hash = block.hash();

  assert(!entry.isGenesis());

  // We can now add a hash->next-block index.
  this.put(layout.n(entry.prevBlock), hash);

  // We can now add a height->hash index.
  this.put(layout.H(entry.height), hash);
  this.cacheHeight.push(entry.height, entry);

  // Re-insert into cache.
  this.cacheHash.push(entry.hash, entry);

  // Update state caches.
  this.saveUpdates();

  // Connect inputs.
  await this.connectBlock(entry, block, view);

  // Update chain state.
  this.put(layout.R, this.pending.commit(hash));
};

/**
 * Disconnect block from the chain.
 * @param {ChainEntry} entry
 * @param {Block} block
 * @returns {Promise}
 */

ChainDB.prototype.disconnect = async function disconnect(entry, block) {
  this.start();

  let view;
  try {
    view = await this._disconnect(entry, block);
  } catch (e) {
    this.drop();
    throw e;
  }

  await this.commit();

  return view;
};

/**
 * Disconnect block without a batch.
 * @private
 * @param {ChainEntry} entry
 * @param {Block} block
 * @returns {Promise} - Returns {@link CoinView}.
 */

ChainDB.prototype._disconnect = async function _disconnect(entry, block) {
  // Remove hash->next-block index.
  this.del(layout.n(entry.prevBlock));

  // Remove height->hash index.
  this.del(layout.H(entry.height));
  this.cacheHeight.unpush(entry.height);

  // Update state caches.
  this.saveUpdates();

  // Disconnect inputs.
  const view = await this.disconnectBlock(entry, block);

  // Revert chain state to previous tip.
  this.put(layout.R, this.pending.commit(entry.prevBlock));

  return view;
};

/**
 * Save state cache updates.
 * @private
 */

ChainDB.prototype.saveUpdates = function saveUpdates() {
  const updates = this.stateCache.updates;

  if (updates.length === 0)
    return;

  this.logger.info('Saving %d state cache updates.', updates.length);

  for (const update of updates) {
    const {bit, hash} = update;
    this.put(layout.v(bit, hash), update.toRaw());
  }
};

/**
 * Reset the chain to a height or hash. Useful for replaying
 * the blockchain download for SPV.
 * @param {Hash|Number} block - hash/height
 * @returns {Promise}
 */

ChainDB.prototype.reset = async function reset(block) {
  const entry = await this.getEntry(block);

  if (!entry)
    throw new Error('Block not found.');

  if (!await this.isMainChain(entry))
    throw new Error('Cannot reset on alternate chain.');

  if (this.options.prune)
    throw new Error('Cannot reset when pruned.');

  // We need to remove all alternate
  // chains first. This is ugly, but
  // it's the only safe way to reset
  // the chain.
  await this.removeChains();

  let tip = await this.getTip();
  assert(tip);

  this.logger.debug('Resetting main chain to: %s', entry.rhash());

  for (;;) {
    this.start();

    // Stop once we hit our target tip.
    if (tip.hash === entry.hash) {
      this.put(layout.R, this.pending.commit(tip.hash));
      await this.commit();
      break;
    }

    assert(!tip.isGenesis());

    // Revert the tip index.
    this.del(layout.p(tip.hash));
    this.put(layout.p(tip.prevBlock), null);

    // Remove all records (including
    // main-chain-only records).
    this.del(layout.H(tip.height));
    this.del(layout.h(tip.hash));
    this.del(layout.e(tip.hash));
    this.del(layout.n(tip.prevBlock));

    // Disconnect and remove block data.
    try {
      await this.removeBlock(tip);
    } catch (e) {
      this.drop();
      throw e;
    }

    // Revert chain state to previous tip.
    this.put(layout.R, this.pending.commit(tip.prevBlock));

    await this.commit();

    // Update caches _after_ successful commit.
    this.cacheHeight.remove(tip.height);
    this.cacheHash.remove(tip.hash);

    tip = await this.getPrevious(tip);
    assert(tip);
  }

  return tip;
};

/**
 * Remove all alternate chains.
 * @returns {Promise}
 */

ChainDB.prototype.removeChains = async function removeChains() {
  const tips = await this.getTips();

  // Note that this has to be
  // one giant atomic write!
  this.start();

  try {
    for (const tip of tips)
      await this._removeChain(tip);
  } catch (e) {
    this.drop();
    throw e;
  }

  await this.commit();
};

/**
 * Remove an alternate chain.
 * @private
 * @param {Hash} hash - Alternate chain tip.
 * @returns {Promise}
 */

ChainDB.prototype._removeChain = async function _removeChain(hash) {
  let tip = await this.getEntryByHash(hash);

  if (!tip)
    throw new Error('Alternate chain tip not found.');

  this.logger.debug('Removing alternate chain: %s.', tip.rhash());

  for (;;) {
    if (await this.isMainChain(tip))
      break;

    assert(!tip.isGenesis());

    // Remove all non-main-chain records.
    this.del(layout.p(tip.hash));
    this.del(layout.h(tip.hash));
    this.del(layout.e(tip.hash));
    this.del(layout.b(tip.hash));

    // Queue up hash to be removed
    // on successful write.
    this.cacheHash.unpush(tip.hash);

    tip = await this.getPrevious(tip);
    assert(tip);
  }
};

/**
 * Save a block (not an entry) to the
 * database and potentially connect the inputs.
 * @param {ChainEntry} entry
 * @param {Block} block
 * @param {CoinView?} view
 * @returns {Promise} - Returns {@link Block}.
 */

ChainDB.prototype.saveBlock = async function saveBlock(entry, block, view) {
  const hash = block.hash();

  if (this.options.spv)
    return;

  // Write actual block data (this may be
  // better suited to flat files in the future).
  this.put(layout.b(hash), block.toRaw());

  if (!view)
    return;

  await this.connectBlock(entry, block, view);
};

/**
 * Remove a block (not an entry) to the database.
 * Disconnect inputs.
 * @param {ChainEntry} entry
 * @returns {Promise} - Returns {@link Block}.
 */

ChainDB.prototype.removeBlock = async function removeBlock(entry) {
  if (this.options.spv)
    return new CoinView();

  const block = await this.getBlock(entry.hash);

  if (!block)
    throw new Error('Block not found.');

  this.del(layout.b(block.hash()));

  return await this.disconnectBlock(entry, block);
};

/**
 * Commit coin view to database.
 * @private
 * @param {CoinView} view
 */

ChainDB.prototype.saveView = function saveView(view) {
  for (const [hash, coins] of view.map) {
    for (const [index, coin] of coins.outputs) {
      if (coin.spent) {
        this.del(layout.c(hash, index));
        this.coinCache.unpush(hash + index);
        continue;
      }

      const raw = coin.toRaw();

      this.put(layout.c(hash, index), raw);
      this.coinCache.push(hash + index, raw);
    }
  }
};

/**
 * Connect block inputs.
 * @param {ChainEntry} entry
 * @param {Block} block
 * @param {CoinView} view
 * @returns {Promise} - Returns {@link Block}.
 */

ChainDB.prototype.connectBlock = async function connectBlock(entry, block, view) {
  if (this.options.spv)
    return;

  const hash = block.hash();

  this.pending.connect(block);

  // Genesis block's coinbase is unspendable.
  //if (entry.isGenesis())
  //  return;

  // Update chain state value.
  for (let i = 0; i < block.txs.length; i++) {
    const tx = block.txs[i];

    if (i > 0) {
      for (const {prevout} of tx.inputs)
        this.pending.spend(view.getOutput(prevout));
    }

    for (const output of tx.outputs) {
      if (output.script.isUnspendable())
        continue;

      this.pending.add(output);
    }

    // Index the transaction if enabled.
    this.indexTX(tx, view, entry, i);
  }

  // Commit new coin state.
  this.saveView(view);

  // Write undo coins (if there are any).
  if (!view.undo.isEmpty())
    this.put(layout.u(hash), view.undo.commit());

  // Prune height-288 if pruning is enabled.
  await this.pruneBlock(entry);
};

/**
 * Disconnect block inputs.
 * @param {ChainEntry} entry
 * @param {Block} block
 * @returns {Promise} - Returns {@link CoinView}.
 */

ChainDB.prototype.disconnectBlock = async function disconnectBlock(entry, block) {
  const view = new CoinView();

  if (this.options.spv)
    return view;

  const hash = block.hash();
  const undo = await this.getUndoCoins(hash);

  this.pending.disconnect(block);

  // Disconnect all transactions.
  for (let i = block.txs.length - 1; i >= 0; i--) {
    const tx = block.txs[i];

    if (i > 0) {
      for (let j = tx.inputs.length - 1; j >= 0; j--) {
        const {prevout} = tx.inputs[j];
        undo.apply(view, prevout);
        this.pending.add(view.getOutput(prevout));
      }
    }

    // Remove any created coins.
    view.removeTX(tx, entry.height);

    for (let j = tx.outputs.length - 1; j >= 0; j--) {
      const output = tx.outputs[j];

      if (output.script.isUnspendable())
        continue;

      this.pending.spend(output);
    }

    // Remove from transaction index.
    this.unindexTX(tx, view);
  }

  // Undo coins should be empty.
  assert(undo.isEmpty(), 'Undo coins data inconsistency.');

  // Commit new coin state.
  this.saveView(view);

  // Remove undo coins.
  this.del(layout.u(hash));

  return view;
};

/**
 * Prune a block from the chain and
 * add current block to the prune queue.
 * @private
 * @param {ChainEntry} entry
 * @returns {Promise}
 */

ChainDB.prototype.pruneBlock = async function pruneBlock(entry) {
  if (this.options.spv)
    return;

  if (!this.options.prune)
    return;

  const height = entry.height - this.network.block.keepBlocks;

  if (height <= this.network.block.pruneAfterHeight)
    return;

  const hash = await this.getHash(height);

  if (!hash)
    return;

  this.del(layout.b(hash));
  this.del(layout.u(hash));
};

/**
 * Save database options.
 * @returns {Promise}
 */

ChainDB.prototype.saveFlags = function saveFlags() {
  const flags = ChainFlags.fromOptions(this.options);
  return this.db.put(layout.O, flags.toRaw());
};

/**
 * Index a transaction by txid and address.
 * @private
 * @param {TX} tx
 * @param {CoinView} view
 * @param {ChainEntry} entry
 * @param {Number} index
 */

ChainDB.prototype.indexTX = function indexTX(tx, view, entry, index) {
  const hash = tx.hash();

  if (this.options.indexTX) {
    const meta = TXMeta.fromTX(tx, entry, index);

    this.put(layout.t(hash), meta.toRaw());

    if (this.options.indexAddress) {
      const hashes = tx.getHashes(view);
      for (const addr of hashes)
        this.put(layout.T(addr, hash), null);
    }
  }

  if (!this.options.indexAddress)
    return;

  if (!tx.isCoinbase()) {
    for (const {prevout} of tx.inputs) {
      const addr = view.getOutput(prevout).getHash();

      if (!addr)
        continue;

      this.del(layout.C(addr, prevout.hash, prevout.index));
    }
  }

  for (let i = 0; i < tx.outputs.length; i++) {
    const output = tx.outputs[i];
    const addr = output.getHash();

    if (!addr)
      continue;

    this.put(layout.C(addr, hash, i), null);
  }
};

/**
 * Remove transaction from index.
 * @private
 * @param {TX} tx
 * @param {CoinView} view
 */

ChainDB.prototype.unindexTX = function unindexTX(tx, view) {
  const hash = tx.hash();

  if (this.options.indexTX) {
    this.del(layout.t(hash));
    if (this.options.indexAddress) {
      const hashes = tx.getHashes(view);
      for (const addr of hashes)
        this.del(layout.T(addr, hash));
    }
  }

  if (!this.options.indexAddress)
    return;

  if (!tx.isCoinbase()) {
    for (const {prevout} of tx.inputs) {
      const addr = view.getOutput(prevout).getHash();

      if (!addr)
        continue;

      this.put(layout.C(addr, prevout.hash, prevout.index), null);
    }
  }

  for (let i = 0; i < tx.outputs.length; i++) {
    const output = tx.outputs[i];
    const addr = output.getHash();

    if (!addr)
      continue;

    this.del(layout.C(addr, hash, i));
  }
};

/**
 * Chain Flags
 * @alias module:blockchain.ChainFlags
 * @constructor
 */

function ChainFlags(options) {
  if (!(this instanceof ChainFlags))
    return new ChainFlags(options);

  this.network = Network.primary;
  this.spv = false;
  this.witness = true;
  this.bip91 = false;
  this.bip148 = false;
  this.prune = false;
  this.indexTX = true;
  this.indexAddress = true;

  if (options)
    this.fromOptions(options);
}

ChainFlags.prototype.fromOptions = function fromOptions(options) {
  this.network = Network.get(options.network);

  if (options.spv != null) {
    assert(typeof options.spv === 'boolean');
    this.spv = options.spv;
  }

  if (options.bip91 != null) {
    assert(typeof options.bip91 === 'boolean');
    this.bip91 = options.bip91;
  }

  if (options.bip148 != null) {
    assert(typeof options.bip148 === 'boolean');
    this.bip148 = options.bip148;
  }

  if (options.prune != null) {
    assert(typeof options.prune === 'boolean');
    this.prune = options.prune;
  }

  if (options.indexTX != null) {
    assert(typeof options.indexTX === 'boolean');
    this.indexTX = options.indexTX;
  }

  if (options.indexAddress != null) {
    assert(typeof options.indexAddress === 'boolean');
    this.indexAddress = options.indexAddress;
  }

  return this;
};

ChainFlags.fromOptions = function fromOptions(data) {
  return new ChainFlags().fromOptions(data);
};

ChainFlags.prototype.toRaw = function toRaw() {
  const bw = new StaticWriter(12);
  let flags = 0;

  if (this.spv)
    flags |= 1 << 0;

  if (this.witness)
    flags |= 1 << 1;

  if (this.prune)
    flags |= 1 << 2;

  if (this.indexTX)
    flags |= 1 << 3;

  if (this.indexAddress)
    flags |= 1 << 4;

  if (this.bip91)
    flags |= 1 << 5;

  if (this.bip148)
    flags |= 1 << 6;

  bw.writeU32(this.network.magic);
  bw.writeU32(flags);
  bw.writeU32(0);

  return bw.render();
};

ChainFlags.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data);

  this.network = Network.fromMagic(br.readU32());

  const flags = br.readU32();

  this.spv = (flags & 1) !== 0;
  this.witness = (flags & 2) !== 0;
  this.prune = (flags & 4) !== 0;
  this.indexTX = (flags & 8) !== 0;
  this.indexAddress = (flags & 16) !== 0;
  this.bip91 = (flags & 32) !== 0;
  this.bip148 = (flags & 64) !== 0;

  return this;
};

ChainFlags.fromRaw = function fromRaw(data) {
  return new ChainFlags().fromRaw(data);
};

/**
 * Chain State
 * @alias module:blockchain.ChainState
 * @constructor
 */

function ChainState() {
  this.tip = encoding.NULL_HASH;
  this.tx = 0;
  this.coin = 0;
  this.value = 0;
  this.committed = false;
}

ChainState.prototype.rhash = function rhash() {
  return util.revHex(this.tip);
};

ChainState.prototype.clone = function clone() {
  const state = new ChainState();
  state.tip = this.tip;
  state.tx = this.tx;
  state.coin = this.coin;
  state.value = this.value;
  return state;
};

ChainState.prototype.connect = function connect(block) {
  this.tx += block.txs.length;
};

ChainState.prototype.disconnect = function disconnect(block) {
  this.tx -= block.txs.length;
};

ChainState.prototype.add = function add(coin) {
  this.coin++;
  this.value += coin.value;
};

ChainState.prototype.spend = function spend(coin) {
  this.coin--;
  this.value -= coin.value;
};

ChainState.prototype.commit = function commit(hash) {
  if (typeof hash !== 'string')
    hash = hash.toString('hex');
  this.tip = hash;
  this.committed = true;
  return this.toRaw();
};

ChainState.prototype.toRaw = function toRaw() {
  const bw = new StaticWriter(56);
  bw.writeHash(this.tip);
  bw.writeU64(this.tx);
  bw.writeU64(this.coin);
  bw.writeU64(this.value);
  return bw.render();
};

ChainState.fromRaw = function fromRaw(data) {
  const state = new ChainState();
  const br = new BufferReader(data);
  state.tip = br.readHash('hex');
  state.tx = br.readU64();
  state.coin = br.readU64();
  state.value = br.readU64();
  return state;
};

/**
 * StateCache
 * @alias module:blockchain.StateCache
 * @constructor
 */

function StateCache(network) {
  this.network = network;
  this.bits = [];
  this.updates = [];
  this._init();
}

StateCache.prototype._init = function _init() {
  for (let i = 0; i < 32; i++)
    this.bits.push(null);

  for (const {bit} of this.network.deploys) {
    assert(!this.bits[bit]);
    this.bits[bit] = new Map();
  }
};

StateCache.prototype.set = function set(bit, entry, state) {
  const cache = this.bits[bit];

  assert(cache);

  if (cache.get(entry.hash) !== state) {
    cache.set(entry.hash, state);
    this.updates.push(new CacheUpdate(bit, entry.hash, state));
  }
};

StateCache.prototype.get = function get(bit, entry) {
  const cache = this.bits[bit];

  assert(cache);

  const state = cache.get(entry.hash);

  if (state == null)
    return -1;

  return state;
};

StateCache.prototype.commit = function commit() {
  this.updates.length = 0;
};

StateCache.prototype.drop = function drop() {
  for (const {bit, hash} of this.updates) {
    const cache = this.bits[bit];
    assert(cache);
    cache.delete(hash);
  }

  this.updates.length = 0;
};

StateCache.prototype.insert = function insert(bit, hash, state) {
  const cache = this.bits[bit];
  assert(cache);
  cache.set(hash, state);
};

/**
 * CacheUpdate
 * @constructor
 * @ignore
 */

function CacheUpdate(bit, hash, state) {
  this.bit = bit;
  this.hash = hash;
  this.state = state;
}

CacheUpdate.prototype.toRaw = function toRaw() {
  return U8(this.state);
};

/*
 * Helpers
 */

function getSize(value) {
  return value.length + 80;
}

/*
 * Expose
 */

module.exports = ChainDB;


/***/ }),
/* 164 */
/***/ (function(module, exports) {

module.exports = require("node-x15");

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * txmeta.js - extended transaction object for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const TX = __webpack_require__(16);
const StaticWriter = __webpack_require__(4);
const BufferReader = __webpack_require__(2);

/**
 * An extended transaction object.
 * @alias module:primitives.TXMeta
 * @constructor
 * @param {Object} options
 */

function TXMeta(options) {
  if (!(this instanceof TXMeta))
    return new TXMeta(options);

  this.tx = new TX();
  this.mtime = util.now();
  this.height = -1;
  this.block = null;
  this.time = 0;
  this.index = -1;

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from options object.
 * @private
 * @param {Object} options
 */

TXMeta.prototype.fromOptions = function fromOptions(options) {
  if (options.tx) {
    assert(options.tx instanceof TX);
    this.tx = options.tx;
  }

  if (options.mtime != null) {
    assert(util.isU32(options.mtime));
    this.mtime = options.mtime;
  }

  if (options.height != null) {
    assert(util.isInt(options.height));
    this.height = options.height;
  }

  if (options.block !== undefined) {
    assert(options.block === null || typeof options.block === 'string');
    this.block = options.block;
  }

  if (options.time != null) {
    assert(util.isU32(options.time));
    this.time = options.time;
  }

  if (options.index != null) {
    assert(util.isInt(options.index));
    this.index = options.index;
  }

  return this;
};

/**
 * Instantiate TXMeta from options.
 * @param {Object} options
 * @returns {TXMeta}
 */

TXMeta.fromOptions = function fromOptions(options) {
  return new TXMeta().fromOptions(options);
};

/**
 * Inject properties from options object.
 * @private
 * @param {Object} options
 */

TXMeta.prototype.fromTX = function fromTX(tx, entry, index) {
  this.tx = tx;
  if (entry) {
    this.height = entry.height;
    this.block = entry.hash;
    this.time = entry.time;
    this.index = index;
  }
  return this;
};

/**
 * Instantiate TXMeta from options.
 * @param {Object} options
 * @returns {TXMeta}
 */

TXMeta.fromTX = function fromTX(tx, entry, index) {
  return new TXMeta().fromTX(tx, entry, index);
};

/**
 * Inspect the transaction.
 * @returns {Object}
 */

TXMeta.prototype.inspect = function inspect() {
  return this.format();
};

/**
 * Inspect the transaction.
 * @returns {Object}
 */

TXMeta.prototype.format = function format(view) {
  const data = this.tx.format(view, null, this.index);
  data.mtime = this.mtime;
  data.height = this.height;
  data.block = this.block ? util.revHex(this.block) : null;
  data.time = this.time;
  return data;
};

/**
 * Convert transaction to JSON.
 * @returns {Object}
 */

TXMeta.prototype.toJSON = function toJSON() {
  return this.getJSON();
};

/**
 * Convert the transaction to an object suitable
 * for JSON serialization.
 * @param {Network} network
 * @param {CoinView} view
 * @returns {Object}
 */

TXMeta.prototype.getJSON = function getJSON(network, view) {
  const json = this.tx.getJSON(network, view, null, this.index);
  json.mtime = this.mtime;
  json.height = this.height;
  json.block = this.block ? util.revHex(this.block) : null;
  json.time = this.time;
  return json;
};

/**
 * Inject properties from a json object.
 * @private
 * @param {Object} json
 */

TXMeta.prototype.fromJSON = function fromJSON(json) {
  this.tx.fromJSON(json);

  assert(util.isU32(json.mtime));
  assert(util.isInt(json.height));
  assert(!json.block || typeof json.block === 'string');
  assert(util.isU32(json.time));
  assert(util.isInt(json.index));

  this.mtime = json.mtime;
  this.height = json.height;
  this.block = util.revHex(json.block);
  this.index = json.index;

  return this;
};

/**
 * Instantiate a transaction from a
 * jsonified transaction object.
 * @param {Object} json - The jsonified transaction object.
 * @returns {TX}
 */

TXMeta.fromJSON = function fromJSON(json) {
  return new TXMeta().fromJSON(JSON);
};

/**
 * Calculate serialization size.
 * @returns {Number}
 */

TXMeta.prototype.getSize = function getSize() {
  let size = 0;

  size += this.tx.getSize();
  size += 4;

  if (this.block) {
    size += 1;
    size += 32;
    size += 4 * 3;
  } else {
    size += 1;
  }

  return size;
};

/**
 * Serialize a transaction to "extended format".
 * This is the serialization format wmcc_core uses internally
 * to store transactions in the database. The extended
 * serialization includes the height, block hash, index,
 * timestamp, and pending-since time.
 * @returns {Buffer}
 */

TXMeta.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  const bw = new StaticWriter(size);

  this.tx.toWriter(bw);

  bw.writeU32(this.mtime);

  if (this.block) {
    bw.writeU8(1);
    bw.writeHash(this.block);
    bw.writeU32(this.height);
    bw.writeU32(this.time);
    bw.writeU32(this.index);
  } else {
    bw.writeU8(0);
  }

  return bw.render();
};

/**
 * Inject properties from "extended" serialization format.
 * @private
 * @param {Buffer} data
 */

TXMeta.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data);

  this.tx.fromReader(br);

  this.mtime = br.readU32();

  if (br.readU8() === 1) {
    this.block = br.readHash('hex');
    this.height = br.readU32();
    this.time = br.readU32();
    this.index = br.readU32();
    if (this.index === 0x7fffffff)
      this.index = -1;
  }

  return this;
};

/**
 * Instantiate a transaction from a Buffer
 * in "extended" serialization format.
 * @param {Buffer} data
 * @param {String?} enc - One of `"hex"` or `null`.
 * @returns {TX}
 */

TXMeta.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new TXMeta().fromRaw(data);
};

/**
 * Test whether an object is an TXMeta.
 * @param {Object} obj
 * @returns {Boolean}
 */

TXMeta.isTXMeta = function isTXMeta(obj) {
  return obj instanceof TXMeta;
};

/*
 * Expose
 */

module.exports = TXMeta;


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * chacha20.js - chacha20 for wmcc_core.
 */



const assert = __webpack_require__(0);
const native = __webpack_require__(18).binding;

const BIG_ENDIAN = new Int8Array(new Int16Array([1]).buffer)[0] === 0;

/**
 * ChaCha20 (used for bip151)
 * @alias module:crypto.ChaCha20
 * @constructor
 * @see https://tools.ietf.org/html/rfc7539#section-2
 */

function ChaCha20() {
  if (!(this instanceof ChaCha20))
    return new ChaCha20();

  this.state = new Uint32Array(16);
  this.stream = new Uint32Array(16);
  this.bytes = new Uint8Array(this.stream.buffer);

  if (BIG_ENDIAN)
    this.bytes = Buffer.allocUnsafe(64);

  this.pos = 0;
  this.ivSize = 0;
}

/**
 * Initialize chacha20 with a key, iv, and counter.
 * @param {Buffer} key
 * @param {Buffer} iv
 * @param {Number} counter
 */

ChaCha20.prototype.init = function init(key, iv, counter) {
  if (key)
    this.initKey(key);

  if (iv)
    this.initIV(iv, counter);
};

/**
 * Set key.
 * @param {Buffer} key
 */

ChaCha20.prototype.initKey = function initKey(key) {
  this.state[0] = 0x61707865;
  this.state[1] = 0x3320646e;
  this.state[2] = 0x79622d32;
  this.state[3] = 0x6b206574;

  this.state[4] = key.readUInt32LE(0, true);
  this.state[5] = key.readUInt32LE(4, true);
  this.state[6] = key.readUInt32LE(8, true);
  this.state[7] = key.readUInt32LE(12, true);
  this.state[8] = key.readUInt32LE(16, true);
  this.state[9] = key.readUInt32LE(20, true);
  this.state[10] = key.readUInt32LE(24, true);
  this.state[11] = key.readUInt32LE(28, true);

  this.state[12] = 0;

  this.pos = 0xffffffff;
};

/**
 * Set IV and counter.
 * @param {Buffer} iv
 * @param {Number} counter
 */

ChaCha20.prototype.initIV = function initIV(iv, counter) {
  if (iv.length === 8) {
    this.state[13] = 0;
    this.state[14] = iv.readUInt32LE(0, true);
    this.state[15] = iv.readUInt32LE(4, true);
  } else if (iv.length === 12) {
    this.state[13] = iv.readUInt32LE(0, true);
    this.state[14] = iv.readUInt32LE(4, true);
    this.state[15] = iv.readUInt32LE(8, true);
  } else {
    assert(false, 'Bad iv size.');
  }

  this.ivSize = iv.length * 8;

  this.setCounter(counter);
};

/**
 * Encrypt/decrypt data.
 * @param {Buffer} data - Will be mutated.
 */

ChaCha20.prototype.encrypt = function encrypt(data) {
  for (let i = 0; i < data.length; i++) {
    if (this.pos >= 64) {
      for (let j = 0; j < 16; j++)
        this.stream[j] = this.state[j];

      for (let j = 0; j < 10; j++) {
        qround(this.stream, 0, 4, 8, 12);
        qround(this.stream, 1, 5, 9, 13);
        qround(this.stream, 2, 6, 10, 14);
        qround(this.stream, 3, 7, 11, 15);
        qround(this.stream, 0, 5, 10, 15);
        qround(this.stream, 1, 6, 11, 12);
        qround(this.stream, 2, 7, 8, 13);
        qround(this.stream, 3, 4, 9, 14);
      }

      for (let j = 0; j < 16; j++) {
        this.stream[j] += this.state[j];
        if (BIG_ENDIAN)
          this.bytes.writeUInt32LE(this.stream[j], j * 4, true);
      }

      this.state[12]++;

      if (this.state[12] === 0) {
        assert(this.ivSize === 64, 'Counter overflow.');
        this.state[13]++;
        assert(this.state[13] !== 0, 'Counter overflow.');
      }

      this.pos = 0;
    }

    data[i] ^= this.bytes[this.pos++];
  }

  return data;
};

/**
 * Artificially set the counter.
 * @param {Number} counter
 */

ChaCha20.prototype.setCounter = function setCounter(counter) {
  if (!counter)
    counter = 0;

  const lo = counter % 0x100000000;
  const hi = (counter - lo) / 0x100000000;

  this.state[12] = lo;

  if (this.ivSize === 64)
    this.state[13] = hi;
};

/**
 * Get the counter as a uint64.
 * @returns {Number}
 */

ChaCha20.prototype.getCounter = function getCounter() {
  const lo = this.state[12];
  const hi = this.state[13];
  if (this.ivSize === 64)
    return hi * 0x100000000 + lo;
  return lo;
};

if (native)
  ChaCha20 = native.ChaCha20;

/*
 * Helpers
 */

function qround(x, a, b, c, d) {
  x[a] += x[b];
  x[d] = rotl32(x[d] ^ x[a], 16);

  x[c] += x[d];
  x[b] = rotl32(x[b] ^ x[c], 12);

  x[a] += x[b];
  x[d] = rotl32(x[d] ^ x[a], 8);

  x[c] += x[d];
  x[b] = rotl32(x[b] ^ x[c], 7);
}

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}

/*
 * Expose
 */

module.exports = ChaCha20;


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * poly1305.js - poly1305 for wmcc_core.
 */



const native = __webpack_require__(18).binding;

/**
 * Poly1305 (used for bip151)
 * @alias module:crypto/chachapoly.Poly1305
 * @constructor
 * @see https://github.com/floodyberry/poly1305-donna
 * @see https://tools.ietf.org/html/rfc7539#section-2.5
 */

function Poly1305() {
  if (!(this instanceof Poly1305))
    return new Poly1305();

  this.r = new Uint16Array(10);
  this.h = new Uint16Array(10);
  this.pad = new Uint16Array(8);
  this.fin = 0;
  this.leftover = 0;
  this.buffer = Buffer.allocUnsafe(16);
}

/**
 * Initialize poly1305 with a key.
 * @param {Buffer} key
 */

Poly1305.prototype.init = function init(key) {
  // r &= 0xffffffc0ffffffc0ffffffc0fffffff
  const t0 = key.readUInt16LE(0, true);
  const t1 = key.readUInt16LE(2, true);
  const t2 = key.readUInt16LE(4, true);
  const t3 = key.readUInt16LE(6, true);
  const t4 = key.readUInt16LE(8, true);
  const t5 = key.readUInt16LE(10, true);
  const t6 = key.readUInt16LE(12, true);
  const t7 = key.readUInt16LE(14, true);

  this.r[0] = t0 & 0x1fff;
  this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;
  this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;
  this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;
  this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;
  this.r[5] = (t4 >>> 1) & 0x1ffe;
  this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;
  this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;
  this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;
  this.r[9] = (t7 >>> 5) & 0x007f;

  // h = 0
  for (let i = 0; i < 10; i++)
    this.h[i] = 0;

  // save pad for later
  for (let i = 0; i < 8; i++)
    this.pad[i] = key.readUInt16LE(16 + (2 * i), true);

  this.leftover = 0;
  this.fin = 0;
};

/**
 * Process 16 byte blocks.
 * @param {Buffer} data - Blocks.
 * @param {Number} bytes - Size.
 * @param {Number} m - Offset pointer.
 */

Poly1305.prototype.blocks = function blocks(data, bytes, m) {
  const hibit = this.fin ? 0 : (1 << 11); // 1 << 128
  const d = new Uint32Array(10);

  while (bytes >= 16) {
    // h += m[i]
    const t0 = data.readUInt16LE(m + 0, true);
    const t1 = data.readUInt16LE(m + 2, true);
    const t2 = data.readUInt16LE(m + 4, true);
    const t3 = data.readUInt16LE(m + 6, true);
    const t4 = data.readUInt16LE(m + 8, true);
    const t5 = data.readUInt16LE(m + 10, true);
    const t6 = data.readUInt16LE(m + 12, true);
    const t7 = data.readUInt16LE(m + 14, true);

    this.h[0] += t0 & 0x1fff;
    this.h[1] += ((t0 >>> 13) | (t1 << 3)) & 0x1fff;
    this.h[2] += ((t1 >>> 10) | (t2 << 6)) & 0x1fff;
    this.h[3] += ((t2 >>> 7) | (t3 << 9)) & 0x1fff;
    this.h[4] += ((t3 >>> 4) | (t4 << 12)) & 0x1fff;
    this.h[5] += ((t4 >>> 1)) & 0x1fff;
    this.h[6] += ((t4 >>> 14) | (t5 << 2)) & 0x1fff;
    this.h[7] += ((t5 >>> 11) | (t6 << 5)) & 0x1fff;
    this.h[8] += ((t6 >>> 8) | (t7 << 8)) & 0x1fff;
    this.h[9] += ((t7 >>> 5)) | hibit;

    // h *= r, (partial) h %= p
    let c = 0;
    for (let i = 0; i < 10; i++) {
      d[i] = c;

      for (let j = 0; j < 10; j++) {
        let a = this.h[j];

        if (j <= i)
          a *= this.r[i - j];
        else
          a *= 5 * this.r[i + 10 - j];

        d[i] += a;

        // Sum(h[i] * r[i] * 5) will overflow slightly
        // above 6 products with an unclamped r, so
        // carry at 5
        if (j === 4) {
          c = d[i] >>> 13;
          d[i] &= 0x1fff;
        }
      }

      c += d[i] >>> 13;
      d[i] &= 0x1fff;
    }

    c = (c << 2) + c; // c *= 5
    c += d[0];
    d[0] = (c & 0x1fff);
    c = c >>> 13;
    d[1] += c;

    for (let i = 0; i < 10; i++)
      this.h[i] = d[i];

    m += 16;
    bytes -= 16;
  }
};

/**
 * Update the MAC with data (will be
 * processed as 16 byte blocks).
 * @param {Buffer} data
 */

Poly1305.prototype.update = function update(data) {
  let bytes = data.length;
  let m = 0;

  // handle leftover
  if (this.leftover) {
    let want = 16 - this.leftover;

    if (want > bytes)
      want = bytes;

    for (let i = 0; i < want; i++)
      this.buffer[this.leftover + i] = data[m + i];

    bytes -= want;
    m += want;

    this.leftover += want;

    if (this.leftover < 16)
      return;

    this.blocks(this.buffer, 16, 0);
    this.leftover = 0;
  }

  // process full blocks
  if (bytes >= 16) {
    const want = bytes & ~(16 - 1);
    this.blocks(data, want, m);
    m += want;
    bytes -= want;
  }

  // store leftover
  if (bytes) {
    for (let i = 0; i < bytes; i++)
      this.buffer[this.leftover + i] = data[m + i];
    this.leftover += bytes;
  }
};

/**
 * Finalize and return a 16-byte MAC.
 * @returns {Buffer}
 */

Poly1305.prototype.finish = function finish() {
  const mac = Buffer.allocUnsafe(16);
  const g = new Uint16Array(10);

  // process the remaining block
  if (this.leftover) {
    let i = this.leftover;
    this.buffer[i++] = 1;
    for (; i < 16; i++)
      this.buffer[i] = 0;
    this.fin = 1;
    this.blocks(this.buffer, 16, 0);
  }

  // fully carry h
  let c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  for (let i = 2; i < 10; i++) {
    this.h[i] += c;
    c = this.h[i] >>> 13;
    this.h[i] &= 0x1fff;
  }
  this.h[0] += c * 5;
  c = this.h[0] >>> 13;
  this.h[0] &= 0x1fff;
  this.h[1] += c;
  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  this.h[2] += c;

  // compute h + -p
  g[0] = this.h[0] + 5;
  c = g[0] >>> 13;
  g[0] &= 0x1fff;
  for (let i = 1; i < 10; i++) {
    g[i] = this.h[i] + c;
    c = g[i] >>> 13;
    g[i] &= 0x1fff;
  }

  // select h if h < p, or h + -p if h >= p
  let mask = (c ^ 1) - 1;
  for (let i = 0; i < 10; i++)
    g[i] &= mask;
  mask = ~mask;
  for (let i = 0; i < 10; i++)
    this.h[i] = (this.h[i] & mask) | g[i];

  // h = h % (2^128)
  this.h[0] = ((this.h[0]) | (this.h[1] << 13)) & 0xffff;
  this.h[1] = ((this.h[1] >>> 3) | (this.h[2] << 10)) & 0xffff;
  this.h[2] = ((this.h[2] >>> 6) | (this.h[3] << 7)) & 0xffff;
  this.h[3] = ((this.h[3] >>> 9) | (this.h[4] << 4)) & 0xffff;
  this.h[4] = ((this.h[4] >>> 12)
    | (this.h[5] << 1) | (this.h[6] << 14)) & 0xffff;
  this.h[5] = ((this.h[6] >>> 2) | (this.h[7] << 11)) & 0xffff;
  this.h[6] = ((this.h[7] >>> 5) | (this.h[8] << 8)) & 0xffff;
  this.h[7] = ((this.h[8] >>> 8) | (this.h[9] << 5)) & 0xffff;

  // mac = (h + pad) % (2^128)
  let f = this.h[0] + this.pad[0];
  this.h[0] = f;
  for (let i = 1; i < 8; i++) {
    f = this.h[i] + this.pad[i] + (f >>> 16);
    this.h[i] = f;
  }

  for (let i = 0; i < 8; i++)
    mac.writeUInt16LE(this.h[i], i * 2, true);

  // zero out the state
  for (let i = 0; i < 10; i++)
    this.h[i] = 0;

  for (let i = 0; i < 10; i++)
    this.r[i] = 0;

  for (let i = 0; i < 8; i++)
    this.pad[i] = 0;

  return mac;
};

/**
 * Return a MAC for a message and key.
 * @param {Buffer} msg
 * @param {Buffer} key
 * @returns {Buffer} MAC
 */

Poly1305.auth = function auth(msg, key) {
  const poly = new Poly1305();
  poly.init(key);
  poly.update(msg);
  return poly.finish();
};

/**
 * Compare two MACs in constant time.
 * @param {Buffer} mac1
 * @param {Buffer} mac2
 * @returns {Boolean}
 */

Poly1305.verify = function verify(mac1, mac2) {
  let dif = 0;

  // Compare in constant time.
  for (let i = 0; i < 16; i++)
    dif |= mac1[i] ^ mac2[i];

  dif = (dif - 1) >>> 31;

  return (dif & 1) !== 0;
};

if (native)
  Poly1305 = native.Poly1305;

/*
 * Expose
 */

module.exports = Poly1305;


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * siphash.js - siphash for wmcc_core.
 *
 * Ported from:
 * https://github.com/bitcoin/bitcoin/blob/master/src/hash.cpp
 */



/**
 * @module crypto/siphash
 */

const native = __webpack_require__(18).binding;

/**
 * Javascript siphash implementation. Used for compact block relay.
 * @alias module:crypto/siphash.siphash24
 * @param {Buffer} data
 * @param {Buffer} key - 128 bit key.
 * @returns {Array} [hi, lo]
 */

function siphash24(data, key, shift) {
  const blocks = Math.floor(data.length / 8);
  const c0 = U64(0x736f6d65, 0x70736575);
  const c1 = U64(0x646f7261, 0x6e646f6d);
  const c2 = U64(0x6c796765, 0x6e657261);
  const c3 = U64(0x74656462, 0x79746573);
  const f0 = U64(blocks << (shift - 32), 0);
  const f1 = U64(0, 0xff);
  const k0 = U64.fromRaw(key, 0);
  const k1 = U64.fromRaw(key, 8);

  // Init
  const v0 = c0.ixor(k0);
  const v1 = c1.ixor(k1);
  const v2 = c2.ixor(k0);
  const v3 = c3.ixor(k1);

  // Blocks
  let p = 0;
  for (let i = 0; i < blocks; i++) {
    const d = U64.fromRaw(data, p);
    p += 8;
    v3.ixor(d);
    sipround(v0, v1, v2, v3);
    sipround(v0, v1, v2, v3);
    v0.ixor(d);
  }

  switch (data.length & 7) {
    case 7:
      f0.hi |= data[p + 6] << 16;
    case 6:
      f0.hi |= data[p + 5] << 8;
    case 5:
      f0.hi |= data[p + 4];
    case 4:
      f0.lo |= data[p + 3] << 24;
    case 3:
      f0.lo |= data[p + 2] << 16;
    case 2:
      f0.lo |= data[p + 1] << 8;
    case 1:
      f0.lo |= data[p];
  }

  // Finalization
  v3.ixor(f0);
  sipround(v0, v1, v2, v3);
  sipround(v0, v1, v2, v3);
  v0.ixor(f0);
  v2.ixor(f1);
  sipround(v0, v1, v2, v3);
  sipround(v0, v1, v2, v3);
  sipround(v0, v1, v2, v3);
  sipround(v0, v1, v2, v3);
  v0.ixor(v1);
  v0.ixor(v2);
  v0.ixor(v3);

  return [v0.hi, v0.lo];
}

function sipround(v0, v1, v2, v3) {
  v0.iadd(v1);
  v1.irotl(13);
  v1.ixor(v0);

  v0.irotl(32);

  v2.iadd(v3);
  v3.irotl(16);
  v3.ixor(v2);

  v0.iadd(v3);
  v3.irotl(21);
  v3.ixor(v0);

  v2.iadd(v1);
  v1.irotl(17);
  v1.ixor(v2);

  v2.irotl(32);
}

/**
 * Javascript siphash implementation (shift=56).
 * @alias module:crypto/siphash.siphash
 * @param {Buffer} data
 * @param {Buffer} key - 128 bit key.
 * @returns {Array} [hi, lo]
 */

function siphash(data, key) {
  return siphash24(data, key, 56);
}

/**
 * Javascript siphash implementation (shift=59).
 * @alias module:crypto/siphash.siphash256
 * @param {Buffer} data
 * @param {Buffer} key - 128 bit key.
 * @returns {Array} [hi, lo]
 */

function siphash256(data, key) {
  return siphash24(data, key, 59);
}

if (native) {
  siphash = native.siphash;
  siphash256 = native.siphash256;
}

/*
 * U64
 * @constructor
 * @ignore
 */

function U64(hi, lo) {
  if (!(this instanceof U64))
    return new U64(hi, lo);

  this.hi = hi | 0;
  this.lo = lo | 0;
}

U64.prototype.iadd = function iadd(b) {
  const a = this;

  // Credit to @indutny for this method.
  const lo = (a.lo + b.lo) | 0;

  const s = lo >> 31;
  const as = a.lo >> 31;
  const bs = b.lo >> 31;

  const c = ((as & bs) | (~s & (as ^ bs))) & 1;

  const hi = ((a.hi + b.hi) | 0) + c;

  a.hi = hi | 0;
  a.lo = lo;

  return a;
};

U64.prototype.ixor = function ixor(b) {
  this.hi ^= b.hi;
  this.lo ^= b.lo;
  return this;
};

U64.prototype.irotl = function irotl(bits) {
  let ahi = this.hi;
  let alo = this.lo;
  let bhi = this.hi;
  let blo = this.lo;

  // a = x << b
  if (bits < 32) {
    ahi <<= bits;
    ahi |= alo >>> (32 - bits);
    alo <<= bits;
  } else {
    ahi = alo << (bits - 32);
    alo = 0;
  }

  bits = 64 - bits;

  // b = x >> (64 - b)
  if (bits < 32) {
    blo >>>= bits;
    blo |= bhi << (32 - bits);
    bhi >>>= bits;
  } else {
    blo = bhi >>> (bits - 32);
    bhi = 0;
  }

  // a | b
  this.hi = ahi | bhi;
  this.lo = alo | blo;

  return this;
};

U64.fromRaw = function fromRaw(data, off) {
  const lo = data.readUInt32LE(off, true);
  const hi = data.readUInt32LE(off + 4, true);
  return new U64(hi, lo);
};

/*
 * Expose
 */

exports = siphash;
exports.siphash = siphash;
exports.siphash256 = siphash256;

module.exports = exports;


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * http.js - http server for wmcc_core.
 */



const assert = __webpack_require__(0);
const path = __webpack_require__(25);
const EventEmitter = __webpack_require__(10);
const URL = __webpack_require__(90);
const {StringDecoder} = __webpack_require__(170);
const AsyncObject = __webpack_require__(31);
const util = __webpack_require__(1);
const co = __webpack_require__(17);
const Validator = __webpack_require__(71);
const {List, ListItem} = __webpack_require__(91);
const fs = __webpack_require__(58);
const digest = __webpack_require__(5);
const ccmp = __webpack_require__(52);

/**
 * HTTPBase
 * @alias module:http.Base
 * @constructor
 * @param {Object?} options
 * @emits HTTPBase#socket
 */

function HTTPBase(options) {
  if (!(this instanceof HTTPBase))
    return new HTTPBase(options);

  AsyncObject.call(this);

  this.config = new HTTPBaseOptions(options);
  this.config.load();

  this.server = null;
  this.io = null;
  this.sockets = new List();
  this.channels = new Map();
  this.routes = new Routes();
  this.mounts = [];
  this.stack = [];
  this.hooks = [];

  this._init();
}

Object.setPrototypeOf(HTTPBase.prototype, AsyncObject.prototype);

/**
 * Initialize server.
 * @private
 */

HTTPBase.prototype._init = function _init() {
  const backend = this.config.getBackend();
  const options = this.config.toHTTP();

  this.server = backend.createServer(options);

  this._initRouter();
  this._initSockets();

  this.server.on('connection', (socket) => {
    socket.on('error', (err) => {
      if (err.message === 'Parse Error') {
        let msg = 'http_parser.execute failure';
        msg += ` (parsed=${err.bytesParsed || -1}`;
        msg += ` code=${err.code})`;
        err = new Error(msg);
      }

      this.emit('error', err);

      try {
        socket.destroy();
      } catch (e) {
        ;
      }
    });
  });

  this.server.on('error', (err) => {
    this.emit('error', err);
  });
};

/**
 * Initialize router.
 * @private
 */

HTTPBase.prototype._initRouter = function _initRouter() {
  this.server.on('request', async (hreq, hres) => {
    const req = new Request(hreq, hres, hreq.url);
    const res = new Response(hreq, hres);

    req.on('error', () => {});

    try {
      req.pause();
      await this.handleRequest(req, res);
    } catch (e) {
      res.error(e.statusCode || 500, e);
      this.emit('error', e);
    }
  });
};

/**
 * Handle a request.
 * @private
 * @param {ServerRequest} req
 * @param {ServerResponse} res
 * @returns {Promise}
 */

HTTPBase.prototype.handleRequest = async function handleRequest(req, res) {
  if (await this.handleMounts(req, res))
    return;

  this.emit('request', req, res);

  if (await this.handleStack(req, res))
    return;

  const routes = this.routes.getHandlers(req.method);

  if (!routes)
    throw new Error(`No routes found for method: ${req.method}.`);

  for (const route of routes) {
    const params = route.match(req.pathname);

    if (!params)
      continue;

    req.params = params;

    if (await this.handleHooks(req, res))
      return;

    if (await route.call(req, res))
      return;
  }

  throw new Error(`No routes found for path: ${req.pathname}.`);
};

/**
 * CORS middleware.
 * @returns {Function}
 */

HTTPBase.prototype.cors = function cors() {
  return async (req, res) => {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Credentials', 'true');
    res.setHeader(
      'Access-Control-Allow-Methods',
      'GET,HEAD,PUT,PATCH,POST,DELETE');
    res.setHeader('Access-Control-Allow-Headers', 'Authorization');

    if (req.method === 'OPTIONS') {
      res.setStatus(200);
      res.end();
      return;
    }
  };
};

/**
 * Basic auth middleware.
 * @param {Object} options
 * @returns {Function}
 */

HTTPBase.prototype.basicAuth = function basicAuth(options) {
  assert(options, 'Basic auth requires options.');

  let user = options.username;
  let pass = options.password;
  let realm = options.realm;

  if (user != null) {
    assert(typeof user === 'string');
    assert(user.length <= 255, 'Username too long.');
    assert(util.isAscii(user), 'Username must be ASCII.');
    user = digest.hash256(Buffer.from(user, 'ascii'));
  }

  assert(typeof pass === 'string');
  assert(pass.length <= 255, 'Password too long.');
  assert(util.isAscii(pass), 'Password must be ASCII.');
  pass = digest.hash256(Buffer.from(pass, 'ascii'));

  if (!realm)
    realm = 'server';

  assert(typeof realm === 'string');

  const fail = (res) => {
    res.setHeader('WWW-Authenticate', `Basic realm="${realm}"`);
    res.setStatus(401);
    res.end();
  };

  return async (req, res) => {
    const hdr = req.headers['authorization'];

    if (!hdr) {
      fail(res);
      return;
    }

    if (hdr.length > 674) {
      fail(res);
      return;
    }

    const parts = hdr.split(' ');

    if (parts.length !== 2) {
      fail(res);
      return;
    }

    const [type, b64] = parts;

    if (type !== 'Basic') {
      fail(res);
      return;
    }

    const auth = Buffer.from(b64, 'base64').toString('ascii');
    const items = auth.split(':');

    const username = items.shift();
    const password = items.join(':');

    if (user) {
      if (username.length > 255) {
        fail(res);
        return;
      }

      const raw = Buffer.from(username, 'ascii');
      const hash = digest.hash256(raw);

      if (!ccmp(hash, user)) {
        fail(res);
        return;
      }
    }

    if (password.length > 255) {
      fail(res);
      return;
    }

    const raw = Buffer.from(password, 'ascii');
    const hash = digest.hash256(raw);

    if (!ccmp(hash, pass)) {
      fail(res);
      return;
    }

    req.username = username;
  };
};

/**
 * Body parser middleware.
 * @param {Object} options
 * @returns {Function}
 */

HTTPBase.prototype.bodyParser = function bodyParser(options) {
  const opt = new BodyParserOptions(options);

  return async (req, res) => {
    if (req.hasBody)
      return;

    try {
      req.resume();
      req.body = await this.parseBody(req, opt);
    } finally {
      req.pause();
    }

    req.hasBody = true;
  };
};

/**
 * Parse request body.
 * @private
 * @param {ServerRequest} req
 * @param {Object} options
 * @returns {Promise}
 */

HTTPBase.prototype.parseBody = async function parseBody(req, options) {
  let body = Object.create(null);

  if (req.method === 'GET')
    return body;

  let type = req.contentType;

  if (options.contentType)
    type = options.contentType;

  if (type === 'bin')
    return body;

  const data = await this.readBody(req, 'utf8', options);

  if (!data)
    return body;

  switch (type) {
    case 'json':
      body = JSON.parse(data);
      if (!body || typeof body !== 'object' || Array.isArray(body))
        throw new Error('JSON body must be an object.');
      break;
    case 'form':
      body = parsePairs(data, options.keyLimit);
      break;
  }

  return body;
};

/**
 * Read and buffer request body.
 * @param {ServerRequest} req
 * @param {String} enc
 * @param {Object} options
 * @returns {Promise}
 */

HTTPBase.prototype.readBody = function readBody(req, enc, options) {
  return new Promise((resolve, reject) => {
    return this._readBody(req, enc, options, resolve, reject);
  });
};

/**
 * Read and buffer request body.
 * @private
 * @param {ServerRequest} req
 * @param {String} enc
 * @param {Object} options
 * @param {Function} resolve
 * @param {Function} reject
 */

HTTPBase.prototype._readBody = function _readBody(req, enc, options, resolve, reject) {
  const decode = new StringDecoder(enc);
  let hasData = false;
  let total = 0;
  let body = '';

  const cleanup = () => {
    /* eslint-disable */
    req.removeListener('data', onData);
    req.removeListener('error', onError);
    req.removeListener('end', onEnd);

    if (timer != null) {
      timer = null;
      clearTimeout(timer);
    }
    /* eslint-enable */
  };

  const onData = (data) => {
    total += data.length;
    hasData = true;

    if (total > options.bodyLimit) {
      reject(new Error('Request body overflow.'));
      return;
    }

    body += decode.write(data);
  };

  const onError = (err) => {
    cleanup();
    reject(err);
  };

  const onEnd = () => {
    cleanup();

    if (hasData) {
      resolve(body);
      return;
    }

    resolve(null);
  };

  let timer = setTimeout(() => {
    timer = null;
    cleanup();
    reject(new Error('Request body timed out.'));
  }, options.timeout);

  req.on('data', onData);
  req.on('error', onError);
  req.on('end', onEnd);
};

/**
 * JSON rpc middleware.
 * @param {RPCBase} rpc
 * @returns {Function}
 */

HTTPBase.prototype.jsonRPC = function jsonRPC(rpc) {
  return async (req, res) => {
    if (req.method !== 'POST')
      return;

    if (req.pathname !== '/')
      return;

    if (typeof req.body.method !== 'string')
      return;

    let json = await rpc.call(req.body, req.query);

    json = JSON.stringify(json);
    json += '\n';

    res.setHeader('X-Long-Polling', '/?longpoll=1');

    res.send(200, json, 'json');
  };
};

/**
 * Handle mount stack.
 * @private
 * @param {HTTPRequest} req
 * @param {HTTPResponse} res
 * @returns {Promise}
 */

HTTPBase.prototype.handleMounts = async function handleMounts(req, res) {
  let url = req.url;

  for (const route of this.mounts) {
    const server = route.handler;

    if (!route.hasPrefix(req.pathname))
      continue;

    assert(url.indexOf(route.path) === 0);

    url = url.substring(route.path.length);
    req = req.rewrite(url);

    await server.handleRequest(req, res);

    return true;
  }

  return false;
};

/**
 * Handle middleware stack.
 * @private
 * @param {HTTPRequest} req
 * @param {HTTPResponse} res
 * @returns {Promise}
 */

HTTPBase.prototype.handleStack = async function handleStack(req, res) {
  for (const route of this.stack) {
    if (!route.hasPrefix(req.pathname))
      continue;

    if (await route.call(req, res))
      return true;
  }

  return false;
};

/**
 * Handle hook stack.
 * @private
 * @param {HTTPRequest} req
 * @param {HTTPResponse} res
 * @returns {Promise}
 */

HTTPBase.prototype.handleHooks = async function handleHooks(req, res) {
  for (const route of this.hooks) {
    if (!route.hasPrefix(req.pathname))
      continue;

    if (await route.call(req, res))
      return true;
  }

  return false;
};

/**
 * Initialize websockets.
 * @private
 */

HTTPBase.prototype._initSockets = function _initSockets() {
  if (!this.config.sockets)
    return;

  let IOServer;
  try {
    IOServer = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"socket.io\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
  } catch (e) {
    ;
  }

  if (!IOServer)
    return;

  this.io = new IOServer({
    transports: ['websocket'],
    serveClient: false
  });

  this.io.attach(this.server);

  this.io.on('connection', (ws) => {
    this.addSocket(ws);
  });
};

/**
 * Broadcast event to channel.
 * @param {String} name
 * @param {String} type
 * @param {...Object} args
 */

HTTPBase.prototype.to = function to(name, ...args) {
  const list = this.channels.get(name);

  if (!list)
    return;

  assert(list.size > 0);

  for (let item = list.head; item; item = item.next) {
    const socket = item.value;
    socket.emit(...args);
  }
};

/**
 * Broadcast event to all connections.
 * @param {String} channel
 * @param {String} type
 * @param {...Object} args
 */

HTTPBase.prototype.all = function all() {
  const list = this.sockets;

  for (let socket = list.head; socket; socket = socket.next)
    socket.emit.apply(socket, arguments);
};

/**
 * Add and initialize a websocket.
 * @private
 * @param {SocketIO.Socket} ws
 */

HTTPBase.prototype.addSocket = function addSocket(ws) {
  const socket = new WebSocket(ws, this);

  socket.on('error', (err) => {
    this.emit('error', err);
  });

  socket.on('close', () => {
    this.removeSocket(socket);
  });

  socket.on('join channel', (name) => {
    this.joinChannel(socket, name);
  });

  socket.on('leave channel', (name) => {
    this.leaveChannel(socket, name);
  });

  this.sockets.push(socket);

  for (const route of this.mounts)
    route.handler.addSocket(ws);

  this.emit('socket', socket);
};

/**
 * Remove a socket from lists.
 * @private
 * @param {WebSocket} socket
 */

HTTPBase.prototype.removeSocket = function removeSocket(socket) {
  for (const key of socket.channels.keys())
    this.leaveChannel(socket, key);

  assert(this.sockets.remove(socket));
};

/**
 * Add a socket to channel list.
 * @private
 * @param {WebSocket} socket
 * @param {String} name
 */

HTTPBase.prototype.joinChannel = function joinChannel(socket, name) {
  let item = socket.channels.get(name);

  if (item)
    return;

  let list = this.channels.get(name);

  if (!list) {
    list = new List();
    this.channels.set(name, list);
  }

  item = new ListItem(socket);
  list.push(item);

  socket.channels.set(name, item);
};

/**
 * Remove a socket from channel list.
 * @private
 * @param {WebSocket} socket
 * @param {String} name
 */

HTTPBase.prototype.leaveChannel = function leaveChannel(socket, name) {
  const item = socket.channels.get(name);

  if (!item)
    return;

  const list = this.channels.get(name);

  assert(list);
  assert(list.remove(item));

  if (list.size === 0)
    this.channels.delete(name);

  socket.channels.delete(name);
};

/**
 * Get channel list.
 * @private
 * @param {String} name
 */

HTTPBase.prototype.channel = function channel(name) {
  const list = this.channels.get(name);

  if (!list)
    return null;

  assert(list.size > 0);

  return list;
};

/**
 * Open the server.
 * @alias HTTPBase#open
 * @returns {Promise}
 */

HTTPBase.prototype._open = function _open() {
  return this.listen(this.config.port, this.config.host);
};

/**
 * Close the server.
 * @alias HTTPBase#close
 * @returns {Promise}
 */

HTTPBase.prototype._close = function _close() {
  return new Promise((resolve, reject) => {
    if (this.io) {
      this.server.once('close', resolve);
      this.io.close();
      return;
    }

    this.server.close((err) => {
      if (err) {
        reject(err);
        return;
      }
      resolve();
    });
  });
};

/**
 * Mount a server.
 * @param {String?} path
 * @param {HTTPBase} server
 * @param {Object?} ctx
 */

HTTPBase.prototype.mount = function mount(path, server, ctx) {
  if (!server) {
    server = path;
    path = null;
  }
  this.mounts.push(new Route(ctx || this, path, server));
};

/**
 * Add a middleware to the stack.
 * @param {String?} path
 * @param {Function} handler
 * @param {Object?} ctx
 */

HTTPBase.prototype.use = function use(path, handler, ctx) {
  if (!handler) {
    handler = path;
    path = null;
  }
  this.stack.push(new Route(ctx || this, path, handler));
};

/**
 * Add a hook to the stack.
 * @param {String?} path
 * @param {Function} handler
 * @param {Object?} ctx
 */

HTTPBase.prototype.hook = function hook(path, handler, ctx) {
  if (!handler) {
    handler = path;
    path = null;
  }
  this.hooks.push(new Route(ctx || this, path, handler));
};

/**
 * Add a GET route.
 * @param {String} path
 * @param {Function} handler
 * @param {Object?} ctx
 */

HTTPBase.prototype.get = function get(path, handler, ctx) {
  this.routes.get.push(new Route(ctx || this, path, handler));
};

/**
 * Add a POST route.
 * @param {String} path
 * @param {Function} handler
 * @param {Object?} ctx
 */

HTTPBase.prototype.post = function post(path, handler, ctx) {
  this.routes.post.push(new Route(ctx || this, path, handler));
};

/**
 * Add a PUT route.
 * @param {String} path
 * @param {Function} handler
 * @param {Object?} ctx
 */

HTTPBase.prototype.put = function put(path, handler, ctx) {
  this.routes.put.push(new Route(ctx || this, path, handler));
};

/**
 * Add a DELETE route.
 * @param {String} path
 * @param {Function} handler
 * @param {Object?} ctx
 */

HTTPBase.prototype.del = function del(path, handler, ctx) {
  this.routes.del.push(new Route(ctx || this, path, handler));
};

/**
 * Get server address.
 * @returns {Object}
 */

HTTPBase.prototype.address = function address() {
  return this.server.address();
};

/**
 * Listen on port and host.
 * @param {Number} port
 * @param {String} host
 * @returns {Promise}
 */

HTTPBase.prototype.listen = function listen(port, host) {
  return new Promise((resolve, reject) => {
    this.server.once('error', reject);
    this.server.listen(port, host, () => {
      const addr = this.address();

      this.emit('listening', addr);

      this.server.removeListener('error', reject);
      resolve(addr);
    });
  });
};

/**
 * HTTP Base Options
 * @alias module:http.HTTPBaseOptions
 * @constructor
 * @param {Object} options
 */

function HTTPBaseOptions(options) {
  if (!(this instanceof HTTPBaseOptions))
    return new HTTPBaseOptions(options);

  this.host = '127.0.0.1';
  this.port = 8080;
  this.sockets = true;

  this.ssl = false;
  this.keyFile = null;
  this.certFile = null;
  this.key = null;
  this.cert = null;
  this.ca = null;

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from object.
 * @private
 * @param {Object} options
 * @returns {HTTPBaseOptions}
 */

HTTPBaseOptions.prototype.fromOptions = function fromOptions(options) {
  assert(options);

  if (options.host != null) {
    assert(typeof options.host === 'string');
    this.host = options.host;
  }

  if (options.port != null) {
    assert(util.isU16(options.port), 'Port must be a number.');
    this.port = options.port;
  }

  if (options.sockets != null) {
    assert(typeof options.sockets === 'boolean');
    this.sockets = options.sockets;
  }

  if (options.prefix != null) {
    assert(typeof options.prefix === 'string');
    this.prefix = options.prefix;
    this.keyFile = path.join(this.prefix, 'key.pem');
    this.certFile = path.join(this.prefix, 'cert.pem');
  }

  if (options.ssl != null) {
    assert(typeof options.ssl === 'boolean');
    this.ssl = options.ssl;
  }

  if (options.keyFile != null) {
    assert(typeof options.keyFile === 'string');
    this.keyFile = options.keyFile;
  }

  if (options.certFile != null) {
    assert(typeof options.certFile === 'string');
    this.certFile = options.certFile;
  }

  if (options.key != null) {
    assert(typeof options.key === 'string' || Buffer.isBuffer(options.key));
    this.key = options.key;
  }

  if (options.cert != null) {
    assert(typeof options.cert === 'string' || Buffer.isBuffer(options.cert));
    this.cert = options.cert;
  }

  if (options.ca != null) {
    assert(Array.isArray(options.ca));
    this.ca = options.ca;
  }

  if (this.ssl) {
    assert(this.key || this.keyFile, 'SSL specified with no provided key.');
    assert(this.cert || this.certFile, 'SSL specified with no provided cert.');
  }

  return this;
};

/**
 * Load key and cert file.
 * @private
 */

HTTPBaseOptions.prototype.load = function load() {
  if (!this.ssl)
    return;

  if (this.keyFile)
    this.key = fs.readFileSync(this.keyFile);

  if (this.certFile)
    this.cert = fs.readFileSync(this.certFile);
};

/**
 * Instantiate http server options from object.
 * @param {Object} options
 * @returns {HTTPBaseOptions}
 */

HTTPBaseOptions.fromOptions = function fromOptions(options) {
  return new HTTPBaseOptions().fromOptions(options);
};

/**
 * Get HTTP server backend.
 * @private
 * @returns {Object}
 */

HTTPBaseOptions.prototype.getBackend = function getBackend() {
  return this.ssl ? __webpack_require__(109) : __webpack_require__(72);
};

/**
 * Get HTTP server options.
 * @private
 * @returns {Object}
 */

HTTPBaseOptions.prototype.toHTTP = function toHTTP() {
  if (!this.ssl)
    return undefined;

  return {
    key: this.key,
    cert: this.cert,
    ca: this.ca
  };
};

/**
 * HTTP Base Options
 * @alias module:http.BodyParserOptions
 * @constructor
 * @param {Object} options
 */

function BodyParserOptions(options) {
  if (!(this instanceof BodyParserOptions))
    return new BodyParserOptions(options);

  this.keyLimit = 100;
  this.bodyLimit = 20 << 20;
  this.contentType = null;
  this.timeout = 10 * 1000;

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from object.
 * @private
 * @param {Object} options
 * @returns {BodyParserOptions}
 */

BodyParserOptions.prototype.fromOptions = function fromOptions(options) {
  assert(options);

  if (options.keyLimit != null) {
    assert(typeof options.keyLimit === 'number');
    this.keyLimit = options.keyLimit;
  }

  if (options.bodyLimit != null) {
    assert(typeof options.bodyLimit === 'number');
    this.bodyLimit = options.bodyLimit;
  }

  if (options.contentType != null) {
    assert(typeof options.contentType === 'string');
    this.contentType = options.contentType;
  }

  return this;
};

/**
 * Route
 * @constructor
 * @ignore
 */

function Route(ctx, path, handler) {
  if (!(this instanceof Route))
    return new Route(ctx, path, handler);

  this.ctx = null;
  this.path = null;
  this.handler = null;

  this.regex = /^/;
  this.map = [];
  this.compiled = false;

  if (ctx) {
    assert(typeof ctx === 'object');
    this.ctx = ctx;
  }

  if (path) {
    if (path instanceof RegExp) {
      this.regex = path;
    } else {
      assert(typeof path === 'string');
      assert(path.length > 0);
      this.path = path;
    }
  }

  assert(handler);
  assert(typeof handler === 'function' || typeof handler === 'object');

  this.handler = handler;
}

Route.prototype.compile = function compile() {
  let path = this.path;
  const map = this.map;

  if (this.compiled)
    return;

  this.compiled = true;

  if (!path)
    return;

  path = path.replace(/(\/[^\/]+)\?/g, '(?:$1)?');
  path = path.replace(/\.(?!\+)/g, '\\.');
  path = path.replace(/\*/g, '.*?');
  path = path.replace(/%/g, '\\');

  path = path.replace(/:(\w+)/g, (str, name) => {
    map.push(name);
    return '([^/]+)';
  });

  this.regex = new RegExp('^' + path + '$');
};

Route.prototype.match = function match(pathname) {
  this.compile();

  assert(this.regex);

  const matches = this.regex.exec(pathname);

  if (!matches)
    return null;

  const params = Object.create(null);

  for (let i = 1; i < matches.length; i++) {
    const item = matches[i];
    const key = this.map[i - 1];

    if (key)
      params[key] = item;

    params[i - 1] = item;
  }

  return params;
};

Route.prototype.hasPrefix = function hasPrefix(pathname) {
  if (!this.path)
    return true;

  return pathname.indexOf(this.path) === 0;
};

Route.prototype.call = async function call(req, res) {
  await this.handler.call(this.ctx, req, res);
  return res.sent;
};

/**
 * Routes
 * @constructor
 * @ignore
 */

function Routes() {
  if (!(this instanceof Routes))
    return new Routes();

  this.get = [];
  this.post = [];
  this.put = [];
  this.del = [];
}

Routes.prototype.getHandlers = function getHandlers(method) {
  if (!method)
    return null;

  method = method.toUpperCase();

  switch (method) {
    case 'GET':
      return this.get;
    case 'POST':
      return this.post;
    case 'PUT':
      return this.put;
    case 'DELETE':
      return this.del;
    default:
      return null;
  }
};

/**
 * Request
 * @constructor
 * @ignore
 */

function Request(req, res, url) {
  if (!(this instanceof Request))
    return new Request(req, res, url);

  EventEmitter.call(this);

  this.req = null;
  this.res = null;
  this.socket = null;
  this.method = 'GET';
  this.headers = Object.create(null);
  this.contentType = 'bin';
  this.url = '/';
  this.pathname = '/';
  this.path = [];
  this.trailing = false;
  this.query = Object.create(null);
  this.params = Object.create(null);
  this.body = Object.create(null);
  this.hasBody = false;
  this.username = null;
  this.readable = true;
  this.writable = false;

  if (req)
    this.init(req, res, url);
}

Object.setPrototypeOf(Request.prototype, EventEmitter.prototype);

Request.prototype.init = function init(req, res, url) {
  assert(req);
  assert(res);

  this.req = req;
  this.res = res;
  this.socket = req.socket;
  this.method = req.method;
  this.headers = req.headers;
  this.contentType = parseType(req.headers['content-type']);

  req.on('error', (err) => {
    this.emit('error', err);
  });

  req.on('data', (data) => {
    this.emit('data', data);
  });

  req.on('end', () => {
    this.emit('end');
  });

  if (url != null) {
    try {
      this.parse(url);
    } catch (e) {
      ;
    }
  }
};

Request.prototype.parse = function parse(url) {
  const uri = URL.parse(url);
  let pathname = uri.pathname;
  let query = Object.create(null);
  let trailing = false;

  if (pathname) {
    pathname = pathname.replace(/\/{2,}/g, '/');

    if (pathname[0] !== '/')
      pathname = '/' + pathname;

    if (pathname.length > 1) {
      if (pathname[pathname.length - 1] === '/') {
        pathname = pathname.slice(0, -1);
        trailing = true;
      }
    }

    pathname = pathname.replace(/%2f/gi, '');
    pathname = unescape(pathname);
  } else {
    pathname = '/';
  }

  assert(pathname.length > 0);
  assert(pathname[0] === '/');

  if (pathname.length > 1)
    assert(pathname[pathname.length - 1] !== '/');

  let path = pathname;

  if (path[0] === '/')
    path = path.substring(1);

  let parts = path.split('/');

  if (parts.length === 1) {
    if (parts[0].length === 0)
      parts = [];
  }

  url = pathname;

  if (uri.search && uri.search.length > 1) {
    assert(uri.search[0] === '?');
    url += uri.search;
  }

  if (uri.hash && uri.hash.length > 1) {
    assert(uri.hash[0] === '#');
    url += uri.hash;
  }

  if (uri.query)
    query = parsePairs(uri.query, 100);

  this.url = url;
  this.pathname = pathname;
  this.path = parts;
  this.query = query;
  this.trailing = trailing;
};

Request.prototype.rewrite = function rewrite(url) {
  const req = new Request();
  req.init(this.req, this.res, url);
  req.body = this.body;
  req.hasBody = this.hasBody;
  return req;
};

Request.prototype.valid = function valid() {
  return new Validator([this.query, this.params, this.body]);
};

Request.prototype.pipe = function pipe(dest) {
  return this.req.pipe(dest);
};

Request.prototype.pause = function pause() {
  return this.req.pause();
};

Request.prototype.resume = function resume() {
  return this.req.resume();
};

Request.prototype.destroy = function destroy() {
  return this.req.destroy();
};

/**
 * Response
 * @constructor
 * @ignore
 */

function Response(req, res) {
  if (!(this instanceof Response))
    return new Response(req, res);

  EventEmitter.call(this);

  this.req = req;
  this.res = res;
  this.sent = false;
  this.readable = false;
  this.writable = true;
  this.statusCode = 200;
  this.res.statusCode = 200;

  if (req)
    this.init(req, res);
}

Object.setPrototypeOf(Response.prototype, EventEmitter.prototype);

Response.prototype.init = function init(req, res) {
  assert(req);
  assert(res);

  res.on('error', (err) => {
    this.emit('error', err);
  });

  res.on('drain', () => {
    this.emit('drain');
  });

  res.on('close', () => {
    this.emit('close');
  });
};

Response.prototype.setStatus = function setStatus(code) {
  this.statusCode = code;
  this.res.statusCode = code;
};

Response.prototype.setType = function setType(type) {
  this.setHeader('Content-Type', getType(type));
};

Response.prototype.hasType = function hasType() {
  return this.getHeader('Content-Type') != null;
};

Response.prototype.destroy = function destroy() {
  return this.res.destroy();
};

Response.prototype.setHeader = function setHeader(key, value) {
  return this.res.setHeader(key, value);
};

Response.prototype.getHeader = function getHeader(key) {
  return this.res.getHeader(key);
};

Response.prototype.writeHead = function writeHead(code, headers) {
  return this.res.writeHead(code, headers);
};

Response.prototype.write = function write(data, enc) {
  return this.res.write(data, enc);
};

Response.prototype.end = function end(data, enc) {
  this.sent = true;
  return this.res.end(data, enc);
};

Response.prototype.error = function error(code, err) {
  if (this.sent)
    return;

  if (!code)
    code = 400;

  this.send(code, {
    error: {
      type: err.type || 'Error',
      message: err.message,
      code: err.code
    }
  });
};

Response.prototype.redirect = function redirect(code, url) {
  if (!url) {
    url = code;
    code = 301;
  }

  this.setStatus(code);
  this.setHeader('Location', url);
  this.end();
};

Response.prototype.send = function send(code, msg, type) {
  if (this.sent)
    return;

  assert(typeof code === 'number', 'Code must be a number.');

  if (msg == null) {
    msg = {
      error: {
        type: 'Error',
        message: 'No message.'
      }
    };
  }

  if (msg && typeof msg === 'object' && !Buffer.isBuffer(msg)) {
    msg = JSON.stringify(msg, null, 2) + '\n';
    if (!type)
      type = 'json';
    assert(type === 'json', 'Bad type passed with json object.');
  }

  if (!type && !this.hasType())
    type = typeof msg === 'string' ? 'txt' : 'bin';

  this.setStatus(code);

  if (type)
    this.setType(type);

  if (typeof msg === 'string') {
    const len = Buffer.byteLength(msg, 'utf8');
    this.setHeader('Content-Length', len.toString(10));
    try {
      this.write(msg, 'utf8');
      this.end();
    } catch (e) {
      ;
    }
    return;
  }

  if (Buffer.isBuffer(msg)) {
    this.setHeader('Content-Length', msg.length.toString(10));
    try {
      this.write(msg);
      this.end();
    } catch (e) {
      ;
    }
    return;
  }

  assert(false, 'Bad object passed to send.');
};

/**
 * WebSocket
 * @constructor
 * @ignore
 * @param {SocketIO.Socket}
 */

function WebSocket(socket, ctx) {
  if (!(this instanceof WebSocket))
    return new WebSocket(socket, ctx);

  EventEmitter.call(this);

  this.context = ctx;
  this.socket = socket;
  this.remoteAddress = socket.conn.remoteAddress;
  this.hooks = Object.create(null);
  this.channels = new Map();
  this.auth = false;
  this.filter = null;
  this.prev = null;
  this.next = null;

  this.init();
}

Object.setPrototypeOf(WebSocket.prototype, EventEmitter.prototype);

WebSocket.prototype.init = function init() {
  const socket = this.socket;
  const onevent = socket.onevent.bind(socket);

  socket.onevent = (packet) => {
    const result = onevent(packet);
    this.onevent(packet);
    return result;
  };

  socket.on('error', (err) => {
    this.dispatch('error', err);
  });

  socket.on('disconnect', () => {
    this.dispatch('close');
  });
};

WebSocket.prototype.onevent = async function onevent(packet) {
  const args = (packet.data || []).slice();
  const type = args.shift() || '';

  let ack;
  if (typeof args[args.length - 1] === 'function')
    ack = args.pop();
  else
    ack = this.socket.ack(packet.id);

  let result;
  try {
    result = await this.fire(type, args);
  } catch (e) {
    ack({
      type: e.type || 'Error',
      message: e.message,
      code: e.code
    });
    return;
  }

  if (result === undefined)
    return;

  ack(null, result);
};

WebSocket.prototype.hook = function hook(type, handler) {
  assert(!this.hooks[type], 'Event already added.');
  this.hooks[type] = handler;
};

WebSocket.prototype.fire = async function fire(type, args) {
  const handler = this.hooks[type];

  if (!handler)
    return undefined;

  return await handler.call(this.context, args);
};

WebSocket.prototype.join = function join(name) {
  this.dispatch('join channel', name);
};

WebSocket.prototype.leave = function leave(name) {
  this.dispatch('leave channel', name);
};

WebSocket.prototype.dispatch = function dispatch() {
  const emit = EventEmitter.prototype.emit;
  return emit.apply(this, arguments);
};

WebSocket.prototype.emit = function emit() {
  return this.socket.emit.apply(this.socket, arguments);
};

WebSocket.prototype.call = function call(...args) {
  const socket = this.socket;
  return new Promise((resolve, reject) => {
    args.push(co.wrap(resolve, reject));
    socket.emit(...args);
  });
};

WebSocket.prototype.destroy = function destroy() {
  return this.socket.disconnect();
};

/*
 * Helpers
 */

function parsePairs(str, limit) {
  const parts = str.split('&');
  const data = Object.create(null);

  if (parts.length > limit)
    return data;

  assert(!limit || parts.length <= limit, 'Too many keys in querystring.');

  for (const pair of parts) {
    const index = pair.indexOf('=');

    let key, value;
    if (index === -1) {
      key = pair;
      value = '';
    } else {
      key = pair.substring(0, index);
      value = pair.substring(index + 1);
    }

    key = unescape(key);

    if (key.length === 0)
      continue;

    value = unescape(value);

    if (value.length === 0)
      continue;

    data[key] = value;
  }

  return data;
}

function unescape(str) {
  try {
    str = decodeURIComponent(str);
    str = str.replace(/\+/g, ' ');
  } catch (e) {
    ;
  }
  str = str.replace(/\0/g, '');
  return str;
}

function getType(type) {
  switch (type) {
    case 'json':
      return 'application/json';
    case 'form':
      return 'application/x-www-form-urlencoded; charset=utf-8';
    case 'html':
      return 'text/html; charset=utf-8';
    case 'xml':
      return 'application/xml; charset=utf-8';
    case 'js':
      return 'application/javascript; charset=utf-8';
    case 'css':
      return 'text/css; charset=utf-8';
    case 'txt':
      return 'text/plain; charset=utf-8';
    case 'bin':
      return 'application/octet-stream';
    default:
      return type;
  }
}

function parseType(type) {
  type = type || '';
  type = type.split(';')[0];
  type = type.toLowerCase();
  type = type.trim();

  switch (type) {
    case 'text/x-json':
    case 'application/json':
      return 'json';
    case 'application/x-www-form-urlencoded':
      return 'form';
    case 'text/html':
    case 'application/xhtml+xml':
      return 'html';
    case 'text/javascript':
    case 'application/javascript':
      return 'js';
    case 'text/css':
      return 'css';
    case 'text/plain':
      return 'txt';
    case 'application/octet-stream':
      return 'bin';
    default:
      return 'bin';
  }
}

/*
 * Expose
 */

module.exports = HTTPBase;


/***/ }),
/* 170 */
/***/ (function(module, exports) {

module.exports = require("string_decoder");

/***/ }),
/* 171 */
/***/ (function(module, exports) {

module.exports = require("tty");

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var argv = process.argv;

var terminator = argv.indexOf('--');
var hasFlag = function (flag) {
	flag = '--' + flag;
	var pos = argv.indexOf(flag);
	return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
};

module.exports = (function () {
	if ('FORCE_COLOR' in process.env) {
		return true;
	}

	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false')) {
		return false;
	}

	if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
})();


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var debug = __webpack_require__(283)('socket.io-parser');
var Emitter = __webpack_require__(73);
var binary = __webpack_require__(287);
var isArray = __webpack_require__(221);
var isBuf = __webpack_require__(222);

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

var ERROR_PACKET = exports.ERROR + '"encode error"';

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    encodeAsBinary(obj, callback);
  } else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {

  // first is type
  var str = '' + obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    str += obj.attachments + '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' !== obj.nsp) {
    str += obj.nsp + ',';
  }

  // immediately followed by the id
  if (null != obj.id) {
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    var payload = tryStringify(obj.data);
    if (payload !== false) {
      str += payload;
    } else {
      return ERROR_PACKET;
    }
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

function tryStringify(str) {
  try {
    return JSON.stringify(str);
  } catch(e){
    return false;
  }
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an encoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if (typeof obj === 'string') {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  } else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  } else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var i = 0;
  // look up type
  var p = {
    type: Number(str.charAt(0))
  };

  if (null == exports.types[p.type]) {
    return error('unknown packet type ' + p.type);
  }

  // look up attachments if type binary
  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
    var buf = '';
    while (str.charAt(++i) !== '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) !== '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' === str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' === c) break;
      p.nsp += c;
      if (i === str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i === str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    var payload = tryParse(str.substr(i));
    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));
    if (isPayloadValid) {
      p.data = payload;
    } else {
      return error('invalid payload');
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

function tryParse(str) {
  try {
    return JSON.parse(str);
  } catch(e){
    return false;
  }
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(msg) {
  return {
    type: exports.ERROR,
    data: 'parser error: ' + msg
  };
}


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.
 *
 * This can be used with JS designed for browsers to improve reuse of code and
 * allow the use of existing libraries.
 *
 * Usage: include("XMLHttpRequest.js") and use XMLHttpRequest per W3C specs.
 *
 * @author Dan DeFelippi <dan@driverdan.com>
 * @contributor David Ellis <d.f.ellis@ieee.org>
 * @license MIT
 */

var fs = __webpack_require__(64);
var Url = __webpack_require__(90);
var spawn = __webpack_require__(225).spawn;

/**
 * Module exports.
 */

module.exports = XMLHttpRequest;

// backwards-compat
XMLHttpRequest.XMLHttpRequest = XMLHttpRequest;

/**
 * `XMLHttpRequest` constructor.
 *
 * Supported options for the `opts` object are:
 *
 *  - `agent`: An http.Agent instance; http.globalAgent may be used; if 'undefined', agent usage is disabled
 *
 * @param {Object} opts optional "options" object
 */

function XMLHttpRequest(opts) {
  "use strict";

  opts = opts || {};

  /**
   * Private variables
   */
  var self = this;
  var http = __webpack_require__(72);
  var https = __webpack_require__(109);

  // Holds http.js objects
  var request;
  var response;

  // Request settings
  var settings = {};

  // Disable header blacklist.
  // Not part of XHR specs.
  var disableHeaderCheck = false;

  // Set some default headers
  var defaultHeaders = {
    "User-Agent": "node-XMLHttpRequest",
    "Accept": "*/*"
  };

  var headers = Object.assign({}, defaultHeaders);

  // These headers are not user setable.
  // The following are allowed but banned in the spec:
  // * user-agent
  var forbiddenRequestHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "content-transfer-encoding",
    "cookie",
    "cookie2",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "via"
  ];

  // These request methods are not allowed
  var forbiddenRequestMethods = [
    "TRACE",
    "TRACK",
    "CONNECT"
  ];

  // Send flag
  var sendFlag = false;
  // Error flag, used when errors occur or abort is called
  var errorFlag = false;

  // Event listeners
  var listeners = {};

  /**
   * Constants
   */

  this.UNSENT = 0;
  this.OPENED = 1;
  this.HEADERS_RECEIVED = 2;
  this.LOADING = 3;
  this.DONE = 4;

  /**
   * Public vars
   */

  // Current state
  this.readyState = this.UNSENT;

  // default ready state change handler in case one is not set or is set late
  this.onreadystatechange = null;

  // Result & response
  this.responseText = "";
  this.responseXML = "";
  this.status = null;
  this.statusText = null;

  /**
   * Private methods
   */

  /**
   * Check if the specified header is allowed.
   *
   * @param string header Header to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpHeader = function(header) {
    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);
  };

  /**
   * Check if the specified method is allowed.
   *
   * @param string method Request method to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpMethod = function(method) {
    return (method && forbiddenRequestMethods.indexOf(method) === -1);
  };

  /**
   * Public methods
   */

  /**
   * Open the connection. Currently supports local server requests.
   *
   * @param string method Connection method (eg GET, POST)
   * @param string url URL for the connection.
   * @param boolean async Asynchronous connection. Default is true.
   * @param string user Username for basic authentication (optional)
   * @param string password Password for basic authentication (optional)
   */
  this.open = function(method, url, async, user, password) {
    this.abort();
    errorFlag = false;

    // Check for valid request method
    if (!isAllowedHttpMethod(method)) {
      throw "SecurityError: Request method not allowed";
    }

    settings = {
      "method": method,
      "url": url.toString(),
      "async": (typeof async !== "boolean" ? true : async),
      "user": user || null,
      "password": password || null
    };

    setState(this.OPENED);
  };

  /**
   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.
   * This does not conform to the W3C spec.
   *
   * @param boolean state Enable or disable header checking.
   */
  this.setDisableHeaderCheck = function(state) {
    disableHeaderCheck = state;
  };

  /**
   * Sets a header for the request.
   *
   * @param string header Header name
   * @param string value Header value
   * @return boolean Header added
   */
  this.setRequestHeader = function(header, value) {
    if (this.readyState != this.OPENED) {
      throw "INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN";
      return false;
    }
    if (!isAllowedHttpHeader(header)) {
      console.warn('Refused to set unsafe header "' + header + '"');
      return false;
    }
    if (sendFlag) {
      throw "INVALID_STATE_ERR: send flag is true";
      return false;
    }
    headers[header] = value;
    return true;
  };

  /**
   * Gets a header from the server response.
   *
   * @param string header Name of header to get.
   * @return string Text of the header or null if it doesn't exist.
   */
  this.getResponseHeader = function(header) {
    if (typeof header === "string"
      && this.readyState > this.OPENED
      && response.headers[header.toLowerCase()]
      && !errorFlag
    ) {
      return response.headers[header.toLowerCase()];
    }

    return null;
  };

  /**
   * Gets all the response headers.
   *
   * @return string A string with all response headers separated by CR+LF
   */
  this.getAllResponseHeaders = function() {
    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {
      return "";
    }
    var result = "";

    for (var i in response.headers) {
      // Cookie headers are excluded
      if (i !== "set-cookie" && i !== "set-cookie2") {
        result += i + ": " + response.headers[i] + "\r\n";
      }
    }
    return result.substr(0, result.length - 2);
  };

  /**
   * Gets a request header
   *
   * @param string name Name of header to get
   * @return string Returns the request header or empty string if not set
   */
  this.getRequestHeader = function(name) {
    // @TODO Make this case insensitive
    if (typeof name === "string" && headers[name]) {
      return headers[name];
    }

    return "";
  };

  /**
   * Sends the request to the server.
   *
   * @param string data Optional data to send as request body.
   */
  this.send = function(data) {
    if (this.readyState != this.OPENED) {
      throw "INVALID_STATE_ERR: connection must be opened before send() is called";
    }

    if (sendFlag) {
      throw "INVALID_STATE_ERR: send has already been called";
    }

    var ssl = false, local = false;
    var url = Url.parse(settings.url);
    var host;
    // Determine the server
    switch (url.protocol) {
      case 'https:':
        ssl = true;
        // SSL & non-SSL both need host, no break here.
      case 'http:':
        host = url.hostname;
        break;

      case 'file:':
        local = true;
        break;

      case undefined:
      case '':
        host = "localhost";
        break;

      default:
        throw "Protocol not supported.";
    }

    // Load files off the local filesystem (file://)
    if (local) {
      if (settings.method !== "GET") {
        throw "XMLHttpRequest: Only GET method is supported";
      }

      if (settings.async) {
        fs.readFile(url.pathname, 'utf8', function(error, data) {
          if (error) {
            self.handleError(error);
          } else {
            self.status = 200;
            self.responseText = data;
            setState(self.DONE);
          }
        });
      } else {
        try {
          this.responseText = fs.readFileSync(url.pathname, 'utf8');
          this.status = 200;
          setState(self.DONE);
        } catch(e) {
          this.handleError(e);
        }
      }

      return;
    }

    // Default to port 80. If accessing localhost on another port be sure
    // to use http://localhost:port/path
    var port = url.port || (ssl ? 443 : 80);
    // Add query string if one is used
    var uri = url.pathname + (url.search ? url.search : '');

    // Set the Host header or the server may reject the request
    headers["Host"] = host;
    if (!((ssl && port === 443) || port === 80)) {
      headers["Host"] += ':' + url.port;
    }

    // Set Basic Auth if necessary
    if (settings.user) {
      if (typeof settings.password == "undefined") {
        settings.password = "";
      }
      var authBuf = new Buffer(settings.user + ":" + settings.password);
      headers["Authorization"] = "Basic " + authBuf.toString("base64");
    }

    // Set content length header
    if (settings.method === "GET" || settings.method === "HEAD") {
      data = null;
    } else if (data) {
      headers["Content-Length"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);

      if (!headers["Content-Type"]) {
        headers["Content-Type"] = "text/plain;charset=UTF-8";
      }
    } else if (settings.method === "POST") {
      // For a post with no data set Content-Length: 0.
      // This is required by buggy servers that don't meet the specs.
      headers["Content-Length"] = 0;
    }

    var agent = opts.agent || false;
    var options = {
      host: host,
      port: port,
      path: uri,
      method: settings.method,
      headers: headers,
      agent: agent
    };

    if (ssl) {
      options.pfx = opts.pfx;
      options.key = opts.key;
      options.passphrase = opts.passphrase;
      options.cert = opts.cert;
      options.ca = opts.ca;
      options.ciphers = opts.ciphers;
      options.rejectUnauthorized = opts.rejectUnauthorized;
    }

    // Reset error flag
    errorFlag = false;

    // Handle async requests
    if (settings.async) {
      // Use the proper protocol
      var doRequest = ssl ? https.request : http.request;

      // Request is being sent, set send flag
      sendFlag = true;

      // As per spec, this is called here for historical reasons.
      self.dispatchEvent("readystatechange");

      // Handler for the response
      var responseHandler = function(resp) {
        // Set response var to the response we got back
        // This is so it remains accessable outside this scope
        response = resp;
        // Check for redirect
        // @TODO Prevent looped redirects
        if (response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {
          // Change URL to the redirect location
          settings.url = response.headers.location;
          var url = Url.parse(settings.url);
          // Set host var in case it's used later
          host = url.hostname;
          // Options for the new request
          var newOptions = {
            hostname: url.hostname,
            port: url.port,
            path: url.path,
            method: response.statusCode === 303 ? 'GET' : settings.method,
            headers: headers
          };

          if (ssl) {
            newOptions.pfx = opts.pfx;
            newOptions.key = opts.key;
            newOptions.passphrase = opts.passphrase;
            newOptions.cert = opts.cert;
            newOptions.ca = opts.ca;
            newOptions.ciphers = opts.ciphers;
            newOptions.rejectUnauthorized = opts.rejectUnauthorized;
          }

          // Issue the new request
          request = doRequest(newOptions, responseHandler).on('error', errorHandler);
          request.end();
          // @TODO Check if an XHR event needs to be fired here
          return;
        }

        if (response && response.setEncoding) {
          response.setEncoding("utf8");
        }

        setState(self.HEADERS_RECEIVED);
        self.status = response.statusCode;

        response.on('data', function(chunk) {
          // Make sure there's some data
          if (chunk) {
            self.responseText += chunk;
          }
          // Don't emit state changes if the connection has been aborted.
          if (sendFlag) {
            setState(self.LOADING);
          }
        });

        response.on('end', function() {
          if (sendFlag) {
            // The sendFlag needs to be set before setState is called.  Otherwise if we are chaining callbacks
            // there can be a timing issue (the callback is called and a new call is made before the flag is reset).
            sendFlag = false;
            // Discard the 'end' event if the connection has been aborted
            setState(self.DONE);
          }
        });

        response.on('error', function(error) {
          self.handleError(error);
        });
      }

      // Error handler for the request
      var errorHandler = function(error) {
        self.handleError(error);
      }

      // Create the request
      request = doRequest(options, responseHandler).on('error', errorHandler);

      // Node 0.4 and later won't accept empty data. Make sure it's needed.
      if (data) {
        request.write(data);
      }

      request.end();

      self.dispatchEvent("loadstart");
    } else { // Synchronous
      // Create a temporary file for communication with the other Node process
      var contentFile = ".node-xmlhttprequest-content-" + process.pid;
      var syncFile = ".node-xmlhttprequest-sync-" + process.pid;
      fs.writeFileSync(syncFile, "", "utf8");
      // The async request the other Node process executes
      var execString = "var http = require('http'), https = require('https'), fs = require('fs');"
        + "var doRequest = http" + (ssl ? "s" : "") + ".request;"
        + "var options = " + JSON.stringify(options) + ";"
        + "var responseText = '';"
        + "var req = doRequest(options, function(response) {"
        + "response.setEncoding('utf8');"
        + "response.on('data', function(chunk) {"
        + "  responseText += chunk;"
        + "});"
        + "response.on('end', function() {"
        + "fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-STATUS:' + response.statusCode + ',' + responseText, 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + "response.on('error', function(error) {"
        + "fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + "}).on('error', function(error) {"
        + "fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + (data ? "req.write('" + data.replace(/'/g, "\\'") + "');":"")
        + "req.end();";
      // Start the other Node Process, executing this string
      var syncProc = spawn(process.argv[0], ["-e", execString]);
      var statusText;
      while(fs.existsSync(syncFile)) {
        // Wait while the sync file is empty
      }
      self.responseText = fs.readFileSync(contentFile, 'utf8');
      // Kill the child process once the file has data
      syncProc.stdin.end();
      // Remove the temporary file
      fs.unlinkSync(contentFile);
      if (self.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR:/)) {
        // If the file returned an error, handle it
        var errorObj = self.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, "");
        self.handleError(errorObj);
      } else {
        // If the file returned okay, parse its data and move to the DONE state
        self.status = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:([0-9]*),.*/, "$1");
        self.responseText = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:[0-9]*,(.*)/, "$1");
        setState(self.DONE);
      }
    }
  };

  /**
   * Called when an error is encountered to deal with it.
   */
  this.handleError = function(error) {
    this.status = 503;
    this.statusText = error;
    this.responseText = error.stack;
    errorFlag = true;
    setState(this.DONE);
  };

  /**
   * Aborts a request.
   */
  this.abort = function() {
    if (request) {
      request.abort();
      request = null;
    }

    headers = Object.assign({}, defaultHeaders);
    this.responseText = "";
    this.responseXML = "";

    errorFlag = true;

    if (this.readyState !== this.UNSENT
        && (this.readyState !== this.OPENED || sendFlag)
        && this.readyState !== this.DONE) {
      sendFlag = false;
      setState(this.DONE);
    }
    this.readyState = this.UNSENT;
  };

  /**
   * Adds an event listener. Preferred method of binding to events.
   */
  this.addEventListener = function(event, callback) {
    if (!(event in listeners)) {
      listeners[event] = [];
    }
    // Currently allows duplicate callbacks. Should it?
    listeners[event].push(callback);
  };

  /**
   * Remove an event callback that has already been bound.
   * Only works on the matching funciton, cannot be a copy.
   */
  this.removeEventListener = function(event, callback) {
    if (event in listeners) {
      // Filter will return a new array with the callback removed
      listeners[event] = listeners[event].filter(function(ev) {
        return ev !== callback;
      });
    }
  };

  /**
   * Dispatch any events, including both "on" methods and events attached using addEventListener.
   */
  this.dispatchEvent = function(event) {
    if (typeof self["on" + event] === "function") {
      self["on" + event]();
    }
    if (event in listeners) {
      for (var i = 0, len = listeners[event].length; i < len; i++) {
        listeners[event][i].call(self);
      }
    }
  };

  /**
   * Changes readyState and calls onreadystatechange.
   *
   * @param int state New state
   */
  var setState = function(state) {
    if (self.readyState !== state) {
      self.readyState = state;

      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {
        self.dispatchEvent("readystatechange");
      }

      if (self.readyState === self.DONE && !errorFlag) {
        self.dispatchEvent("load");
        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)
        self.dispatchEvent("loadend");
      }
    }
  };
};


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var parser = __webpack_require__(74);
var Emitter = __webpack_require__(73);

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.forceNode = opts.forceNode;

  // results of ReactNative environment detection
  this.isReactNative = opts.isReactNative;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
  this.localAddress = opts.localAddress;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' === this.readyState || '' === this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function (packets) {
  if ('open' === this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function (data) {
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};


/***/ }),
/* 176 */
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  const target = Buffer.allocUnsafe(totalLength);
  var offset = 0;

  for (var i = 0; i < list.length; i++) {
    const buf = list[i];
    buf.copy(target, offset);
    offset += buf.length;
  }

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (var i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  const length = buffer.length;
  for (var i = 0; i < length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

try {
  const bufferUtil = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"bufferutil\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
  const bu = bufferUtil.BufferUtil || bufferUtil;

  module.exports = {
    mask(source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bu.mask(source, mask, output, offset, length);
    },
    unmask(buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bu.unmask(buffer, mask);
    },
    concat
  };
} catch (e) /* istanbul ignore next */ {
  module.exports = { concat, mask: _mask, unmask: _unmask };
}


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * rpcbase.js - json rpc for wmcc_core.
 */



const assert = __webpack_require__(0);
const EventEmitter = __webpack_require__(10);
const Lock = __webpack_require__(23);
const Logger = __webpack_require__(34);

/**
 * JSON RPC
 * @alias module:http.RPCBase
 * @constructor
 */

function RPCBase() {
  if (!(this instanceof RPCBase))
    return new RPCBase();

  EventEmitter.call(this);

  this.logger = Logger.global;
  this.calls = Object.create(null);
  this.mounts = [];
  this.locker = new Lock();
}

Object.setPrototypeOf(RPCBase.prototype, EventEmitter.prototype);

/**
 * RPC errors.
 * @enum {Number}
 * @default
 */

RPCBase.errors = {
  // Standard JSON-RPC 2.0 errors
  INVALID_REQUEST: -32600,
  METHOD_NOT_FOUND: -32601,
  INVALID_PARAMS: -32602,
  INTERNAL_ERROR: -32603,
  PARSE_ERROR: -32700,

  // General application defined errors
  MISC_ERROR: -1,
  FORBIDDEN_BY_SAFE_MODE: -2,
  TYPE_ERROR: -3,
  INVALID_ADDRESS_OR_KEY: -5,
  OUT_OF_MEMORY: -7,
  INVALID_PARAMETER: -8,
  DATABASE_ERROR: -20,
  DESERIALIZATION_ERROR: -22,
  VERIFY_ERROR: -25,
  VERIFY_REJECTED: -26,
  VERIFY_ALREADY_IN_CHAIN: -27,
  IN_WARMUP: -28,

  // Aliases for backward compatibility
  TRANSACTION_ERROR: -25,
  TRANSACTION_REJECTED: -26,
  TRANSACTION_ALREADY_IN_CHAIN: -27,

  // P2P client errors
  CLIENT_NOT_CONNECTED: -9,
  CLIENT_IN_INITIAL_DOWNLOAD: -10,
  CLIENT_NODE_ALREADY_ADDED: -23,
  CLIENT_NODE_NOT_ADDED: -24,
  CLIENT_NODE_NOT_CONNECTED: -29,
  CLIENT_INVALID_IP_OR_SUBNET: -30,
  CLIENT_P2P_DISABLED: -31,

  // Wallet errors
  WALLET_ERROR: -4,
  WALLET_INSUFFICIENT_FUNDS: -6,
  WALLET_INVALID_ACCOUNT_NAME: -11,
  WALLET_KEYPOOL_RAN_OUT: -12,
  WALLET_UNLOCK_NEEDED: -13,
  WALLET_PASSPHRASE_INCORRECT: -14,
  WALLET_WRONG_ENC_STATE: -15,
  WALLET_ENCRYPTION_FAILED: -16,
  WALLET_ALREADY_UNLOCKED: -17
};

/**
 * Magic string for signing.
 * @const {String}
 * @default
 */

RPCBase.MAGIC_STRING = 'WMCoin Signed Message:\n';

/**
 * Execute batched RPC calls.
 * @param {Object|Object[]} body
 * @param {Object} query
 * @returns {Promise}
 */

RPCBase.prototype.call = async function call(body, query) {
  let cmds = body;
  let out = [];
  let array = true;

  if (!Array.isArray(cmds)) {
    cmds = [cmds];
    array = false;
  }

  for (const cmd of cmds) {
    if (!cmd || typeof cmd !== 'object') {
      out.push({
        result: null,
        error: {
          message: 'Invalid request.',
          code: RPCBase.errors.INVALID_REQUEST
        },
        id: null
      });
      continue;
    }

    if (cmd.id && typeof cmd.id === 'object') {
      out.push({
        result: null,
        error: {
          message: 'Invalid ID.',
          code: RPCBase.errors.INVALID_REQUEST
        },
        id: null
      });
      continue;
    }

    if (cmd.id == null)
      cmd.id = null;

    if (!cmd.params)
      cmd.params = [];

    if (typeof cmd.method !== 'string') {
      out.push({
        result: null,
        error: {
          message: 'Method not found.',
          code: RPCBase.errors.METHOD_NOT_FOUND
        },
        id: cmd.id
      });
      continue;
    }

    if (!Array.isArray(cmd.params)) {
      out.push({
        result: null,
        error: {
          message: 'Invalid params.',
          code: RPCBase.errors.INVALID_PARAMS
        },
        id: cmd.id
      });
      continue;
    }

    if (cmd.method !== 'getwork'
        && cmd.method !== 'getblocktemplate'
        && cmd.method !== 'getbestblockhash') {
      this.logger.debug('Handling RPC call: %s.', cmd.method);
      if (cmd.method !== 'submitblock'
          && cmd.method !== 'getmemorypool') {
        this.logger.debug(cmd.params);
      }
    }

    if (cmd.method === 'getwork') {
      if (query.longpoll)
        cmd.method = 'getworklp';
    }

    let result;
    try {
      result = await this.execute(cmd);
    } catch (err) {
      let code;

      switch (err.type) {
        case 'RPCError':
          code = err.code;
          break;
        case 'ValidationError':
          code = RPCBase.errors.TYPE_ERROR;
          break;
        case 'EncodingError':
          code = RPCBase.errors.DESERIALIZATION_ERROR;
          break;
        case 'FundingError':
          code = RPCBase.errors.WALLET_INSUFFICIENT_FUNDS;
          break;
        default:
          code = RPCBase.errors.INTERNAL_ERROR;
          this.logger.error('RPC internal error.');
          this.logger.error(err);
          break;
      }

      out.push({
        result: null,
        error: {
          message: err.message,
          code: code
        },
        id: cmd.id
      });

      continue;
    }

    if (result === undefined)
      result = null;

    out.push({
      result: result,
      error: null,
      id: cmd.id
    });
  }

  if (!array)
    out = out[0];

  return out;
};

/**
 * Execute an RPC call.
 * @private
 * @param {Object} json
 * @param {Boolean} help
 * @returns {Promise}
 */

RPCBase.prototype.execute = async function execute(json, help) {
  const func = this.calls[json.method];

  if (!func) {
    for (const mount of this.mounts) {
      if (mount.calls[json.method])
        return await mount.execute(json, help);
    }
    throw new RPCError(RPCBase.errors.METHOD_NOT_FOUND,
      `Method not found: ${json.method}.`);
  }

  return await func.call(this, json.params, help);
};

/**
 * Add a custom RPC call.
 * @param {String} name
 * @param {Function} func
 */

RPCBase.prototype.add = function add(name, func) {
  assert(typeof func === 'function', 'Handler must be a function.');
  assert(!this.calls[name], 'Duplicate RPC call.');
  this.calls[name] = func;
};

/**
 * Mount another RPC object.
 * @param {Object} rpc
 */

RPCBase.prototype.mount = function mount(rpc) {
  assert(rpc, 'RPC must be an object.');
  assert(typeof rpc.execute === 'function', 'Execute must be a method.');
  this.mounts.push(rpc);
};

/**
 * Attach to another RPC object.
 * @param {Object} rpc
 */

RPCBase.prototype.attach = function attach(rpc) {
  assert(rpc, 'RPC must be an object.');
  assert(typeof rpc.execute === 'function', 'Execute must be a method.');
  rpc.mount(this);
};

/**
 * RPC Error
 * @constructor
 * @ignore
 */

function RPCError(code, msg) {
  Error.call(this);

  assert(typeof code === 'number');
  assert(typeof msg === 'string');

  this.type = 'RPCError';
  this.message = msg;
  this.code = code;

  if (Error.captureStackTrace)
    Error.captureStackTrace(this, RPCError);
}

Object.setPrototypeOf(RPCError.prototype, Error.prototype);

/*
 * Expose
 */

exports = RPCBase;
exports.RPCError = RPCError;

module.exports = exports;


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * base32.js - base32 for wmcc_core.
 */



/**
 * @module utils/base32
 */

const base32 = 'abcdefghijklmnopqrstuvwxyz234567';
const padding = [0, 6, 4, 3, 1];
const unbase32 = {};

for (let i = 0; i < base32.length; i++)
  unbase32[base32[i]] = i;

/**
 * Encode a base32 string.
 * @param {Buffer} data
 * @returns {String}
 */

exports.encode = function encode(data) {
  let str = '';
  let mode = 0;
  let left = 0;

  for (let i = 0; i < data.length; i++) {
    const ch = data[i];
    switch (mode) {
      case 0:
        str += base32[ch >>> 3];
        left = (ch & 7) << 2;
        mode = 1;
        break;
      case 1:
        str += base32[left | (ch >>> 6)];
        str += base32[(ch >>> 1) & 31];
        left = (ch & 1) << 4;
        mode = 2;
        break;
      case 2:
        str += base32[left | (ch >>> 4)];
        left = (ch & 15) << 1;
        mode = 3;
        break;
      case 3:
        str += base32[left | (ch >>> 7)];
        str += base32[(ch >>> 2) & 31];
        left = (ch & 3) << 3;
        mode = 4;
        break;
      case 4:
        str += base32[left | (ch >>> 5)];
        str += base32[ch & 31];
        mode = 0;
        break;
    }
  }

  if (mode > 0) {
    str += base32[left];
    for (let i = 0; i < padding[mode]; i++)
      str += '=';
  }

  return str;
};

/**
 * Decode a base32 string.
 * @param {String} str
 * @returns {Buffer}
 */

exports.decode = function decode(str) {
  const data = Buffer.allocUnsafe(str.length * 5 / 8 | 0);
  let mode = 0;
  let left = 0;
  let j = 0;
  let i;

  for (i = 0; i < str.length; i++) {
    const ch = unbase32[str[i]];

    if (ch == null)
      break;

    switch (mode) {
      case 0:
        left = ch;
        mode = 1;
        break;
      case 1:
        data[j++] = (left << 3) | (ch >>> 2);
        left = ch & 3;
        mode = 2;
        break;
      case 2:
        left = left << 5 | ch;
        mode = 3;
        break;
      case 3:
        data[j++] = (left << 1) | (ch >>> 4);
        left = ch & 15;
        mode = 4;
        break;
      case 4:
        data[j++] = (left << 4) | (ch >>> 1);
        left = ch & 1;
        mode = 5;
        break;
      case 5:
        left = left << 5 | ch;
        mode = 6;
        break;
      case 6:
        data[j++] = (left << 2) | (ch >>> 3);
        left = ch & 7;
        mode = 7;
        break;
      case 7:
        data[j++] = (left << 5) | ch;
        mode = 0;
        break;
    }
  }

  switch (mode) {
    case 0:
      break;
    case 1:
    case 3:
    case 6:
      throw new Error('Invalid base32 string.');
    case 2:
      if (left > 0)
        throw new Error('Invalid padding.');

      if (str.slice(i, i + 6) !== '======')
        throw new Error('Invalid base32 character.');

      if (unbase32[str[i + 6]] != null)
        throw new Error('Invalid padding.');

      break;
    case 4:
      if (left > 0)
        throw new Error('Invalid padding.');

      if (str.slice(i, i + 4) !== '====')
        throw new Error('Invalid base32 character.');

      if (unbase32[str[i + 4]] != null)
        throw new Error('Invalid padding.');

      break;
    case 5:
      if (left > 0)
        throw new Error('Invalid padding.');

      if (str.slice(i, i + 3) !== '===')
        throw new Error('Invalid base32 character.');

      if (unbase32[str[i + 3]] != null)
        throw new Error('Invalid padding.');

      break;
    case 7:
      if (left > 0)
        throw new Error('Invalid padding.');

      if (str[i] !== '=')
        throw new Error('Invalid base32 character.');

      if (unbase32[str[i + 1]] != null)
        throw new Error('Invalid padding.');

      break;
  }

  return data.slice(0, j);
};


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * server.js - http server for wmcc_core.
 */



const assert = __webpack_require__(0);
const path = __webpack_require__(25);
const HTTPBase = __webpack_require__(169);
const util = __webpack_require__(1);
const base58 = __webpack_require__(26);
const Bloom = __webpack_require__(43);
const TX = __webpack_require__(16);
const Outpoint = __webpack_require__(21);
const digest = __webpack_require__(5);
const random = __webpack_require__(29);
const ccmp = __webpack_require__(52);
const Network = __webpack_require__(6);
const Validator = __webpack_require__(71);
const pkg = __webpack_require__(94);

/**
 * HTTPServer
 * @alias module:http.Server
 * @constructor
 * @param {Object} options
 * @param {Fullnode} options.node
 * @see HTTPBase
 * @emits HTTPServer#socket
 */

function HTTPServer(options) {
  if (!(this instanceof HTTPServer))
    return new HTTPServer(options);

  options = new HTTPOptions(options);

  HTTPBase.call(this, options);

  this.options = options;
  this.network = this.options.network;
  this.logger = this.options.logger.context('http');
  this.node = this.options.node;

  this.chain = this.node.chain;
  this.mempool = this.node.mempool;
  this.pool = this.node.pool;
  this.fees = this.node.fees;
  this.miner = this.node.miner;
  this.rpc = this.node.rpc;

  this.init();
}

Object.setPrototypeOf(HTTPServer.prototype, HTTPBase.prototype);

/**
 * Initialize routes.
 * @private
 */

HTTPServer.prototype.init = function init() {
  this.on('request', (req, res) => {
    if (req.method === 'POST' && req.pathname === '/')
      return;

    this.logger.debug('Request for method=%s path=%s (%s).',
      req.method, req.pathname, req.socket.remoteAddress);
  });

  this.on('listening', (address) => {
    this.logger.info('Node HTTP server listening on %s (port=%d).',
      address.address, address.port);
  });

  this.initRouter();
  this.initSockets();
};

/**
 * Initialize routes.
 * @private
 */

HTTPServer.prototype.initRouter = function initRouter() {
  this.use(this.cors());

  if (!this.options.noAuth) {
    this.use(this.basicAuth({
      password: this.options.apiKey,
      realm: 'node'
    }));
  }

  this.use(this.bodyParser({
    contentType: 'json'
  }));

  this.use(this.jsonRPC(this.rpc));

  this.get('/', async (req, res) => {
    const totalTX = this.mempool ? this.mempool.map.size : 0;
    const size = this.mempool ? this.mempool.getSize() : 0;
    let addr = this.pool.hosts.getLocal();

    if (!addr)
      addr = this.pool.hosts.address;

    res.send(200, {
      version: pkg.version,
      network: this.network.type,
      chain: {
        height: this.chain.height,
        tip: this.chain.tip.rhash(),
        progress: this.chain.getProgress()
      },
      pool: {
        host: addr.host,
        port: addr.port,
        agent: this.pool.options.agent,
        services: this.pool.options.services.toString(2),
        outbound: this.pool.peers.outbound,
        inbound: this.pool.peers.inbound
      },
      mempool: {
        tx: totalTX,
        size: size
      },
      time: {
        uptime: this.node.uptime(),
        system: util.now(),
        adjusted: this.network.now(),
        offset: this.network.time.offset
      },
      memory: util.memoryUsage()
    });
  });

  // UTXO by address
  this.get('/coin/address/:address', async (req, res) => {
    const valid = req.valid();
    const address = valid.str('address');

    enforce(address, 'Address is required.');
    enforce(!this.chain.options.spv, 'Cannot get coins in SPV mode.');

    const coins = await this.node.getCoinsByAddress(address);
    const result = [];

    for (const coin of coins)
      result.push(coin.getJSON(this.network));

    res.send(200, result);
  });

  // UTXO by address
  this.get('/coin/address/:address/:after', async (req, res) => {
    const valid = req.valid();
    const address = valid.str('address');
    const after = valid.u32('after');

    enforce(address, 'Address is required.');
    enforce(!this.chain.options.spv, 'Cannot get coins in SPV mode.');

    const coins = await this.node.getCoinsByAddress(address, after);
    const result = [];

    for (const coin of coins)
      result.push(coin.getJSON(this.network));

    res.send(200, result);
  });

  // UTXO by id
  this.get('/coin/:hash/:index', async (req, res) => {
    const valid = req.valid();
    const hash = valid.hash('hash');
    const index = valid.u32('index');

    enforce(hash, 'Hash is required.');
    enforce(index != null, 'Index is required.');
    enforce(!this.chain.options.spv, 'Cannot get coins in SPV mode.');

    const coin = await this.node.getCoin(hash, index);

    if (!coin) {
      res.send(404);
      return;
    }

    res.send(200, coin.getJSON(this.network));
  });

  // Bulk read UTXOs
  this.post('/coin/address', async (req, res) => {
    const valid = req.valid();
    const address = valid.array('addresses');

    enforce(address, 'Address is required.');
    enforce(!this.chain.options.spv, 'Cannot get coins in SPV mode.');

    const coins = await this.node.getCoinsByAddress(address);
    const result = [];

    for (const coin of coins)
      result.push(coin.getJSON(this.network));

    res.send(200, result);
  });

  // TX by hash
  this.get('/tx/:hash', async (req, res) => {
    const valid = req.valid();
    const hash = valid.hash('hash');

    enforce(hash, 'Hash is required.');
    enforce(!this.chain.options.spv, 'Cannot get TX in SPV mode.');

    const meta = await this.node.getMeta(hash);

    if (!meta) {
      res.send(404);
      return;
    }

    const view = await this.node.getMetaView(meta);

    res.send(200, meta.getJSON(this.network, view));
  });

  // TX by address
  this.get('/tx/address/:address', async (req, res) => {
    const valid = req.valid();
    const address = valid.str('address');

    enforce(address, 'Address is required.');
    enforce(!this.chain.options.spv, 'Cannot get TX in SPV mode.');

    const metas = await this.node.getMetaByAddress(address);
    const result = [];

    for (const meta of metas) {
      const view = await this.node.getMetaView(meta);
      result.push(meta.getJSON(this.network, view));
    }

    res.send(200, result);
  });

  // Bulk read TXs
  this.post('/tx/address', async (req, res) => {
    const valid = req.valid();
    const address = valid.array('addresses');

    enforce(address, 'Address is required.');
    enforce(!this.chain.options.spv, 'Cannot get TX in SPV mode.');

    const metas = await this.node.getMetaByAddress(address);
    const result = [];

    for (const meta of metas) {
      const view = await this.node.getMetaView(meta);
      result.push(meta.getJSON(this.network, view));
    }

    res.send(200, result);
  });

  // Block by hash/height
  this.get('/block/:block', async (req, res) => {
    const valid = req.valid();
    let hash = valid.get('block');

    enforce(typeof hash === 'string', 'Hash or height required.');
    enforce(!this.chain.options.spv, 'Cannot get block in SPV mode.');

    if (hash.length === 64)
      hash = util.revHex(hash);
    else
      hash = parseInt(hash, 10);

    const block = await this.chain.getBlock(hash);

    if (!block) {
      res.send(404);
      return;
    }

    const view = await this.chain.getBlockView(block);

    if (!view) {
      res.send(404);
      return;
    }

    const height = await this.chain.getHeight(hash);

    res.send(200, block.getJSON(this.network, view, height));
  });

  // Mempool snapshot
  this.get('/mempool', async (req, res) => {
    enforce(this.mempool, 'No mempool available.');

    const hashes = this.mempool.getSnapshot();
    const result = [];

    for (const hash of hashes)
      result.push(util.revHex(hash));

    res.send(200, result);
  });

  // Broadcast TX
  this.post('/broadcast', async (req, res) => {
    const valid = req.valid();
    const raw = valid.buf('tx');

    enforce(raw, 'TX is required.');

    const tx = TX.fromRaw(raw);

    await this.node.sendTX(tx);

    res.send(200, { success: true });
  });

  // Estimate fee
  this.get('/fee', async (req, res) => {
    const valid = req.valid();
    const blocks = valid.u32('blocks');

    if (!this.fees) {
      res.send(200, { rate: this.network.feeRate });
      return;
    }

    const fee = this.fees.estimateFee(blocks);

    res.send(200, { rate: fee });
  });

  // Reset chain
  this.post('/reset', async (req, res) => {
    const valid = req.valid();
    const height = valid.u32('height');

    enforce(height != null, 'Height is required.');

    await this.chain.reset(height);

    res.send(200, { success: true });
  });
};

/**
 * Initialize websockets.
 * @private
 */

HTTPServer.prototype.initSockets = function initSockets() {
  if (!this.io)
    return;

  this.on('socket', (socket) => {
    this.handleSocket(socket);
  });
};

/**
 * Handle new websocket.
 * @private
 * @param {WebSocket} socket
 */

HTTPServer.prototype.handleSocket = function handleSocket(socket) {
  socket.hook('auth', (args) => {
    if (socket.auth)
      throw new Error('Already authed.');

    if (!this.options.noAuth) {
      const valid = new Validator([args]);
      const key = valid.str(0, '');

      if (key.length > 255)
        throw new Error('Invalid API key.');

      const data = Buffer.from(key, 'ascii');
      const hash = digest.hash256(data);

      if (!ccmp(hash, this.options.apiHash))
        throw new Error('Invalid API key.');
    }

    socket.auth = true;

    this.logger.info('Successful auth from %s.', socket.remoteAddress);
    this.handleAuth(socket);

    return null;
  });

  socket.emit('version', {
    version: pkg.version,
    network: this.network.type
  });
};

/**
 * Handle new auth'd websocket.
 * @private
 * @param {WebSocket} socket
 */

HTTPServer.prototype.handleAuth = function handleAuth(socket) {
  socket.hook('watch chain', (args) => {
    socket.join('chain');
    return null;
  });

  socket.hook('unwatch chain', (args) => {
    socket.leave('chain');
    return null;
  });

  socket.hook('watch mempool', (args) => {
    socket.join('mempool');
    return null;
  });

  socket.hook('unwatch mempool', (args) => {
    socket.leave('mempool');
    return null;
  });

  socket.hook('set filter', (args) => {
    const valid = new Validator([args]);
    const data = valid.buf(0);

    if (!data)
      throw new Error('Invalid parameter.');

    socket.filter = Bloom.fromRaw(data);

    return null;
  });

  socket.hook('get tip', (args) => {
    return this.chain.tip.toRaw();
  });

  socket.hook('get entry', async (args) => {
    const valid = new Validator([args]);
    const block = valid.numhash(0);

    if (block == null)
      throw new Error('Invalid parameter.');

    const entry = await this.chain.getEntry(block);

    if (!entry)
      return null;

    if (!await this.chain.isMainChain(entry))
      return null;

    return entry.toRaw();
  });

  socket.hook('add filter', (args) => {
    const valid = new Validator([args]);
    const chunks = valid.array(0);

    if (!chunks)
      throw new Error('Invalid parameter.');

    if (!socket.filter)
      throw new Error('No filter set.');

    const items = new Validator([chunks]);

    for (let i = 0; i < chunks.length; i++) {
      const data = items.buf(i);

      if (!data)
        throw new Error('Bad data chunk.');

      this.filter.add(data);

      if (this.node.spv)
        this.pool.watch(data);
    }

    return null;
  });

  socket.hook('reset filter', (args) => {
    socket.filter = null;
    return null;
  });

  socket.hook('estimate fee', (args) => {
    const valid = new Validator([args]);
    const blocks = valid.u32(0);

    if (!this.fees)
      return this.network.feeRate;

    return this.fees.estimateFee(blocks);
  });

  socket.hook('send', (args) => {
    const valid = new Validator([args]);
    const data = valid.buf(0);

    if (!data)
      throw new Error('Invalid parameter.');

    const tx = TX.fromRaw(data);

    this.node.send(tx);

    return null;
  });

  socket.hook('rescan', (args) => {
    const valid = new Validator([args]);
    const start = valid.numhash(0);

    if (start == null)
      throw new Error('Invalid parameter.');

    return this.scan(socket, start);
  });

  this.bindChain();
};

/**
 * Bind to chain events.
 * @private
 */

HTTPServer.prototype.bindChain = function bindChain() {
  const pool = this.mempool || this.pool;

  this.chain.on('connect', (entry, block, view) => {
    const list = this.channel('chain');

    if (!list)
      return;

    const raw = entry.toRaw();

    this.to('chain', 'chain connect', raw);

    for (let item = list.head; item; item = item.next) {
      const socket = item.value;
      const txs = this.filterBlock(socket, block);
      socket.emit('block connect', raw, txs);
    }
  });

  this.chain.on('disconnect', (entry, block, view) => {
    const list = this.channel('chain');

    if (!list)
      return;

    const raw = entry.toRaw();

    this.to('chain', 'chain disconnect', raw);
    this.to('chain', 'block disconnect', raw);
  });

  this.chain.on('reset', (tip) => {
    const list = this.channel('chain');

    if (!list)
      return;

    const raw = tip.toRaw();

    this.to('chain', 'chain reset', raw);
  });

  pool.on('tx', (tx) => {
    const list = this.channel('mempool');

    if (!list)
      return;

    const raw = tx.toRaw();

    for (let item = list.head; item; item = item.next) {
      const socket = item.value;

      if (!this.filterTX(socket, tx))
        continue;

      socket.emit('tx', raw);
    }
  });
};

/**
 * Filter block by socket.
 * @private
 * @param {WebSocket} socket
 * @param {Block} block
 * @returns {TX[]}
 */

HTTPServer.prototype.filterBlock = function filterBlock(socket, block) {
  if (!socket.filter)
    return [];

  const txs = [];

  for (const tx of block.txs) {
    if (this.filterTX(socket, tx))
      txs.push(tx.toRaw());
  }

  return txs;
};

/**
 * Filter transaction by socket.
 * @private
 * @param {WebSocket} socket
 * @param {TX} tx
 * @returns {Boolean}
 */

HTTPServer.prototype.filterTX = function filterTX(socket, tx) {
  if (!socket.filter)
    return false;

  let found = false;

  for (let i = 0; i < tx.outputs.length; i++) {
    const output = tx.outputs[i];
    const hash = output.getHash();

    if (!hash)
      continue;

    if (socket.filter.test(hash)) {
      const prevout = Outpoint.fromTX(tx, i);
      socket.filter.add(prevout.toRaw());
      found = true;
    }
  }

  if (found)
    return true;

  if (!tx.isCoinbase()) {
    for (const {prevout} of tx.inputs) {
      if (socket.filter.test(prevout.toRaw()))
        return true;
    }
  }

  return false;
};

/**
 * Scan using a socket's filter.
 * @private
 * @param {WebSocket} socket
 * @param {Hash} start
 * @returns {Promise}
 */

HTTPServer.prototype.scan = async function scan(socket, start) {
  const scanner = this.scanner.bind(this, socket);
  await this.node.scan(start, socket.filter, scanner);
  return null;
};

/**
 * Handle rescan iteration.
 * @private
 * @param {WebSocket} socket
 * @param {ChainEntry} entry
 * @param {TX[]} txs
 * @returns {Promise}
 */

HTTPServer.prototype.scanner = function scanner(socket, entry, txs) {
  const block = entry.toRaw();
  const raw = [];

  for (const tx of txs)
    raw.push(tx.toRaw());

  socket.emit('block rescan', block, raw);

  return Promise.resolve();
};

/**
 * HTTPOptions
 * @alias module:http.HTTPOptions
 * @constructor
 * @param {Object} options
 */

function HTTPOptions(options) {
  if (!(this instanceof HTTPOptions))
    return new HTTPOptions(options);

  this.network = Network.primary;
  this.logger = null;
  this.node = null;
  this.apiKey = base58.encode(random.randomBytes(20));
  this.apiHash = digest.hash256(Buffer.from(this.apiKey, 'ascii'));
  this.noAuth = false;

  this.prefix = null;
  this.host = '127.0.0.1';
  this.port = 8080;
  this.ssl = false;
  this.keyFile = null;
  this.certFile = null;

  this.fromOptions(options);
}

/**
 * Inject properties from object.
 * @private
 * @param {Object} options
 * @returns {HTTPOptions}
 */

HTTPOptions.prototype.fromOptions = function fromOptions(options) {
  assert(options);
  assert(options.node && typeof options.node === 'object',
    'HTTP Server requires a Node.');

  this.node = options.node;
  this.network = options.node.network;
  this.logger = options.node.logger;

  this.port = this.network.rpcPort;

  if (options.logger != null) {
    assert(typeof options.logger === 'object');
    this.logger = options.logger;
  }

  if (options.apiKey != null) {
    assert(typeof options.apiKey === 'string',
      'API key must be a string.');
    assert(options.apiKey.length <= 255,
      'API key must be under 256 bytes.');
    assert(util.isAscii(options.apiKey),
      'API key must be ascii.');
    this.apiKey = options.apiKey;
    this.apiHash = digest.hash256(Buffer.from(this.apiKey, 'ascii'));
  }

  if (options.noAuth != null) {
    assert(typeof options.noAuth === 'boolean');
    this.noAuth = options.noAuth;
  }

  if (options.prefix != null) {
    assert(typeof options.prefix === 'string');
    this.prefix = options.prefix;
    this.keyFile = path.join(this.prefix, 'key.pem');
    this.certFile = path.join(this.prefix, 'cert.pem');
  }

  if (options.host != null) {
    assert(typeof options.host === 'string');
    this.host = options.host;
  }

  if (options.port != null) {
    assert(util.isU16(options.port), 'Port must be a number.');
    this.port = options.port;
  }

  if (options.ssl != null) {
    assert(typeof options.ssl === 'boolean');
    this.ssl = options.ssl;
  }

  if (options.keyFile != null) {
    assert(typeof options.keyFile === 'string');
    this.keyFile = options.keyFile;
  }

  if (options.certFile != null) {
    assert(typeof options.certFile === 'string');
    this.certFile = options.certFile;
  }

  // Allow no-auth implicitly
  // if we're listening locally.
  if (!options.apiKey) {
    if (this.host === '127.0.0.1' || this.host === '::1')
      this.noAuth = true;
  }

  return this;
};

/**
 * Instantiate http options from object.
 * @param {Object} options
 * @returns {HTTPOptions}
 */

HTTPOptions.fromOptions = function fromOptions(options) {
  return new HTTPOptions().fromOptions(options);
};

/*
 * Helpers
 */

function enforce(value, msg) {
  if (!value) {
    const err = new Error(msg);
    err.statusCode = 400;
    throw err;
  }
}

/*
 * Expose
 */

module.exports = HTTPServer;


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * mempoolentry.js - mempool entry object for wmcc_core.
 */



const policy = __webpack_require__(19);
const util = __webpack_require__(1);
const Script = __webpack_require__(8);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const TX = __webpack_require__(16);

/**
 * Represents a mempool entry.
 * @alias module:mempool.MempoolEntry
 * @constructor
 * @param {Object} options
 * @param {TX} options.tx - Transaction in mempool.
 * @param {Number} options.height - Entry height.
 * @param {Number} options.priority - Entry priority.
 * @param {Number} options.time - Entry time.
 * @param {Amount} options.value - Value of on-chain coins.
 * @property {TX} tx
 * @property {Number} height
 * @property {Number} priority
 * @property {Number} time
 * @property {Amount} value
 */

function MempoolEntry(options) {
  if (!(this instanceof MempoolEntry))
    return new MempoolEntry(options);

  this.tx = null;
  this.height = -1;
  this.size = 0;
  this.sigops = 0;
  this.priority = 0;
  this.fee = 0;
  this.deltaFee = 0;
  this.time = 0;
  this.value = 0;
  this.coinbase = false;
  this.dependencies = false;
  this.descFee = 0;
  this.descSize = 0;

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from options object.
 * @private
 * @param {Object} options
 */

MempoolEntry.prototype.fromOptions = function fromOptions(options) {
  this.tx = options.tx;
  this.height = options.height;
  this.size = options.size;
  this.sigops = options.sigops;
  this.priority = options.priority;
  this.fee = options.fee;
  this.deltaFee = options.deltaFee;
  this.time = options.time;
  this.value = options.value;
  this.coinbase = options.coinbase;
  this.dependencies = options.dependencies;
  this.descFee = options.descFee;
  this.descSize = options.descSize;
  return this;
};

/**
 * Instantiate mempool entry from options.
 * @param {Object} options
 * @returns {MempoolEntry}
 */

MempoolEntry.fromOptions = function fromOptions(options) {
  return new MempoolEntry().fromOptions(options);
};

/**
 * Inject properties from transaction.
 * @private
 * @param {TX} tx
 * @param {Number} height
 */

MempoolEntry.prototype.fromTX = function fromTX(tx, view, height) {
  const flags = Script.flags.STANDARD_VERIFY_FLAGS;
  const value = tx.getChainValue(view);
  const sigops = tx.getSigopsCost(view, flags);
  const size = tx.getSigopsSize(sigops);
  const priority = tx.getPriority(view, height, size);
  const fee = tx.getFee(view);

  let dependencies = false;
  let coinbase = false;
  for (const {prevout} of tx.inputs) {
    if (view.isCoinbase(prevout))
      coinbase = true;

    if (view.getHeight(prevout) === -1)// {
      dependencies = true;
    //  break;
   // }
  }

  this.tx = tx;
  this.height = height;
  this.size = size;
  this.sigops = sigops;
  this.priority = priority;
  this.fee = fee;
  this.deltaFee = fee;
  this.time = util.now();
  this.value = value;
  this.coinbase = coinbase;
  this.dependencies = dependencies;
  this.descFee = fee;
  this.descSize = size;

  return this;
};

/**
 * Create a mempool entry from a TX.
 * @param {TX} tx
 * @param {Number} height - Entry height.
 * @returns {MempoolEntry}
 */

MempoolEntry.fromTX = function fromTX(tx, view, height) {
  return new MempoolEntry().fromTX(tx, view, height);
};

/**
 * Calculate transaction hash.
 * @param {String?} enc
 * @returns {Hash}
 */

MempoolEntry.prototype.hash = function hash(enc) {
  return this.tx.hash(enc);
};

/**
 * Calculate reverse transaction hash.
 * @returns {Hash}
 */

MempoolEntry.prototype.txid = function txid() {
  return this.tx.txid();
};

/**
 * Calculate priority, taking into account
 * the entry height delta, modified size,
 * and chain value.
 * @param {Number} height
 * @returns {Number} Priority.
 */

MempoolEntry.prototype.getPriority = function getPriority(height) {
  const delta = height - this.height;
  const priority = (delta * this.value) / this.size;
  let result = this.priority + Math.floor(priority);
  if (result < 0)
    result = 0;
  return result;
};

/**
 * Get fee.
 * @returns {Amount}
 */

MempoolEntry.prototype.getFee = function getFee() {
  return this.fee;
};

/**
 * Get delta fee.
 * @returns {Amount}
 */

MempoolEntry.prototype.getDeltaFee = function getDeltaFee() {
  return this.deltaFee;
};

/**
 * Calculate fee rate.
 * @returns {Rate}
 */

MempoolEntry.prototype.getRate = function getRate() {
  return policy.getRate(this.size, this.fee);
};

/**
 * Calculate delta fee rate.
 * @returns {Rate}
 */

MempoolEntry.prototype.getDeltaRate = function getDeltaRate() {
  return policy.getRate(this.size, this.deltaFee);
};

/**
 * Calculate fee cumulative descendant rate.
 * @returns {Rate}
 */

MempoolEntry.prototype.getDescRate = function getDescRate() {
  return policy.getRate(this.descSize, this.descFee);
};

/**
 * Calculate the memory usage of a transaction.
 * Note that this only calculates the JS heap
 * size. Sizes of buffers are ignored (the v8
 * heap is what we care most about). All numbers
 * are based on the output of v8 heap snapshots
 * of TX objects.
 * @returns {Number} Usage in bytes.
 */

MempoolEntry.prototype.memUsage = function memUsage() {
  const tx = this.tx;
  let total = 0;

  total += 176; // mempool entry
  total += 48; // coinbase
  total += 48; // dependencies

  total += 208; // tx
  total += 80; // _hash
  total += 88; // _hhash
  total += 80; // _raw
  total += 80; // _whash
  total += 48; // mutable

  total += 32; // input array

  for (const input of tx.inputs) {
    total += 120; // input
    total += 104; // prevout
    total += 88; // prevout hash

    total += 40; // script
    total += 80; // script raw buffer
    total += 32; // script code array
    total += input.script.code.length * 40; // opcodes

    for (const op of input.script.code) {
      if (op.data)
        total += 80; // op buffers
    }

    total += 96; // witness
    total += 32; // witness items
    total += input.witness.items.length * 80; // witness buffers
  }

  total += 32; // output array

  for (const output of tx.outputs) {
    total += 104; // output
    total += 40; // script
    total += 80; // script raw buffer
    total += 32; // script code array
    total += output.script.code.length * 40; // opcodes

    for (const op of output.script.code) {
      if (op.data)
        total += 80; // op buffers
    }
  }

  return total;
};

/**
 * Test whether the entry is free with
 * the current priority (calculated by
 * current height).
 * @param {Number} height
 * @returns {Boolean}
 */

MempoolEntry.prototype.isFree = function isFree(height) {
  const priority = this.getPriority(height);
  return priority > policy.FREE_THRESHOLD;
};

/**
 * Get entry serialization size.
 * @returns {Number}
 */

MempoolEntry.prototype.getSize = function getSize() {
  //return this.tx.getSize() + 41;
  return this.tx.getSize() + 42;
};

/**
 * Serialize entry to a buffer.
 * @returns {Buffer}
 */

MempoolEntry.prototype.toRaw = function toRaw() {
  const bw = new StaticWriter(this.getSize());
  bw.writeBytes(this.tx.toRaw());
  bw.writeU32(this.height);
  bw.writeU32(this.size);
  bw.writeU32(this.sigops);
  bw.writeDouble(this.priority);
  bw.writeU64(this.fee);
  bw.writeU32(this.time);
  bw.writeU64(this.value);
  bw.writeU8(this.coinbase ? 1 : 0);
  bw.writeU8(this.dependencies ? 1 : 0);
  return bw.render();
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 * @returns {MempoolEntry}
 */

MempoolEntry.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data);
  this.tx = TX.fromReader(br);
  this.height = br.readU32();
  this.size = br.readU32();
  this.sigops = br.readU32();
  this.priority = br.readDouble();
  this.fee = br.readU64();
  this.deltaFee = this.fee;
  this.time = br.readU32();
  this.value = br.readU64();
  this.coinbase = br.readU8() === 1;
  this.dependencies = br.readU8() === 1;
  this.descFee = this.fee;
  this.descSize = this.size;
  return this;
};

/**
 * Instantiate entry from serialized data.
 * @param {Buffer} data
 * @returns {MempoolEntry}
 */

MempoolEntry.fromRaw = function fromRaw(data) {
  return new MempoolEntry().fromRaw(data);
};

/*
 * Expose
 */

module.exports = MempoolEntry;


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * mempool.js - mempool for wmcc_core.
 */



const assert = __webpack_require__(0);
const path = __webpack_require__(25);
const AsyncObject = __webpack_require__(31);
const common = __webpack_require__(89);
const consensus = __webpack_require__(7);
const policy = __webpack_require__(19);
const util = __webpack_require__(1);
const random = __webpack_require__(29);
const {VerifyError} = __webpack_require__(105);
const RollingFilter = __webpack_require__(118);
const Address = __webpack_require__(11);
const Script = __webpack_require__(8);
const Outpoint = __webpack_require__(21);
const TX = __webpack_require__(16);
const Coin = __webpack_require__(44);
const TXMeta = __webpack_require__(165);
const MempoolEntry = __webpack_require__(181);
const Network = __webpack_require__(6);
const encoding = __webpack_require__(3);
const layout = __webpack_require__(239);
const LDB = __webpack_require__(88);
const Fees = __webpack_require__(117);
const CoinView = __webpack_require__(30);
//const Coins = require('../coins/coins');
const Heap = __webpack_require__(183);

/**
 * Represents a mempool.
 * @alias module:mempool.Mempool
 * @constructor
 * @param {Object} options
 * @param {String?} options.name - Database name.
 * @param {String?} options.location - Database file location.
 * @param {String?} options.db - Database backend (`"memory"` by default).
 * @param {Boolean?} options.limitFree
 * @param {Number?} options.limitFreeRelay
 * @param {Number?} options.maxSize - Max pool size (default ~300mb).
 * @param {Boolean?} options.relayPriority
 * @param {Boolean?} options.requireStandard
 * @param {Boolean?} options.rejectAbsurdFees
 * @param {Boolean?} options.relay
 * @property {Boolean} loaded
 * @property {Object} db
 * @property {Number} size
 * @property {Lock} locker
 * @property {Number} freeCount
 * @property {Number} lastTime
 * @property {Number} maxSize
 * @property {Rate} minRelayFee
 * @emits Mempool#open
 * @emits Mempool#error
 * @emits Mempool#tx
 * @emits Mempool#add tx
 * @emits Mempool#remove tx
 */

function Mempool(options) {
  if (!(this instanceof Mempool))
    return new Mempool(options);

  AsyncObject.call(this);

  this.options = new MempoolOptions(options);

  this.network = this.options.network;
  this.logger = this.options.logger.context('mempool');
  this.workers = this.options.workers;
  this.chain = this.options.chain;
  this.fees = this.options.fees;

  this.locker = this.chain.locker;

  this.cache = new MempoolCache(this.options);

  this.size = 0;
  this.freeCount = 0;
  this.lastTime = 0;
  this.lastFlush = 0;
  this.tip = this.network.genesis.hash;

  this.waiting = new Map();
  this.orphans = new Map();
  this.map = new Map();
  this.spents = new Map();
  this.rejects = new RollingFilter(120000, 0.000001);

  this.coinIndex = new CoinIndex();
  this.txIndex = new TXIndex();
}

Object.setPrototypeOf(Mempool.prototype, AsyncObject.prototype);

/**
 * Open the chain, wait for the database to load.
 * @method
 * @alias Mempool#open
 * @returns {Promise}
 */

Mempool.prototype._open = async function _open() {
  await this.chain.open();
  await this.cache.open();

  if (this.options.persistent) {
    const entries = await this.cache.getEntries();

    for (const entry of entries)
      this.trackEntry(entry);

    for (const entry of entries) {
      this.updateAncestors(entry, addFee);

      if (this.options.indexAddress) {
        const view = await this.getCoinView(entry.tx);
        this.indexEntry(entry, view);
      }
    }

    this.logger.info(
      'Loaded mempool from disk (%d entries).',
      entries.length);

    if (this.fees) {
      const fees = await this.cache.getFees();

      if (fees) {
        this.fees.inject(fees);
        this.logger.info(
          'Loaded mempool fee data (rate=%d).',
          this.fees.estimateFee());
      }
    }
  }

  this.tip = this.chain.tip.hash;

  const size = (this.options.maxSize / 1024).toFixed(2);

  this.logger.info('Mempool loaded (maxsize=%dkb).', size);
};

/**
 * Close the chain, wait for the database to close.
 * @alias Mempool#close
 * @returns {Promise}
 */

Mempool.prototype._close = async function _close() {
  await this.cache.close();
};

/**
 * Notify the mempool that a new block has come
 * in (removes all transactions contained in the
 * block from the mempool).
 * @method
 * @param {ChainEntry} block
 * @param {TX[]} txs
 * @returns {Promise}
 */

Mempool.prototype.addBlock = async function addBlock(block, txs) {
  const unlock = await this.locker.lock();
  try {
    return await this._addBlock(block, txs);
  } finally {
    unlock();
  }
};

/**
 * Notify the mempool that a new block
 * has come without a lock.
 * @private
 * @param {ChainEntry} block
 * @param {TX[]} txs
 * @returns {Promise}
 */

Mempool.prototype._addBlock = async function _addBlock(block, txs) {
  if (this.map.size === 0) {
    this.tip = block.hash;
    return;
  }

  const entries = [];

  for (let i = txs.length - 1; i >= 1; i--) {
    const tx = txs[i];
    const hash = tx.hash('hex');
    const entry = this.getEntry(hash);

    if (!entry) {
      this.removeOrphan(hash);
      //this.resolveOrphans(tx);
      this.removeDoubleSpends(tx);
      if (this.waiting.has(hash))
        await this.handleOrphans(tx);
      continue;
    }

    this.removeEntry(entry);

    this.emit('confirmed', tx, block);

    entries.push(entry);
  }

  // We need to reset the rejects filter periodically.
  // There may be a locktime in a TX that is now valid.
  this.rejects.reset();

  if (this.fees) {
    this.fees.processBlock(block.height, entries, this.chain.synced);
    this.cache.writeFees(this.fees);
  }

  this.cache.sync(block.hash);

  await this.cache.flush();

  this.tip = block.hash;

  if (entries.length === 0)
    return;

  this.logger.debug(
    'Removed %d txs from mempool for block %d.',
    entries.length, block.height);
};

/**
 * Notify the mempool that a block has been disconnected
 * from the main chain (reinserts transactions into the mempool).
 * @method
 * @param {ChainEntry} block
 * @param {TX[]} txs
 * @returns {Promise}
 */

Mempool.prototype.removeBlock = async function removeBlock(block, txs) {
  const unlock = await this.locker.lock();
  try {
    return await this._removeBlock(block, txs);
  } finally {
    unlock();
  }
};

/**
 * Notify the mempool that a block
 * has been disconnected without a lock.
 * @method
 * @private
 * @param {ChainEntry} block
 * @param {TX[]} txs
 * @returns {Promise}
 */

Mempool.prototype._removeBlock = async function _removeBlock(block, txs) {
  if (this.map.size === 0) {
    this.tip = block.prevBlock;
    return;
  }

  let total = 0;

  for (let i = 1; i < txs.length; i++) {
    const tx = txs[i];
    const hash = tx.hash('hex');

    if (this.hasEntry(hash))
      continue;

    try {
      await this.insertTX(tx, -1);
      total++;
    } catch (e) {
      this.emit('error', e);
      continue;
    }

    this.emit('unconfirmed', tx, block);
  }

  this.rejects.reset();

  this.cache.sync(block.prevBlock);

  await this.cache.flush();

  this.tip = block.prevBlock;

  if (total === 0)
    return;

  this.logger.debug(
    'Added %d txs back into the mempool for block %d.',
    total, block.height);
};

/**
 * Sanitize the mempool after a reorg.
 * @private
 * @returns {Promise}
 */

Mempool.prototype._handleReorg = async function _handleReorg() {
  const height = this.chain.height + 1;
  const mtp = await this.chain.getMedianTime(this.chain.tip);
  const remove = [];

  for (const [hash, entry] of this.map) {
    const {tx} = entry;

    if (!tx.isFinal(height, mtp)) {
      remove.push(hash);
      continue;
    }

    if (tx.version > 1) {
      let hasLocks = false;

      for (const {sequence} of tx.inputs) {
        if (!(sequence & consensus.SEQUENCE_DISABLE_FLAG)) {
          hasLocks = true;
          break;
        }
      }

      if (hasLocks) {
        remove.push(hash);
        continue;
      }
    }

    if (entry.coinbase)
      remove.push(hash);
  }

  for (const hash of remove) {
    const entry = this.getEntry(hash);

    if (!entry)
      continue;

    this.evictEntry(entry);
  }
};

/**
 * Reset the mempool.
 * @method
 * @returns {Promise}
 */

Mempool.prototype.reset = async function reset() {
  const unlock = await this.locker.lock();
  try {
    return await this._reset();
  } finally {
    unlock();
  }
};

/**
 * Reset the mempool without a lock.
 * @private
 */

Mempool.prototype._reset = async function _reset() {
  this.logger.info('Mempool reset (%d txs removed).', this.map.size);

  this.size = 0;

  this.waiting.clear();
  this.orphans.clear();
  this.map.clear();
  this.spents.clear();
  this.coinIndex.reset();
  this.txIndex.reset();

  this.freeCount = 0;
  this.lastTime = 0;

  if (this.fees)
    this.fees.reset();

  this.rejects.reset();

  if (this.options.persistent) {
    await this.cache.wipe();
    this.cache.clear();
  }

  this.tip = this.chain.tip.hash;
};

/**
 * Ensure the size of the mempool stays below `maxSize`.
 * Evicts entries by timestamp and cumulative fee rate.
 * @param {MempoolEntry} added
 * @returns {Promise}
 */

Mempool.prototype.limitSize = function limitSize(added) {
  const maxSize = this.options.maxSize;

  if (this.size <= maxSize)
    return false;

  const threshold = maxSize - (maxSize / 10);
  const expiryTime = this.options.expiryTime;

  const now = util.now();
  let start = util.hrtime();
  const queue = new Heap(cmpRate);

  for (const entry of this.map.values()) {
    if (this.hasDepends(entry.tx))
      continue;

    if (now < entry.time + expiryTime) {
      queue.insert(entry);
      continue;
    }

    this.logger.debug(
      'Removing package %s from mempool (too old).',
      entry.txid());

    this.evictEntry(entry);
  }

  if (this.size <= threshold)
    return !this.hasEntry(added);

  this.logger.debug(
    '(bench) Heap mempool traversal: %d.',
    util.hrtime(start));

  start = util.hrtime();

  this.logger.debug(
    '(bench) Heap mempool queue size: %d.',
    queue.size());

  while (queue.size() > 0) {
    const entry = queue.shift();
    const hash = entry.hash('hex');

    assert(this.hasEntry(hash));

    this.logger.debug(
      'Removing package %s from mempool (low fee).',
      entry.txid());

    this.evictEntry(entry);

    if (this.size <= threshold)
      break;
  }

  this.logger.debug(
    '(bench) Heap mempool map removal: %d.',
    util.hrtime(start));

  return !this.hasEntry(added);
};

/**
 * Retrieve a transaction from the mempool.
 * @param {Hash} hash
 * @returns {TX}
 */

Mempool.prototype.getTX = function getTX(hash) {
  const entry = this.map.get(hash);

  if (!entry)
    return null;

  return entry.tx;
};

/**
 * Retrieve a transaction from the mempool.
 * @param {Hash} hash
 * @returns {MempoolEntry}
 */

Mempool.prototype.getEntry = function getEntry(hash) {
  return this.map.get(hash);
};

/**
 * Retrieve a coin from the mempool (unspents only).
 * @param {Hash} hash
 * @param {Number} index
 * @returns {Coin}
 */

Mempool.prototype.getCoin = function getCoin(hash, index) {
  const entry = this.map.get(hash);

  if (!entry)
    return null;

  if (this.isSpent(hash, index))
    return null;

  if (index >= entry.tx.outputs.length)
    return null;

  return Coin.fromTX(entry.tx, index, -1);
};

/**
 * Check to see if a coin has been spent. This differs from
 * {@link ChainDB#isSpent} in that it actually maintains a
 * map of spent coins, whereas ChainDB may return `true`
 * for transaction outputs that never existed.
 * @param {Hash} hash
 * @param {Number} index
 * @returns {Boolean}
 */

Mempool.prototype.isSpent = function isSpent(hash, index) {
  const key = Outpoint.toKey(hash, index);
  return this.spents.has(key);
};

/**
 * Get an output's spender entry.
 * @param {Hash} hash
 * @param {Number} index
 * @returns {MempoolEntry}
 */

Mempool.prototype.getSpent = function getSpent(hash, index) {
  const key = Outpoint.toKey(hash, index);
  return this.spents.get(key);
};

/**
 * Get an output's spender transaction.
 * @param {Hash} hash
 * @param {Number} index
 * @returns {MempoolEntry}
 */

Mempool.prototype.getSpentTX = function getSpentTX(hash, index) {
  const key = Outpoint.toKey(hash, index);
  const entry = this.spents.get(key);

  if (!entry)
    return null;

  return entry.tx;
};

/**
 * Find all coins pertaining to a certain address.
 * @param {Address[]} addrs
 * @returns {Coin[]}
 */

Mempool.prototype.getCoinsByAddress = function getCoinsByAddress(addrs) {
  if (!Array.isArray(addrs))
    addrs = [addrs];

  const out = [];

  for (const addr of addrs) {
    const hash = Address.getHash(addr, 'hex');
    const coins = this.coinIndex.get(hash);

    for (const coin of coins)
      out.push(coin);
  }

  return out;
};

/**
 * Find all transactions pertaining to a certain address.
 * @param {Address[]} addrs
 * @returns {TX[]}
 */

Mempool.prototype.getTXByAddress = function getTXByAddress(addrs) {
  if (!Array.isArray(addrs))
    addrs = [addrs];

  const out = [];

  for (const addr of addrs) {
    const hash = Address.getHash(addr, 'hex');
    const txs = this.txIndex.get(hash);

    for (const tx of txs)
      out.push(tx);
  }

  return out;
};

/**
 * Find all transactions pertaining to a certain address.
 * @param {Address[]} addrs
 * @returns {TXMeta[]}
 */

Mempool.prototype.getMetaByAddress = function getMetaByAddress(addrs) {
  if (!Array.isArray(addrs))
    addrs = [addrs];

  const out = [];

  for (const addr of addrs) {
    const hash = Address.getHash(addr, 'hex');
    const txs = this.txIndex.getMeta(hash);

    for (const tx of txs)
      out.push(tx);
  }

  return out;
};

/**
 * Find all transactions to a certain address.
 * @param {Address[]} addrs
 * @returns {TXMeta[]}
 */

Mempool.prototype.getAllMetaByAddress = function getAllMetaByAddress(addr) {
  const meta = [];
  this.map.forEach((entry, hash) => {
    for(let input of entry.tx.inputs) {
      if (input.getAddress().equals(addr))
        meta.push(TXMeta.fromTX(entry.tx));
    }
    for(let output of entry.tx.outputs) {
      if (output.getAddress().equals(addr))
        meta.push(TXMeta.fromTX(entry.tx));
    }
  });

  return meta;
};

/**
 * Retrieve a transaction from the mempool.
 * @param {Hash} hash
 * @returns {TXMeta}
 */

Mempool.prototype.getMeta = function getMeta(hash) {
  const entry = this.getEntry(hash);

  if (!entry)
    return null;

  const meta = TXMeta.fromTX(entry.tx);
  meta.mtime = entry.time;

  return meta;
};

/**
 * Test the mempool to see if it contains a transaction.
 * @param {Hash} hash
 * @returns {Boolean}
 */

Mempool.prototype.hasEntry = function hasEntry(hash) {
  return this.map.has(hash);
};

/**
 * Test the mempool to see if it
 * contains a transaction or an orphan.
 * @param {Hash} hash
 * @returns {Boolean}
 */

Mempool.prototype.has = function has(hash) {
  if (this.locker.has(hash))
    return true;

  if (this.hasOrphan(hash))
    return true;

  return this.hasEntry(hash);
};

/**
 * Test the mempool to see if it
 * contains a transaction or an orphan.
 * @private
 * @param {Hash} hash
 * @returns {Boolean}
 */

Mempool.prototype.exists = function exists(hash) {
  if (this.locker.hasPending(hash))
    return true;

  if (this.hasOrphan(hash))
    return true;

  return this.hasEntry(hash);
};

/**
 * Test the mempool to see if it
 * contains a recent reject.
 * @param {Hash} hash
 * @returns {Boolean}
 */

Mempool.prototype.hasReject = function hasReject(hash) {
  return this.rejects.test(hash, 'hex');
};

/**
 * Add a transaction to the mempool. Note that this
 * will lock the mempool until the transaction is
 * fully processed.
 * @method
 * @param {TX} tx
 * @param {Number?} id
 * @returns {Promise}
 */

Mempool.prototype.addTX = async function addTX(tx, id) {
  const hash = tx.hash('hex');
  const unlock = await this.locker.lock(hash);
  try {
    return await this._addTX(tx, id);
  } finally {
    unlock();
  }
};

/**
 * Add a transaction to the mempool without a lock.
 * @method
 * @private
 * @param {TX} tx
 * @param {Number?} id
 * @returns {Promise}
 */

Mempool.prototype._addTX = async function _addTX(tx, id) {
  if (id == null)
    id = -1;

  let missing;
  try {
    missing = await this.insertTX(tx, id);
  } catch (err) {
    if (err.type === 'VerifyError') {
      if (!tx.hasWitness() && !err.malleated)
        this.rejects.add(tx.hash());
    }
    throw err;
  }

  if (util.now() - this.lastFlush > 10) {
    await this.cache.flush();
    this.lastFlush = util.now();
  }

  return missing;
};

/**
 * Add a transaction to the mempool without a lock.
 * @method
 * @private
 * @param {TX} tx
 * @param {Number?} id
 * @returns {Promise}
 */

Mempool.prototype.insertTX = async function insertTX(tx, id) {
  assert(!tx.mutable, 'Cannot add mutable TX to mempool.');

  const lockFlags = common.lockFlags.STANDARD_LOCKTIME_FLAGS;
  const height = this.chain.height;
  const hash = tx.hash('hex');

  // Basic sanity checks.
  // This is important because it ensures
  // other functions will be overflow safe.
  const [valid, reason, score] = tx.checkSanity(height);

  if (!valid)
    throw new VerifyError(tx, 'invalid', reason, score);

  // Coinbases are an insta-ban.
  // Why? Who knows.
  if (tx.isCoinbase()) {
    throw new VerifyError(tx,
      'invalid',
      'coinbase',
      100);
  }

  // Do not allow CSV until it's activated.
  if (this.options.requireStandard) {
    if (!this.chain.state.hasCSV() && tx.version >= 2) {
      throw new VerifyError(tx,
        'nonstandard',
        'premature-version2-tx',
        0);
    }
  }

  // Do not allow segwit until it's activated.
  if (!this.chain.state.hasWitness() && !this.options.prematureWitness) {
    if (tx.hasWitness()) {
      throw new VerifyError(tx,
        'nonstandard',
        'no-witness-yet',
        0,
        true);
    }
  }

  // Non-contextual standardness checks.
  if (this.options.requireStandard) {
    const [valid, reason, score] = tx.checkStandard();

    if (!valid)
      throw new VerifyError(tx, 'nonstandard', reason, score);

    if (!this.options.replaceByFee) {
      if (tx.isRBF()) {
        throw new VerifyError(tx,
          'nonstandard',
          'replace-by-fee',
          0);
      }
    }
  }

  // Verify transaction finality (see isFinal()).
  if (!await this.verifyFinal(tx, lockFlags)) {
    throw new VerifyError(tx,
      'nonstandard',
      'non-final',
      0);
  }

  // We can maybe ignore this.
  if (this.exists(hash)) {
    throw new VerifyError(tx,
      'alreadyknown',
      'txn-already-in-mempool',
      0);
  }

  // We can test whether this is an
  // non-fully-spent transaction on
  // the chain.
  if (await this.chain.hasCoins(tx)) {
    throw new VerifyError(tx,
      'alreadyknown',
      'txn-already-known',
      0);
  }

  // Quick and dirty test to verify we're
  // not double-spending an output in the
  // mempool.
  if (this.isDoubleSpend(tx)) {
    this.emit('conflict', tx);
    throw new VerifyError(tx,
      'duplicate',
      'bad-txns-inputs-spent',
      0);
  }

  // Get coin viewpoint as it
  // pertains to the mempool.
  const view = await this.getCoinView(tx);

  /*// Find missing outpoints.
  const missing = this.findMissing(tx, view);*/

  // Maybe store as an orphan.
  const missing = this.maybeOrphan(tx, view, id);

  // Return missing outpoint hashes.
  if (missing)
    //return this.storeOrphan(tx, missing, id);
    return missing;

  // Create a new mempool entry
  // at current chain height.
  const entry = MempoolEntry.fromTX(tx, view, height);

  // Contextual verification.
  await this.verify(entry, view);

  // Add and index the entry.
  await this.addEntry(entry, view);

  // Trim size if we're too big.
  if (this.limitSize(hash)) {
    throw new VerifyError(tx,
      'insufficientfee',
      'mempool full',
      0);
  }

  return null;
};

/**
 * Verify a transaction with mempool standards.
 * @method
 * @param {TX} tx
 * @param {CoinView} view
 * @returns {Promise}
 */

Mempool.prototype.verify = async function verify(entry, view) {
  const height = this.chain.height + 1;
  const lockFlags = common.lockFlags.STANDARD_LOCKTIME_FLAGS;
  const tx = entry.tx;

  // Verify sequence locks.
  if (!await this.verifyLocks(tx, view, lockFlags)) {
    throw new VerifyError(tx,
      'nonstandard',
      'non-BIP68-final',
      0);
  }

  // Check input an witness standardness.
  if (this.options.requireStandard) {
    if (!tx.hasStandardInputs(view)) {
      throw new VerifyError(tx,
        'nonstandard',
        'bad-txns-nonstandard-inputs',
        0);
    }
    if (this.chain.state.hasWitness()) {
      if (!tx.hasStandardWitness(view)) {
        throw new VerifyError(tx,
          'nonstandard',
          'bad-witness-nonstandard',
          0,
          true);
      }
    }
  }

  // Annoying process known as sigops counting.
  if (entry.sigops > policy.MAX_TX_SIGOPS_COST) {
    throw new VerifyError(tx,
      'nonstandard',
      'bad-txns-too-many-sigops',
      0);
  }

  // Make sure this guy gave a decent fee.
  const minFee = policy.getMinFee(entry.size, this.options.minRelay);

  if (this.options.relayPriority && entry.fee < minFee) {
    if (!entry.isFree(height)) {
      throw new VerifyError(tx,
        'insufficientfee',
        'insufficient priority',
        0);
    }
  }

  // Continuously rate-limit free (really, very-low-fee)
  // transactions. This mitigates 'penny-flooding'.
  if (this.options.limitFree && entry.fee < minFee) {
    const now = util.now();

    // Use an exponentially decaying ~10-minute window.
    this.freeCount *= Math.pow(1 - 1 / 600, now - this.lastTime);
    this.lastTime = now;

    // The limitFreeRelay unit is thousand-bytes-per-minute
    // At default rate it would take over a month to fill 1GB.
    if (this.freeCount > this.options.limitFreeRelay * 10 * 1000) {
      throw new VerifyError(tx,
        'insufficientfee',
        'rate limited free transaction',
        0);
    }

    this.freeCount += entry.size;
  }

  // Important safety feature.
  if (this.options.rejectAbsurdFees && entry.fee > minFee * 10000)
    throw new VerifyError(tx, 'highfee', 'absurdly-high-fee', 0);

  // Why do we have this here? Nested transactions are cool.
  if (this.countAncestors(entry) + 1 > this.options.maxAncestors) {
    throw new VerifyError(tx,
      'nonstandard',
      'too-long-mempool-chain',
      0);
  }

  // Contextual sanity checks.
  const [fee, reason, score] = tx.checkInputs(view, height);

  if (fee === -1)
    throw new VerifyError(tx, 'invalid', reason, score);

  // Script verification.
  let flags = Script.flags.STANDARD_VERIFY_FLAGS;
  try {
    await this.verifyInputs(tx, view, flags);
  } catch (err) {
    if (tx.hasWitness())
      throw err;

    // Try without segwit and cleanstack.
    flags &= ~Script.flags.VERIFY_WITNESS;
    flags &= ~Script.flags.VERIFY_CLEANSTACK;

    // If it failed, the first verification
    // was the only result we needed.
    if (!await this.verifyResult(tx, view, flags))
      throw err;

    // If it succeeded, segwit may be causing the
    // failure. Try with segwit but without cleanstack.
    flags |= Script.flags.VERIFY_CLEANSTACK;

    // Cleanstack was causing the failure.
    if (await this.verifyResult(tx, view, flags))
      throw err;

    // Do not insert into reject cache.
    err.malleated = true;
    throw err;
  }

  // Paranoid checks.
  if (this.options.paranoidChecks) {
    const flags = Script.flags.MANDATORY_VERIFY_FLAGS;
    assert(await this.verifyResult(tx, view, flags),
      'BUG: Verify failed for mandatory but not standard.');
  }
};

/**
 * Verify inputs, return a boolean
 * instead of an error based on success.
 * @method
 * @param {TX} tx
 * @param {CoinView} view
 * @param {VerifyFlags} flags
 * @returns {Promise}
 */

Mempool.prototype.verifyResult = async function verifyResult(tx, view, flags) {
  try {
    await this.verifyInputs(tx, view, flags);
  } catch (err) {
    if (err.type === 'VerifyError')
      return false;
    throw err;
  }
  return true;
};

/**
 * Verify inputs for standard
 * _and_ mandatory flags on failure.
 * @method
 * @param {TX} tx
 * @param {CoinView} view
 * @param {VerifyFlags} flags
 * @returns {Promise}
 */

Mempool.prototype.verifyInputs = async function verifyInputs(tx, view, flags) {
  if (await tx.verifyAsync(view, flags, this.workers))
    return;

  if (flags & Script.flags.ONLY_STANDARD_VERIFY_FLAGS) {
    flags &= ~Script.flags.ONLY_STANDARD_VERIFY_FLAGS;

    if (await tx.verifyAsync(view, flags, this.workers)) {
      throw new VerifyError(tx,
        'nonstandard',
        'non-mandatory-script-verify-flag',
        0);
    }
  }

  throw new VerifyError(tx,
    'nonstandard',
    'mandatory-script-verify-flag',
    100);
};

/**
 * Add a transaction to the mempool without performing any
 * validation. Note that this method does not lock the mempool
 * and may lend itself to race conditions if used unwisely.
 * This function will also resolve orphans if possible (the
 * resolved orphans _will_ be validated).
 * @method
 * @param {MempoolEntry} entry
 * @param {CoinView} view
 * @returns {Promise}
 */

Mempool.prototype.addEntry = async function addEntry(entry, view) {
  const tx = entry.tx;

  this.trackEntry(entry, view);

  this.updateAncestors(entry, addFee);

  this.emit('tx', tx, view);
  this.emit('add entry', entry);

  if (this.fees)
    this.fees.processTX(entry, this.chain.synced);

  this.logger.debug(
    'Added %s to mempool (txs=%d).',
    tx.txid(), this.map.size);

  this.cache.save(entry);

  await this.handleOrphans(tx);
};

/**
 * Remove a transaction from the mempool.
 * Generally only called when a new block
 * is added to the main chain.
 * @param {MempoolEntry} entry
 */

Mempool.prototype.removeEntry = function removeEntry(entry) {
  const tx = entry.tx;
  const hash = tx.hash('hex');

  this.untrackEntry(entry);

  if (this.fees)
    this.fees.removeTX(hash);

  this.cache.remove(tx.hash());

  this.emit('remove entry', entry);
};

/**
 * Remove a transaction from the mempool.
 * Recursively remove its spenders.
 * @param {MempoolEntry} entry
 */

Mempool.prototype.evictEntry = function evictEntry(entry) {
  this.removeSpenders(entry);
  this.updateAncestors(entry, removeFee);
  this.removeEntry(entry);
};

/**
 * Recursively remove spenders of a transaction.
 * @private
 * @param {MempoolEntry} entry
 */

Mempool.prototype.removeSpenders = function removeSpenders(entry) {
  const tx = entry.tx;
  const hash = tx.hash('hex');

  for (let i = 0; i < tx.outputs.length; i++) {
    const spender = this.getSpent(hash, i);

    if (!spender)
      continue;

    this.removeSpenders(spender);
    this.removeEntry(spender);
  }
};

/**
 * Count the highest number of
 * ancestors a transaction may have.
 * @param {MempoolEntry} entry
 * @returns {Number}
 */

Mempool.prototype.countAncestors = function countAncestors(entry) {
  return this._countAncestors(entry, new Set(), entry, nop);
};

/**
 * Count the highest number of
 * ancestors a transaction may have.
 * Update descendant fees and size.
 * @param {MempoolEntry} entry
 * @param {Function} map
 * @returns {Number}
 */

Mempool.prototype.updateAncestors = function updateAncestors(entry, map) {
  return this._countAncestors(entry, new Set(), entry, map);
};

/**
 * Traverse ancestors and count.
 * @private
 * @param {MempoolEntry} entry
 * @param {Object} set
 * @param {MempoolEntry} child
 * @param {Function} map
 * @returns {Number}
 */

Mempool.prototype._countAncestors = function _countAncestors(entry, set, child, map) {
  const tx = entry.tx;

  //for (const input of tx.inputs) {
    //const hash = input.prevout.hash;
  for (const {prevout} of tx.inputs) {
    const hash = prevout.hash;
    const parent = this.getEntry(hash);

    if (!parent)
      continue;

    if (set.has(hash))
      continue;

    set.add(hash);

    map(parent, child);

    if (set.size > this.options.maxAncestors)
      break;

    this._countAncestors(parent, set, child, map);

    if (set.size > this.options.maxAncestors)
      break;
  }

  return set.size;
};

/**
 * Count the highest number of
 * descendants a transaction may have.
 * @param {MempoolEntry} entry
 * @returns {Number}
 */

Mempool.prototype.countDescendants = function countDescendants(entry) {
  return this._countDescendants(entry, new Set());
};

/**
 * Count the highest number of
 * descendants a transaction may have.
 * @private
 * @param {MempoolEntry} entry
 * @param {Object} set
 * @returns {Number}
 */

Mempool.prototype._countDescendants = function _countDescendants(entry, set) {
  const tx = entry.tx;
  const hash = tx.hash('hex');

  for (let i = 0; i < tx.outputs.length; i++) {
    const child = this.getSpent(hash, i);

    if (!child)
      continue;

    const next = child.hash('hex');

    if (set.has(next))
      continue;

    set.add(next);

    this._countDescendants(child, set);
  }

  return set.size;
};

/**
 * Get all transaction ancestors.
 * @param {MempoolEntry} entry
 * @returns {MempoolEntry[]}
 */

Mempool.prototype.getAncestors = function getAncestors(entry) {
  return this._getAncestors(entry, [], new Set());
};

/**
 * Get all transaction ancestors.
 * @private
 * @param {MempoolEntry} entry
 * @param {MempoolEntry[]} entries
 * @param {Object} set
 * @returns {MempoolEntry[]}
 */

Mempool.prototype._getAncestors = function _getAncestors(entry, entries, set) {
  const tx = entry.tx;

  //for (const input of tx.inputs) {
    //const hash = input.prevout.hash;
  for (const {prevout} of tx.inputs) {
    const hash = prevout.hash;
    const parent = this.getEntry(hash);

    if (!parent)
      continue;

    if (set.has(hash))
      continue;

    set.add(hash);
    entries.push(parent);

    this._getAncestors(parent, entries, set);
  }

  return entries;
};

/**
 * Get all a transaction descendants.
 * @param {MempoolEntry} entry
 * @returns {MempoolEntry[]}
 */

Mempool.prototype.getDescendants = function getDescendants(entry) {
  return this._getDescendants(entry, [], new Set());
};

/**
 * Get all a transaction descendants.
 * @param {MempoolEntry} entry
 * @param {MempoolEntry[]} entries
 * @param {Object} set
 * @returns {MempoolEntry[]}
 */

Mempool.prototype._getDescendants = function _getDescendants(entry, entries, set) {
  const tx = entry.tx;
  const hash = tx.hash('hex');

  for (let i = 0; i < tx.outputs.length; i++) {
    const child = this.getSpent(hash, i);

    if (!child)
      continue;

    const next = child.hash('hex');

    if (set.has(next))
      continue;

    set.add(next);
    entries.push(child);

    this._getDescendants(child, entries, set);
  }

  return entries;
};

/**
 * Find a unconfirmed transactions that
 * this transaction depends on.
 * @param {TX} tx
 * @returns {Hash[]}
 */

Mempool.prototype.getDepends = function getDepends(tx) {
  const prevout = tx.getPrevout();
  const depends = [];

  for (const hash of prevout) {
    if (this.hasEntry(hash))
      depends.push(hash);
  }

  return depends;
};

/**
 * Test whether a transaction has dependencies.
 * @param {TX} tx
 * @returns {Boolean}
 */

Mempool.prototype.hasDepends = function hasDepends(tx) {
  //for (const input of tx.inputs) {
    //const hash = input.prevout.hash;
    //if (this.hasEntry(hash))
  for (const {prevout} of tx.inputs) {
    if (this.hasEntry(prevout.hash))
      return true;
  }
  return false;
};

/**
 * Return the full balance of all unspents in the mempool
 * (not very useful in practice, only used for testing).
 * @returns {Amount}
 */

Mempool.prototype.getBalance = function getBalance() {
  let total = 0;

  for (const [hash, entry] of this.map) {
    const tx = entry.tx;
    for (let i = 0; i < tx.outputs.length; i++) {
      const coin = this.getCoin(hash, i);
      if (coin)
        total += coin.value;
    }
  }

  return total;
};

/**
 * Retrieve _all_ transactions from the mempool.
 * @returns {TX[]}
 */

Mempool.prototype.getHistory = function getHistory() {
  const txs = [];

  for (const entry of this.map.values())
    txs.push(entry.tx);

  return txs;
};

/**
 * Retrieve an orphan transaction.
 * @param {Hash} hash
 * @returns {TX}
 */

Mempool.prototype.getOrphan = function getOrphan(hash) {
  return this.orphans.get(hash);
};

/**
 * @param {Hash} hash
 * @returns {Boolean}
 */

Mempool.prototype.hasOrphan = function hasOrphan(hash) {
  return this.orphans.has(hash);
};

/**
 * Store an orphaned transaction.
 * @param {TX} tx
 * @param {Hash[]} missing
 * @param {Number} id

Mempool.prototype.storeOrphan = function storeOrphan(tx, missing, id) {
  if (tx.getWeight() > policy.MAX_TX_WEIGHT) {
    this.logger.debug('Ignoring large orphan: %s', tx.txid());
    if (!tx.hasWitness())
      this.rejects.add(tx.hash());
    return [];
  }

  for (const prev of missing) {
    if (this.hasReject(prev)) {
      this.logger.debug('Not storing orphan %s (rejected parents).', tx.txid());
      this.rejects.add(tx.hash());
      return [];
    }
  }

  if (this.options.maxOrphans === 0)
    return [];

  this.limitOrphans();

  const hash = tx.hash('hex');

  for (const prev of missing) {
    if (!this.waiting.has(prev))
      this.waiting.set(prev, new Set());

    this.waiting.get(prev).add(hash);
  }

  this.orphans.set(hash, new Orphan(tx, missing.length, id));

  this.logger.debug('Added orphan %s to mempool.', tx.txid());

  this.emit('add orphan', tx);

  return missing;
};
 */

/**
 * Maybe store an orphaned transaction.
 * @param {TX} tx
 * @param {CoinView} view
 * @param {Number} id
 */

Mempool.prototype.maybeOrphan = function maybeOrphan(tx, view, id) {
  const hashes = new Set();
  const missing = [];

  for (const {prevout} of tx.inputs) {
    if (view.hasEntry(prevout))
      continue;

    if (this.hasReject(prevout.hash)) {
      this.logger.debug('Not storing orphan %s (rejected parents).', tx.txid());
      this.rejects.add(tx.hash());
      return missing;
    }

    if (this.hasEntry(prevout.hash)) {
      this.logger.debug(
        'Not storing orphan %s (non-existent output).',
        tx.txid());
      this.rejects.add(tx.hash());
      return missing;
    }

    hashes.add(prevout.hash);
  }

  // Not an orphan.
  if (hashes.size === 0)
    return null;

  // Weight limit for orphans.
  if (tx.getWeight() > policy.MAX_TX_WEIGHT) {
    this.logger.debug('Ignoring large orphan: %s', tx.txid());
    if (!tx.hasWitness())
      this.rejects.add(tx.hash());
    return missing;
  }

  if (this.options.maxOrphans === 0)
    return missing;

  this.limitOrphans();

  const hash = tx.hash('hex');

  for (const prev of hashes.keys()) {
    if (!this.waiting.has(prev))
      this.waiting.set(prev, new Set());

    this.waiting.get(prev).add(hash);

    missing.push(prev);
  }

  this.orphans.set(hash, new Orphan(tx, missing.length, id));

  this.logger.debug('Added orphan %s to mempool.', tx.txid());

  this.emit('add orphan', tx);

  return missing;
};

/**
 * Resolve orphans and attempt to add to mempool.
 * @method
 * @param {TX} parent
 * @returns {Promise} - Returns {@link TX}[].
 */

Mempool.prototype.handleOrphans = async function handleOrphans(parent) {
  const resolved = this.resolveOrphans(parent);

  for (const orphan of resolved) {
    let tx, missing;

    try {
      tx = orphan.toTX();
    } catch (e) {
      this.logger.warning('%s %s',
        'Warning: possible memory corruption.',
        'Orphan failed deserialization.');
      continue;
    }

    try {
      //missing = await this.insertTX(tx, -1);
      missing = await this.insertTX(tx, orphan.id);
    } catch (err) {
      if (err.type === 'VerifyError') {
        this.logger.debug(
          'Could not resolve orphan %s: %s.',
          tx.txid(), err.message);

        if (!tx.hasWitness() && !err.malleated)
          this.rejects.add(tx.hash());

        this.emit('bad orphan', err, orphan.id);

        continue;
      }
      throw err;
    }

    //assert(!missing);
    //assert(!missing || missing.length === 0);
    // Can happen if an existing parent is
    // evicted in the interim between fetching
    // the non-present parents.
    if (missing && missing.length > 0) {
      this.logger.debug(
        'Transaction %s was double-orphaned in mempool.',
        tx.txid());
      this.removeOrphan(tx.hash('hex'));
      continue;
    }

    this.logger.debug('Resolved orphan %s in mempool.', tx.txid());
  }
};

/**
 * Potentially resolve any transactions
 * that redeem the passed-in transaction.
 * Deletes all orphan entries and
 * returns orphan objects.
 * @param {TX} parent
 * @returns {Orphan[]}
 */

Mempool.prototype.resolveOrphans = function resolveOrphans(parent) {
  const hash = parent.hash('hex');
  const set = this.waiting.get(hash);

  if (!set)
    return [];

  assert(set.size > 0);

  const resolved = [];

  //for (const orphanHash of set.keys()) {
    //const orphan = this.getOrphan(orphanHash);
  for (const hash of set.keys()) {
    const orphan = this.getOrphan(hash);

    assert(orphan);

    if (--orphan.missing === 0) {
      //this.orphans.delete(orphanHash);
      this.orphans.delete(hash);
      resolved.push(orphan);
    }
  }

  this.waiting.delete(hash);

  return resolved;
};

/**
 * Remove a transaction from the mempool.
 * @param {Hash} tx
 * @returns {Boolean}
 */

Mempool.prototype.removeOrphan = function removeOrphan(hash) {
  const orphan = this.getOrphan(hash);

  if (!orphan)
    return false;

  let tx;
  try {
    tx = orphan.toTX();
  } catch (e) {
    this.orphans.delete(hash);
    this.logger.warning('%s %s',
      'Warning: possible memory corruption.',
      'Orphan failed deserialization.');
    return false;
  }

  for (const prev of tx.getPrevout()) {
    const set = this.waiting.get(prev);

    if (!set)
      continue;

    assert(set.has(hash));

    set.delete(hash);

    if (set.size === 0)
      this.waiting.delete(prev);
  }

  this.orphans.delete(hash);

  this.emit('remove orphan', tx);

  return true;
};

/**
 * Remove a random orphan transaction from the mempool.
 * @returns {Boolean}
 */

Mempool.prototype.limitOrphans = function limitOrphans() {
  if (this.orphans.size < this.options.maxOrphans)
    return false;

  let index = random.randomRange(0, this.orphans.size);

  let hash;
  for (hash of this.orphans.keys()) {
    if (index === 0)
      break;
    index--;
  }

  assert(hash);

  this.logger.debug('Removing orphan %s from mempool.', util.revHex(hash));

  this.removeOrphan(hash);

  return true;
};

/**
 * Test all of a transactions outpoints to see if they are doublespends.
 * Note that this will only test against the mempool spents, not the
 * blockchain's. The blockchain spents are not checked against because
 * the blockchain does not maintain a spent list. The transaction will
 * be seen as an orphan rather than a double spend.
 * @param {TX} tx
 * @returns {Promise} - Returns Boolean.
 */

Mempool.prototype.isDoubleSpend = function isDoubleSpend(tx) {
  //for (const input of tx.inputs) {
    //const prevout = input.prevout;
    //if (this.isSpent(prevout.hash, prevout.index))
  for (const {prevout} of tx.inputs) {
    const {hash, index} = prevout;
    if (this.isSpent(hash, index))
      return true;
  }

  return false;
};

/**
 * Get coin viewpoint (lock).
 * @method
 * @param {TX} tx
 * @returns {Promise} - Returns {@link CoinView}.
 */

Mempool.prototype.getSpentView = async function getSpentView(tx) {
  const unlock = await this.locker.lock();
  try {
    return await this.getCoinView(tx);
  } finally {
    unlock();
  }
};

/**
 * Get coin viewpoint (no lock).
 * @method
 * @param {TX} tx
 * @returns {Promise} - Returns {@link CoinView}.
 */

Mempool.prototype.getCoinView = async function getCoinView(tx) {
  const view = new CoinView();

  for (const {prevout} of tx.inputs) {
    //const entry = this.getEntry(prevout.hash);
    const {hash, index} = prevout;
    const tx = this.getTX(hash);

    /*if (entry) {
      view.addTX(entry.tx, -1);
      continue;
    }*/
    if (tx) {
      if (index < tx.outputs.length)
        view.addIndex(tx, index, -1);
      continue;
    }

    const coin = await this.chain.readCoin(prevout);

    /*if (!coin) {
      const coins = new Coins();
      view.add(prevout.hash, coins);
      continue;
    }

    view.addEntry(prevout, coin);*/
    if (coin)
      view.addEntry(prevout, coin);
  }

  return view;
};

/**
 * Find missing outpoints.
 * @param {TX} tx
 * @param {CoinView} view
 * @returns {Hash[]}

Mempool.prototype.findMissing = function findMissing(tx, view) {
  const missing = [];

  for (const {prevout} of tx.inputs) {
    if (view.hasEntry(prevout))
      continue;

    missing.push(prevout.hash);
  }

  if (missing.length === 0)
    return null;

  return missing;
};
 */

/**
 * Get a snapshot of all transaction hashes in the mempool. Used
 * for generating INV packets in response to MEMPOOL packets.
 * @returns {Hash[]}
 */

Mempool.prototype.getSnapshot = function getSnapshot() {
  const keys = [];

  for (const hash of this.map.keys())
    keys.push(hash);

  return keys;
};

/**
 * Check sequence locks on a transaction against the current tip.
 * @param {TX} tx
 * @param {CoinView} view
 * @param {LockFlags} flags
 * @returns {Promise} - Returns Boolean.
 */

Mempool.prototype.verifyLocks = function verifyLocks(tx, view, flags) {
  return this.chain.verifyLocks(this.chain.tip, tx, view, flags);
};

/**
 * Check locktime on a transaction against the current tip.
 * @param {TX} tx
 * @param {LockFlags} flags
 * @returns {Promise} - Returns Boolean.
 */

Mempool.prototype.verifyFinal = function verifyFinal(tx, flags) {
  return this.chain.verifyFinal(this.chain.tip, tx, flags);
};

/**
 * Map a transaction to the mempool.
 * @private
 * @param {MempoolEntry} entry
 * @param {CoinView} view
 */

Mempool.prototype.trackEntry = function trackEntry(entry, view) {
  const tx = entry.tx;
  const hash = tx.hash('hex');

  assert(!this.map.has(hash));
  this.map.set(hash, entry);

  assert(!tx.isCoinbase());

  //for (const input of tx.inputs) {
    //const key = input.prevout.toKey();
  for (const {prevout} of tx.inputs) {
    const key = prevout.toKey();
    this.spents.set(key, entry);
  }

  if (this.options.indexAddress && view)
    this.indexEntry(entry, view);

  this.size += entry.memUsage();
};

/**
 * Unmap a transaction from the mempool.
 * @private
 * @param {MempoolEntry} entry
 */

Mempool.prototype.untrackEntry = function untrackEntry(entry) {
  const tx = entry.tx;
  const hash = tx.hash('hex');

  assert(this.map.has(hash));
  this.map.delete(hash);

  assert(!tx.isCoinbase());

  //for (const input of tx.inputs) {
    //const key = input.prevout.toKey();
  for (const {prevout} of tx.inputs) {
    const key = prevout.toKey();
    this.spents.delete(key);
  }

  if (this.options.indexAddress)
    this.unindexEntry(entry);

  this.size -= entry.memUsage();
};

/**
 * Index an entry by address.
 * @private
 * @param {MempoolEntry} entry
 * @param {CoinView} view
 */

Mempool.prototype.indexEntry = function indexEntry(entry, view) {
  const tx = entry.tx;

  this.txIndex.insert(entry, view);

  //for (const input of tx.inputs) {
    //const prev = input.prevout;
    //this.coinIndex.remove(prev.hash, prev.index);
  for (const {prevout} of tx.inputs) {
    const {hash, index} = prevout;
    this.coinIndex.remove(hash, index);
  }

  for (let i = 0; i < tx.outputs.length; i++)
    this.coinIndex.insert(tx, i);
};

/**
 * Unindex an entry by address.
 * @private
 * @param {MempoolEntry} entry
 */

Mempool.prototype.unindexEntry = function unindexEntry(entry) {
  const tx = entry.tx;
  const hash = tx.hash('hex');

  this.txIndex.remove(hash);

  //for (const input of tx.inputs) {
    //const prevout = input.prevout.hash;
    //const prev = this.getTX(prevout.hash);
  for (const {prevout} of tx.inputs) {
    const {hash, index} = prevout;
    const prev = this.getTX(hash);

    if (!prev)
      continue;

    //this.coinIndex.insert(prev, prevout.index);
    this.coinIndex.insert(prev, index);
  }

  for (let i = 0; i < tx.outputs.length; i++)
    this.coinIndex.remove(hash, i);
};

/**
 * Recursively remove double spenders
 * of a mined transaction's outpoints.
 * @private
 * @param {TX} tx
 */

Mempool.prototype.removeDoubleSpends = function removeDoubleSpends(tx) {
  //for (const input of tx.inputs) {
    //const prevout = input.prevout;
    //const spent = this.getSpent(prevout.hash, prevout.index);
  for (const {prevout} of tx.inputs) {
    const {hash, index} = prevout;
    const spent = this.getSpent(hash, index);

    if (!spent)
      continue;

    this.logger.debug(
      'Removing double spender from mempool: %s.',
      spent.txid());

    this.evictEntry(spent);

    this.emit('double spend', spent);
  }
};

/**
 * Calculate the memory usage of the entire mempool.
 * @see DynamicMemoryUsage()
 * @returns {Number} Usage in bytes.
 */

Mempool.prototype.getSize = function getSize() {
  return this.size;
};

/**
 * Calculate the mempool mapped txs size.
 * @returns {Number} Mempool map size.
 */

Mempool.prototype.getCount = function getCount() {
  return this.map.size;
};

/**
 * Prioritise transaction.
 * @param {MempoolEntry} entry
 * @param {Number} pri
 * @param {Amount} fee
 */

Mempool.prototype.prioritise = function prioritise(entry, pri, fee) {
  if (-pri > entry.priority)
    pri = -entry.priority;

  entry.priority += pri;

  if (-fee > entry.deltaFee)
    fee = -entry.deltaFee;

  if (fee === 0)
    return;

  this.updateAncestors(entry, prePrioritise);

  entry.deltaFee += fee;
  entry.descFee += fee;

  this.updateAncestors(entry, postPrioritise);
};

/**
 * MempoolOptions
 * @alias module:mempool.MempoolOptions
 * @constructor
 * @param {Object}
 */

function MempoolOptions(options) {
  if (!(this instanceof MempoolOptions))
    return new MempoolOptions(options);

  this.network = Network.primary;
  this.chain = null;
  this.logger = null;
  this.workers = null;
  this.fees = null;

  this.limitFree = true;
  this.limitFreeRelay = 15;
  this.relayPriority = true;
  this.requireStandard = this.network.requireStandard;
  this.rejectAbsurdFees = true;
  this.prematureWitness = false;
  this.paranoidChecks = false;
  this.replaceByFee = false;

  this.maxSize = policy.MEMPOOL_MAX_SIZE;
  this.maxOrphans = policy.MEMPOOL_MAX_ORPHANS;
  this.maxAncestors = policy.MEMPOOL_MAX_ANCESTORS;
  this.expiryTime = policy.MEMPOOL_EXPIRY_TIME;
  this.minRelay = this.network.minRelay;

  this.prefix = null;
  this.location = null;
  this.db = 'memory';
  this.maxFiles = 64;
  this.cacheSize = 32 << 20;
  this.compression = true;
  this.bufferKeys = layout.binary;

  this.persistent = false;

  this.fromOptions(options);
}

/**
 * Inject properties from object.
 * @private
 * @param {Object} options
 * @returns {MempoolOptions}
 */

MempoolOptions.prototype.fromOptions = function fromOptions(options) {
  assert(options, 'Mempool requires options.');
  assert(options.chain && typeof options.chain === 'object',
    'Mempool requires a blockchain.');

  this.chain = options.chain;
  this.network = options.chain.network;
  this.logger = options.chain.logger;
  this.workers = options.chain.workers;

  this.requireStandard = this.network.requireStandard;
  this.minRelay = this.network.minRelay;

  if (options.logger != null) {
    assert(typeof options.logger === 'object');
    this.logger = options.logger;
  }

  if (options.workers != null) {
    assert(typeof options.workers === 'object');
    this.workers = options.workers;
  }

  if (options.fees != null) {
    assert(typeof options.fees === 'object');
    this.fees = options.fees;
  }

  if (options.limitFree != null) {
    assert(typeof options.limitFree === 'boolean');
    this.limitFree = options.limitFree;
  }

  if (options.limitFreeRelay != null) {
    assert(util.isU32(options.limitFreeRelay));
    this.limitFreeRelay = options.limitFreeRelay;
  }

  if (options.relayPriority != null) {
    assert(typeof options.relayPriority === 'boolean');
    this.relayPriority = options.relayPriority;
  }

  if (options.requireStandard != null) {
    assert(typeof options.requireStandard === 'boolean');
    this.requireStandard = options.requireStandard;
  }

  if (options.rejectAbsurdFees != null) {
    assert(typeof options.rejectAbsurdFees === 'boolean');
    this.rejectAbsurdFees = options.rejectAbsurdFees;
  }

  if (options.prematureWitness != null) {
    assert(typeof options.prematureWitness === 'boolean');
    this.prematureWitness = options.prematureWitness;
  }

  if (options.paranoidChecks != null) {
    assert(typeof options.paranoidChecks === 'boolean');
    this.paranoidChecks = options.paranoidChecks;
  }

  if (options.replaceByFee != null) {
    assert(typeof options.replaceByFee === 'boolean');
    this.replaceByFee = options.replaceByFee;
  }

  if (options.maxSize != null) {
    assert(util.isU64(options.maxSize));
    this.maxSize = options.maxSize;
  }

  if (options.maxOrphans != null) {
    assert(util.isU32(options.maxOrphans));
    this.maxOrphans = options.maxOrphans;
  }

  if (options.maxAncestors != null) {
    assert(util.isU32(options.maxAncestors));
    this.maxAncestors = options.maxAncestors;
  }

  if (options.expiryTime != null) {
    assert(util.isU32(options.expiryTime));
    this.expiryTime = options.expiryTime;
  }

  if (options.minRelay != null) {
    assert(util.isU64(options.minRelay));
    this.minRelay = options.minRelay;
  }

  if (options.prefix != null) {
    assert(typeof options.prefix === 'string');
    this.prefix = options.prefix;
    this.location = path.join(this.prefix, 'mempool');
  }

  if (options.location != null) {
    assert(typeof options.location === 'string');
    this.location = options.location;
  }

  if (options.db != null) {
    assert(typeof options.db === 'string');
    this.db = options.db;
  }

  if (options.maxFiles != null) {
    assert(util.isU32(options.maxFiles));
    this.maxFiles = options.maxFiles;
  }

  if (options.cacheSize != null) {
    assert(util.isU64(options.cacheSize));
    this.cacheSize = options.cacheSize;
  }

  if (options.compression != null) {
    assert(typeof options.compression === 'boolean');
    this.compression = options.compression;
  }

  if (options.persistent != null) {
    assert(typeof options.persistent === 'boolean');
    this.persistent = options.persistent;
  }

  if (options.indexAddress != null) {
    assert(typeof options.indexAddress === 'boolean');
    this.indexAddress = options.indexAddress;
  }

  return this;
};

/**
 * Instantiate mempool options from object.
 * @param {Object} options
 * @returns {MempoolOptions}
 */

MempoolOptions.fromOptions = function fromOptions(options) {
  return new MempoolOptions().fromOptions(options);
};

/**
 * TX Address Index
 * @constructor
 * @ignore
 */

function TXIndex() {
  // Map of addr->entries.
  this.index = new Map();

  // Map of txid->addrs.
  this.map = new Map();
}

TXIndex.prototype.reset = function reset() {
  this.index.clear();
  this.map.clear();
};

TXIndex.prototype.get = function get(addr) {
  const items = this.index.get(addr);

  if (!items)
    return [];

  const out = [];

  for (const entry of items.values())
    out.push(entry.tx);

  return out;
};

TXIndex.prototype.getMeta = function getMeta(addr) {
  const items = this.index.get(addr);

  if (!items)
    return [];

  const out = [];

  for (const entry of items.values()) {
    const meta = TXMeta.fromTX(entry.tx);
    meta.mtime = entry.time;
    out.push(meta);
  }

  return out;
};

TXIndex.prototype.insert = function insert(entry, view) {
  const tx = entry.tx;
  const hash = tx.hash('hex');
  const addrs = tx.getHashes(view, 'hex');

  if (addrs.length === 0)
    return;

  for (const addr of addrs) {
    let items = this.index.get(addr);

    if (!items) {
      items = new Map();
      this.index.set(addr, items);
    }

    assert(!items.has(hash));
    items.set(hash, entry);
  }

  this.map.set(hash, addrs);
};

TXIndex.prototype.remove = function remove(hash) {
  const addrs = this.map.get(hash);

  if (!addrs)
    return;

  for (const addr of addrs) {
    const items = this.index.get(addr);

    assert(items);
    assert(items.has(hash));

    items.delete(hash);

    if (items.size === 0)
      this.index.delete(addr);
  }

  this.map.delete(hash);
};

/**
 * Coin Address Index
 * @constructor
 * @ignore
 */

function CoinIndex() {
  // Map of addr->coins.
  this.index = new Map();

  // Map of outpoint->addr.
  this.map = new Map();
}

CoinIndex.prototype.reset = function reset() {
  this.index.clear();
  this.map.clear();
};

CoinIndex.prototype.get = function get(addr) {
  const items = this.index.get(addr);

  if (!items)
    return [];

  const out = [];

  for (const coin of items.values())
    out.push(coin.toCoin());

  return out;
};

CoinIndex.prototype.insert = function insert(tx, index) {
  const output = tx.outputs[index];
  const hash = tx.hash('hex');
  const addr = output.getHash('hex');

  if (!addr)
    return;

  let items = this.index.get(addr);

  if (!items) {
    items = new Map();
    this.index.set(addr, items);
  }

  const key = Outpoint.toKey(hash, index);

  assert(!items.has(key));
  items.set(key, new IndexedCoin(tx, index));

  this.map.set(key, addr);
};

CoinIndex.prototype.remove = function remove(hash, index) {
  const key = Outpoint.toKey(hash, index);
  const addr = this.map.get(key);

  if (!addr)
    return;

  const items = this.index.get(addr);

  assert(items);
  assert(items.has(key));
  items.delete(key);

  if (items.size === 0)
    this.index.delete(addr);

  this.map.delete(key);
};

/**
 * IndexedCoin
 * @constructor
 * @ignore
 * @param {TX} tx
 * @param {Number} index
 */

function IndexedCoin(tx, index) {
  this.tx = tx;
  this.index = index;
}

IndexedCoin.prototype.toCoin = function toCoin() {
  return Coin.fromTX(this.tx, this.index, -1);
};

/**
 * Orphan
 * @constructor
 * @ignore
 * @param {TX} tx
 * @param {Hash[]} missing
 * @param {Number} id
 */

function Orphan(tx, missing, id) {
  this.raw = tx.toRaw();
  this.missing = missing;
  this.id = id;
}

Orphan.prototype.toTX = function toTX() {
  return TX.fromRaw(this.raw);
};

/**
 * Mempool Cache
 * @ignore
 * @constructor
 * @param {Object} options
 */

function MempoolCache(options) {
  if (!(this instanceof MempoolCache))
    return new MempoolCache(options);

  this.logger = options.logger;
  this.chain = options.chain;
  this.network = options.network;
  this.db = null;
  this.batch = null;

  if (options.persistent)
    this.db = LDB(options);
}

MempoolCache.VERSION = 2;

MempoolCache.prototype.getVersion = async function getVersion() {
  const data = await this.db.get(layout.V);

  if (!data)
    return -1;

  return data.readUInt32LE(0, true);
};

MempoolCache.prototype.getTip = async function getTip() {
  const hash = await this.db.get(layout.R);

  if (!hash)
    return null;

  return hash.toString('hex');
};

MempoolCache.prototype.getFees = async function getFees() {
  const data = await this.db.get(layout.F);

  if (!data)
    return null;

  let fees;
  try {
    fees = Fees.fromRaw(data);
  } catch (e) {
    this.logger.warning(
      'Fee data failed deserialization: %s.',
      e.message);
  }

  return fees;
};

MempoolCache.prototype.getEntries = function getEntries() {
  return this.db.values({
    gte: layout.e(encoding.ZERO_HASH),
    lte: layout.e(encoding.MAX_HASH),
    parse: MempoolEntry.fromRaw
  });
};

MempoolCache.prototype.getKeys = function getKeys() {
  return this.db.keys({
    gte: layout.e(encoding.ZERO_HASH),
    lte: layout.e(encoding.MAX_HASH)
  });
};

MempoolCache.prototype.open = async function open() {
  if (!this.db)
    return;

  await this.db.open();
  await this.verify();

  this.batch = this.db.batch();
};

MempoolCache.prototype.close = async function close() {
  if (!this.db)
    return;

  await this.db.close();

  this.batch = null;
};

MempoolCache.prototype.save = function save(entry) {
  if (!this.db)
    return;

  this.batch.put(layout.e(entry.tx.hash()), entry.toRaw());
};

MempoolCache.prototype.remove = function remove(hash) {
  if (!this.db)
    return;

  this.batch.del(layout.e(hash));
};

MempoolCache.prototype.sync = function sync(hash) {
  if (!this.db)
    return;

  this.batch.put(layout.R, Buffer.from(hash, 'hex'));
};

MempoolCache.prototype.writeFees = function writeFees(fees) {
  if (!this.db)
    return;

  this.batch.put(layout.F, fees.toRaw());
};

MempoolCache.prototype.clear = function clear() {
  this.batch.clear();
  this.batch = this.db.batch();
};

MempoolCache.prototype.flush = async function flush() {
  if (!this.db)
    return;

  await this.batch.write();

  this.batch = this.db.batch();
};

MempoolCache.prototype.init = async function init(hash) {
  const batch = this.db.batch();
  batch.put(layout.V, encoding.U32(MempoolCache.VERSION));
  batch.put(layout.R, Buffer.from(hash, 'hex'));
  await batch.write();
};

MempoolCache.prototype.verify = async function verify() {
  let version = await this.getVersion();
  let tip;

  if (version === -1) {
    version = MempoolCache.VERSION;
    tip = this.chain.tip.hash;

    this.logger.info(
      'Mempool cache is empty. Writing tip %s.',
      util.revHex(tip));

    await this.init(tip);
  }

  if (version !== MempoolCache.VERSION) {
    this.logger.warning(
      'Mempool cache version mismatch (%d != %d)!',
      version,
      MempoolCache.VERSION);
    this.logger.warning('Invalidating mempool cache.');
    await this.wipe();
    return false;
  }

  tip = await this.getTip();

  if (tip !== this.chain.tip.hash) {
    this.logger.warning(
      'Mempool tip not consistent with chain tip (%s != %s)!',
      util.revHex(tip),
      this.chain.tip.rhash());
    this.logger.warning('Invalidating mempool cache.');
    await this.wipe();
    return false;
  }

  return true;
};

MempoolCache.prototype.wipe = async function wipe() {
  const batch = this.db.batch();
  const keys = await this.getKeys();

  for (const key of keys)
    batch.del(key);

  batch.put(layout.V, encoding.U32(MempoolCache.VERSION));
  batch.put(layout.R, Buffer.from(this.chain.tip.hash, 'hex'));
  batch.del(layout.F);

  await batch.write();

  this.logger.info('Removed %d mempool entries from disk.', keys.length);
};

/*
 * Helpers
 */

function nop(parent, child) {
  ;
}

function addFee(parent, child) {
  parent.descFee += child.deltaFee;
  parent.descSize += child.size;
}

function removeFee(parent, child) {
  parent.descFee -= child.descFee;
  parent.descSize -= child.descSize;
}

function prePrioritise(parent, child) {
  parent.descFee -= child.deltaFee;
}

function postPrioritise(parent, child) {
  parent.descFee += child.deltaFee;
}

function cmpRate(a, b) {
  let xf = a.deltaFee;
  let xs = a.size;
  let yf = b.deltaFee;
  let ys = b.size;
  let x, y;

  if (useDesc(a)) {
    xf = a.descFee;
    xs = a.descSize;
  }

  if (useDesc(b)) {
    yf = b.descFee;
    ys = b.descSize;
  }

  x = xf * ys;
  y = xs * yf;

  if (x === y) {
    x = a.time;
    y = b.time;
  }

  return x - y;
}

function useDesc(a) {
  const x = a.deltaFee * a.descSize;
  const y = a.descFee * a.size;
  return y > x;
}

/*
 * Expose
 */

module.exports = Mempool;


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * heap.js - heap object for wmcc_core.
 */



const assert = __webpack_require__(0);

/**
 * Binary Heap
 * @alias module:utils.Heap
 * @constructor
 * @param {Function?} compare
 */

function Heap(compare) {
  if (!(this instanceof Heap))
    return new Heap(compare);

  this.compare = comparator;
  this.items = [];

  if (compare)
    this.set(compare);
}

/**
 * Initialize and sort heap.
 */

Heap.prototype.init = function init() {
  const n = this.items.length;

  if (n <= 1)
    return;

  for (let i = (n / 2 | 0) - 1; i >= 0; i--)
    this.down(i, n);
};

/**
 * Get heap size.
 * @returns {Number}
 */

Heap.prototype.size = function size() {
  return this.items.length;
};

/**
 * Set comparator.
 * @param {Function} compare
 */

Heap.prototype.set = function set(compare) {
  assert(typeof compare === 'function',
    'Comparator must be a function.');
  this.compare = compare;
};

/**
 * Push item onto heap.
 * @param {Object} item
 * @returns {Number}
 */

Heap.prototype.insert = function insert(item) {
  this.items.push(item);
  this.up(this.items.length - 1);
  return this.items.length;
};

/**
 * Pop next item off of heap.
 * @param {Object} item
 * @returns {Object}
 */

Heap.prototype.shift = function shift() {
  if (this.items.length === 0)
    return null;

  const n = this.items.length - 1;

  this.swap(0, n);
  this.down(0, n);

  return this.items.pop();
};

/**
 * Remove item from heap.
 * @param {Number} i
 * @returns {Object}
 */

Heap.prototype.remove = function remove(i) {
  if (this.items.length === 0)
    return null;

  const n = this.items.length - 1;

  if (i < 0 || i > n)
    return null;

  if (n !== i) {
    this.swap(i, n);
    this.down(i, n);
    this.up(i);
  }

  return this.items.pop();
};

/**
 * Swap indicies.
 * @private
 * @param {Number} a
 * @param {Number} b
 */

Heap.prototype.swap = function swap(a, b) {
  const x = this.items[a];
  const y = this.items[b];
  this.items[a] = y;
  this.items[b] = x;
};

/**
 * Compare indicies.
 * @private
 * @param {Number} i
 * @param {Number} j
 * @returns {Boolean}
 */

Heap.prototype.less = function less(i, j) {
  return this.compare(this.items[i], this.items[j]) < 0;
};

/**
 * Bubble item down.
 * @private
 * @param {Number} i
 * @param {Number} n
 */

Heap.prototype.down = function down(i, n) {
  for (;;) {
    const l = 2 * i + 1;

    assert(l >= 0);

    if (l < 0 || l >= n)
      break;

    let j = l;
    const r = l + 1;

    if (r < n && !this.less(l, r))
      j = r;

    if (!this.less(j, i))
      break;

    this.swap(i, j);
    i = j;
  }
};

/**
 * Bubble item up.
 * @private
 * @param {Number} i
 */

Heap.prototype.up = function up(i) {
  for (;;) {
    const j = (i - 1) / 2 | 0;

    assert(j >= 0);

    if (j < 0 || j === i)
      break;

    if (!this.less(i, j))
      break;

    this.swap(j, i);
    i = j;
  }
};

/**
 * Convert heap to sorted array.
 * @returns {Object[]}
 */

Heap.prototype.toArray = function toArray() {
  const heap = new Heap();
  const result = [];

  heap.compare = this.compare;
  heap.items = this.items.slice();

  while (heap.size() > 0)
    result.push(heap.shift());

  return result;
};

/**
 * Instantiate heap from array and comparator.
 * @param {Function} compare
 * @param {Object[]} items
 * @returns {Heap}
 */

Heap.fromArray = function fromArray(compare, items) {
  const heap = new Heap();
  heap.set(compare);
  heap.items = items;
  heap.init();
  return heap;
};

/*
 * Helpers
 */

function comparator(a, b) {
  throw new Error('No heap comparator set.');
}

/*
 * Expose
 */

module.exports = Heap;


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * common.js - mining utils.
 */



const assert = __webpack_require__(0);
const consensus = __webpack_require__(7);
const BN = __webpack_require__(27);

/**
 * @exports mining/common
 */

const common = exports;

/*
 * Constants
 */

const DIFF = 0x00000000ffff0000000000000000000000000000000000000000000000000000;
const B192 = 0x1000000000000000000000000000000000000000000000000;
const B128 = 0x100000000000000000000000000000000;
const B64 = 0x10000000000000000;
const B0 = 0x1;

/**
 * Swap 32 bit endianness of uint256.
 * @param {Buffer} data
 * @returns {Buffer}
 */

common.swap32 = function swap32(data) {
  for (let i = 0; i < data.length; i += 4) {
    const field = data.readUInt32LE(i, true);
    data.writeUInt32BE(field, i, true);
  }

  return data;
};

/**
 * Swap 32 bit endianness of uint256 (hex).
 * @param {String} str
 * @returns {String}
 */

common.swap32hex = function swap32hex(str) {
  const data = Buffer.from(str, 'hex');
  return common.swap32(data).toString('hex');
};

/**
 * Compare two uint256le's.
 * @param {Buffer} a
 * @param {Buffer} b
 * @returns {Number}
 */

common.rcmp = function rcmp(a, b) {
  assert(a.length === b.length);

  for (let i = a.length - 1; i >= 0; i--) {
    if (a[i] < b[i])
      return -1;
    if (a[i] > b[i])
      return 1;
  }

  return 0;
};

/**
 * Convert a uint256le to a double.
 * @param {Buffer} target
 * @returns {Number}
 */

common.double256 = function double256(target) {
  let n = 0;
  let hi, lo;

  assert(target.length === 32);

  hi = target.readUInt32LE(28, true);
  lo = target.readUInt32LE(24, true);
  n += (hi * 0x100000000 + lo) * B192;

  hi = target.readUInt32LE(20, true);
  lo = target.readUInt32LE(16, true);
  n += (hi * 0x100000000 + lo) * B128;

  hi = target.readUInt32LE(12, true);
  lo = target.readUInt32LE(8, true);
  n += (hi * 0x100000000 + lo) * B64;

  hi = target.readUInt32LE(4, true);
  lo = target.readUInt32LE(0, true);
  n += (hi * 0x100000000 + lo) * B0;

  return n;
};

/**
 * Calculate mining difficulty
 * from little-endian target.
 * @param {Buffer} target
 * @param {Number} decimal
 * @returns {Number|Float}
 */

common.getDifficulty = function getDifficulty(target, dec) {
  const d = DIFF;
  const n = common.double256(target);

  if (n === 0)
    return d;

  if (dec) {
    const calc = Math.pow(10, dec);
    return Math.trunc((d/n)*calc)/calc;
  }

  return Math.floor(d / n);
};

/**
 * Get target from bits as a uint256le.
 * @param {Number} bits
 * @returns {Buffer}
 */

common.getTarget = function getTarget(bits) {
  const target = consensus.fromCompact(bits);

  if (target.isNeg())
    throw new Error('Target is negative.');

  if (target.cmpn(0) === 0)
    throw new Error('Target is zero.');

  return target.toArrayLike(Buffer, 'le', 32);
};

/**
 * Get bits from target.
 * @param {Buffer} data
 * @returns {Buffer}
 */

common.getBits = function getBits(data) {
  const target = new BN(data, 'le');

  if (target.cmpn(0) === 0)
    throw new Error('Target is zero.');

  return consensus.toCompact(target);
};


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * miner.js - block generator forwmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const Heap = __webpack_require__(183);
const AsyncObject = __webpack_require__(31);
const Amount = __webpack_require__(20);
const Address = __webpack_require__(11);
const BlockTemplate = __webpack_require__(186);
const Network = __webpack_require__(6);
const consensus = __webpack_require__(7);
const policy = __webpack_require__(19);
const CPUMiner = __webpack_require__(240);
const BlockEntry = BlockTemplate.BlockEntry;

/**
 * A WMCoin miner and block generator.
 * @alias module:mining.Miner
 * @constructor
 * @param {Object} options
 */

function Miner(options) {
  if (!(this instanceof Miner))
    return new Miner(options);

  AsyncObject.call(this);

  this.options = new MinerOptions(options);
  this.network = this.options.network;
  this.logger = this.options.logger.context('miner');
  this.workers = this.options.workers;
  this.chain = this.options.chain;
  this.mempool = this.options.mempool;
  this.addresses = this.options.addresses;
  this.locker = this.chain.locker;
  this.cpu = new CPUMiner(this);

  this.address = null;

  this.init();
}

Object.setPrototypeOf(Miner.prototype, AsyncObject.prototype);

/**
 * Open the miner, wait for the chain and mempool to load.
 * @method
 * @alias module:mining.Miner#open
 * @returns {Promise}
 */

Miner.prototype.init = function init() {
  this.cpu.on('error', (err) => {
    this.emit('error', err);
  });

  this.cpu.on('block', (block, entry) => {
    this.emit('miner found', block, entry);
  });
};

/**
 * Open the miner, wait for the chain and mempool to load.
 * @method
 * @alias module:mining.Miner#open
 * @returns {Promise}
 */

Miner.prototype._open = async function _open() {
  await this.chain.open();

  if (this.mempool)
    await this.mempool.open();

  await this.cpu.open();

  this.logger.info('Miner loaded (flags=%s).',
    this.options.coinbaseFlags.toString('utf8'));

  if (this.addresses.length === 0)
    this.logger.info('No default reward address is set for miner.\nClient will use your recent wallet address.');
};

/**
 * Close the miner.
 * @method
 * @alias module:mining.Miner#close
 * @returns {Promise}
 */

Miner.prototype._close = async function _close() {
  await this.cpu.close();
};

/**
 * Create a block template.
 * @method
 * @param {ChainEntry?} tip
 * @param {Address?} address
 * @returns {Promise} - Returns {@link BlockTemplate}.
 */

Miner.prototype.createBlock = async function createBlock(tip, address) {
  const unlock = await this.locker.lock();
  try {
    return await this._createBlock(tip, address);
  } finally {
    unlock();
  }
};

/**
 * Create a block template (without a lock).
 * @method
 * @private
 * @param {ChainEntry?} tip
 * @param {Address?} address
 * @returns {Promise} - Returns {@link BlockTemplate}.
 */

Miner.prototype._createBlock = async function _createBlock(tip, address) {
  let version = this.options.version;

  if (!tip)
    tip = this.chain.tip;

  if (!address)
    address = this.getAddress();

  if (version === -1)
    version = await this.chain.computeBlockVersion(tip);

  const mtp = await this.chain.getMedianTime(tip);

  let time;
  try {
    time = await this.network.current();
  } catch (e) {
    time = Math.max(this.network.now(), mtp + 1);
  }

  const state = await this.chain.getDeployments(time, tip);
  const target = await this.chain.getTarget(time, tip);

  const locktime = state.hasMTP() ? mtp : time;

  const block = await this.chain.getBlock(tip.hash);
  const reserve = block.getCoinreserve();

  const attempt = new BlockTemplate({
    prevBlock: tip.hash,
    height: tip.height + 1,
    version: version,
    time: time,
    bits: target,
    locktime: locktime,
    mtp: mtp,
    flags: state.flags,
    address: address,
    reserve: reserve.getAddress(),
    coinbaseFlags: this.options.coinbaseFlags,
    witness: state.hasWitness(),
    interval: this.network.halvingInterval,
    weight: this.options.reservedWeight,
    sigops: this.options.reservedSigops
  });

  this.assemble(attempt);

  this.logger.debug(
    'Created block template (height=%d, weight=%d, fees=%d, txs=%s, diff=%d).',
    attempt.height,
    attempt.weight,
    Amount.wmcc(attempt.fees),
    attempt.items.length + 1,
    attempt.getDifficulty());

  if (this.options.preverify) {
    const block = attempt.toBlock();

    try {
      await this.chain._verifyBlock(block);
    } catch (e) {
      if (e.type === 'VerifyError') {
        this.logger.warning('Miner created invalid block!');
        this.logger.error(e);
        throw new Error('BUG: Miner created invalid block.');
      }
      throw e;
    }

    this.logger.debug(
      'Preverified block %d successfully!',
      attempt.height);
  }

  this.emit('miner block', attempt);

  return attempt;
};

/**
 * Update block timestamp.
 * @param {BlockTemplate} attempt
 */

Miner.prototype.updateTime = function updateTime(attempt) {
  attempt.time = Math.max(this.network.now(), attempt.mtp + 1);
};

/**
 * Create a cpu miner job.
 * @method
 * @param {ChainEntry?} tip
 * @param {Address?} address
 * @returns {Promise} Returns {@link CPUJob}.
 */

Miner.prototype.createJob = function createJob(tip, address) {
  return this.cpu.createJob(tip, address);
};

/**
 * Mine a single block.
 * @method
 * @param {ChainEntry?} tip
 * @param {Address?} address
 * @returns {Promise} Returns {@link Block}.
 */

Miner.prototype.mineBlock = function mineBlock(tip, address) {
  return this.cpu.mineBlock(tip, address);
};

/**
 * Reset cpu miner.
 * @param {Boolean} start
 */

Miner.prototype.reset = async function reset(start) {
  try {
    this.cpu.job.destroy();
    this.cpu.workers.destroy();
  } catch (e) {;}
  this.cpu = new CPUMiner(this);
  if (start)
    await this.cpu.start();
};

/**
 * Add an address to the address list.
 * @param {Address} address
 */

Miner.prototype.addAddress = function addAddress(address) {
  this.addresses.push(Address(address));
};

/**
 * Get a random address from the address list.
 * @returns {Address}
 */

Miner.prototype.getAddress = function getAddress() {
  assert(this.addresses.length);
  //if (this.addresses.length === 0)
    //return new Address();
  return this.address = (this.address || this.addresses[Math.random() * this.addresses.length | 0]);
};

/**
 * Get mempool entries, sort by dependency order.
 * Prioritize by priority and fee rates.
 * @param {BlockTemplate} attempt
 * @returns {MempoolEntry[]}
 */

Miner.prototype.assemble = function assemble(attempt) {
  if (!this.mempool) {
    attempt.refresh();
    return;
  }

  assert(this.mempool.tip === this.chain.tip.hash,
    'Mempool/chain tip mismatch! Unsafe to create block.');

  const depMap = new Map();
  const queue = new Heap(cmpRate);

  let priority = this.options.priorityWeight > 0;

  if (priority)
    queue.set(cmpPriority);

  for (const entry of this.mempool.map.values()) {
    const item = BlockEntry.fromEntry(entry, attempt);
    const tx = item.tx;

    if (tx.isCoinbase())
      throw new Error('Cannot add coinbase to block.');

    for (const {prevout} of tx.inputs) {
      const hash = prevout.hash;

      if (!this.mempool.hasEntry(hash))
        continue;

      item.depCount += 1;

      if (!depMap.has(hash))
        depMap.set(hash, []);

      depMap.get(hash).push(item);
    }

    if (item.depCount > 0)
      continue;

    queue.insert(item);
  }

  while (queue.size() > 0) {
    const item = queue.shift();
    const tx = item.tx;
    const hash = item.hash;

    let weight = attempt.weight;
    let sigops = attempt.sigops;

    if (!tx.isFinal(attempt.height, attempt.locktime))
      continue;

    if (!attempt.witness && tx.hasWitness())
      continue;

    weight += tx.getWeight();

    if (weight > this.options.maxWeight)
      continue;

    sigops += item.sigops;

    if (sigops > this.options.maxSigops)
      continue;

    if (priority) {
      if (weight > this.options.priorityWeight
          || item.priority < this.options.priorityThreshold) {
        priority = false;
        queue.set(cmpRate);
        queue.init();
        queue.insert(item);
        continue;
      }
    } else {
      if (item.free && weight >= this.options.minWeight)
        continue;
    }

    attempt.weight = weight;
    attempt.sigops = sigops;
    attempt.fees += item.fee;
    attempt.items.push(item);

    const deps = depMap.get(hash);

    if (!deps)
      continue;

    for (const item of deps) {
      if (--item.depCount === 0)
        queue.insert(item);
    }
  }

  attempt.refresh();

  assert(attempt.weight <= consensus.MAX_BLOCK_WEIGHT,
    'Block exceeds reserved weight!');

  if (this.options.preverify) {
    const block = attempt.toBlock();

    assert(block.getWeight() <= attempt.weight,
      'Block exceeds reserved weight!');

    assert(block.getBaseSize() <= consensus.MAX_BLOCK_SIZE,
      'Block exceeds max block size.');
  }
};

/**
 * MinerOptions
 * @alias module:mining.MinerOptions
 * @constructor
 * @param {Object}
 */

function MinerOptions(options) {
  if (!(this instanceof MinerOptions))
    return new MinerOptions(options);

  this.network = Network.primary;
  this.logger = null;
  this.workers = null;
  this.chain = null;
  this.mempool = null;

  this.version = -1;
  this.addresses = [];
  this.coinbaseFlags = Buffer.from('mined by wmcc_user', 'ascii');
  this.preverify = false;

  this.minWeight = policy.MIN_BLOCK_WEIGHT;
  this.maxWeight = policy.MAX_BLOCK_WEIGHT;
  this.priorityWeight = policy.BLOCK_PRIORITY_WEIGHT;
  this.priorityThreshold = policy.BLOCK_PRIORITY_THRESHOLD;
  this.maxSigops = consensus.MAX_BLOCK_SIGOPS_COST;
  this.reservedWeight = 4000;
  this.reservedSigops = 400;

  this.fromOptions(options);
}

/**
 * Inject properties from object.
 * @private
 * @param {Object} options
 * @returns {MinerOptions}
 */

MinerOptions.prototype.fromOptions = function fromOptions(options) {
  assert(options, 'Miner requires options.');
  assert(options.chain && typeof options.chain === 'object',
    'Miner requires a blockchain.');

  this.chain = options.chain;
  this.network = options.chain.network;
  this.logger = options.chain.logger;
  this.workers = options.chain.workers;

  if (options.logger != null) {
    assert(typeof options.logger === 'object');
    this.logger = options.logger;
  }

  if (options.workers != null) {
    assert(typeof options.workers === 'object');
    this.workers = options.workers;
  }

  if (options.mempool != null) {
    assert(typeof options.mempool === 'object');
    this.mempool = options.mempool;
  }

  if (options.version != null) {
    assert(util.isInt(options.version));
    this.version = options.version;
  }

  if (options.address) {
    if (Array.isArray(options.address)) {
      for (const item of options.address)
        this.addresses.push(new Address(item));
    } else {
      this.addresses.push(new Address(options.address));
    }
  }

  if (options.addresses) {
    assert(Array.isArray(options.addresses));
    for (const item of options.addresses)
      this.addresses.push(new Address(item));
  }

  if (options.coinbaseFlags) {
    let flags = options.coinbaseFlags;
    if (typeof flags === 'string')
      flags = Buffer.from(flags, 'utf8');
    assert(Buffer.isBuffer(flags));
    assert(flags.length <= 20, 'Coinbase flags > 20 bytes.');
    this.coinbaseFlags = flags;
  }

  if (options.preverify != null) {
    assert(typeof options.preverify === 'boolean');
    this.preverify = options.preverify;
  }

  if (options.minWeight != null) {
    assert(util.isU32(options.minWeight));
    this.minWeight = options.minWeight;
  }

  if (options.maxWeight != null) {
    assert(util.isU32(options.maxWeight));
    assert(options.maxWeight <= consensus.MAX_BLOCK_WEIGHT,
      'Max weight must be below MAX_BLOCK_WEIGHT');
    this.maxWeight = options.maxWeight;
  }

  if (options.maxSigops != null) {
    assert(util.isU32(options.maxSigops));
    assert(options.maxSigops <= consensus.MAX_BLOCK_SIGOPS_COST,
      'Max sigops must be below MAX_BLOCK_SIGOPS_COST');
    this.maxSigops = options.maxSigops;
  }

  if (options.priorityWeight != null) {
    assert(util.isU32(options.priorityWeight));
    this.priorityWeight = options.priorityWeight;
  }

  if (options.priorityThreshold != null) {
    assert(util.isU32(options.priorityThreshold));
    this.priorityThreshold = options.priorityThreshold;
  }

  if (options.reservedWeight != null) {
    assert(util.isU32(options.reservedWeight));
    this.reservedWeight = options.reservedWeight;
  }

  if (options.reservedSigops != null) {
    assert(util.isU32(options.reservedSigops));
    this.reservedSigops = options.reservedSigops;
  }

  return this;
};

/**
 * Instantiate miner options from object.
 * @param {Object} options
 * @returns {MinerOptions}
 */

MinerOptions.fromOptions = function fromOptions(options) {
  return new MinerOptions().fromOptions(options);
};

/*
 * Helpers
 */

function cmpPriority(a, b) {
  if (a.priority === b.priority)
    return cmpRate(a, b);
  return b.priority - a.priority;
}

function cmpRate(a, b) {
  let x = a.rate;
  let y = b.rate;

  if (a.descRate > a.rate)
    x = a.descRate;

  if (b.descRate > b.rate)
    y = b.descRate;

  if (x === y) {
    x = a.priority;
    y = b.priority;
  }

  return y - x;
}

/*
 * Expose
 */

module.exports = Miner;


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * template.js - block template object for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const digest = __webpack_require__(5);
const merkle = __webpack_require__(63);
const StaticWriter = __webpack_require__(4);
const Address = __webpack_require__(11);
const TX = __webpack_require__(16);
const Block = __webpack_require__(51);
const Input = __webpack_require__(42);
const Output = __webpack_require__(13);
const consensus = __webpack_require__(7);
const policy = __webpack_require__(19);
const encoding = __webpack_require__(3);
const CoinView = __webpack_require__(30);
const Script = __webpack_require__(8);
const common = __webpack_require__(184);
const scrypt = __webpack_require__(45); // ctl
const X15 = __webpack_require__(57);
const DUMMY = Buffer.alloc(0);

/**
 * Block Template
 * @alias module:mining.BlockTemplate
 * @constructor
 * @param {Object} options
 */

function BlockTemplate(options) {
  if (!(this instanceof BlockTemplate))
    return new BlockTemplate(options);

  this.prevBlock = encoding.NULL_HASH;
  this.version = 1;
  this.height = 0;
  this.time = 0;
  this.bits = 0;
  this.target = encoding.ZERO_HASH;
  this.locktime = 0;
  this.mtp = 0;
  this.flags = 0;
  this.coinbaseFlags = DUMMY;
  this.witness = false;
  this.address = new Address();
  this.reserve = new Address();
  this.sigops = 400;
  this.weight = 4000;
  this.interval = 210000;
  this.fees = 0;
  this.tree = new MerkleTree();
  this.commitment = encoding.ZERO_HASH;
  this.left = DUMMY;
  this.right = DUMMY;
  this.items = [];

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from options.
 * @private
 * @param {Object} options
 * @returns {BlockTemplate}
 */

BlockTemplate.prototype.fromOptions = function fromOptions(options) {
  assert(options);

  if (options.prevBlock != null) {
    assert(typeof options.prevBlock === 'string');
    this.prevBlock = options.prevBlock;
  }

  if (options.version != null) {
    assert(typeof options.version === 'number');
    this.version = options.version;
  }

  if (options.height != null) {
    assert(typeof options.height === 'number');
    this.height = options.height;
  }

  if (options.time != null) {
    assert(typeof options.time === 'number');
    this.time = options.time;
  }

  if (options.bits != null)
    this.setBits(options.bits);

  if (options.target != null)
    this.setTarget(options.target);

  if (options.locktime != null) {
    assert(typeof options.locktime === 'number');
    this.locktime = options.locktime;
  }

  if (options.mtp != null) {
    assert(typeof options.mtp === 'number');
    this.mtp = options.mtp;
  }

  if (options.flags != null) {
    assert(typeof options.flags === 'number');
    this.flags = options.flags;
  }

  if (options.coinbaseFlags != null) {
    assert(Buffer.isBuffer(options.coinbaseFlags));
    this.coinbaseFlags = options.coinbaseFlags;
  }

  if (options.witness != null) {
    assert(typeof options.witness === 'boolean');
    this.witness = options.witness;
  }

  if (options.address != null)
    this.address.fromOptions(options.address);

  if (options.reserve != null)
    this.reserve.fromOptions(options.reserve);

  if (options.sigops != null) {
    assert(typeof options.sigops === 'number');
    this.sigops = options.sigops;
  }

  if (options.weight != null) {
    assert(typeof options.weight === 'number');
    this.weight = options.weight;
  }

  if (options.interval != null) {
    assert(typeof options.interval === 'number');
    this.interval = options.interval;
  }

  if (options.fees != null) {
    assert(typeof options.fees === 'number');
    this.fees = options.fees;
  }

  if (options.items != null) {
    assert(Array.isArray(options.items));
    this.items = options.items;
  }

  return this;
};

/**
 * Instantiate block template from options.
 * @param {Object} options
 * @returns {BlockTemplate}
 */

BlockTemplate.fromOptions = function fromOptions(options) {
  return new BlockTemplate().fromOptions(options);
};

/**
 * Create witness commitment hash.
 * @returns {Buffer}
 */

BlockTemplate.prototype.getWitnessHash = function getWitnessHash() {
  const nonce = encoding.ZERO_HASH;
  const leaves = [];

  leaves.push(encoding.ZERO_HASH);

  for (const item of this.items)
    leaves.push(item.tx.witnessHash());

  const [root, malleated] = merkle.createRoot(leaves);

  assert(!malleated);

  return digest.root256(root, nonce);
};

/**
 * Create witness commitment script.
 * @returns {Script}
 */

BlockTemplate.prototype.getWitnessScript = function getWitnessScript() {
  return Script.fromCommitment(this.commitment);
};

/**
 * Set the target (bits).
 * @param {Number} bits
 */

BlockTemplate.prototype.setBits = function setBits(bits) {
  assert(typeof bits === 'number');
  this.bits = bits;
  this.target = common.getTarget(bits);
};

/**
 * Set the target (uint256le).
 * @param {Buffer} target
 */

BlockTemplate.prototype.setTarget = function setTarget(target) {
  assert(Buffer.isBuffer(target));
  this.bits = common.getBits(target);
  this.target = target;
};

/**
 * Calculate the block reward.
 * @returns {Amount}
 */

BlockTemplate.prototype.getReward = function getReward() {
  const reward = consensus.getReward(this.height, this.interval);
  return reward + this.fees;
};

/**
 * Calculate the block reserve.
 * @returns {Amount}
 */

BlockTemplate.prototype.getReserve = function getReserve() {
  return consensus.BASE_RESERVE;
};

/**
 * Initialize the default coinbase.
 * @param {Buffer} hash - Witness commitment hash.
 * @returns {TX}
 */

BlockTemplate.prototype.createCoinbase = function createCoinbase(hash) {
  const scale = consensus.WITNESS_SCALE_FACTOR;
  const cb = new TX();

  // Coinbase input.
  const input = new Input();

  // Height (required in v2+ blocks)
  input.script.pushInt(this.height);

  // Coinbase flags.
  input.script.pushData(encoding.ZERO_HASH160);

  // Smaller nonce for good measure.
  input.script.pushData(util.nonce(4));

  // Extra nonce: incremented when
  // the nonce overflows.
  input.script.pushData(encoding.ZERO_U64);

  input.script.compile();

  // Set up the witness nonce.
  if (this.witness) {
    input.witness.push(encoding.ZERO_HASH);
    input.witness.compile();
  }

  cb.inputs.push(input);

  // Reward output.
  const output = new Output();
  output.script.fromPubkeyhash(encoding.ZERO_HASH160);
  output.value = this.getReward();
  // output.value = consensus.INITIAL_COIN; // genesis

  cb.outputs.push(output);

  // Reverse output.
  const reserve = new Output();
  reserve.script.fromPubkeyhash(encoding.ZERO_HASH160);
  reserve.value = this.getReserve();
  // reserve.value = consensus.INITIAL_COINRESERVE; // genesis

  cb.outputs.push(reserve);

  // If we're using segwit, we
  // need to set up the commitment.
  if (this.witness) {
    // Commitment output.
    const commit = new Output();
    commit.script.fromCommitment(hash);
    cb.outputs.push(commit);
  }

  // Padding for the CB height (constant size).
  const op = input.script.get(0);
  assert(op);
  const padding = 5 - op.getSize();
  assert(padding >= 0);

  // Reserved size.
  // Without segwit:
  // **Plus reserve
  //   CB weight = 500
  //   CB stripped size = 125
  //   CB size = 125
  //   Sigops cost = 4
  // With segwit:
  //   CB weight = 724
  //   CB stripped size = 172
  //   CB size = 208
  //   Sigops cost = 4
  if (!this.witness) {
    assert.strictEqual(cb.getWeight() + padding * scale, 500 + 136);
    assert.strictEqual(cb.getBaseSize() + padding, 125 + 34);
    assert.strictEqual(cb.getSize() + padding, 125 + 34);
  } else {
    assert.strictEqual(cb.getWeight() + padding * scale, 724 + 136);
    assert.strictEqual(cb.getBaseSize() + padding, 172 + 34);
    assert.strictEqual(cb.getSize() + padding, 208 + 34);
  }

  // Setup coinbase flags (variable size).
  input.script.setData(1, this.coinbaseFlags);
  input.script.compile();

  // Setup reward output script (variable size).
  output.script.fromAddress(this.address);
  // Setup reserve output script (variable size).
  reserve.script.fromAddress(this.reserve);

  cb.refresh();

  assert(input.script.getSize() <= 100,
    'Coinbase input script is too large!');

  return cb;
};

/**
 * Refresh the coinbase and merkle tree.
 */

BlockTemplate.prototype.refresh = function refresh() {
  const hash = this.getWitnessHash();
  const cb = this.createCoinbase(hash);
  const raw = cb.toNormal();
  let size = 0;

  size += 4; // version
  size += 1; // varint inputs length
  size += cb.inputs[0].getSize(); // input size
  size -= 4 + 4 + 4; // -(nonce1 + nonce2 + sequence)

  // Cut off right after the nonce
  // push and before the sequence.
  const left = raw.slice(0, size);

  // Include the sequence.
  size += 4 + 4; // nonce1 + nonce2
  const right = raw.slice(size);

  this.commitment = hash;
  this.left = left;
  this.right = right;
  this.tree = MerkleTree.fromItems(this.items);
};

/**
 * Get raw coinbase with desired nonces.
 * @param {Number} nonce1
 * @param {Number} nonce2
 * @returns {Buffer}
 */

BlockTemplate.prototype.getRawCoinbase = function getRawCoinbase(nonce1, nonce2) {
  let size = 0;

  size += this.left.length;
  size += 4 + 4;
  size += this.right.length;

  const bw = new StaticWriter(size);
  bw.writeBytes(this.left);
  bw.writeU32BE(nonce1);
  bw.writeU32BE(nonce2);
  bw.writeBytes(this.right);

  return bw.render();
};

/**
 * Calculate the merkle root with given nonces.
 * @param {Number} nonce1
 * @param {Number} nonce2
 * @returns {Buffer}
 */

BlockTemplate.prototype.getRoot = function getRoot(nonce1, nonce2) {
  const raw = this.getRawCoinbase(nonce1, nonce2);
  const hash = digest.hash256(raw);
  return this.tree.withFirst(hash);
};

/**
 * Check for reserve of previous block.
 * @returns {Address}

BlockTemplate.prototype.getReserveAddress = function getReserveAddress() {
  console.log('todo here');
  return `WV17cxcpPmNNJYuFp7nkNoXJ75uZj11zTC`;
};
 */

/**
 * Create raw block header with given parameters.
 * @param {Buffer} root
 * @param {Number} time
 * @param {Number} nonce
 * @returns {Buffer}
 */

BlockTemplate.prototype.getHeader = function getHeader(root, time, nonce) {
  const bw = new StaticWriter(80);

  bw.writeU32(this.version);
  bw.writeHash(this.prevBlock);
  bw.writeHash(root);
  bw.writeU32(time);
  bw.writeU32(this.bits);
  bw.writeU32(nonce);

  return bw.render();
};

/**
 * Calculate proof with given parameters.
 * @param {Number} nonce1
 * @param {Number} nonce2
 * @param {Number} time
 * @param {Number} nonce
 * @returns {BlockProof}
 */

BlockTemplate.prototype.getProof = function getProof(nonce1, nonce2, time, nonce) {
  const root = this.getRoot(nonce1, nonce2);
  const data = this.getHeader(root, time, nonce);
  // const hash = digest.hash256(data); cfc
  // const hash = scrypt.derive(data, data, 1024, 1, 1, 32); // ctl
  const hash = X15.digest(data);
  return new BlockProof(hash, root, nonce1, nonce2, time, nonce);
};

/**
 * Create coinbase from given parameters.
 * @param {Number} nonce1
 * @param {Number} nonce2
 * @returns {TX}
 */

BlockTemplate.prototype.getCoinbase = function getCoinbase(nonce1, nonce2) {
  const raw = this.getRawCoinbase(nonce1, nonce2);
  const tx = TX.fromRaw(raw);

  if (this.witness) {
    const input = tx.inputs[0];
    input.witness.push(encoding.ZERO_HASH);
    input.witness.compile();
    tx.refresh();
  }

  return tx;
};

/**
 * Create block from calculated proof.
 * @param {BlockProof} proof
 * @returns {Block}
 */

BlockTemplate.prototype.commit = function commit(proof) {
  const root = proof.root;
  const n1 = proof.nonce1;
  const n2 = proof.nonce2;
  const time = proof.time;
  const nonce = proof.nonce;
  const block = new Block();

  block.version = this.version;
  block.prevBlock = this.prevBlock;
  block.merkleRoot = root.toString('hex');
  block.time = time;
  block.bits = this.bits;
  block.nonce = nonce;

  const tx = this.getCoinbase(n1, n2);

  block.txs.push(tx);

  for (const item of this.items)
    block.txs.push(item.tx);

  return block;
};

/**
 * Quick and dirty way to
 * get a coinbase tx object.
 * @returns {TX}
 */

BlockTemplate.prototype.toCoinbase = function toCoinbase() {
  return this.getCoinbase(0, 0);
};

/**
 * Quick and dirty way to get a block
 * object (most likely to be an invalid one).
 * @returns {Block}
 */

BlockTemplate.prototype.toBlock = function toBlock() {
  const proof = this.getProof(0, 0, this.time, 0);
  return this.commit(proof);
};

/**
 * Calculate the target difficulty.
 * @param {Number} Decimal
 * @returns {Number|Float}
 */

BlockTemplate.prototype.getDifficulty = function getDifficulty(dec) {
  return common.getDifficulty(this.target, dec);
};

/**
 * Set the reward output
 * address and refresh.
 * @param {Address} address
 */

BlockTemplate.prototype.setAddress = function setAddress(address) {
  this.address = Address(address);
  this.refresh();
};

/**
 * Add a transaction to the template.
 * @param {TX} tx
 * @param {CoinView} view
 */

BlockTemplate.prototype.addTX = function addTX(tx, view) {
  assert(!tx.mutable, 'Cannot add mutable TX to block.');

  const item = BlockEntry.fromTX(tx, view, this);
  const weight = item.tx.getWeight();
  const sigops = item.sigops;

  if (!tx.isFinal(this.height, this.locktime))
    return false;

  if (this.weight + weight > consensus.MAX_BLOCK_WEIGHT)
    return false;

  if (this.sigops + sigops > consensus.MAX_BLOCK_SIGOPS_COST)
    return false;

  if (!this.witness && tx.hasWitness())
    return false;

  this.weight += weight;
  this.sigops += sigops;
  this.fees += item.fee;

  // Add the tx to our block
  this.items.push(item);

  return true;
};

/**
 * Add a transaction to the template
 * (less verification than addTX).
 * @param {TX} tx
 * @param {CoinView?} view
 */

BlockTemplate.prototype.pushTX = function pushTX(tx, view) {
  assert(!tx.mutable, 'Cannot add mutable TX to block.');

  if (!view)
    view = new CoinView();

  const item = BlockEntry.fromTX(tx, view, this);
  const weight = item.tx.getWeight();
  const sigops = item.sigops;

  this.weight += weight;
  this.sigops += sigops;
  this.fees += item.fee;

  // Add the tx to our block
  this.items.push(item);

  return true;
};

/**
 * BlockEntry
 * @alias module:mining.BlockEntry
 * @constructor
 * @param {TX} tx
 * @property {TX} tx
 * @property {Hash} hash
 * @property {Amount} fee
 * @property {Rate} rate
 * @property {Number} priority
 * @property {Boolean} free
 * @property {Sigops} sigops
 * @property {Number} depCount
 */

function BlockEntry(tx) {
  this.tx = tx;
  this.hash = tx.hash('hex');
  this.fee = 0;
  this.rate = 0;
  this.priority = 0;
  this.free = false;
  this.sigops = 0;
  this.descRate = 0;
  this.depCount = 0;
}

/**
 * Instantiate block entry from transaction.
 * @param {TX} tx
 * @param {CoinView} view
 * @param {BlockTemplate} attempt
 * @returns {BlockEntry}
 */

BlockEntry.fromTX = function fromTX(tx, view, attempt) {
  const item = new BlockEntry(tx);
  item.fee = tx.getFee(view);
  item.rate = tx.getRate(view);
  item.priority = tx.getPriority(view, attempt.height);
  item.free = false;
  item.sigops = tx.getSigopsCost(view, attempt.flags);
  item.descRate = item.rate;
  return item;
};

/**
 * Instantiate block entry from mempool entry.
 * @param {MempoolEntry} entry
 * @param {BlockTemplate} attempt
 * @returns {BlockEntry}
 */

BlockEntry.fromEntry = function fromEntry(entry, attempt) {
  const item = new BlockEntry(entry.tx);
  item.fee = entry.getFee();
  item.rate = entry.getDeltaRate();
  item.priority = entry.getPriority(attempt.height);
  item.free = entry.getDeltaFee() < policy.getMinFee(entry.size);
  item.sigops = entry.sigops;
  item.descRate = entry.getDescRate();
  return item;
};

/*
 * BlockProof
 * @constructor
 * @param {Hash} hash
 * @param {Hash} root
 * @param {Number} nonce1
 * @param {Number} nonce2
 * @param {Number} time
 * @param {Number} nonce
 */

function BlockProof(hash, root, nonce1, nonce2, time, nonce) {
  this.hash = hash;
  this.root = root;
  this.nonce1 = nonce1;
  this.nonce2 = nonce2;
  this.time = time;
  this.nonce = nonce;
}

BlockProof.prototype.rhash = function rhash() {
  return util.revHex(this.hash.toString('hex'));
};

BlockProof.prototype.verify = function verify(target) {
  return common.rcmp(this.hash, target) <= 0;
};

BlockProof.prototype.getDifficulty = function getDifficulty(dec) {
  return common.getDifficulty(this.hash, dec);
};

/*
 * MerkleTree
 * @constructor
 * @property {Hash[]} steps
 */

function MerkleTree() {
  this.steps = [];
}

MerkleTree.prototype.withFirst = function withFirst(hash) {
  for (const step of this.steps)
    hash = digest.root256(hash, step);
  return hash;
};

MerkleTree.prototype.toJSON = function toJSON() {
  const steps = [];

  for (const step of this.steps)
    steps.push(step.toString('hex'));

  return steps;
};

MerkleTree.prototype.fromItems = function fromItems(items) {
  const leaves = [];

  leaves.push(encoding.ZERO_HASH);

  for (const item of items)
    leaves.push(item.tx.hash());

  return this.fromLeaves(leaves);
};

MerkleTree.fromItems = function fromItems(items) {
  return new MerkleTree().fromItems(items);
};

MerkleTree.prototype.fromBlock = function fromBlock(txs) {
  const leaves = [];

  leaves.push(encoding.ZERO_HASH);

  for (let i = 1; i < txs.length; i++) {
    const tx = txs[i];
    leaves.push(tx.hash());
  }

  return this.fromLeaves(leaves);
};

MerkleTree.fromBlock = function fromBlock(txs) {
  return new MerkleTree().fromBlock(txs);
};

MerkleTree.prototype.fromLeaves = function fromLeaves(leaves) {
  let len = leaves.length;

  while (len > 1) {
    const hashes = [encoding.ZERO_HASH];

    this.steps.push(leaves[1]);

    if (len % 2)
      leaves.push(leaves[len - 1]);

    for (let i = 2; i < len; i += 2) {
      const hash = digest.root256(leaves[i], leaves[i + 1]);
      hashes.push(hash);
    }

    leaves = hashes;
    len = leaves.length;
  }

  return this;
};

MerkleTree.fromLeaves = function fromLeaves(leaves) {
  return new MerkleTree().fromLeaves(leaves);
};

/*
 * Expose
 */

exports = BlockTemplate;
exports.BlockTemplate = BlockTemplate;
exports.BlockEntry = BlockEntry;

module.exports = exports;


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * socks.js - socks proxy for wmcc_core.
 */



/**
 * @module net/socks
 */

const assert = __webpack_require__(0);
const EventEmitter = __webpack_require__(10);
const net = __webpack_require__(176);
const util = __webpack_require__(1);
const IP = __webpack_require__(46);
const StaticWriter = __webpack_require__(4);
const BufferReader = __webpack_require__(2);

/**
 * SOCKS state machine
 * @constructor
 */

function SOCKS() {
  if (!(this instanceof SOCKS))
    return new SOCKS();

  EventEmitter.call(this);

  this.socket = new net.Socket();
  this.state = SOCKS.states.INIT;
  this.target = SOCKS.states.INIT;
  this.destHost = '0.0.0.0';
  this.destPort = 0;
  this.username = '';
  this.password = '';
  this.name = 'localhost';
  this.destroyed = false;
  this.timeout = null;
  this.proxied = false;
}

Object.setPrototypeOf(SOCKS.prototype, EventEmitter.prototype);

SOCKS.states = {
  INIT: 0,
  CONNECT: 1,
  HANDSHAKE: 2,
  AUTH: 3,
  PROXY: 4,
  PROXY_DONE: 5,
  RESOLVE: 6,
  RESOLVE_DONE: 7
};

SOCKS.statesByVal = util.reverse(SOCKS.states);

SOCKS.errors = [
  '',
  'General failure',
  'Connection not allowed',
  'Network is unreachable',
  'Host is unreachable',
  'Connection refused',
  'TTL expired',
  'Command not supported',
  'Address type not supported',
  'Unknown proxy error'
];

SOCKS.prototype.error = function error(err) {
  if (this.destroyed)
    return;

  if (err instanceof Error) {
    this.emit('error', err);
    this.destroy();
    return;
  }

  const msg = util.fmt.apply(util, arguments);
  this.emit('error', new Error(msg));
  this.destroy();
};

SOCKS.prototype.getError = function getError(code) {
  if (code >= SOCKS.errors.length)
    return SOCKS.errors[9];

  return SOCKS.errors[code];
};

SOCKS.prototype.destroy = function destroy() {
  if (this.destroyed)
    return;

  this.destroyed = true;
  this.socket.destroy();

  this.stopTimeout();

  if (this.state === this.target)
    return;

  this.emit('close');
};

SOCKS.prototype.startTimeout = function startTimeout() {
  this.timeout = setTimeout(() => {
    const state = SOCKS.statesByVal[this.state];
    this.timeout = null;
    this.error('SOCKS request timed out (state=%s).', state);
  }, 8000);
};

SOCKS.prototype.stopTimeout = function stopTimeout() {
  if (this.timeout != null) {
    clearTimeout(this.timeout);
    this.timeout = null;
  }
};

SOCKS.prototype.connect = function connect(port, host) {
  assert(typeof port === 'number');
  assert(typeof host === 'string');

  this.state = SOCKS.states.CONNECT;
  this.socket.connect(port, host);

  this.socket.on('connect', () => {
    if (this.proxied)
      return;
    this.handleConnect();
  });

  this.socket.on('data', (data) => {
    if (this.proxied)
      return;
    this.handleData(data);
  });

  this.socket.on('error', (err) => {
    if (this.proxied)
      return;
    this.handleError(err);
  });

  this.socket.on('close', () => {
    if (this.proxied)
      return;
    this.handleClose();
  });
};

SOCKS.prototype.open = function open(options) {
  assert(this.state === SOCKS.states.INIT);

  assert(options);

  if (options.username != null) {
    assert(typeof options.username === 'string');
    this.username = options.username;
    assert(typeof options.password === 'string',
      'Username must have a password.');
  }

  if (options.password != null) {
    assert(typeof options.password === 'string');
    this.password = options.password;
  }

  this.startTimeout();
  this.connect(options.port, options.host);
};

SOCKS.prototype.proxy = function proxy(options) {
  assert(options);
  assert(typeof options.destHost === 'string');
  assert(typeof options.destPort === 'number');

  this.destHost = options.destHost;
  this.destPort = options.destPort;
  this.target = SOCKS.states.PROXY_DONE;

  this.open(options);
};

SOCKS.prototype.resolve = function resolve(options) {
  assert(options);
  assert(typeof options.name === 'string');

  this.name = options.name;
  this.target = SOCKS.states.RESOLVE_DONE;

  this.open(options);
};

SOCKS.prototype.handleConnect = function handleConnect() {
  assert(this.state === SOCKS.states.CONNECT);
  this.sendHandshake();
};

SOCKS.prototype.handleError = function handleError(err) {
  this.error(err);
};

SOCKS.prototype.handleClose = function handleClose() {
  if (this.state !== this.target) {
    const state = SOCKS.statesByVal[this.state];
    this.error('SOCKS request destroyed (state=%s).', state);
    return;
  }

  this.destroy();
};

SOCKS.prototype.handleData = function handleData(data) {
  switch (this.state) {
    case SOCKS.states.INIT:
      this.error('Data before SOCKS connection.');
      break;
    case SOCKS.states.CONNECT:
      this.error('Data before SOCKS handshake.');
      break;
    case SOCKS.states.HANDSHAKE:
      this.handleHandshake(data);
      break;
    case SOCKS.states.AUTH:
      this.handleAuth(data);
      break;
    case SOCKS.states.PROXY:
      this.handleProxy(data);
      break;
    case SOCKS.states.RESOLVE:
      this.handleResolve(data);
      break;
    case SOCKS.states.PROXY_DONE:
    case SOCKS.states.RESOLVE_DONE:
      break;
    default:
      assert(false, 'Bad state.');
      break;
  }
};

SOCKS.prototype.sendHandshake = function sendHandshake() {
  let packet;

  if (this.username) {
    packet = Buffer.allocUnsafe(4);
    packet[0] = 0x05;
    packet[1] = 0x02;
    packet[2] = 0x00;
    packet[3] = 0x02;
  } else {
    packet = Buffer.allocUnsafe(3);
    packet[0] = 0x05;
    packet[1] = 0x01;
    packet[2] = 0x00;
  }

  this.state = SOCKS.states.HANDSHAKE;
  this.socket.write(packet);
};

SOCKS.prototype.handleHandshake = function handleHandshake(data) {
  if (data.length !== 2) {
    this.error('Bad SOCKS handshake response (size).');
    return;
  }

  if (data[0] !== 0x05) {
    this.error('Bad SOCKS version for handshake.');
    return;
  }

  this.emit('handshake');

  switch (data[1]) {
    case 0xff:
      this.error('No acceptable SOCKS auth methods.');
      break;
    case 0x02:
      this.sendAuth();
      break;
    case 0x00:
      this.state = SOCKS.states.AUTH;
      this.auth();
      break;
    default:
      this.error('SOCKS handshake error: %d.', data[1]);
      break;
  }
};

SOCKS.prototype.sendAuth = function sendAuth() {
  const user = this.username;
  const pass = this.password;

  if (!user) {
    this.error('No username passed for SOCKS auth.');
    return;
  }

  if (!pass) {
    this.error('No password passed for SOCKS auth.');
    return;
  }

  const ulen = Buffer.byteLength(user, 'ascii');
  const plen = Buffer.byteLength(pass, 'ascii');
  const size = 3 + ulen + plen;

  const bw = new StaticWriter(size);

  bw.writeU8(0x01);
  bw.writeU8(ulen);
  bw.writeString(user, 'ascii');
  bw.writeU8(plen);
  bw.writeString(pass, 'ascii');

  const packet = bw.render();

  this.state = SOCKS.states.AUTH;
  this.socket.write(packet);
};

SOCKS.prototype.handleAuth = function handleAuth(data) {
  if (data.length !== 2) {
    this.error('Bad packet size for SOCKS auth.');
    return;
  }

  if (data[0] !== 0x01) {
    this.error('Bad SOCKS auth version number.');
    return;
  }

  if (data[1] !== 0x00) {
    this.error('SOCKS auth failure: %d.', data[0]);
    return;
  }

  this.auth();
};

SOCKS.prototype.auth = function auth() {
  this.emit('auth');

  switch (this.target) {
    case SOCKS.states.PROXY_DONE:
      this.sendProxy();
      break;
    case SOCKS.states.RESOLVE_DONE:
      this.sendResolve();
      break;
    default:
      this.error('Bad target state.');
      break;
  }
};

SOCKS.prototype.sendProxy = function sendProxy() {
  const host = this.destHost;
  const port = this.destPort;
  let ip, len, type, name;

  switch (IP.getStringType(host)) {
    case IP.types.IPV4:
      ip = IP.toBuffer(host);
      type = 0x01;
      name = ip.slice(12, 16);
      len = 4;
      break;
    case IP.types.IPV6:
      ip = IP.toBuffer(host);
      type = 0x04;
      name = ip;
      len = 16;
      break;
    default:
      type = 0x03;
      name = Buffer.from(host, 'ascii');
      len = 1 + name.length;
      break;
  }

  const bw = new StaticWriter(6 + len);

  bw.writeU8(0x05);
  bw.writeU8(0x01);
  bw.writeU8(0x00);
  bw.writeU8(type);

  if (type === 0x03)
    bw.writeU8(name.length);

  bw.writeBytes(name);
  bw.writeU16BE(port);

  const packet = bw.render();

  this.state = SOCKS.states.PROXY;
  this.socket.write(packet);
};

SOCKS.prototype.handleProxy = function handleProxy(data) {
  if (data.length < 6) {
    this.error('Bad packet size for SOCKS connect.');
    return;
  }

  if (data[0] !== 0x05) {
    this.error('Bad SOCKS version for connect.');
    return;
  }

  if (data[1] !== 0x00) {
    const msg = this.getError(data[1]);
    this.error('SOCKS connect error: %s.', msg);
    return;
  }

  if (data[2] !== 0x00) {
    this.error('SOCKS connect failed (padding).');
    return;
  }

  let addr;
  try {
    addr = parseAddr(data, 3);
  } catch (e) {
    this.error(e);
    return;
  }

  this.state = SOCKS.states.PROXY_DONE;
  this.stopTimeout();
  this.proxied = true;

  this.emit('proxy address', addr);
  this.emit('proxy', this.socket);
};

SOCKS.prototype.sendResolve = function sendResolve() {
  const name = this.name;
  const len = Buffer.byteLength(name, 'utf8');

  const bw = new StaticWriter(7 + len);

  bw.writeU8(0x05);
  bw.writeU8(0xf0);
  bw.writeU8(0x00);
  bw.writeU8(0x03);
  bw.writeU8(len);
  bw.writeString(name, 'utf8');
  bw.writeU16BE(0);

  const packet = bw.render();

  this.state = SOCKS.states.RESOLVE;
  this.socket.write(packet);
};

SOCKS.prototype.handleResolve = function handleResolve(data) {
  if (data.length < 6) {
    this.error('Bad packet size for tor resolve.');
    return;
  }

  if (data[0] !== 0x05) {
    this.error('Bad SOCKS version for tor resolve.');
    return;
  }

  if (data[1] !== 0x00) {
    const msg = this.getError(data[1]);
    this.error('Tor resolve error: %s (%s).', msg, this.name);
    return;
  }

  if (data[2] !== 0x00) {
    this.error('Tor resolve failed (padding).');
    return;
  }

  let addr;
  try {
    addr = parseAddr(data, 3);
  } catch (e) {
    this.error(e);
    return;
  }

  if (addr.type === 0x03) {
    this.error('Bad address type for tor resolve.');
    return;
  }

  this.state = SOCKS.states.RESOLVE_DONE;
  this.destroy();

  this.emit('resolve', [addr.host]);
};

SOCKS.resolve = function resolve(options) {
  const socks = new SOCKS();
  return new Promise((resolve, reject) => {
    socks.resolve(options);
    socks.on('resolve', resolve);
    socks.on('error', reject);
  });
};

SOCKS.proxy = function proxy(options) {
  const socks = new SOCKS();
  return new Promise((resolve, reject) => {
    socks.proxy(options);
    socks.on('proxy', resolve);
    socks.on('error', reject);
  });
};

/**
 * Proxy Socket
 * @constructor
 * @param {String} host
 * @param {Number} port
 * @param {String?} user
 * @param {String?} pass
 */

function Proxy(host, port, user, pass) {
  if (!(this instanceof Proxy))
    return new Proxy(host, port, user, pass);

  EventEmitter.call(this);

  assert(typeof host === 'string');
  assert(typeof port === 'number');

  this.socket = null;
  this.host = host;
  this.port = port;
  this.username = user || null;
  this.password = pass || null;
  this.bytesWritten = 0;
  this.bytesRead = 0;
  this.remoteAddress = null;
  this.remotePort = 0;
  this.ops = [];
}

Object.setPrototypeOf(Proxy.prototype, EventEmitter.prototype);

Proxy.prototype.connect = async function connect(port, host) {
  assert(!this.socket, 'Already connected.');

  const options = {
    host: this.host,
    port: this.port,
    username: this.username,
    password: this.password,
    destHost: host,
    destPort: port
  };

  let socket;
  try {
    socket = await SOCKS.proxy(options);
  } catch (e) {
    this.emit('error', e);
    return;
  }

  this.remoteAddress = host;
  this.remotePort = port;
  this.socket = socket;

  this.socket.on('error', (err) => {
    this.emit('error', err);
  });

  this.socket.on('close', () => {
    this.emit('close');
  });

  this.socket.on('data', (data) => {
    this.bytesRead += data.length;
    this.emit('data', data);
  });

  this.socket.on('drain', () => {
    this.emit('drain');
  });

  this.socket.on('timeout', () => {
    this.emit('timeout');
  });

  for (const op of this.ops)
    op.call(this);

  this.ops.length = 0;

  this.emit('connect');
};

Proxy.prototype.setKeepAlive = function setKeepAlive(enable, delay) {
  if (!this.socket) {
    this.ops.push(() => {
      this.socket.setKeepAlive(enable, delay);
    });
    return;
  }
  this.socket.setKeepAlive(enable, delay);
};

Proxy.prototype.setNoDelay = function setNoDelay(enable) {
  if (!this.socket) {
    this.ops.push(() => {
      this.socket.setNoDelay(enable);
    });
    return;
  }
  this.socket.setNoDelay(enable);
};

Proxy.prototype.setTimeout = function setTimeout(timeout, callback) {
  if (!this.socket) {
    this.ops.push(() => {
      this.socket.setTimeout(timeout, callback);
    });
    return;
  }
  this.socket.setTimeout(timeout, callback);
};

Proxy.prototype.write = function write(data, callback) {
  assert(this.socket, 'Not connected.');
  this.bytesWritten += data.length;
  return this.socket.write(data, callback);
};

Proxy.prototype.end = function end() {
  assert(this.socket, 'Not connected.');
  return this.socket.end();
};

Proxy.prototype.pause = function pause() {
  assert(this.socket, 'Not connected.');
  return this.socket.pause();
};

Proxy.prototype.resume = function resume() {
  assert(this.socket, 'Not connected.');
  return this.socket.resume();
};

Proxy.prototype.destroy = function destroy() {
  if (!this.socket)
    return;
  this.socket.destroy();
};

/*
 * Helpers
 */

function parseProxy(host) {
  const index = host.indexOf('@');

  if (index === -1) {
    const addr = IP.fromHostname(host, 1080);
    return {
      host: addr.host,
      port: addr.port
    };
  }

  const left = host.substring(0, index);
  const right = host.substring(index + 1);

  const parts = left.split(':');
  assert(parts.length > 1, 'Bad username and password.');

  const addr = IP.fromHostname(right, 1080);

  return {
    host: addr.host,
    port: addr.port,
    username: parts[0],
    password: parts[1]
  };
}

function parseAddr(data, offset) {
  const br = new BufferReader(data);

  if (br.left() < offset + 2)
    throw new Error('Bad SOCKS address length.');

  br.seek(offset);

  const type = br.readU8();
  let host, port;

  switch (type) {
    case 0x01: {
      if (br.left() < 6)
        throw new Error('Bad SOCKS ipv4 length.');

      host = IP.toString(br.readBytes(4));
      port = br.readU16BE();
      break;
    }
    case 0x03: {
      const len = br.readU8();

      if (br.left() < len + 2)
        throw new Error('Bad SOCKS domain length.');

      host = br.readString(len, 'utf8');
      port = br.readU16BE();
      break;
    }
    case 0x04: {
      if (br.left() < 18)
        throw new Error('Bad SOCKS ipv6 length.');

      host = IP.toString(br.readBytes(16));
      port = br.readU16BE();
      break;
    }
    default: {
      throw new Error(`Unknown SOCKS address type: ${type}.`);
    }
  }

  return {
    type: type,
    host: host,
    port: port
  };
}

/*
 * Expose
 */

exports.connect = function connect(proxy, destPort, destHost) {
  const addr = parseProxy(proxy);
  const host = addr.host;
  const port = addr.port;
  const user = addr.username;
  const pass = addr.password;

  const socket = new Proxy(host, port, user, pass);
  socket.connect(destPort, destHost);

  return socket;
};

exports.resolve = function resolve(proxy, name) {
  const addr = parseProxy(proxy);
  return SOCKS.resolve({
    host: addr.host,
    port: addr.port,
    username: addr.username,
    password: addr.password,
    name: name
  });
};


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * peer.js - peer object for wmcc_core.
 */



const assert = __webpack_require__(0);
const EventEmitter = __webpack_require__(10);
const util = __webpack_require__(1);
const co = __webpack_require__(17);
const Parser = __webpack_require__(245);
const Framer = __webpack_require__(243);
const packets = __webpack_require__(60);
const consensus = __webpack_require__(7);
const common = __webpack_require__(59);
const InvItem = __webpack_require__(36);
const Lock = __webpack_require__(23);
const RollingFilter = __webpack_require__(118);
const BIP151 = __webpack_require__(120);
const BIP150 = __webpack_require__(119);
const BIP152 = __webpack_require__(96);
const Block = __webpack_require__(51);
const TX = __webpack_require__(16);
const encoding = __webpack_require__(3);
const NetAddress = __webpack_require__(75);
const Network = __webpack_require__(6);
const Logger = __webpack_require__(34);
const tcp = __webpack_require__(121);
const services = common.services;
const invTypes = InvItem.types;
const packetTypes = packets.types;

/**
 * Represents a remote peer.
 * @alias module:net.Peer
 * @constructor
 * @param {PeerOptions} options
 * @property {net.Socket} socket
 * @property {NetAddress} address
 * @property {Parser} parser
 * @property {Framer} framer
 * @property {Number} version
 * @property {Boolean} destroyed
 * @property {Boolean} ack - Whether verack has been received.
 * @property {Boolean} connected
 * @property {Number} time
 * @property {Boolean} preferHeaders - Whether the peer has
 * requested getheaders.
 * @property {Hash?} hashContinue - The block hash at which to continue
 * the sync for the peer.
 * @property {Bloom?} spvFilter - The _peer's_ bloom spvFilter.
 * @property {Boolean} noRelay - Whether to relay transactions
 * immediately to the peer.
 * @property {BN} challenge - Local nonce.
 * @property {Number} lastPong - Timestamp for last `pong`
 * received (unix time).
 * @property {Number} lastPing - Timestamp for last `ping`
 * sent (unix time).
 * @property {Number} minPing - Lowest ping time seen.
 * @property {Number} banScore
 * @emits Peer#ack
 */

function Peer(options) {
  if (!(this instanceof Peer))
    return new Peer(options);

  EventEmitter.call(this);

  this.options = options;
  this.network = this.options.network;
  this.logger = this.options.logger.context('peer');
  this.locker = new Lock();

  this.parser = new Parser(this.network);
  this.framer = new Framer(this.network);

  this.id = -1;
  this.socket = null;
  this.opened = false;
  this.outbound = false;
  this.loader = false;
  this.address = new NetAddress();
  this.local = new NetAddress();
  this.connected = false;
  this.destroyed = false;
  this.ack = false;
  this.handshake = false;
  this.time = 0;
  this.lastSend = 0;
  this.lastRecv = 0;
  this.drainSize = 0;
  this.drainQueue = [];
  this.banScore = 0;
  this.invQueue = [];
  this.onPacket = null;

  this.next = null;
  this.prev = null;

  this.version = -1;
  this.services = 0;
  this.height = -1;
  this.agent = null;
  this.noRelay = false;
  this.preferHeaders = false;
  this.hashContinue = null;
  this.spvFilter = null;
  this.feeRate = -1;
  this.bip151 = null;
  this.bip150 = null;
  this.compactMode = -1;
  this.compactWitness = false;
  this.merkleBlock = null;
  this.merkleTime = -1;
  this.merkleMatches = 0;
  this.merkleMap = null;
  this.syncing = false;
  this.sentAddr = false;
  this.sentGetAddr = false;
  this.challenge = null;
  this.lastPong = -1;
  this.lastPing = -1;
  this.minPing = -1;
  this.blockTime = -1;

  this.bestHash = null;
  this.bestHeight = -1;

  this.connectTimeout = null;
  this.pingTimer = null;
  this.invTimer = null;
  this.stallTimer = null;

  this.addrFilter = new RollingFilter(5000, 0.001);
  this.invFilter = new RollingFilter(50000, 0.000001);

  this.blockMap = new Map();
  this.txMap = new Map();
  this.responseMap = new Map();
  this.compactBlocks = new Map();

  this._init();
}

Object.setPrototypeOf(Peer.prototype, EventEmitter.prototype);

/**
 * Max output bytes buffered before
 * invoking stall behavior for peer.
 * @const {Number}
 * @default
 */

Peer.DRAIN_MAX = 10 << 20;

/**
 * Interval to check for drainage
 * and required responses from peer.
 * @const {Number}
 * @default
 */

Peer.STALL_INTERVAL = 5000;

/**
 * Interval for pinging peers.
 * @const {Number}
 * @default
 */

Peer.PING_INTERVAL = 30000;

/**
 * Interval to flush invs.
 * Higher means more invs (usually
 * txs) will be accumulated before
 * flushing.
 * @const {Number}
 * @default
 */

Peer.INV_INTERVAL = 5000;

/**
 * Required time for peers to
 * respond to messages (i.e.
 * getblocks/getdata).
 * @const {Number}
 * @default
 */

Peer.RESPONSE_TIMEOUT = 30000;

/**
 * Required time for loader to
 * respond with block/merkleblock.
 * @const {Number}
 * @default
 */

Peer.BLOCK_TIMEOUT = 120000;

/**
 * Required time for loader to
 * respond with a tx.
 * @const {Number}
 * @default
 */

Peer.TX_TIMEOUT = 120000;

/**
 * Generic timeout interval.
 * @const {Number}
 * @default
 */

Peer.TIMEOUT_INTERVAL = 20 * 60000;

/**
 * Create inbound peer from socket.
 * @param {PeerOptions} options
 * @param {net.Socket} socket
 * @returns {Peer}
 */

Peer.fromInbound = function fromInbound(options, socket) {
  const peer = new Peer(options);
  peer.accept(socket);
  return peer;
};

/**
 * Create outbound peer from net address.
 * @param {PeerOptions} options
 * @param {NetAddress} addr
 * @returns {Peer}
 */

Peer.fromOutbound = function fromOutbound(options, addr) {
  const peer = new Peer(options);
  peer.connect(addr);
  return peer;
};

/**
 * Create a peer from options.
 * @param {Object} options
 * @returns {Peer}
 */

Peer.fromOptions = function fromOptions(options) {
  return new Peer(new PeerOptions(options));
};

/**
 * Begin peer initialization.
 * @private
 */

Peer.prototype._init = function _init() {
  this.parser.on('packet', async (packet) => {
    try {
      await this.readPacket(packet);
    } catch (e) {
      this.error(e);
      this.destroy();
    }
  });

  this.parser.on('error', (err) => {
    if (this.destroyed)
      return;

    this.error(err);
    this.sendReject('malformed', 'error parsing message');
    this.increaseBan(10);
  });
};

/**
 * Getter to retrieve hostname.
 * @returns {String}
 */

Peer.prototype.hostname = function hostname() {
  return this.address.hostname;
};

/**
 * Frame a payload with a header.
 * @param {String} cmd - Packet type.
 * @param {Buffer} payload
 * @returns {Buffer} Payload with header prepended.
 */

Peer.prototype.framePacket = function framePacket(cmd, payload, checksum) {
  if (this.bip151 && this.bip151.handshake)
    return this.bip151.packet(cmd, payload);
  return this.framer.packet(cmd, payload, checksum);
};

/**
 * Feed data to the parser.
 * @param {Buffer} data
 */

Peer.prototype.feedParser = function feedParser(data) {
  if (this.bip151 && this.bip151.handshake)
    return this.bip151.feed(data);
  return this.parser.feed(data);
};

/**
 * Set BIP151 cipher type.
 * @param {Number} cipher
 */

Peer.prototype.setCipher = function setCipher(cipher) {
  assert(!this.bip151, 'BIP151 already set.');
  assert(this.socket, 'Peer must be initialized with a socket.');
  assert(!this.opened, 'Cannot set cipher after open.');

  this.bip151 = new BIP151(cipher);

  this.bip151.on('error', (err) => {
    this.error(err);
    this.destroy();
  });

  this.bip151.on('rekey', () => {
    if (this.destroyed)
      return;

    this.logger.debug('Rekeying with peer (%s).', this.hostname());
    this.send(this.bip151.toRekey());
  });

  this.bip151.on('packet', (cmd, body) => {
    let payload = null;
    try {
      payload = this.parser.parsePayload(cmd, body);
    } catch (e) {
      this.parser.error(e);
      return;
    }
    this.parser.emit('packet', payload);
  });
};

/**
 * Set BIP150 auth.
 * @param {AuthDB} db
 * @param {Buffer} key
 */

Peer.prototype.setAuth = function setAuth(db, key) {
  const bip151 = this.bip151;
  const hostname = this.hostname();
  const outbound = this.outbound;

  assert(this.bip151, 'BIP151 not set.');
  assert(!this.bip150, 'BIP150 already set.');
  assert(this.socket, 'Peer must be initialized with a socket.');
  assert(!this.opened, 'Cannot set auth after open.');

  this.bip150 = new BIP150(bip151, hostname, outbound, db, key);
  this.bip151.bip150 = this.bip150;
};

/**
 * Bind to socket.
 * @param {net.Socket} socket
 */

Peer.prototype.bind = function bind(socket) {
  assert(!this.socket);

  this.socket = socket;

  this.socket.once('error', (err) => {
    if (!this.connected)
      return;

    this.error(err);
    this.destroy();
  });

  this.socket.once('close', () => {
    this.error('Socket hangup.');
    this.destroy();
  });

  this.socket.on('drain', () => {
    this.handleDrain();
  });

  this.socket.on('data', (chunk) => {
    this.lastRecv = util.ms();
    this.feedParser(chunk);
  });

  this.socket.setNoDelay(true);
};

/**
 * Accept an inbound socket.
 * @param {net.Socket} socket
 * @returns {net.Socket}
 */

Peer.prototype.accept = function accept(socket) {
  assert(!this.socket);

  this.address = NetAddress.fromSocket(socket, this.network);
  this.address.services = 0;
  this.time = util.ms();
  this.outbound = false;
  this.connected = true;

  this.bind(socket);

  return socket;
};

/**
 * Create the socket and begin connecting. This method
 * will use `options.createSocket` if provided.
 * @param {NetAddress} addr
 * @returns {net.Socket}
 */

Peer.prototype.connect = function connect(addr) {
  assert(!this.socket);

  const socket = this.options.createSocket(addr.port, addr.host);

  this.address = addr;
  this.outbound = true;
  this.connected = false;

  this.bind(socket);

  return socket;
};

/**
 * Open and perform initial handshake (without rejection).
 * @method
 * @returns {Promise}
 */

Peer.prototype.tryOpen = async function tryOpen() {
  try {
    await this.open();
  } catch (e) {
    ;
  }
};

/**
 * Open and perform initial handshake.
 * @method
 * @returns {Promise}
 */

Peer.prototype.open = async function open() {
  try {
    await this._open();
  } catch (e) {
    this.error(e);
    this.destroy();
    throw e;
  }
};

/**
 * Open and perform initial handshake.
 * @method
 * @returns {Promise}
 */

Peer.prototype._open = async function _open() {
  this.opened = true;

  // Connect to peer.
  await this.initConnect();
  await this.initStall();
  await this.initBIP151();
  await this.initBIP150();
  await this.initVersion();
  await this.finalize();

  assert(!this.destroyed);

  // Finally we can let the pool know
  // that this peer is ready to go.
  this.emit('open');
};

/**
 * Wait for connection.
 * @private
 * @returns {Promise}
 */

Peer.prototype.initConnect = function initConnect() {
  if (this.connected) {
    assert(!this.outbound);
    return Promise.resolve();
  }

  return new Promise((resolve, reject) => {
    const cleanup = () => {
      if (this.connectTimeout != null) {
        clearTimeout(this.connectTimeout);
        this.connectTimeout = null;
      }
      // eslint-disable-next-line no-use-before-define
      this.socket.removeListener('error', onError);
    };

    const onError = (err) => {
      cleanup();
      reject(err);
    };

    this.socket.once('connect', () => {
      this.time = util.ms();
      this.connected = true;
      this.emit('connect');

      cleanup();
      resolve();
    });

    this.socket.once('error', onError);

    this.connectTimeout = setTimeout(() => {
      this.connectTimeout = null;
      cleanup();
      reject(new Error('Connection timed out.'));
    }, 10000);
  });
};

/**
 * Setup stall timer.
 * @private
 * @returns {Promise}
 */

Peer.prototype.initStall = function initStall() {
  assert(!this.stallTimer);
  assert(!this.destroyed);
  this.stallTimer = setInterval(() => {
    this.maybeTimeout();
  }, Peer.STALL_INTERVAL);
  return Promise.resolve();
};

/**
 * Handle `connect` event (called immediately
 * if a socket was passed into peer).
 * @method
 * @private
 * @returns {Promise}
 */

Peer.prototype.initBIP151 = async function initBIP151() {
  assert(!this.destroyed);

  // Send encinit. Wait for handshake to complete.
  if (!this.bip151)
    return;

  assert(!this.bip151.completed);

  this.logger.info('Attempting BIP151 handshake (%s).', this.hostname());

  this.send(this.bip151.toEncinit());

  try {
    await this.bip151.wait(3000);
  } catch (err) {
    this.error(err);
  }

  if (this.destroyed)
    throw new Error('Peer was destroyed during BIP151 handshake.');

  assert(this.bip151.completed);

  if (this.bip151.handshake) {
    this.logger.info('BIP151 handshake complete (%s).', this.hostname());
    this.logger.info('Connection is encrypted (%s).', this.hostname());
  }
};

/**
 * Handle post bip151-handshake.
 * @method
 * @private
 * @returns {Promise}
 */

Peer.prototype.initBIP150 = async function initBIP150() {
  assert(!this.destroyed);

  if (!this.bip150)
    return;

  assert(this.bip151);
  assert(!this.bip150.completed);

  if (!this.bip151.handshake)
    throw new Error('BIP151 handshake was not completed for BIP150.');

  this.logger.info('Attempting BIP150 handshake (%s).', this.hostname());

  if (this.bip150.outbound) {
    if (!this.bip150.peerIdentity)
      throw new Error('No known identity for peer.');
    this.send(this.bip150.toChallenge());
  }

  await this.bip150.wait(3000);

  assert(!this.destroyed);
  assert(this.bip150.completed);

  if (this.bip150.auth) {
    this.logger.info('BIP150 handshake complete (%s).', this.hostname());
    this.logger.info('Peer is authed (%s): %s.',
      this.hostname(), this.bip150.getAddress());
  }
};

/**
 * Handle post handshake.
 * @method
 * @private
 * @returns {Promise}
 */

Peer.prototype.initVersion = async function initVersion() {
  assert(!this.destroyed);

  // Say hello.
  this.sendVersion();

  if (!this.ack) {
    await this.wait(packetTypes.VERACK, 10000);
    assert(this.ack);
  }

  // Wait for _their_ version.
  if (this.version === -1) {
    this.logger.debug(
      'Peer sent a verack without a version (%s).',
      this.hostname());

    await this.wait(packetTypes.VERSION, 10000);

    assert(this.version !== -1);
  }

  if (this.destroyed)
    throw new Error('Peer was destroyed during handshake.');

  this.handshake = true;

  this.logger.debug('Version handshake complete (%s).', this.hostname());
};

/**
 * Finalize peer after handshake.
 * @method
 * @private
 * @returns {Promise}
 */

Peer.prototype.finalize = async function finalize() {
  assert(!this.destroyed);

  // Setup the ping interval.
  this.pingTimer = setInterval(() => {
    this.sendPing();
  }, Peer.PING_INTERVAL);

  // Setup the inv flusher.
  this.invTimer = setInterval(() => {
    this.flushInv();
  }, Peer.INV_INTERVAL);
};

/**
 * Broadcast blocks to peer.
 * @param {Block[]} blocks
 */

Peer.prototype.announceBlock = function announceBlock(blocks) {
  if (!this.handshake)
    return;

  if (this.destroyed)
    return;

  if (!Array.isArray(blocks))
    blocks = [blocks];

  const inv = [];

  for (const block of blocks) {
    assert(block instanceof Block);

    // Don't send if they already have it.
    if (this.invFilter.test(block.hash()))
      continue;

    // Send them the block immediately if
    // they're using compact block mode 1.
    if (this.compactMode === 1) {
      this.invFilter.add(block.hash());
      this.sendCompactBlock(block);
      continue;
    }

    // Convert item to block headers
    // for peers that request it.
    if (this.preferHeaders) {
      inv.push(block.toHeaders());
      continue;
    }

    inv.push(block.toInv());
  }

  if (this.preferHeaders) {
    this.sendHeaders(inv);
    return;
  }

  this.queueInv(inv);
};

/**
 * Broadcast transactions to peer.
 * @param {TX[]} txs
 */

Peer.prototype.announceTX = function announceTX(txs) {
  if (!this.handshake)
    return;

  if (this.destroyed)
    return;

  // Do not send txs to spv clients
  // that have relay unset.
  if (this.noRelay)
    return;

  if (!Array.isArray(txs))
    txs = [txs];

  const inv = [];

  for (const tx of txs) {
    assert(tx instanceof TX);

    // Don't send if they already have it.
    if (this.invFilter.test(tx.hash()))
      continue;

    // Check the peer's bloom
    // filter if they're using spv.
    if (this.spvFilter) {
      if (!tx.isWatched(this.spvFilter))
        continue;
    }

    // Check the fee filter.
    if (this.feeRate !== -1) {
      const hash = tx.hash('hex');
      const rate = this.options.getRate(hash);
      if (rate !== -1 && rate < this.feeRate)
        continue;
    }

    inv.push(tx.toInv());
  }

  this.queueInv(inv);
};

/**
 * Send inv to a peer.
 * @param {InvItem[]} items
 */

Peer.prototype.queueInv = function queueInv(items) {
  if (!this.handshake)
    return;

  if (this.destroyed)
    return;

  if (!Array.isArray(items))
    items = [items];

  let hasBlock = false;

  for (const item of items) {
    if (item.type === invTypes.BLOCK)
      hasBlock = true;
    this.invQueue.push(item);
  }

  if (this.invQueue.length >= 500 || hasBlock)
    this.flushInv();
};

/**
 * Flush inv queue.
 * @private
 */

Peer.prototype.flushInv = function flushInv() {
  if (this.destroyed)
    return;

  const queue = this.invQueue;

  if (queue.length === 0)
    return;

  this.invQueue = [];

  this.logger.spam('Serving %d inv items to %s.',
    queue.length, this.hostname());

  const items = [];

  for (const item of queue) {
    if (!this.invFilter.added(item.hash, 'hex'))
      continue;

    items.push(item);
  }

  for (let i = 0; i < items.length; i += 1000) {
    const chunk = items.slice(i, i + 1000);
    this.send(new packets.InvPacket(chunk));
  }
};

/**
 * Force send an inv (no filter check).
 * @param {InvItem[]} items
 */

Peer.prototype.sendInv = function sendInv(items) {
  if (!this.handshake)
    return;

  if (this.destroyed)
    return;

  if (!Array.isArray(items))
    items = [items];

  for (const item of items)
    this.invFilter.add(item.hash, 'hex');

  if (items.length === 0)
    return;

  this.logger.spam('Serving %d inv items to %s.',
    items.length, this.hostname());

  for (let i = 0; i < items.length; i += 1000) {
    const chunk = items.slice(i, i + 1000);
    this.send(new packets.InvPacket(chunk));
  }
};

/**
 * Send headers to a peer.
 * @param {Headers[]} items
 */

Peer.prototype.sendHeaders = function sendHeaders(items) {
  if (!this.handshake)
    return;

  if (this.destroyed)
    return;

  if (!Array.isArray(items))
    items = [items];

  for (const item of items)
    this.invFilter.add(item.hash());

  if (items.length === 0)
    return;

  this.logger.spam('Serving %d headers to %s.',
    items.length, this.hostname());

  for (let i = 0; i < items.length; i += 2000) {
    const chunk = items.slice(i, i + 2000);
    this.send(new packets.HeadersPacket(chunk));
  }
};

/**
 * Send a compact block.
 * @private
 * @param {Block} block
 * @returns {Boolean}
 */

Peer.prototype.sendCompactBlock = function sendCompactBlock(block) {
  const witness = this.compactWitness;
  const compact = BIP152.CompactBlock.fromBlock(block, witness);
  this.send(new packets.CmpctBlockPacket(compact, witness));
};

/**
 * Send a `version` packet.
 */

Peer.prototype.sendVersion = function sendVersion() {
  const packet = new packets.VersionPacket();
  packet.version = this.options.version;
  packet.services = this.options.services;
  packet.time = this.network.now();
  packet.remote = this.address;
  packet.local.setNull();
  packet.local.services = this.options.services;
  packet.nonce = this.options.createNonce(this.hostname());
  packet.agent = this.options.agent;
  packet.height = this.options.getHeight();
  packet.noRelay = this.options.noRelay;
  this.send(packet);
};

/**
 * Send a `getaddr` packet.
 */

Peer.prototype.sendGetAddr = function sendGetAddr() {
  if (this.sentGetAddr)
    return;

  this.sentGetAddr = true;
  this.send(new packets.GetAddrPacket());
};

/**
 * Send a `ping` packet.
 */

Peer.prototype.sendPing = function sendPing() {
  if (!this.handshake)
    return;

  if (this.version <= common.PONG_VERSION) {
    this.send(new packets.PingPacket());
    return;
  }

  if (this.challenge) {
    this.logger.debug('Peer has not responded to ping (%s).', this.hostname());
    return;
  }

  this.lastPing = util.ms();
  this.challenge = util.nonce();

  this.send(new packets.PingPacket(this.challenge));
};

/**
 * Send `filterload` to update the local bloom filter.
 */

Peer.prototype.sendFilterLoad = function sendFilterLoad(filter) {
  if (!this.handshake)
    return;

  if (!this.options.spv)
    return;

  if (!(this.services & services.BLOOM))
    return;

  this.send(new packets.FilterLoadPacket(filter));
};

/**
 * Set a fee rate filter for the peer.
 * @param {Rate} rate
 */

Peer.prototype.sendFeeRate = function sendFeeRate(rate) {
  if (!this.handshake)
    return;

  this.send(new packets.FeeFilterPacket(rate));
};

/**
 * Disconnect from and destroy the peer.
 */

Peer.prototype.destroy = function destroy() {
  const connected = this.connected;

  if (this.destroyed)
    return;

  this.destroyed = true;
  this.connected = false;

  this.socket.destroy();
  this.socket = null;

  if (this.bip151)
    this.bip151.destroy();

  if (this.bip150)
    this.bip150.destroy();

  if (this.pingTimer != null) {
    clearInterval(this.pingTimer);
    this.pingTimer = null;
  }

  if (this.invTimer != null) {
    clearInterval(this.invTimer);
    this.invTimer = null;
  }

  if (this.stallTimer != null) {
    clearInterval(this.stallTimer);
    this.stallTimer = null;
  }

  if (this.connectTimeout != null) {
    clearTimeout(this.connectTimeout);
    this.connectTimeout = null;
  }

  const jobs = this.drainQueue;

  this.drainSize = 0;
  this.drainQueue = [];

  for (const job of jobs)
    job.reject(new Error('Peer was destroyed.'));

  for (const [cmd, entry] of this.responseMap) {
    this.responseMap.delete(cmd);
    entry.reject(new Error('Peer was destroyed.'));
  }

  this.locker.destroy();

  this.emit('close', connected);
};

/**
 * Write data to the peer's socket.
 * @param {Buffer} data
 */

Peer.prototype.write = function write(data) {
  if (this.destroyed)
    throw new Error('Peer is destroyed (write).');

  this.lastSend = util.ms();

  if (this.socket.write(data) === false)
    this.needsDrain(data.length);
};

/**
 * Send a packet.
 * @param {Packet} packet
 */

Peer.prototype.send = function send(packet) {
  if (this.destroyed)
    throw new Error('Peer is destroyed (send).');

  // Used cached hashes as the
  // packet checksum for speed.
  let checksum = null;
  if (packet.type === packetTypes.TX) {
    const tx = packet.tx;
    if (packet.witness) {
      if (!tx.isCoinbase())
        checksum = tx.witnessHash();
    } else {
      checksum = tx.hash();
    }
  }

  this.sendRaw(packet.cmd, packet.toRaw(), checksum);

  this.addTimeout(packet);
};

/**
 * Send a packet.
 * @param {Packet} packet
 */

Peer.prototype.sendRaw = function sendRaw(cmd, body, checksum) {
  const payload = this.framePacket(cmd, body, checksum);
  this.write(payload);
};

/**
 * Wait for a drain event.
 * @returns {Promise}
 */

Peer.prototype.drain = function drain() {
  if (this.destroyed)
    return Promise.reject(new Error('Peer is destroyed.'));

  if (this.drainSize === 0)
    return Promise.resolve();

  return new Promise((resolve, reject) => {
    this.drainQueue.push(co.job(resolve, reject));
  });
};

/**
 * Handle drain event.
 * @private
 */

Peer.prototype.handleDrain = function handleDrain() {
  const jobs = this.drainQueue;

  this.drainSize = 0;

  if (jobs.length === 0)
    return;

  this.drainQueue = [];

  for (const job of jobs)
    job.resolve();
};

/**
 * Add to drain counter.
 * @private
 * @param {Number} size
 */

Peer.prototype.needsDrain = function needsDrain(size) {
  this.drainSize += size;

  if (this.drainSize >= Peer.DRAIN_MAX) {
    this.logger.warning(
      'Peer is not reading: %dmb buffered (%s).',
      util.mb(this.drainSize),
      this.hostname());
    this.error('Peer stalled (drain).');
    this.destroy();
  }
};

/**
 * Potentially add response timeout.
 * @private
 * @param {Packet} packet
 */

Peer.prototype.addTimeout = function addTimeout(packet) {
  const timeout = Peer.RESPONSE_TIMEOUT;

  if (!this.outbound)
    return;

  switch (packet.type) {
    case packetTypes.MEMPOOL:
      this.request(packetTypes.INV, timeout);
      break;
    case packetTypes.GETBLOCKS:
      if (!this.options.isFull())
        this.request(packetTypes.INV, timeout);
      break;
    case packetTypes.GETHEADERS:
      this.request(packetTypes.HEADERS, timeout * 2);
      break;
    case packetTypes.GETDATA:
      this.request(packetTypes.DATA, timeout * 2);
      break;
    case packetTypes.GETBLOCKTXN:
      this.request(packetTypes.BLOCKTXN, timeout);
      break;
  }
};

/**
 * Potentially finish response timeout.
 * @private
 * @param {Packet} packet
 */

Peer.prototype.fulfill = function fulfill(packet) {
  switch (packet.type) {
    case packetTypes.BLOCK:
    case packetTypes.CMPCTBLOCK:
    case packetTypes.MERKLEBLOCK:
    case packetTypes.TX:
    case packetTypes.NOTFOUND: {
      const entry = this.response(packetTypes.DATA, packet);
      assert(!entry || entry.jobs.length === 0);
      break;
    }
  }

  return this.response(packet.type, packet);
};

/**
 * Potentially timeout peer if it hasn't responded.
 * @private
 */

Peer.prototype.maybeTimeout = function maybeTimeout() {
  const now = util.ms();

  for (const [key, entry] of this.responseMap) {
    if (now > entry.timeout) {
      const name = packets.typesByVal[key];
      this.error('Peer is stalling (%s).', name.toLowerCase());
      this.destroy();
      return;
    }
  }

  if (this.merkleBlock) {
    assert(this.merkleTime !== -1);
    if (now > this.merkleTime + Peer.BLOCK_TIMEOUT) {
      this.error('Peer is stalling (merkleblock).');
      this.destroy();
      return;
    }
  }

  if (this.syncing && this.loader && !this.options.isFull()) {
    if (now > this.blockTime + Peer.BLOCK_TIMEOUT) {
      this.error('Peer is stalling (block).');
      this.destroy();
      return;
    }
  }

  if (this.options.isFull() || !this.syncing) {
    for (const time of this.blockMap.values()) {
      if (now > time + Peer.BLOCK_TIMEOUT) {
        this.error('Peer is stalling (block).');
        this.destroy();
        return;
      }
    }

    for (const time of this.txMap.values()) {
      if (now > time + Peer.TX_TIMEOUT) {
        this.error('Peer is stalling (tx).');
        this.destroy();
        return;
      }
    }

    for (const block of this.compactBlocks.values()) {
      if (now > block.now + Peer.RESPONSE_TIMEOUT) {
        this.error('Peer is stalling (blocktxn).');
        this.destroy();
        return;
      }
    }
  }

  if (now > this.time + 60000) {
    assert(this.time !== 0);

    if (this.lastRecv === 0 || this.lastSend === 0) {
      this.error('Peer is stalling (no message).');
      this.destroy();
      return;
    }

    if (now > this.lastSend + Peer.TIMEOUT_INTERVAL) {
      this.error('Peer is stalling (send).');
      this.destroy();
      return;
    }

    const mult = this.version <= common.PONG_VERSION ? 4 : 1;

    if (now > this.lastRecv + Peer.TIMEOUT_INTERVAL * mult) {
      this.error('Peer is stalling (recv).');
      this.destroy();
      return;
    }

    if (this.challenge && now > this.lastPing + Peer.TIMEOUT_INTERVAL) {
      this.error('Peer is stalling (ping).');
      this.destroy();
      return;
    }
  }
};

/**
 * Wait for a packet to be received from peer.
 * @private
 * @param {Number} type - Packet type.
 * @param {Number} timeout
 * @returns {RequestEntry}
 */

Peer.prototype.request = function request(type, timeout) {
  if (this.destroyed)
    return null;

  let entry = this.responseMap.get(type);

  if (!entry) {
    entry = new RequestEntry();
    this.responseMap.set(type, entry);
  }

  entry.setTimeout(timeout);

  return entry;
};

/**
 * Fulfill awaiting requests created with {@link Peer#request}.
 * @private
 * @param {Number} type - Packet type.
 * @param {Object} payload
 */

Peer.prototype.response = function response(type, payload) {
  const entry = this.responseMap.get(type);

  if (!entry)
    return null;

  this.responseMap.delete(type);

  return entry;
};

/**
 * Wait for a packet to be received from peer.
 * @private
 * @param {Number} type - Packet type.
 * @returns {Promise} - Returns Object(payload).
 * Executed on timeout or once packet is received.
 */

Peer.prototype.wait = function wait(type, timeout) {
  return new Promise((resolve, reject) => {
    if (this.destroyed) {
      reject(new Error('Peer is destroyed (request).'));
      return;
    }

    const entry = this.request(type);

    entry.setTimeout(timeout);
    entry.addJob(resolve, reject);
  });
};

/**
 * Emit an error and destroy the peer.
 * @private
 * @param {...String|Error} err
 */

Peer.prototype.error = function error(err) {
  if (this.destroyed)
    return;

  if (typeof err === 'string') {
    const msg = util.fmt.apply(util, arguments);
    err = new Error(msg);
  }

  if (typeof err.code === 'string' && err.code[0] === 'E') {
    const msg = err.code;
    err = new Error(msg);
    err.code = msg;
    err.message = `Socket Error: ${msg}`;
  }

  err.message += ` (${this.hostname()})`;

  this.emit('error', err);
};

/**
 * Calculate peer block inv type (filtered,
 * compact, witness, or non-witness).
 * @returns {Number}
 */

Peer.prototype.blockType = function blockType() {
  if (this.options.spv)
    return invTypes.FILTERED_BLOCK;

  if (this.options.compact
      && this.hasCompactSupport()
      && this.hasCompact()) {
    return invTypes.CMPCT_BLOCK;
  }

  if (this.hasWitness())
    return invTypes.WITNESS_BLOCK;

  return invTypes.BLOCK;
};

/**
 * Calculate peer tx inv type (witness or non-witness).
 * @returns {Number}
 */

Peer.prototype.txType = function txType() {
  if (this.hasWitness())
    return invTypes.WITNESS_TX;

  return invTypes.TX;
};

/**
 * Send `getdata` to peer.
 * @param {InvItem[]} items
 */

Peer.prototype.getData = function getData(items) {
  this.send(new packets.GetDataPacket(items));
};

/**
 * Send batched `getdata` to peer.
 * @param {InvType} type
 * @param {Hash[]} hashes
 */

Peer.prototype.getItems = function getItems(type, hashes) {
  const items = [];

  for (const hash of hashes)
    items.push(new InvItem(type, hash));

  if (items.length === 0)
    return;

  this.getData(items);
};

/**
 * Send batched `getdata` to peer (blocks).
 * @param {Hash[]} hashes
 */

Peer.prototype.getBlock = function getBlock(hashes) {
  this.getItems(this.blockType(), hashes);
};

/**
 * Send batched `getdata` to peer (txs).
 * @param {Hash[]} hashes
 */

Peer.prototype.getTX = function getTX(hashes) {
  this.getItems(this.txType(), hashes);
};

/**
 * Send `getdata` to peer for a single block.
 * @param {Hash} hash
 */

Peer.prototype.getFullBlock = function getFullBlock(hash) {
  assert(!this.options.spv);

  let type = invTypes.BLOCK;

  if (this.hasWitness())
    type |= InvItem.WITNESS_FLAG;

  this.getItems(type, [hash]);
};

/**
 * Handle a packet payload.
 * @method
 * @private
 * @param {Packet} packet
 */

Peer.prototype.readPacket = async function readPacket(packet) {
  if (this.destroyed)
    return;

  // The "pre-handshake" packets get
  // to bypass the lock, since they
  // are meant to change the way input
  // is handled at a low level. They
  // must be handled immediately.
  switch (packet.type) {
    case packetTypes.ENCINIT:
    case packetTypes.ENCACK:
    case packetTypes.AUTHCHALLENGE:
    case packetTypes.AUTHREPLY:
    case packetTypes.AUTHPROPOSE:
    case packetTypes.PONG: {
      try {
        this.socket.pause();
        await this.handlePacket(packet);
      } finally {
        if (!this.destroyed)
          this.socket.resume();
      }
      break;
    }
    default: {
      const unlock = await this.locker.lock();
      try {
        this.socket.pause();
        await this.handlePacket(packet);
      } finally {
        if (!this.destroyed)
          this.socket.resume();
        unlock();
      }
      break;
    }
  }
};

/**
 * Handle a packet payload without a lock.
 * @method
 * @private
 * @param {Packet} packet
 */

Peer.prototype.handlePacket = async function handlePacket(packet) {
  if (this.destroyed)
    throw new Error('Destroyed peer sent a packet.');

  if (this.bip151
      && this.bip151.job
      && !this.bip151.completed
      && packet.type !== packetTypes.ENCINIT
      && packet.type !== packetTypes.ENCACK) {
    this.bip151.reject(new Error('Message before BIP151 handshake.'));
  }

  if (this.bip150
      && this.bip150.job
      && !this.bip150.completed
      && packet.type !== packetTypes.AUTHCHALLENGE
      && packet.type !== packetTypes.AUTHREPLY
      && packet.type !== packetTypes.AUTHPROPOSE) {
    this.bip150.reject(new Error('Message before BIP150 auth.'));
  }

  const entry = this.fulfill(packet);

  switch (packet.type) {
    case packetTypes.VERSION:
      await this.handleVersion(packet);
      break;
    case packetTypes.VERACK:
      await this.handleVerack(packet);
      break;
    case packetTypes.PING:
      await this.handlePing(packet);
      break;
    case packetTypes.PONG:
      await this.handlePong(packet);
      break;
    case packetTypes.SENDHEADERS:
      await this.handleSendHeaders(packet);
      break;
    case packetTypes.FILTERLOAD:
      await this.handleFilterLoad(packet);
      break;
    case packetTypes.FILTERADD:
      await this.handleFilterAdd(packet);
      break;
    case packetTypes.FILTERCLEAR:
      await this.handleFilterClear(packet);
      break;
    case packetTypes.FEEFILTER:
      await this.handleFeeFilter(packet);
      break;
    case packetTypes.SENDCMPCT:
      await this.handleSendCmpct(packet);
      break;
    case packetTypes.ENCINIT:
      await this.handleEncinit(packet);
      break;
    case packetTypes.ENCACK:
      await this.handleEncack(packet);
      break;
    case packetTypes.AUTHCHALLENGE:
      await this.handleAuthChallenge(packet);
      break;
    case packetTypes.AUTHREPLY:
      await this.handleAuthReply(packet);
      break;
    case packetTypes.AUTHPROPOSE:
      await this.handleAuthPropose(packet);
      break;
  }

  if (this.onPacket)
    await this.onPacket(packet);

  this.emit('packet', packet);

  if (entry)
    entry.resolve(packet);
};

/**
 * Handle `version` packet.
 * @method
 * @private
 * @param {VersionPacket} packet
 */

Peer.prototype.handleVersion = async function handleVersion(packet) {
  if (this.version !== -1)
    throw new Error('Peer sent a duplicate version.');

  this.version = packet.version;
  this.services = packet.services;
  this.height = packet.height;
  this.agent = packet.agent;
  this.noRelay = packet.noRelay;
  this.local = packet.remote;

  if (!this.network.selfConnect) {
    if (this.options.hasNonce(packet.nonce))
      throw new Error('We connected to ourself. Oops.');
  }

  if (this.version < common.MIN_VERSION)
    throw new Error('Peer does not support required protocol version.');

  if (this.outbound) {
    if (!(this.services & services.NETWORK))
      throw new Error('Peer does not support network services.');

    if (this.options.headers) {
      if (this.version < common.HEADERS_VERSION)
        throw new Error('Peer does not support getheaders.');
    }

    if (this.options.spv) {
      if (!(this.services & services.BLOOM))
        throw new Error('Peer does not support BIP37.');

      if (this.version < common.BLOOM_VERSION)
        throw new Error('Peer does not support BIP37.');
    }

    if (this.options.hasWitness()) {
      if (!(this.services & services.WITNESS))
        throw new Error('Peer does not support segregated witness.');
    }

    if (this.options.compact) {
      if (!this.hasCompactSupport()) {
        this.logger.debug(
          'Peer does not support compact blocks (%s).',
          this.hostname());
      }
    }
  }

  this.send(new packets.VerackPacket());
};

/**
 * Handle `verack` packet.
 * @method
 * @private
 * @param {VerackPacket} packet
 */

Peer.prototype.handleVerack = async function handleVerack(packet) {
  if (this.ack) {
    this.logger.debug('Peer sent duplicate ack (%s).', this.hostname());
    return;
  }

  this.ack = true;
  this.logger.debug('Received verack (%s).', this.hostname());
};

/**
 * Handle `ping` packet.
 * @method
 * @private
 * @param {PingPacket} packet
 */

Peer.prototype.handlePing = async function handlePing(packet) {
  if (!packet.nonce)
    return;

  this.send(new packets.PongPacket(packet.nonce));
};

/**
 * Handle `pong` packet.
 * @method
 * @private
 * @param {PongPacket} packet
 */

Peer.prototype.handlePong = async function handlePong(packet) {
  const nonce = packet.nonce;
  const now = util.ms();

  if (!this.challenge) {
    this.logger.debug('Peer sent an unsolicited pong (%s).', this.hostname());
    return;
  }

  if (!nonce.equals(this.challenge)) {
    if (nonce.equals(encoding.ZERO_U64)) {
      this.logger.debug('Peer sent a zero nonce (%s).', this.hostname());
      this.challenge = null;
      return;
    }
    this.logger.debug('Peer sent the wrong nonce (%s).', this.hostname());
    return;
  }

  if (now >= this.lastPing) {
    this.lastPong = now;
    if (this.minPing === -1)
      this.minPing = now - this.lastPing;
    this.minPing = Math.min(this.minPing, now - this.lastPing);
  } else {
    this.logger.debug('Timing mismatch (what?) (%s).', this.hostname());
  }

  this.challenge = null;
};

/**
 * Handle `sendheaders` packet.
 * @method
 * @private
 * @param {SendHeadersPacket} packet
 */

Peer.prototype.handleSendHeaders = async function handleSendHeaders(packet) {
  if (this.preferHeaders) {
    this.logger.debug(
      'Peer sent a duplicate sendheaders (%s).',
      this.hostname());
    return;
  }

  this.preferHeaders = true;
};

/**
 * Handle `filterload` packet.
 * @method
 * @private
 * @param {FilterLoadPacket} packet
 */

Peer.prototype.handleFilterLoad = async function handleFilterLoad(packet) {
  if (!packet.isWithinConstraints()) {
    this.increaseBan(100);
    return;
  }

  this.spvFilter = packet.filter;
  this.noRelay = false;
};

/**
 * Handle `filteradd` packet.
 * @method
 * @private
 * @param {FilterAddPacket} packet
 */

Peer.prototype.handleFilterAdd = async function handleFilterAdd(packet) {
  const data = packet.data;

  if (data.length > consensus.MAX_SCRIPT_PUSH) {
    this.increaseBan(100);
    return;
  }

  if (this.spvFilter)
    this.spvFilter.add(data);

  this.noRelay = false;
};

/**
 * Handle `filterclear` packet.
 * @method
 * @private
 * @param {FilterClearPacket} packet
 */

Peer.prototype.handleFilterClear = async function handleFilterClear(packet) {
  if (this.spvFilter)
    this.spvFilter.reset();

  this.noRelay = false;
};

/**
 * Handle `feefilter` packet.
 * @method
 * @private
 * @param {FeeFilterPacket} packet
 */

Peer.prototype.handleFeeFilter = async function handleFeeFilter(packet) {
  const rate = packet.rate;

  if (rate < 0 || rate > consensus.getMaxMoney(packet.height)) {
    this.increaseBan(100);
    return;
  }

  this.feeRate = rate;
};

/**
 * Handle `sendcmpct` packet.
 * @method
 * @private
 * @param {SendCmpctPacket}
 */

Peer.prototype.handleSendCmpct = async function handleSendCmpct(packet) {
  if (this.compactMode !== -1) {
    this.logger.debug(
      'Peer sent a duplicate sendcmpct (%s).',
      this.hostname());
    return;
  }

  if (packet.version > 2) {
    // Ignore
    this.logger.info(
      'Peer request compact blocks version %d (%s).',
      packet.version, this.hostname());
    return;
  }

  if (packet.mode > 1) {
    this.logger.info(
      'Peer request compact blocks mode %d (%s).',
      packet.mode, this.hostname());
    return;
  }

  this.logger.info(
    'Peer initialized compact blocks (mode=%d, version=%d) (%s).',
    packet.mode, packet.version, this.hostname());

  this.compactMode = packet.mode;
  this.compactWitness = packet.version === 2;
};

/**
 * Handle `encinit` packet.
 * @method
 * @private
 * @param {EncinitPacket} packet
 */

Peer.prototype.handleEncinit = async function handleEncinit(packet) {
  if (!this.bip151)
    return;

  this.bip151.encinit(packet.publicKey, packet.cipher);

  this.send(this.bip151.toEncack());
};

/**
 * Handle `encack` packet.
 * @method
 * @private
 * @param {EncackPacket} packet
 */

Peer.prototype.handleEncack = async function handleEncack(packet) {
  if (!this.bip151)
    return;

  this.bip151.encack(packet.publicKey);
};

/**
 * Handle `authchallenge` packet.
 * @method
 * @private
 * @param {AuthChallengePacket} packet
 */

Peer.prototype.handleAuthChallenge = async function handleAuthChallenge(packet) {
  if (!this.bip150)
    return;

  const sig = this.bip150.challenge(packet.hash);

  this.send(new packets.AuthReplyPacket(sig));
};

/**
 * Handle `authreply` packet.
 * @method
 * @private
 * @param {AuthReplyPacket} packet
 */

Peer.prototype.handleAuthReply = async function handleAuthReply(packet) {
  if (!this.bip150)
    return;

  const hash = this.bip150.reply(packet.signature);

  if (hash)
    this.send(new packets.AuthProposePacket(hash));
};

/**
 * Handle `authpropose` packet.
 * @method
 * @private
 * @param {AuthProposePacket} packet
 */

Peer.prototype.handleAuthPropose = async function handleAuthPropose(packet) {
  if (!this.bip150)
    return;

  const hash = this.bip150.propose(packet.hash);

  this.send(new packets.AuthChallengePacket(hash));
};

/**
 * Send `getheaders` to peer. Note that unlike
 * `getblocks`, `getheaders` can have a null locator.
 * @param {Hash[]?} locator - Chain locator.
 * @param {Hash?} stop - Hash to stop at.
 */

Peer.prototype.sendGetHeaders = function sendGetHeaders(locator, stop) {
  const packet = new packets.GetHeadersPacket(locator, stop);

  let hash = null;
  if (packet.locator.length > 0)
    hash = util.revHex(packet.locator[0]);

  let end = null;
  if (stop)
    end = util.revHex(stop);

  this.logger.debug(
    'Requesting headers packet from peer with getheaders (%s).',
    this.hostname());

  this.logger.debug(
    'Sending getheaders (hash=%s, stop=%s).',
    hash, end);

  this.send(packet);
};

/**
 * Send `getblocks` to peer.
 * @param {Hash[]} locator - Chain locator.
 * @param {Hash?} stop - Hash to stop at.
 */

Peer.prototype.sendGetBlocks = function sendGetBlocks(locator, stop) {
  const packet = new packets.GetBlocksPacket(locator, stop);

  let hash = null;
  if (packet.locator.length > 0)
    hash = util.revHex(packet.locator[0]);

  let end = null;
  if (stop)
    end = util.revHex(stop);

  this.logger.debug(
    'Requesting inv packet from peer with getblocks (%s).',
    this.hostname());

  this.logger.debug(
    'Sending getblocks (hash=%s, stop=%s).',
    hash, end);

  this.send(packet);
};

/**
 * Send `mempool` to peer.
 */

Peer.prototype.sendMempool = function sendMempool() {
  if (!this.handshake)
    return;

  if (!(this.services & services.BLOOM)) {
    this.logger.debug(
      'Cannot request mempool for non-bloom peer (%s).',
      this.hostname());
    return;
  }

  this.logger.debug(
    'Requesting inv packet from peer with mempool (%s).',
    this.hostname());

  this.send(new packets.MempoolPacket());
};

/**
 * Send `reject` to peer.
 * @param {Number} code
 * @param {String} reason
 * @param {String} msg
 * @param {Hash} hash
 */

Peer.prototype.sendReject = function sendReject(code, reason, msg, hash) {
  const reject = packets.RejectPacket.fromReason(code, reason, msg, hash);

  if (msg) {
    this.logger.debug('Rejecting %s %s (%s): code=%s reason=%s.',
      msg, util.revHex(hash), this.hostname(), code, reason);
  } else {
    this.logger.debug('Rejecting packet from %s: code=%s reason=%s.',
      this.hostname(), code, reason);
  }

  this.logger.debug(
    'Sending reject packet to peer (%s).',
    this.hostname());

  this.send(reject);
};

/**
 * Send a `sendcmpct` packet.
 * @param {Number} mode
 */

Peer.prototype.sendCompact = function sendCompact(mode) {
  if (this.services & common.services.WITNESS) {
    if (this.version >= common.COMPACT_WITNESS_VERSION) {
      this.logger.info(
        'Initializing witness compact blocks (%s).',
        this.hostname());
      this.send(new packets.SendCmpctPacket(mode, 2));
      return;
    }
  }

  if (this.version >= common.COMPACT_VERSION) {
    this.logger.info(
      'Initializing normal compact blocks (%s).',
      this.hostname());

    this.send(new packets.SendCmpctPacket(mode, 1));
  }
};

/**
 * Increase banscore on peer.
 * @param {Number} score
 * @returns {Boolean}
 */

Peer.prototype.increaseBan = function increaseBan(score) {
  this.banScore += score;

  if (this.banScore >= this.options.banScore) {
    this.logger.debug('Ban threshold exceeded (%s).', this.hostname());
    this.ban();
    return true;
  }

  return false;
};

/**
 * Ban peer.
 */

Peer.prototype.ban = function ban() {
  this.emit('ban');
};

/**
 * Send a `reject` packet to peer.
 * @param {String} msg
 * @param {VerifyError} err
 * @returns {Boolean}
 */

Peer.prototype.reject = function reject(msg, err) {
  this.sendReject(err.code, err.reason, msg, err.hash);
  return this.increaseBan(err.score);
};

/**
 * Test whether required services are available.
 * @param {Number} services
 * @returns {Boolean}
 */

Peer.prototype.hasServices = function hasServices(services) {
  return (this.services & services) === services;
};

/**
 * Test whether the WITNESS service bit is set.
 * @returns {Boolean}
 */

Peer.prototype.hasWitness = function hasWitness() {
  return (this.services & services.WITNESS) !== 0;
};

/**
 * Test whether the peer supports compact blocks.
 * @returns {Boolean}
 */

Peer.prototype.hasCompactSupport = function hasCompactSupport() {
  if (this.version < common.COMPACT_VERSION)
    return false;

  if (!this.options.hasWitness())
    return true;

  if (!(this.services & services.WITNESS))
    return false;

  return this.version >= common.COMPACT_WITNESS_VERSION;
};

/**
 * Test whether the peer sent us a
 * compatible compact block handshake.
 * @returns {Boolean}
 */

Peer.prototype.hasCompact = function hasCompact() {
  if (this.compactMode === -1)
    return false;

  if (!this.options.hasWitness())
    return true;

  if (!this.compactWitness)
    return false;

  return true;
};

/**
 * Inspect the peer.
 * @returns {String}
 */

Peer.prototype.inspect = function inspect() {
  return '<Peer:'
    + ` handshake=${this.handshake}`
    + ` host=${this.hostname()}`
    + ` outbound=${this.outbound}`
    + ` ping=${this.minPing}`
    + '>';
};

/**
 * PeerOptions
 * @alias module:net.PeerOptions
 * @constructor
 */

function PeerOptions(options) {
  if (!(this instanceof PeerOptions))
    return new PeerOptions(options);

  this.network = Network.primary;
  this.logger = Logger.global;

  this.createSocket = tcp.createSocket;
  this.version = common.PROTOCOL_VERSION;
  this.services = common.LOCAL_SERVICES;
  this.agent = common.USER_AGENT;
  this.noRelay = false;
  this.spv = false;
  this.compact = false;
  this.headers = false;
  this.banScore = common.BAN_SCORE;

  this.getHeight = PeerOptions.getHeight;
  this.isFull = PeerOptions.isFull;
  this.hasWitness = PeerOptions.hasWitness;
  this.createNonce = PeerOptions.createNonce;
  this.hasNonce = PeerOptions.hasNonce;
  this.getRate = PeerOptions.getRate;

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from object.
 * @private
 * @param {Object} options
 * @returns {PeerOptions}
 */

PeerOptions.prototype.fromOptions = function fromOptions(options) {
  assert(options, 'Options are required.');

  if (options.network != null)
    this.network = Network.get(options.network);

  if (options.logger != null) {
    assert(typeof options.logger === 'object');
    this.logger = options.logger;
  }

  if (options.createSocket != null) {
    assert(typeof options.createSocket === 'function');
    this.createSocket = options.createSocket;
  }

  if (options.version != null) {
    assert(typeof options.version === 'number');
    this.version = options.version;
  }

  if (options.services != null) {
    assert(typeof options.services === 'number');
    this.services = options.services;
  }

  if (options.agent != null) {
    assert(typeof options.agent === 'string');
    this.agent = options.agent;
  }

  if (options.noRelay != null) {
    assert(typeof options.noRelay === 'boolean');
    this.noRelay = options.noRelay;
  }

  if (options.spv != null) {
    assert(typeof options.spv === 'boolean');
    this.spv = options.spv;
  }

  if (options.compact != null) {
    assert(typeof options.compact === 'boolean');
    this.compact = options.compact;
  }

  if (options.headers != null) {
    assert(typeof options.headers === 'boolean');
    this.headers = options.headers;
  }

  if (options.banScore != null) {
    assert(typeof options.banScore === 'number');
    this.banScore = options.banScore;
  }

  if (options.getHeight != null) {
    assert(typeof options.getHeight === 'function');
    this.getHeight = options.getHeight;
  }

  if (options.isFull != null) {
    assert(typeof options.isFull === 'function');
    this.isFull = options.isFull;
  }

  if (options.hasWitness != null) {
    assert(typeof options.hasWitness === 'function');
    this.hasWitness = options.hasWitness;
  }

  if (options.createNonce != null) {
    assert(typeof options.createNonce === 'function');
    this.createNonce = options.createNonce;
  }

  if (options.hasNonce != null) {
    assert(typeof options.hasNonce === 'function');
    this.hasNonce = options.hasNonce;
  }

  if (options.getRate != null) {
    assert(typeof options.getRate === 'function');
    this.getRate = options.getRate;
  }

  return this;
};

/**
 * Instantiate options from object.
 * @param {Object} options
 * @returns {PeerOptions}
 */

PeerOptions.fromOptions = function fromOptions(options) {
  return new PeerOptions().fromOptions(options);
};

/**
 * Get the chain height.
 * @private
 * @returns {Number}
 */

PeerOptions.getHeight = function getHeight() {
  return 0;
};

/**
 * Test whether the chain is synced.
 * @private
 * @returns {Boolean}
 */

PeerOptions.isFull = function isFull() {
  return false;
};

/**
 * Whether segwit is enabled.
 * @private
 * @returns {Boolean}
 */

PeerOptions.hasWitness = function hasWitness() {
  return true;
};

/**
 * Create a version packet nonce.
 * @private
 * @param {String} hostname
 * @returns {Buffer}
 */

PeerOptions.createNonce = function createNonce(hostname) {
  return util.nonce();
};

/**
 * Test whether version nonce is ours.
 * @private
 * @param {Buffer} nonce
 * @returns {Boolean}
 */

PeerOptions.hasNonce = function hasNonce(nonce) {
  return false;
};

/**
 * Get fee rate for txid.
 * @private
 * @param {Hash} hash
 * @returns {Rate}
 */

PeerOptions.getRate = function getRate(hash) {
  return -1;
};

/**
 * RequestEntry
 * @constructor
 * @ignore
 */

function RequestEntry() {
  this.timeout = 0;
  this.jobs = [];
}

RequestEntry.prototype.addJob = function addJob(resolve, reject) {
  this.jobs.push(co.job(resolve, reject));
};

RequestEntry.prototype.setTimeout = function setTimeout(timeout) {
  this.timeout = util.ms() + timeout;
};

RequestEntry.prototype.reject = function reject(err) {
  for (const job of this.jobs)
    job.reject(err);

  this.jobs.length = 0;
};

RequestEntry.prototype.resolve = function resolve(result) {
  for (const job of this.jobs)
    job.resolve(result);

  this.jobs.length = 0;
};

/*
 * Expose
 */

module.exports = Peer;


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * node.js - node object for wmcc_core.
 */



const assert = __webpack_require__(0);
const AsyncObject = __webpack_require__(31);
const util = __webpack_require__(1);
const Network = __webpack_require__(6);
const Logger = __webpack_require__(34);
const WorkerPool = __webpack_require__(124);
const secp256k1 = __webpack_require__(12);
const native = __webpack_require__(18);
const Config = __webpack_require__(123);

/**
 * Base class from which every other
 * Node-like object inherits.
 * @alias module:node.Node
 * @constructor
 * @abstract
 * @param {Object} options
 */

function Node(options) {
  if (!(this instanceof Node))
    return new Node(options);

  AsyncObject.call(this);

  this.config = new Config('wmcc');
  this.config.inject(options);
  this.config.load(options);

  if (options.config)
    this.config.open('wmcc.conf');

  this.network = Network.get(this.config.network);
  this.startTime = -1;
  this.bound = [];
  this.plugins = Object.create(null);
  this.stack = [];

  this.logger = null;
  this.workers = null;

  this.spv = false;
  this.chain = null;
  this.fees = null;
  this.mempool = null;
  this.pool = null;
  this.miner = null;
  this.http = null;

  this.init();
}

Object.setPrototypeOf(Node.prototype, AsyncObject.prototype);

/**
 * Initialize options.
 * @private
 * @param {Object} options
 */

Node.prototype.initOptions = function initOptions() {
  let logger = new Logger();
  const config = this.config;

  if (config.has('logger'))
    logger = config.obj('logger');

  logger.set({
    filename: config.bool('log-file')
      ? config.location('debug.log')
      : null,
    level: config.str('log-level'),
    console: config.bool('log-console'),
    shrink: config.bool('log-shrink')
  });

  this.logger = logger.context('node');

  this.workers = new WorkerPool({
    enabled: config.bool('workers'),
    size: config.uint('workers-size'),
    timeout: config.uint('workers-timeout'),
    file: config.str('worker-file')
  });
};

/**
 * Initialize node.
 * @private
 * @param {Object} options
 */

Node.prototype.init = function init() {
  this.initOptions();

  this.on('error', () => {});

  this.workers.on('spawn', (child) => {
    this.logger.info('Spawning worker process: %d.', child.id);
  });

  this.workers.on('exit', (code, child) => {
    this.logger.warning('Worker %d exited: %s.', child.id, code);
  });

  this.workers.on('log', (text, child) => {
    this.logger.debug('Worker %d says:', child.id);
    this.logger.debug(text);
  });

  this.workers.on('error', (err, child) => {
    if (child) {
      this.logger.error('Worker %d error: %s', child.id, err.message);
      return;
    }
    this.emit('error', err);
  });

  this.hook('preopen', () => this.handlePreopen());
  this.hook('preclose', () => this.handlePreclose());
  this.hook('open', () => this.handleOpen());
  this.hook('close', () => this.handleClose());
};

/**
 * Ensure prefix directory.
 * @returns {Promise}
 */

Node.prototype.ensure = function ensure() {
  return this.config.ensure();
};

/**
 * Create a file path using `prefix`.
 * @param {String} file
 * @returns {String}
 */

Node.prototype.location = function location(name) {
  return this.config.location(name);
};

/**
 * Open node. Bind all events.
 * @private
 */

Node.prototype.handlePreopen = async function handlePreopen() {
  await this.logger.open();
  await this.workers.open();

  this.bind(this.network.time, 'offset', (offset) => {
    this.logger.info('Time offset: %d (%d minutes).', offset, offset / 60 | 0);
  });

  this.bind(this.network.time, 'sample', (sample, total) => {
    this.logger.debug(
      'Added time data: samples=%d, offset=%d (%d minutes).',
      total, sample, sample / 60 | 0);
  });

  this.bind(this.network.time, 'mismatch', () => {
    this.logger.warning('Adjusted time mismatch!');
    this.logger.warning('Please make sure your system clock is correct!');
  });
};

/**
 * Open node.
 * @private
 */

Node.prototype.handleOpen = async function handleOpen() {
  this.startTime = util.now();

  if (!secp256k1.binding) {
    this.logger.warning('Warning: secp256k1-node was not built.');
    this.logger.warning('Verification will be slow.');
  }

  if (!native.binding) {
    this.logger.warning('Warning: wmcc-native was not built.');
    this.logger.warning('Hashing will be slow.');
  }

  if (!this.workers.enabled) {
    this.logger.warning('Warning: worker pool is disabled.');
    this.logger.warning('Verification will be slow.');
  }
};

/**
 * Open node. Bind all events.
 * @private
 */

Node.prototype.handlePreclose = async function handlePreclose() {
  ;
};

/**
 * Close node. Unbind all events.
 * @private
 */

Node.prototype.handleClose = async function handleClose() {
  for (const [obj, event, listener] of this.bound)
    obj.removeListener(event, listener);

  this.bound.length = 0;
  this.startTime = -1;

  await this.workers.close();
  await this.logger.close();
};

/**
 * Bind to an event on `obj`, save listener for removal.
 * @private
 * @param {EventEmitter} obj
 * @param {String} event
 * @param {Function} listener
 */

Node.prototype.bind = function bind(obj, event, listener) {
  this.bound.push([obj, event, listener]);
  obj.on(event, listener);
};

/**
 * Emit and log an error.
 * @private
 * @param {Error} err
 */

Node.prototype.error = function error(err) {
  this.logger.error(err);
  this.emit('error', err);
};

/**
 * Get node uptime in seconds.
 * @returns {Number}
 */

Node.prototype.uptime = function uptime() {
  if (this.startTime === -1)
    return 0;

  return util.now() - this.startTime;
};

/**
 * Attach a plugin.
 * @param {Object} plugin
 * @returns {Object} Plugin instance.
 */

Node.prototype.use = function use(plugin) {
  assert(plugin, 'Plugin must be an object.');
  assert(typeof plugin.init === 'function', '`init` must be a function.');

  assert(!this.loaded, 'Cannot add plugin after node is loaded.');

  const instance = plugin.init(this);

  assert(!instance.open || typeof instance.open === 'function',
    '`open` must be a function.');
  assert(!instance.close || typeof instance.close === 'function',
    '`close` must be a function.');

  if (plugin.id) {
    assert(typeof plugin.id === 'string', '`id` must be a string.');

    // Reserved names
    switch (plugin.id) {
      case 'chain':
      case 'fees':
      case 'mempool':
      case 'miner':
      case 'pool':
      case 'rpc':
      case 'http':
        assert(false, `${plugin.id} is already added.`);
        break;
    }

    assert(!this.plugins[plugin.id], `${plugin.id} is already added.`);

    this.plugins[plugin.id] = instance;
  }

  this.stack.push(instance);

  if (typeof instance.on === 'function')
    instance.on('error', err => this.error(err));

  return instance;
};

/**
 * Test whether a plugin is available.
 * @param {String} name
 * @returns {Boolean}
 */

Node.prototype.has = function has(name) {
  return this.plugins[name] != null;
};

/**
 * Get a plugin.
 * @param {String} name
 * @returns {Object|null}
 */

Node.prototype.get = function get(name) {
  assert(typeof name === 'string', 'Plugin name must be a string.');

  // Reserved names.
  switch (name) {
    case 'chain':
      assert(this.chain, 'chain is not loaded.');
      return this.chain;
    case 'fees':
      assert(this.fees, 'fees is not loaded.');
      return this.fees;
    case 'mempool':
      assert(this.mempool, 'mempool is not loaded.');
      return this.mempool;
    case 'miner':
      assert(this.miner, 'miner is not loaded.');
      return this.miner;
    case 'pool':
      assert(this.pool, 'pool is not loaded.');
      return this.pool;
    case 'rpc':
      assert(this.rpc, 'rpc is not loaded.');
      return this.rpc;
    case 'http':
      assert(this.http, 'http is not loaded.');
      return this.http;
  }

  return this.plugins[name] || null;
};

/**
 * Require a plugin.
 * @param {String} name
 * @returns {Object}
 * @throws {Error} on onloaded plugin
 */

Node.prototype.require = function require(name) {
  const plugin = this.get(name);
  assert(plugin, `${name} is not loaded.`);
  return plugin;
};

/**
 * Load plugins.
 * @private
 */

Node.prototype.loadPlugins = function loadPlugins() {
  const plugins = this.config.array('plugins', []);
  const loader = this.config.func('loader');

  for (let plugin of plugins) {
    if (typeof plugin === 'string') {
      assert(loader, 'Must pass a loader function.');
      plugin = loader(plugin);
    }
    this.use(plugin);
  }
};

/**
 * Open plugins.
 * @private
 */

Node.prototype.openPlugins = async function openPlugins() {
  for (const plugin of this.stack) {
    if (plugin.open)
      await plugin.open();
  }
};

/**
 * Close plugins.
 * @private
 */

Node.prototype.closePlugins = async function closePlugins() {
  for (const plugin of this.stack) {
    if (plugin.close)
      await plugin.close();
  }
};

/*
 * Expose
 */

module.exports = Node;


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * mappedlock.js - lock and queue for wmcc_core.
 */



const assert = __webpack_require__(0);

/**
 * Represents a mutex lock for locking asynchronous object methods.
 * Locks methods according to passed-in key.
 * @alias module:utils.MappedLock
 * @constructor
 */

function MappedLock() {
  if (!(this instanceof MappedLock))
    return MappedLock.create();

  this.jobs = new Map();
  this.busy = new Set();
  this.destroyed = false;
}

/**
 * Create a closure scoped lock.
 * @returns {Function} Lock method.
 */

MappedLock.create = function create() {
  const lock = new MappedLock();
  return function _lock(key, force) {
    return lock.lock(key, force);
  };
};

/**
 * Test whether the lock has a pending
 * job or a job in progress (by name).
 * @param {String} name
 * @returns {Boolean}
 */

MappedLock.prototype.has = function has(name) {
  return this.busy.has(name);
};

/**
 * Test whether the lock has
 * a pending job by name.
 * @param {String} name
 * @returns {Boolean}
 */

MappedLock.prototype.hasPending = function hasPending(name) {
  return this.jobs.has(name);
};

/**
 * Lock the parent object and all its methods
 * which use the lock with a specified key.
 * Begin to queue calls.
 * @param {String|Number} key
 * @param {Boolean?} force - Force a call.
 * @returns {Promise} - Returns {Function}, must be
 * called once the method finishes executing in order
 * to resolve the queue.
 */

MappedLock.prototype.lock = function lock(key, force) {
  if (this.destroyed)
    return Promise.reject(new Error('Lock is destroyed.'));

  if (key == null)
    return Promise.resolve(nop);

  if (force) {
    assert(this.busy.has(key));
    return Promise.resolve(nop);
  }

  if (this.busy.has(key)) {
    return new Promise((resolve, reject) => {
      if (!this.jobs.has(key))
        this.jobs.set(key, []);
      this.jobs.get(key).push(new Job(resolve, reject));
    });
  }

  this.busy.add(key);

  return Promise.resolve(this.unlock(key));
};

/**
 * Create an unlock callback.
 * @private
 * @param {String} key
 * @returns {Function} Unlocker.
 */

MappedLock.prototype.unlock = function unlock(key) {
  const self = this;
  return function unlocker() {
    const jobs = self.jobs.get(key);

    assert(self.destroyed || self.busy.has(key));
    self.busy.delete(key);

    if (!jobs)
      return;

    assert(!self.destroyed);

    const job = jobs.shift();
    assert(job);

    if (jobs.length === 0)
      self.jobs.delete(key);

    self.busy.add(key);

    job.resolve(unlocker);
  };
};

/**
 * Destroy the lock. Purge all pending calls.
 */

MappedLock.prototype.destroy = function destroy() {
  assert(!this.destroyed, 'Lock is already destroyed.');

  const map = this.jobs;

  this.destroyed = true;

  this.jobs = new Map();
  this.busy = new Map();

  for (const jobs of map.values()) {
    for (const job of jobs)
      job.reject(new Error('Lock was destroyed.'));
  }
};

/**
 * Lock Job
 * @constructor
 * @ignore
 * @param {Function} resolve
 * @param {Function} reject
 */

function Job(resolve, reject) {
  this.resolve = resolve;
  this.reject = reject;
}

/*
 * Helpers
 */

function nop() {}

/*
 * Expose
 */

module.exports = MappedLock;


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * account.js - account object for wmcc_core.
 */



const util = __webpack_require__(1);
const assert = __webpack_require__(0);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const encoding = __webpack_require__(3);
const Path = __webpack_require__(76);
const common = __webpack_require__(61);
const Script = __webpack_require__(8);
const WalletKey = __webpack_require__(128);
const HD = __webpack_require__(107);

/**
 * Represents a BIP44 Account belonging to a {@link Wallet}.
 * Note that this object does not enforce locks. Any method
 * that does a write is internal API only and will lead
 * to race conditions if used elsewhere.
 * @alias module:wallet.Account
 * @constructor
 * @param {Object} options
 * @param {WalletDB} options.db
 * @param {HDPublicKey} options.accountKey
 * @param {Boolean?} options.witness - Whether to use witness programs.
 * @param {Number} options.accountIndex - The BIP44 account index.
 * @param {Number?} options.receiveDepth - The index of the _next_ receiving
 * address.
 * @param {Number?} options.changeDepth - The index of the _next_ change
 * address.
 * @param {String?} options.type - Type of wallet (pubkeyhash, multisig)
 * (default=pubkeyhash).
 * @param {Number?} options.m - `m` value for multisig.
 * @param {Number?} options.n - `n` value for multisig.
 * @param {String?} options.wid - Wallet ID
 * @param {String?} options.name - Account name
 */

function Account(db, options) {
  if (!(this instanceof Account))
    return new Account(db, options);

  assert(db, 'Database is required.');

  this.db = db;
  this.network = db.network;
  this.wallet = null;

  this.receive = null;
  this.change = null;
  this.nested = null;

  this.wid = 0;
  this.id = null;
  this.name = null;
  this.initialized = false;
  this.witness = this.db.options.witness === true;
  this.watchOnly = false;
  this.type = Account.types.PUBKEYHASH;
  this.m = 1;
  this.n = 1;
  this.accountIndex = 0;
  this.receiveDepth = 0;
  this.changeDepth = 0;
  this.nestedDepth = 0;
  this.lookahead = 0;
  this.accountKey = null;
  this.keys = [];

  if (options)
    this.fromOptions(options);
}

/**
 * Account types.
 * @enum {Number}
 * @default
 */

Account.types = {
  PUBKEYHASH: 0,
  MULTISIG: 1
};

/**
 * Account types by value.
 * @const {RevMap}
 */

Account.typesByVal = {
  0: 'pubkeyhash',
  1: 'multisig'
};

/**
 * Inject properties from options object.
 * @private
 * @param {Object} options
 */

Account.prototype.fromOptions = function fromOptions(options) {
  assert(options, 'Options are required.');
  assert(util.isU32(options.wid));
  assert(common.isName(options.id), 'Bad Wallet ID.');
  assert(HD.isHD(options.accountKey), 'Account key is required.');
  assert(util.isU32(options.accountIndex), 'Account index is required.');

  this.wid = options.wid;
  this.id = options.id;

  if (options.name != null) {
    assert(common.isName(options.name), 'Bad account name.');
    this.name = options.name;
  }

  if (options.initialized != null) {
    assert(typeof options.initialized === 'boolean');
    this.initialized = options.initialized;
  }

  if (options.witness != null) {
    assert(typeof options.witness === 'boolean');
    this.witness = options.witness;
  }

  if (options.watchOnly != null) {
    assert(typeof options.watchOnly === 'boolean');
    this.watchOnly = options.watchOnly;
  }

  if (options.type != null) {
    if (typeof options.type === 'string') {
      this.type = Account.types[options.type.toUpperCase()];
      assert(this.type != null);
    } else {
      assert(typeof options.type === 'number');
      this.type = options.type;
      assert(Account.typesByVal[this.type]);
    }
  }

  if (options.m != null) {
    assert(util.isU8(options.m));
    this.m = options.m;
  }

  if (options.n != null) {
    assert(util.isU8(options.n));
    this.n = options.n;
  }

  if (options.accountIndex != null) {
    assert(util.isU32(options.accountIndex));
    this.accountIndex = options.accountIndex;
  }

  if (options.receiveDepth != null) {
    assert(util.isU32(options.receiveDepth));
    this.receiveDepth = options.receiveDepth;
  }

  if (options.changeDepth != null) {
    assert(util.isU32(options.changeDepth));
    this.changeDepth = options.changeDepth;
  }

  if (options.nestedDepth != null) {
    assert(util.isU32(options.nestedDepth));
    this.nestedDepth = options.nestedDepth;
  }

  if (options.lookahead != null) {
    assert(util.isU32(options.lookahead));
    assert(options.lookahead >= 0);
    assert(options.lookahead <= Account.MAX_LOOKAHEAD);
    this.lookahead = options.lookahead;
  }

  this.accountKey = options.accountKey;

  if (this.n > 1)
    this.type = Account.types.MULTISIG;

  if (!this.name)
    this.name = this.accountIndex.toString(10);

  if (this.m < 1 || this.m > this.n)
    throw new Error('m ranges between 1 and n');

  if (options.keys) {
    assert(Array.isArray(options.keys));
    for (const key of options.keys)
      this.pushKey(key);
  }

  return this;
};

/**
 * Instantiate account from options.
 * @param {WalletDB} db
 * @param {Object} options
 * @returns {Account}
 */

Account.fromOptions = function fromOptions(db, options) {
  return new Account(db).fromOptions(options);
};

/*
 * Default address lookahead.
 * @const {Number}
 */

Account.MAX_LOOKAHEAD = 40;

/**
 * Attempt to intialize the account (generating
 * the first addresses along with the lookahead
 * addresses). Called automatically from the
 * walletdb.
 * @returns {Promise}
 */

Account.prototype.init = async function init() {
  // Waiting for more keys.
  if (this.keys.length !== this.n - 1) {
    assert(!this.initialized);
    this.save();
    return;
  }

  assert(this.receiveDepth === 0);
  assert(this.changeDepth === 0);
  assert(this.nestedDepth === 0);

  this.initialized = true;

  await this.initDepth();
};

/**
 * Open the account (done after retrieval).
 * @returns {Promise}
 */

Account.prototype.open = function open() {
  if (!this.initialized)
    return Promise.resolve();

  if (this.receive)
    return Promise.resolve();

  this.receive = this.deriveReceive(this.receiveDepth - 1);
  this.change = this.deriveChange(this.changeDepth - 1);

  if (this.witness)
    this.nested = this.deriveNested(this.nestedDepth - 1);

  return Promise.resolve();
};

/**
 * Add a public account key to the account (multisig).
 * Does not update the database.
 * @param {HDPublicKey} key - Account (bip44)
 * key (can be in base58 form).
 * @throws Error on non-hdkey/non-accountkey.
 */

Account.prototype.pushKey = function pushKey(key) {
  if (typeof key === 'string')
    key = HD.PublicKey.fromBase58(key, this.network);

  assert(key.network === this.network,
    'Network mismatch for account key.');

  if (!HD.isPublic(key))
    throw new Error('Must add HD keys to wallet.');

  if (!key.isAccount())
    throw new Error('Must add HD account keys to BIP44 wallet.');

  if (this.type !== Account.types.MULTISIG)
    throw new Error('Cannot add keys to non-multisig wallet.');

  if (key.equals(this.accountKey))
    throw new Error('Cannot add own key.');

  const index = util.binaryInsert(this.keys, key, cmp, true);

  if (index === -1)
    return false;

  if (this.keys.length > this.n - 1) {
    util.binaryRemove(this.keys, key, cmp);
    throw new Error('Cannot add more keys.');
  }

  return true;
};

/**
 * Remove a public account key to the account (multisig).
 * Does not update the database.
 * @param {HDPublicKey} key - Account (bip44)
 * key (can be in base58 form).
 * @throws Error on non-hdkey/non-accountkey.
 */

Account.prototype.spliceKey = function spliceKey(key) {
  if (typeof key === 'string')
    key = HD.PublicKey.fromBase58(key, this.network);

  assert(key.network === this.network,
    'Network mismatch for account key.');

  if (!HD.isPublic(key))
    throw new Error('Must add HD keys to wallet.');

  if (!key.isAccount())
    throw new Error('Must add HD account keys to BIP44 wallet.');

  if (this.type !== Account.types.MULTISIG)
    throw new Error('Cannot remove keys from non-multisig wallet.');

  if (this.keys.length === this.n - 1)
    throw new Error('Cannot remove key.');

  return util.binaryRemove(this.keys, key, cmp);
};

/**
 * Add a public account key to the account (multisig).
 * Saves the key in the wallet database.
 * @param {HDPublicKey} key
 * @returns {Promise}
 */

Account.prototype.addSharedKey = async function addSharedKey(key) {
  const result = this.pushKey(key);

  if (await this.hasDuplicate()) {
    this.spliceKey(key);
    throw new Error('Cannot add a key from another account.');
  }

  // Try to initialize again.
  await this.init();

  return result;
};

/**
 * Ensure accounts are not sharing keys.
 * @private
 * @returns {Promise}
 */

Account.prototype.hasDuplicate = function hasDuplicate() {
  if (this.keys.length !== this.n - 1)
    return false;

  const ring = this.deriveReceive(0);
  const hash = ring.getScriptHash('hex');

  return this.wallet.hasAddress(hash);
};

/**
 * Remove a public account key from the account (multisig).
 * Remove the key from the wallet database.
 * @param {HDPublicKey} key
 * @returns {Promise}
 */

Account.prototype.removeSharedKey = function removeSharedKey(key) {
  const result = this.spliceKey(key);

  if (!result)
    return false;

  this.save();

  return true;
};

/**
 * Create a new receiving address (increments receiveDepth).
 * @returns {WalletKey}
 */

Account.prototype.createReceive = function createReceive() {
  return this.createKey(0);
};

/**
 * Create a new change address (increments receiveDepth).
 * @returns {WalletKey}
 */

Account.prototype.createChange = function createChange() {
  return this.createKey(1);
};

/**
 * Create a new change address (increments receiveDepth).
 * @returns {WalletKey}
 */

Account.prototype.createNested = function createNested() {
  return this.createKey(2);
};

/**
 * Create a new address (increments depth).
 * @param {Boolean} change
 * @returns {Promise} - Returns {@link WalletKey}.
 */

Account.prototype.createKey = async function createKey(branch) {
  let key, lookahead;

  switch (branch) {
    case 0:
      key = this.deriveReceive(this.receiveDepth);
      lookahead = this.deriveReceive(this.receiveDepth + this.lookahead);
      await this.saveKey(lookahead);
      this.receiveDepth++;
      this.receive = key;
      break;
    case 1:
      key = this.deriveChange(this.changeDepth);
      lookahead = this.deriveReceive(this.changeDepth + this.lookahead);
      await this.saveKey(lookahead);
      this.changeDepth++;
      this.change = key;
      break;
    case 2:
      key = this.deriveNested(this.nestedDepth);
      lookahead = this.deriveNested(this.nestedDepth + this.lookahead);
      await this.saveKey(lookahead);
      this.nestedDepth++;
      this.nested = key;
      break;
    default:
      throw new Error(`Bad branch: ${branch}.`);
  }

  this.save();

  return key;
};

/**
 * Derive a receiving address at `index`. Do not increment depth.
 * @param {Number} index
 * @returns {WalletKey}
 */

Account.prototype.deriveReceive = function deriveReceive(index, master) {
  return this.deriveKey(0, index, master);
};

/**
 * Derive a change address at `index`. Do not increment depth.
 * @param {Number} index
 * @returns {WalletKey}
 */

Account.prototype.deriveChange = function deriveChange(index, master) {
  return this.deriveKey(1, index, master);
};

/**
 * Derive a nested address at `index`. Do not increment depth.
 * @param {Number} index
 * @returns {WalletKey}
 */

Account.prototype.deriveNested = function deriveNested(index, master) {
  if (!this.witness)
    throw new Error('Cannot derive nested on non-witness account.');

  return this.deriveKey(2, index, master);
};

/**
 * Derive an address from `path` object.
 * @param {Path} path
 * @param {MasterKey} master
 * @returns {WalletKey}
 */

Account.prototype.derivePath = function derivePath(path, master) {
  switch (path.keyType) {
    case Path.types.HD: {
      return this.deriveKey(path.branch, path.index, master);
    }
    case Path.types.KEY: {
      assert(this.type === Account.types.PUBKEYHASH);

      let data = path.data;

      if (path.encrypted) {
        data = master.decipher(data, path.hash);
        if (!data)
          return null;
      }

      return WalletKey.fromImport(this, data);
    }
    case Path.types.ADDRESS: {
      return null;
    }
    default: {
      throw new Error('Bad key type.');
    }
  }
};

/**
 * Derive an address at `index`. Do not increment depth.
 * @param {Number} branch - Whether the address on the change branch.
 * @param {Number} index
 * @returns {WalletKey}
 */

Account.prototype.deriveKey = function deriveKey(branch, index, master) {
  assert(typeof branch === 'number');

  const keys = [];

  let key;
  if (master && master.key && !this.watchOnly) {
    key = master.key.deriveAccount(44, this.accountIndex);
    key = key.derive(branch).derive(index);
  } else {
    key = this.accountKey.derive(branch).derive(index);
  }

  const ring = WalletKey.fromHD(this, key, branch, index);

  switch (this.type) {
    case Account.types.PUBKEYHASH:
      break;
    case Account.types.MULTISIG:
      keys.push(key.publicKey);

      for (const shared of this.keys) {
        const key = shared.derive(branch).derive(index);
        keys.push(key.publicKey);
      }

      ring.script = Script.fromMultisig(this.m, this.n, keys);

      break;
  }

  return ring;
};

/**
 * Save the account to the database. Necessary
 * when address depth and keys change.
 * @returns {Promise}
 */

Account.prototype.save = function save() {
  return this.db.saveAccount(this);
};

/**
 * Save addresses to path map.
 * @param {WalletKey[]} rings
 * @returns {Promise}
 */

Account.prototype.saveKey = function saveKey(ring) {
  return this.db.saveKey(this.wallet, ring);
};

/**
 * Save paths to path map.
 * @param {Path[]} rings
 * @returns {Promise}
 */

Account.prototype.savePath = function savePath(path) {
  return this.db.savePath(this.wallet, path);
};

/**
 * Initialize address depths (including lookahead).
 * @returns {Promise}
 */

Account.prototype.initDepth = async function initDepth() {
  // Receive Address
  this.receive = this.deriveReceive(0);
  this.receiveDepth = 1;

  await this.saveKey(this.receive);

  // Lookahead
  for (let i = 0; i < this.lookahead; i++) {
    const key = this.deriveReceive(i + 1);
    await this.saveKey(key);
  }

  // Change Address
  this.change = this.deriveChange(0);
  this.changeDepth = 1;

  await this.saveKey(this.change);

  // Lookahead
  for (let i = 0; i < this.lookahead; i++) {
    const key = this.deriveChange(i + 1);
    await this.saveKey(key);
  }

  // Nested Address
  if (this.witness) {
    this.nested = this.deriveNested(0);
    this.nestedDepth = 1;

    await this.saveKey(this.nested);

    // Lookahead
    for (let i = 0; i < this.lookahead; i++) {
      const key = this.deriveNested(i + 1);
      await this.saveKey(key);
    }
  }

  this.save();
};

/**
 * Allocate new lookahead addresses if necessary.
 * @param {Number} receiveDepth
 * @param {Number} changeDepth
 * @param {Number} nestedDepth
 * @returns {Promise} - Returns {@link WalletKey}.
 */

Account.prototype.syncDepth = async function syncDepth(receive, change, nested) {
  let derived = false;
  let result = null;

  if (receive > this.receiveDepth) {
    const depth = this.receiveDepth + this.lookahead;

    assert(receive <= depth + 1);

    for (let i = depth; i < receive + this.lookahead; i++) {
      const key = this.deriveReceive(i);
      await this.saveKey(key);
    }

    this.receive = this.deriveReceive(receive - 1);
    this.receiveDepth = receive;

    derived = true;
    result = this.receive;
  }

  if (change > this.changeDepth) {
    const depth = this.changeDepth + this.lookahead;

    assert(change <= depth + 1);

    for (let i = depth; i < change + this.lookahead; i++) {
      const key = this.deriveChange(i);
      await this.saveKey(key);
    }

    this.change = this.deriveChange(change - 1);
    this.changeDepth = change;

    derived = true;
  }

  if (this.witness && nested > this.nestedDepth) {
    const depth = this.nestedDepth + this.lookahead;

    assert(nested <= depth + 1);

    for (let i = depth; i < nested + this.lookahead; i++) {
      const key = this.deriveNested(i);
      await this.saveKey(key);
    }

    this.nested = this.deriveNested(nested - 1);
    this.nestedDepth = nested;

    derived = true;
    result = this.nested;
  }

  if (derived)
    this.save();

  return result;
};

/**
 * Allocate new lookahead addresses.
 * @param {Number} lookahead
 * @returns {Promise}
 */

Account.prototype.setLookahead = async function setLookahead(lookahead) {
  if (lookahead === this.lookahead) {
    this.db.logger.warning(
      'Lookahead is not changing for: %s/%s.',
      this.id, this.name);
    return;
  }

  if (lookahead < this.lookahead) {
    const diff = this.lookahead - lookahead;

    this.receiveDepth += diff;
    this.receive = this.deriveReceive(this.receiveDepth - 1);

    this.changeDepth += diff;
    this.change = this.deriveChange(this.changeDepth - 1);

    if (this.witness) {
      this.nestedDepth += diff;
      this.nested = this.deriveNested(this.nestedDepth - 1);
    }

    this.lookahead = lookahead;

    this.save();

    return;
  }

  {
    const depth = this.receiveDepth + this.lookahead;
    const target = this.receiveDepth + lookahead;

    for (let i = depth; i < target; i++) {
      const key = this.deriveReceive(i);
      await this.saveKey(key);
    }
  }

  {
    const depth = this.changeDepth + this.lookahead;
    const target = this.changeDepth + lookahead;

    for (let i = depth; i < target; i++) {
      const key = this.deriveChange(i);
      await this.saveKey(key);
    }
  }

  if (this.witness) {
    const depth = this.nestedDepth + this.lookahead;
    const target = this.nestedDepth + lookahead;

    for (let i = depth; i < target; i++) {
      const key = this.deriveNested(i);
      await this.saveKey(key);
    }
  }

  this.lookahead = lookahead;
  this.save();
};

/**
 * Get current receive address.
 * @param {String?} enc - `"base58"` or `null`.
 * @returns {Address|Base58Address}
 */

Account.prototype.getAddress = function getAddress(enc) {
  return this.getReceive(enc);
};

/**
 * Get current receive address.
 * @param {String?} enc - `"base58"` or `null`.
 * @returns {Address|Base58Address}
 */

Account.prototype.getReceive = function getReceive(enc) {
  if (!this.receive)
    return null;
  return this.receive.getAddress(enc);
};

/**
 * Get current change address.
 * @param {String?} enc - `"base58"` or `null`.
 * @returns {Address|Base58Address}
 */

Account.prototype.getChange = function getChange(enc) {
  if (!this.change)
    return null;

  return this.change.getAddress(enc);
};

/**
 * Get current nested address.
 * @param {String?} enc - `"base58"` or `null`.
 * @returns {Address|Base58Address}
 */

Account.prototype.getNested = function getNested(enc) {
  if (!this.nested)
    return null;

  return this.nested.getAddress(enc);
};

/**
 * Get unsave receive address.
 * @param {String?} enc - `"base58"` or `null`.
 * @returns {Address|Base58Address}
 */

Account.prototype.getTempReceive = function getTempReceive(enc) {
  const receive = this.deriveReceive(this.receiveDepth);
  return receive.getAddress(enc);
};

/**
 * Convert the account to a more inspection-friendly object.
 * @returns {Object}
 */

Account.prototype.inspect = function inspect() {
  return {
    wid: this.wid,
    name: this.name,
    network: this.network,
    initialized: this.initialized,
    witness: this.witness,
    watchOnly: this.watchOnly,
    type: Account.typesByVal[this.type].toLowerCase(),
    m: this.m,
    n: this.n,
    accountIndex: this.accountIndex,
    receiveDepth: this.receiveDepth,
    changeDepth: this.changeDepth,
    nestedDepth: this.nestedDepth,
    lookahead: this.lookahead,
    address: this.initialized
      ? this.receive.getAddress()
      : null,
    nestedAddress: this.initialized && this.nested
      ? this.nested.getAddress()
      : null,
    accountKey: this.accountKey.toBase58(),
    keys: this.keys.map((key) => {
      return key.toBase58();
    })
  };
};

/**
 * Convert the account to an object suitable for
 * serialization.
 * @returns {Object}
 */

Account.prototype.toJSON = function toJSON(minimal) {
  return {
    wid: minimal ? undefined : this.wid,
    id: minimal ? undefined : this.id,
    name: this.name,
    initialized: this.initialized,
    witness: this.witness,
    watchOnly: this.watchOnly,
    type: Account.typesByVal[this.type].toLowerCase(),
    m: this.m,
    n: this.n,
    accountIndex: this.accountIndex,
    receiveDepth: this.receiveDepth,
    changeDepth: this.changeDepth,
    nestedDepth: this.nestedDepth,
    lookahead: this.lookahead,
    receiveAddress: this.receive
      ? this.receive.getAddress('string')
      : null,
    nestedAddress: this.nested
      ? this.nested.getAddress('string')
      : null,
    changeAddress: this.change
      ? this.change.getAddress('string')
      : null,
    accountKey: this.accountKey.toBase58(),
    keys: this.keys.map((key) => {
      return key.toBase58();
    })
  };
};

/**
 * Calculate serialization size.
 * @returns {Number}
 */

Account.prototype.getSize = function getSize() {
  let size = 0;
  size += encoding.sizeVarString(this.name, 'ascii');
  size += 105;
  size += this.keys.length * 82;
  return size;
};

/**
 * Serialize the account.
 * @returns {Buffer}
 */

Account.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  const bw = new StaticWriter(size);

  bw.writeVarString(this.name, 'ascii');
  bw.writeU8(this.initialized ? 1 : 0);
  bw.writeU8(this.witness ? 1 : 0);
  bw.writeU8(this.type);
  bw.writeU8(this.m);
  bw.writeU8(this.n);
  bw.writeU32(this.accountIndex);
  bw.writeU32(this.receiveDepth);
  bw.writeU32(this.changeDepth);
  bw.writeU32(this.nestedDepth);
  bw.writeU8(this.lookahead);
  bw.writeBytes(this.accountKey.toRaw());
  bw.writeU8(this.keys.length);

  for (const key of this.keys)
    bw.writeBytes(key.toRaw());

  return bw.render();
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 * @returns {Object}
 */

Account.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data);

  this.name = br.readVarString('ascii');
  this.initialized = br.readU8() === 1;
  this.witness = br.readU8() === 1;
  this.type = br.readU8();
  this.m = br.readU8();
  this.n = br.readU8();
  this.accountIndex = br.readU32();
  this.receiveDepth = br.readU32();
  this.changeDepth = br.readU32();
  this.nestedDepth = br.readU32();
  this.lookahead = br.readU8();
  this.accountKey = HD.PublicKey.fromRaw(br.readBytes(82));

  assert(Account.typesByVal[this.type]);

  const count = br.readU8();

  for (let i = 0; i < count; i++) {
    const key = HD.PublicKey.fromRaw(br.readBytes(82));
    this.pushKey(key);
  }

  return this;
};

/**
 * Instantiate a account from serialized data.
 * @param {WalletDB} data
 * @param {Buffer} data
 * @returns {Account}
 */

Account.fromRaw = function fromRaw(db, data) {
  return new Account(db).fromRaw(data);
};

/**
 * Test an object to see if it is a Account.
 * @param {Object} obj
 * @returns {Boolean}
 */

Account.isAccount = function isAccount(obj) {
  return obj instanceof Account;
};

/*
 * Helpers
 */

function cmp(a, b) {
  return a.compare(b);
}

/*
 * Expose
 */

module.exports = Account;


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * layout.js - data layout for wallets.
 */



const assert = __webpack_require__(0);
const layouts = exports;

/*
 * Wallet Database Layout:
 *  p[addr-hash] -> wallet ids
 *  P[wid][addr-hash] -> path data
 *  r[wid][index][hash] -> path account index
 *  w[wid] -> wallet
 *  l[id] -> wid
 *  a[wid][index] -> account
 *  i[wid][name] -> account index
 *  n[wid][index] -> account name
 *  t[wid]* -> txdb
 *  R -> chain sync state
 *  h[height] -> recent block hash
 *  b[height] -> block->wid map
 *  o[hash][index] -> outpoint->wid map
 */

layouts.walletdb = {
  binary: true,
  p: function p(hash) {
    assert(typeof hash === 'string');
    const key = Buffer.allocUnsafe(1 + (hash.length / 2));
    key[0] = 0x70;
    key.write(hash, 1, 'hex');
    return key;
  },
  pp: function pp(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length >= 21);
    return key.toString('hex', 1);
  },
  P: function P(wid, hash) {
    assert(typeof wid === 'number');
    assert(typeof hash === 'string');
    const key = Buffer.allocUnsafe(1 + 4 + (hash.length / 2));
    key[0] = 0x50;
    key.writeUInt32BE(wid, 1, true);
    key.write(hash, 5, 'hex');
    return key;
  },
  Pp: function Pp(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length >= 25);
    return key.toString('hex', 5);
  },
  r: function r(wid, index, hash) {
    assert(typeof wid === 'number');
    assert(typeof index === 'number');
    assert(typeof hash === 'string');
    const key = Buffer.allocUnsafe(1 + 4 + 4 + (hash.length / 2));
    key[0] = 0x72;
    key.writeUInt32BE(wid, 1, true);
    key.writeUInt32BE(index, 5, true);
    key.write(hash, 9, 'hex');
    return key;
  },
  rr: function rr(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length >= 29);
    return key.toString('hex', 9);
  },
  w: function w(wid) {
    assert(typeof wid === 'number');
    const key = Buffer.allocUnsafe(5);
    key[0] = 0x77;
    key.writeUInt32BE(wid, 1, true);
    return key;
  },
  ww: function ww(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length === 5);
    return key.readUInt32BE(1, true);
  },
  l: function l(id) {
    assert(typeof id === 'string');
    const len = Buffer.byteLength(id, 'ascii');
    const key = Buffer.allocUnsafe(1 + len);
    key[0] = 0x6c;
    if (len > 0)
      key.write(id, 1, 'ascii');
    return key;
  },
  ll: function ll(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length >= 1);
    return key.toString('ascii', 1);
  },
  a: function a(wid, index) {
    assert(typeof wid === 'number');
    assert(typeof index === 'number');
    const key = Buffer.allocUnsafe(9);
    key[0] = 0x61;
    key.writeUInt32BE(wid, 1, true);
    key.writeUInt32BE(index, 5, true);
    return key;
  },
  i: function i(wid, name) {
    assert(typeof wid === 'number');
    assert(typeof name === 'string');
    const len = Buffer.byteLength(name, 'ascii');
    const key = Buffer.allocUnsafe(5 + len);
    key[0] = 0x69;
    key.writeUInt32BE(wid, 1, true);
    if (len > 0)
      key.write(name, 5, 'ascii');
    return key;
  },
  ii: function ii(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length >= 5);
    return [key.readUInt32BE(1, true), key.toString('ascii', 5)];
  },
  n: function n(wid, index) {
    assert(typeof wid === 'number');
    assert(typeof index === 'number');
    const key = Buffer.allocUnsafe(9);
    key[0] = 0x6e;
    key.writeUInt32BE(wid, 1, true);
    key.writeUInt32BE(index, 5, true);
    return key;
  },
  R: Buffer.from([0x52]),
  h: function h(height) {
    assert(typeof height === 'number');
    const key = Buffer.allocUnsafe(5);
    key[0] = 0x68;
    key.writeUInt32BE(height, 1, true);
    return key;
  },
  b: function b(height) {
    assert(typeof height === 'number');
    const key = Buffer.allocUnsafe(5);
    key[0] = 0x62;
    key.writeUInt32BE(height, 1, true);
    return key;
  },
  bb: function bb(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length === 5);
    return key.readUInt32BE(1, true);
  },
  o: function o(hash, index) {
    assert(typeof hash === 'string');
    assert(typeof index === 'number');
    const key = Buffer.allocUnsafe(37);
    key[0] = 0x6f;
    key.write(hash, 1, 'hex');
    key.writeUInt32BE(index, 33, true);
    return key;
  },
  oo: function oo(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length === 37);
    return [key.toString('hex', 1, 33), key.readUInt32BE(33, true)];
  }
};

/*
 * TXDB Database Layout:
 *   t[hash] -> extended tx
 *   c[hash][index] -> coin
 *   d[hash][index] -> undo coin
 *   s[hash][index] -> spent by hash
 *   o[hash][index] -> orphan inputs
 *   p[hash] -> dummy (pending flag)
 *   m[time][hash] -> dummy (tx by time)
 *   h[height][hash] -> dummy (tx by height)
 *   T[account][hash] -> dummy (tx by account)
 *   P[account][hash] -> dummy (pending tx by account)
 *   M[account][time][hash] -> dummy (tx by time + account)
 *   H[account][height][hash] -> dummy (tx by height + account)
 *   C[account][hash][index] -> dummy (coin by account)
 *   r[hash] -> dummy (replace by fee chain)
 */

layouts.txdb = {
  binary: true,
  prefix: function prefix(wid, key) {
    assert(typeof wid === 'number');
    assert(Buffer.isBuffer(key));
    const out = Buffer.allocUnsafe(5 + key.length);
    out[0] = 0x74;
    out.writeUInt32BE(wid, 1);
    key.copy(out, 5);
    return out;
  },
  pre: function pre(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length >= 5);
    return key.readUInt32BE(1, true);
  },
  R: Buffer.from([0x52]),
  hi: function hi(ch, hash, index) {
    assert(typeof hash === 'string');
    assert(typeof index === 'number');
    const key = Buffer.allocUnsafe(37);
    key[0] = ch;
    key.write(hash, 1, 'hex');
    key.writeUInt32BE(index, 33, true);
    return key;
  },
  hii: function hii(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length - 5 === 37);
    key = key.slice(6);
    return [key.toString('hex', 0, 32), key.readUInt32BE(32, true)];
  },
  ih: function ih(ch, index, hash) {
    assert(typeof index === 'number');
    assert(typeof hash === 'string');
    const key = Buffer.allocUnsafe(37);
    key[0] = ch;
    key.writeUInt32BE(index, 1, true);
    key.write(hash, 5, 'hex');
    return key;
  },
  ihh: function ihh(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length - 5 === 37);
    key = key.slice(6);
    return [key.readUInt32BE(0, true), key.toString('hex', 4, 36)];
  },
  iih: function iih(ch, index, num, hash) {
    assert(typeof index === 'number');
    assert(typeof num === 'number');
    assert(typeof hash === 'string');
    const key = Buffer.allocUnsafe(41);
    key[0] = ch;
    key.writeUInt32BE(index, 1, true);
    key.writeUInt32BE(num, 5, true);
    key.write(hash, 9, 'hex');
    return key;
  },
  iihh: function iihh(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length - 5 === 41);
    key = key.slice(6);
    return [
      key.readUInt32BE(0, true),
      key.readUInt32BE(4, true),
      key.toString('hex', 8, 40)
    ];
  },
  ihi: function ihi(ch, index, hash, num) {
    assert(typeof index === 'number');
    assert(typeof hash === 'string');
    assert(typeof num === 'number');
    const key = Buffer.allocUnsafe(41);
    key[0] = ch;
    key.writeUInt32BE(index, 1, true);
    key.write(hash, 5, 'hex');
    key.writeUInt32BE(num, 37, true);
    return key;
  },
  ihii: function ihii(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length - 5 === 41);
    key = key.slice(6);
    return [
      key.readUInt32BE(0, true),
      key.toString('hex', 4, 36),
      key.readUInt32BE(36, true)
    ];
  },
  ha: function ha(ch, hash) {
    assert(typeof hash === 'string');
    const key = Buffer.allocUnsafe(33);
    key[0] = ch;
    key.write(hash, 1, 'hex');
    return key;
  },
  haa: function haa(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length - 5 === 33);
    key = key.slice(6);
    return key.toString('hex', 0);
  },
  t: function t(hash) {
    return this.ha(0x74, hash);
  },
  tt: function tt(key) {
    return this.haa(key);
  },
  c: function c(hash, index) {
    return this.hi(0x63, hash, index);
  },
  cc: function cc(key) {
    return this.hii(key);
  },
  d: function d(hash, index) {
    return this.hi(0x64, hash, index);
  },
  dd: function dd(key) {
    return this.hii(key);
  },
  s: function s(hash, index) {
    return this.hi(0x73, hash, index);
  },
  ss: function ss(key) {
    return this.hii(key);
  },
  p: function p(hash) {
    return this.ha(0x70, hash);
  },
  pp: function pp(key) {
    return this.haa(key);
  },
  m: function m(time, hash) {
    return this.ih(0x6d, time, hash);
  },
  mm: function mm(key) {
    return this.ihh(key);
  },
  h: function h(height, hash) {
    return this.ih(0x68, height, hash);
  },
  hh: function hh(key) {
    return this.ihh(key);
  },
  T: function T(account, hash) {
    return this.ih(0x54, account, hash);
  },
  Tt: function Tt(key) {
    return this.ihh(key);
  },
  P: function P(account, hash) {
    return this.ih(0x50, account, hash);
  },
  Pp: function Pp(key) {
    return this.ihh(key);
  },
  M: function M(account, time, hash) {
    return this.iih(0x4d, account, time, hash);
  },
  Mm: function Mm(key) {
    return this.iihh(key);
  },
  H: function H(account, height, hash) {
    return this.iih(0x48, account, height, hash);
  },
  Hh: function Hh(key) {
    return this.iihh(key);
  },
  C: function C(account, hash, index) {
    return this.ihi(0x43, account, hash, index);
  },
  Cc: function Cc(key) {
    return this.ihii(key);
  },
  r: function r(hash) {
    return this.ha(0x72, hash);
  },
  b: function b(height) {
    assert(typeof height === 'number');
    const key = Buffer.allocUnsafe(5);
    key[0] = 0x62;
    key.writeUInt32BE(height, 1, true);
    return key;
  },
  bb: function bb(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length - 5 === 5);
    key = key.slice(6);
    return key.readUInt32BE(0, true);
  }
};


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = [
  'ebd41040e4bb3ec742c9e381d31ef2a41a48b6685c96e7cef3c1df6cd4331c99',
  'ca42dd41745fd0b81eb902362cf9d8bf719da1bd1b1efc946f5b4c99f42c1b9e',
  'eb04cf5eb1f39afa762f2bb120f296cba520c1b97db1589565b81cb9a17b7244',
  '6dc47172e01cbcb0bf62580d895fe2b8ac9ad4f873801e0c10b9c837d21eb177',
  '16af57a9f676b0ab126095aa5ebadef22ab31119d644ac95cd4b93dbf3f26aeb',
  '8c7209279ac04e275e16d07fd3b775e80154b5968046e31f52dd25766324e9a7',
  '687fa451382278fff0c8b11f8d43d576671c6eb2bceab413fb83d965d06d2ff2',
  '0791ca0749b20782aad3c7d7bd0cdfc9485835843eb2d7996009ce43ab6c6927',
  '8095210805db4bbc355e4428d8fd6ec2cde3ab5fb97a9942988eb8f4dcd06016',
  '73c176434f1bc6d5adf45b0e76e727287c8de57616c1e6e6141a2b2cbc7d8e4c',
  'af8b6762a1e528228161a95d5c559ee266278f75d79e830189a503506abd6b4c',
  'ff856a2d251dcd88d36656f450126798cfabaade40799c722de4d2b5db36a73a',
  'ca2d82a08677072f8ab6764ff035676cfe3e5e325e012172df3f92096db79b85',
  'a0459b9f63b22559f5fa5d4c6db3f9f72ff19342033578f073bf1d1b46cbb912',
  'a0234f3bc8527ca5628eec81ad5d69895da5680dc91d1cb8477f33f878b95b0b',
  '69fac9bd55fb0ac78d53bbee5cf1d597989fd0aaab20a25151bdf1733ee7d122',
  'd8e0febc1db2e38d00940f37d27d41344d993e734b99d5656d9778d4d8143624',
  'd7a7a0fb5d7e2731d771e9484ebcdef71d5f0c3e0a2948782bc83ee0ea699ef4',
  'bd81ce3b4f6591d11a67b5fc7a47fdef25521bf9aa4e18b9e3df2e34a7803be8',
  '3f06e55681d496f5be169eb5389f9f2b8ff61e1708df6881724849cd5d27cb69',
  'a45ede3bbbf09c8ae15c72efc07268d693a21c996fd51e67ca079460fd6d8873',
  '85a0dd7dd720adb7ff05f83d542b209dc7ff4528f7d677b18389fea5e5c49e86',
  '18f1fc7f205df8adddeb7fe007dd57e3af375a9c4d8d73546bf4f1fed1e18d35',
  'e75e72ed9f560eec6eb4800073a43fc3ad19195a392282017895974a99026b6c',
  '7908b40314c138100b518d0735807ffbfcf8518a0095337105ba386b153dd927',
  '6ea54741d004667eed1b4816634aa3a79e6e4b96950f8279dafc8d9bd8812137',
  '0c258a12a5674aef25f28ba7dcfaeceea348e541e6f5cc4ee63b71b361606ac3',
  'ef3cb417fc8ebf6f97876c9e4ece39de1ea5fe649141d1028b7d11c0b2298ced',
  'cecddc905099d8dadfc5b1d209b737cbe2c18cfb2c10c0ff0bcf0d3286fc1aa2',
  'c3846bf24b9e93ca64274c0ec67c1ecc5e024ffcacd2d74019350e81fe546ae4',
  '1465fa205397b876faa6f0a9958e5590e40fcc7faa4fb7c2c8677521fb5fb658',
  'c766a9bef2d4071c863a31aa4920e813b2d198608cb7b7cfe21143b836df09ea',
  '7600295eefe85b9e1fd624db76062aaaae59818a54d2774cd4c0b2c01131e1b3',
  '21db20123660bb2ed418205da11ee7a85a65e2bc6e55b5af7e7899c8a266d92e',
  '3e9099b5015e8f486c00bcea9d111ee721faba355a89bcf1df69561e3dc6325c',
  '4348a0e9444c78cb265e058d5e8944b4d84f9662bd26db257f8934a443c70161',
  '7431e5f4c3c1ce4690774f0b61e05440883ba9a01ed00ba6abd7806ed3b118cf',
  '0f993c8aef97baaf5687140ed59ad1821bb4afacf0aa9a58b5d57a338a3afbcb',
  '0687260331a72403d909f105e69bcf0d32e1bd2493ffc6d9206d11bcd6770739',
  '767c955a76412c89af688e90a1c70f556cfd6b6025dbea10416d7eb6831f8c40',
  '62dd0be9b9f50a163ea0f8e75c053b1eca57ea55c8688f647c6881f2c8357b95',
  'be6c4da2bbb9ba59b6f3939768374246c3c005993fa98f020d1dedbed48a81d5',
  '37d51006c512eaab626421f1ec8c92013fc5f82ae98ee533eb4619b8deb4d06c',
  '8d722f81a9c113c0791df136a2966db26c950a971db46b4199f4ea54b78bfb9f',
  '9acfab7e43c8d880d06b262a94deeee4b4659989c3d0caf19baf6405e41ab7df',
  'f1c1b50ae5a20dd8030ec9f6bc24823dd367b5255759b4e71b61fce9f7375d73',
  '4200f5043ac8590ebb527d209ed1503029fbcbd41ca1b506ec27f15ade7dac69',
  '0c2cd63df7806fa399ede809116b575bf87989f06518f9808c860503178baf66',
  '15f0ba00a3ac7af3ac884c072b1011a077bd77c097f40164b2f8598abd83860c',
  'a71272aeaaa3cfe8727f7fb39f0fb3d1e5426e9060b06ee6f13e9a3c5833cd43',
  '1793927a0614549789adce2f8f34f7f0b66d0f3ae3a3b84d21ec15dbba4fadc7',
  'b9bea7860a962ea3611dab97ab6da3e21c1068b97d55575ed0e11279c11c8932',
  'a22dba681e97376e2d397d728aae3a9b6296b9fdba60bc2e11f647f2c675fb37',
  '41c923866ab4cad6b7ad578081582e020797a6cbdf4fff78ce8396b38937d7f5',
  '327a3d761abadea034eb998406275cb1a4776efdae2fdf6d0168ea1c4f5567d0',
  'e3b6a2db2ed7ce48842f7ac53241c7b71d54144bfb40c11f3f1d0b42f5eea12d',
  'b6191a50d0c3977f7da99bcdaac86a227daeb9679ec70ba3b0c9d92271c170d3',
  '960adf0063e96356750c2965dd0a0867da0b9cbd6e77714aeafb2349ab393da3',
  'c0a6f4dc63a24bfdcf54ef2a6a082a0a72de35803e2ff5ff527ae5d87206dfd5',
  'e4c73430d7a5b50925df43370a0d216e9a79b9d6db8373a0c69eb1cc31c7c52a',
  '0f4e9cdd264b025550d170806340214fe94434c9b02f697ec710fc5feafb5e38',
  '35ae5bddd8f7ae635cffba5682a8f00b95f48462c7108ee9a0e5292b074aafb2',
  'eaa962c4fa4a6bafebe415196d351ccd888d4f53f3fa8ae6d7c466a94e6042bb',
  'e28393773da845a679f2080cc7fb44a3b7a1c3792cb7eb7729fdcb6a8d99aea7',
  '2d47437de17951215a12f3c58e51c729a58026ef1fcc0a5fb3d9dc012f600d19',
  'b478b812250df878635c2aa7ec7d155eaa625ee82916e2cd294361886cd1fbd4',
  'a4310d50af18a6447190372a86afaf8b951ffb431d837f1e5688b45971ed1557',
  '4b03f45807ad70f21bfc2cae71c9fde4604c064cf5ffb686bae5dbaad7fdd34c',
  '5edb7ac43b82a06a8761e8d7be4979ebf2611f7dd79bf91c1c6b566a219ed766',
  '2399561127a57125de8cefea610ddf2fa078b5c8067f4e828290bfb860e84b3c',
  '69ddd7ea90bb57c93e135dc85ea6fcd5480b603239bdc454fc758b2a26cf7f79',
  '6c61dac3a2def031506be036d2a6fe401994fbd13df9c8d466599274c446ec98',
  '668c83947da63b724bece1743c31a0e6aed0db8ec5b31be377bb784f91b6716f',
  'ecc3e9c3407503bee091aa952f41348ff88baa863b2264befac807901574e939',
  'f9e67d336c51002ac054c632022d66dda2e7e3fff10ad061ed31d8bbb410cfb2',
  'bf0feefb9e3a581ad5f9e9db7589985743d261085c4d314f6f5d7259aa421612',
  '03950fb49a531f3e1991942398dfa9e0ea32d7ba1cdd9bc85db57ed9400b434a',
  '3c5f81fea5fab82c64bfa2eaecafcde8e077fc8620a7cae537163df36edbf378',
  'cbb522d7b7f127ad6a0113865bdf1cd4102e7d0759af635a7cf4720dc963c53b',
  '04048028bf1f2864d48f9ad4d83294366a828856553f3b14303f90147f5d40ef',
  '2530cc8e98321502bad96f9b1fba1b099e2d299e0f4548bb914f363bc0d4531f',
  '063e4afac491dfd332f3089b8542e94617d893d7fe944e10a7937ee29d9693c0',
  '136335439334a7698016a0d324de72284e079d7b5220bb8fbd747816eebebaca',
  '45140b3247eb9cc8c5b4f0d7b53091f73292089e6e5a63e2749dd3aca9198eda',
  '2ce1cb0bf9d2f9e102993fbe215152c3b2dd0cabde1c68e5319b839154dbb7f5',
  '568d6905a2c88708a4b3025190edcfedb1974a606a13c6e5290fcb2ae63edab5',
  '0376ab1d54c5f9803ce4b2e201a0ee7eef7b57b636e8a93c9b8d4860c96f5fa7',
  '0a81ec5a929777f145904af38d5d509f66b5e2c58fcdb531058b0e17f3f0b41b',
  '70a73f7f376b60074248904534b11482d5bf0e698ecc498df52577ebf2e93b9a',
  'bd71fdf6da97e4cf62d1647add2581b07d79adf8397eb4ecba9c5e8488821423',
  '5c58468d55f58e497e743982d2b50010b6d165374acf83a7d4a32db768c4408e',
  'fcbfe2886206f72b27593c8b070297e12d769ed10ed7930705a8098effc14d17',
  '8c4edfd04348f322969e7e29a4cd4dca004655061c16e1b076422ef342ad630e',
  'bfd88fe1101c41ae3e801bf8be56350ee9bad1a6b9bd515edc5c6d5b8711ac44',
  '513b2cecb810d4cde5dd85391adfc6c2dd60d87bb736d2b521484aa47a0ebef6',
  '88497f01602f3154246ae28c4d5aef10f1d87ebb76626f4ae0b7f95ba7968799',
  'bc104f15a48be709dca542a7e1d4b9df6f054527e802eaa92d595444258afe71',
  '55926084ec963a64b96e2abe01ce0ba86a64fbfebcc7aab5afc155b37fd76066',
  'c1b48299aba5208fe9630ace55ca68a03eda5a519c8802a0d3a673be8f8e557d',
  'e17890ee09a3fbf4f48b9c414a17d637b7a50647e9bc752322727fcc1742a911',
  'c7ba6567de93a798ae1faa791e712d378fae1f93c4397fea441bb7cbe6fd5995',
  '9a114025197c5bb95d94e63d55cd43790847b646b23cdf11ada4a00eff15fb48',
  'edf7ebbca27a2a384d387b7d4010c666e2edb4843e4c29b4ae1d5b9332e6b24d',
  'fd73dad31c644ff1b43bef0ccdda96710b9cd9875eca7e31707af3e96d522bbd',
  '3e84ba4342908516e77573c0992f0979ca084e4685681ff195ccba8a229b8a76',
  '978cd966f2faa07ba7aa9500d9c02e9d77f2cdada6ad6ba74af4b91c66593c50',
  '49e7a442acf0ea6287050054b52564b650e4f49e42e348d6aa38e039e957b1c1',
  'eec5496b988ce98625b934092eec2908bed0b0f316c2d4730c84eaf1f3d34881',
  '3cfc3c14d1f684ff17e38c43ca440c00b967ec933e8bfe064ca1d72c90f2adb0',
  '1c01c6f4dbb2fefc22558b2bca32563f49844acfc32b7be4b0ff599f9e8c7af7',
  'f09b122c7114f4a09bd4ea4f4a99d558b46e4c25cd81140d29c05613914c3841',
  'd95fea3ca4eedce74cd76e75fc6d1ff62c441f0fa8bc77f034b19e5db258015d',
  'f96f23f4c3e79c077a46988d5af5900676a0f039cb645dd17549b216c82440ce',
  'e23d4a036d7b70e9f595b1422079d2b91edfbb1fb651a0633eaa8a9dc5f80703',
  '9a6ec012e1a7da9dbe34194d478ad7c0db1822fb071df12981496ed104384113',
  '59769007f7685d0fcd50872f9f95d5755a5b2b457d81f3692b610a98672f0e1b',
  'dd6936fe21f8f077c123a1a521c12224f72255b73e03a7260693e8a24b0fa389',
  'b0bfd52bb0d7d9bd92bf5d4dc13da255c02c542f378365ea893911f55e55f23c',
  '91e2f5788d5810eba7ba58737de1548a8ecacd014598bc0b143e041b17052552',
  'f356bea244b7a91eb35d53ca9ad7864ace018e2d35d5f8f96ddf68a6f41aa474',
  '8a866fd1b276b57e578e921c65828a2bed58e9f2f288054134b7f1f4bfc9cc74',
  '8fe4fb0af93a4d0d67db0bebb23e37c71bf325dcbcdd240ea04daf58b47e1840',
  '88ef81de202eb018452e43f864725cea5fbd1fc2d9d205730709c5d8b8690f46',
  '7d05ebb682339f8c9451ee094eebfefa7953a114edb2f44949452fab7d2fc185',
  '7e37cb8b4c47090cab36551ba6f45db840680fba166a952db100717f43053fc2',
  'cb3ccbb76031e5e0138f8dd39a23f9de47ffc35e43c1144cea27d46a5ab1cb5f',
  '31ad6648f8104138c738f39ea4320133393e3a18cc02296ef97c2ac9ef6731d0',
  '552f7bdcf1a7af9e6ce672017f4f12abf77240c78e761ac203d1d9d20ac89988',
  '4b22d5a6aec99f3cdb79aa5ec06838479cd5ecba7164f7f22dc1d65f63d85708',
  'd6f034bd94aa233f0297eca4245b283973e447aa590f310c77f48fdf83112254',
  '52f0e1c4e58ec629291b60317f074671b85d7ea80d5b07273463534b32b40234',
  'e793c9b02fd8aa13e21c31228accb08119643b749c898964b1746d46c3d4cbd2',
  '4ff460d54b9c86dabfbcfc5712e0400d2bed3fbc4d4fbdaa86e06adcd2a9ad7a',
  'bec94911c2955676db6c0a550986d76e3ba005667c442c9762b4fbb773de228c',
  '179fbc148a3dd00fd24ea13458cc43bfa7f59c8182d783a513f6ebec100c8924',
  '3c4fb0b95ab8b30032f432b86f535fe172c185d0fd39865837cf36187fa6f428',
  '4d2491414cfe956746ec4cefa6cf6f72e28a1329432f9d8a907ac4cb5dadc15a',
  '5d56499be4d2e08bcfcad08a3e38723d50503bde706948e42f55603019e528ae',
  '30d0895a9a448a262091635522d1f52010b5867acae12c78ef958fd4f4389f2f',
  '43df5774b03e7fef5fe40d931a7bedf1bb2e6b42738c4e6d3841103d3aa7f339',
  '02ed0eb28c14da45165c566791700d6451d7fb56f0b2ab1d3b8eb070e56edff5',
  '5cc3d78e4e1d5e45547a04e6873e64f90cf9536d1ccc2ef800f355c4c5fd70fd',
  '49351b903444c185ccdc5c693d24d8555cb208d6a8141307699f4af063199d78',
  '8de78655e1be7f7847800b93f694d21d368cc06e033e7fab04bb5eb99da6b700',
  '2a99f5bc1174b73cbb1d620884e01c34e51ccb3978da125f0e33268883bf4158',
  '6b9c08e86eb0f767cfad65cd98b62149e5494a67f5845e7bd1ed019f27b86bd6',
  'd487a56f83b07482e85e963394c1ecc2c9e51d0903ee946b02c301581ed99e16',
  '8b45da1c06f791eb0cabf26be588f5fb23165c2e614bf885562d0dce50b29b02',
  'a1339d33281a0b56e557d3d32b1ce7f9367eb094bd5fa72a7e5004c8ded7cafe',
  'b676f2eddae8775cd36cb0f63cd1d4603961f49e6265ba013a2f0307b6d0b804'
];


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * payment.js - BIP70 payment for wmcc_core.
 */
 


const assert = __webpack_require__(0);
const Output = __webpack_require__(13);
const TX = __webpack_require__(16);
const Script = __webpack_require__(8);
const ProtoReader = __webpack_require__(77);
const ProtoWriter = __webpack_require__(78);
const PaymentDetails = __webpack_require__(162);

/**
 * Represents a BIP70 payment.
 * @alias module:bip70.Payment
 * @constructor
 * @param {Object?} options
 * @property {Buffer} merchantData
 * @property {TX[]} transactions
 * @property {Output[]} refundTo
 * @property {String|null} memo
 */

function Payment(options) {
  if (!(this instanceof Payment))
    return new Payment(options);

  this.merchantData = null;
  this.transactions = [];
  this.refundTo = [];
  this.memo = null;

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from options.
 * @private
 * @param {Object} options
 * @returns {Payment}
 */

Payment.prototype.fromOptions = function fromOptions(options) {
  if (options.merchantData)
    this.setData(options.merchantData);

  if (options.transactions) {
    assert(Array.isArray(options.transactions));
    for (const item of options.transactions) {
      const tx = new TX(item);
      this.transactions.push(tx);
    }
  }

  if (options.refundTo) {
    assert(Array.isArray(options.refundTo));
    for (const item of options.refundTo) {
      const output = new Output(item);
      this.refundTo.push(output);
    }
  }

  if (options.memo != null) {
    assert(typeof options.memo === 'string');
    this.memo = options.memo;
  }

  return this;
};

/**
 * Instantiate payment from options.
 * @param {Object} options
 * @returns {Payment}
 */

Payment.fromOptions = function fromOptions(options) {
  return new Payment().fromOptions(options);
};

/**
 * Set payment details.
 * @method
 * @alias Payment#setData
 * @param {Object} data
 * @param {String?} enc
 */

Payment.prototype.setData = PaymentDetails.prototype.setData;

/**
 * Get payment details.
 * @method
 * @alias Payment#getData
 * @param {String?} enc
 * @returns {String|Object|null}
 */

Payment.prototype.getData = PaymentDetails.prototype.getData;

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 * @returns {Payment}
 */

Payment.prototype.fromRaw = function fromRaw(data) {
  const br = new ProtoReader(data);

  this.merchantData = br.readFieldBytes(1, true);

  while (br.nextTag() === 2) {
    const tx = TX.fromRaw(br.readFieldBytes(2));
    this.transactions.push(tx);
  }

  while (br.nextTag() === 3) {
    const op = new ProtoReader(br.readFieldBytes(3));
    const output = new Output();
    output.value = op.readFieldU64(1, true);
    output.script = Script.fromRaw(op.readFieldBytes(2, true));
    this.refundTo.push(output);
  }

  this.memo = br.readFieldString(4, true);

  return this;
};

/**
 * Instantiate payment from serialized data.
 * @param {Buffer} data
 * @returns {Payment}
 */

Payment.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new Payment().fromRaw(data);
};

/**
 * Serialize the payment (protobuf).
 * @returns {Buffer}
 */

Payment.prototype.toRaw = function toRaw() {
  const bw = new ProtoWriter();

  if (this.merchantData)
    bw.writeFieldBytes(1, this.merchantData);

  for (const tx of this.transactions)
    bw.writeFieldBytes(2, tx.toRaw());

  for (const output of this.refundTo) {
    const op = new ProtoWriter();
    op.writeFieldU64(1, output.value);
    op.writeFieldBytes(2, output.script.toRaw());
    bw.writeFieldBytes(3, op.render());
  }

  if (this.memo != null)
    bw.writeFieldString(4, this.memo);

  return bw.render();
};

/*
 * Expose
 */

module.exports = Payment;


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * x509.js - x509 handling for wmcc_core.
 */
 


const assert = __webpack_require__(0);
const ASN1 = __webpack_require__(196);
const PEM = __webpack_require__(100);
const util = __webpack_require__(1);
const digest = __webpack_require__(5);
const pk = __webpack_require__(197);
const certs = __webpack_require__(193);

/**
 * @exports bip70/x509
 */

const x509 = exports;

/**
 * Map of trusted root certs.
 * @type {Set}
 */

x509.trusted = new Set();

/**
 * Whether to allow untrusted root
 * certs during verification.
 * @type {Boolean}
 */

x509.allowUntrusted = false;

/**
 * OID to algorithm map for PKI.
 * @const {Object}
 * @see https://www.ietf.org/rfc/rfc2459.txt
 * @see https://tools.ietf.org/html/rfc3279
 * @see http://oid-info.com/get/1.2.840.10040.4
 * @see http://oid-info.com/get/1.2.840.113549.1.1
 * @see http://oid-info.com/get/1.2.840.10045.4.3
 */

x509.oid = {
  '1.2.840.10040.4.1'    : { key: 'dsa',   hash: null     },
  '1.2.840.10040.4.2'    : { key: 'dsa',   hash: null     },
  '1.2.840.10040.4.3'    : { key: 'dsa',   hash: 'sha1'   },
  '1.2.840.113549.1.1.1' : { key: 'rsa',   hash: null     },
  '1.2.840.113549.1.1.2' : { key: 'rsa',   hash: 'md2'    },
  '1.2.840.113549.1.1.3' : { key: 'rsa',   hash: 'md4'    },
  '1.2.840.113549.1.1.4' : { key: 'rsa',   hash: 'md5'    },
  '1.2.840.113549.1.1.5' : { key: 'rsa',   hash: 'sha1'   },
  '1.2.840.113549.1.1.11': { key: 'rsa',   hash: 'sha256' },
  '1.2.840.113549.1.1.12': { key: 'rsa',   hash: 'sha384' },
  '1.2.840.113549.1.1.13': { key: 'rsa',   hash: 'sha512' },
  '1.2.840.113549.1.1.14': { key: 'rsa',   hash: 'sha224' },
  '1.2.840.10045.2.1'    : { key: 'ecdsa', hash: null     },
  '1.2.840.10045.4.1'    : { key: 'ecdsa', hash: 'sha1'   },
  '1.2.840.10045.4.3.1'  : { key: 'ecdsa', hash: 'sha224' },
  '1.2.840.10045.4.3.2'  : { key: 'ecdsa', hash: 'sha256' },
  '1.2.840.10045.4.3.3'  : { key: 'ecdsa', hash: 'sha384' },
  '1.2.840.10045.4.3.4'  : { key: 'ecdsa', hash: 'sha512' }
};

/**
 * OID to curve name map for ECDSA.
 * @type {Object}
 */

x509.curves = {
  '1.3.132.0.33': 'p224',
  '1.2.840.10045.3.1.7': 'p256',
  '1.3.132.0.34': 'p384',
  '1.3.132.0.35': 'p521'
};

/**
 * Retrieve cert value by OID.
 * @param {Object} cert
 * @param {String} oid
 * @returns {String}
 */

x509.getSubjectOID = function getSubjectOID(cert, oid) {
  const subject = cert.tbs.subject;

  for (const entry of subject) {
    if (entry.type === oid)
      return entry.value;
  }

  return null;
};

/**
 * Try to retrieve CA name by checking
 * for a few different OIDs.
 * @param {Object} cert
 * @returns {String}
 */

x509.getCAName = function getCAName(cert) {
  // This seems to work the best in practice
  // for getting a human-readable and
  // descriptive name for the CA.
  // See:
  //   http://oid-info.com/get/2.5.4
  // Precedence:
  //   (3) commonName
  //   (11) organizationUnitName
  //   (10) organizationName
  return x509.getSubjectOID(cert, '2.5.4.3')
    || x509.getSubjectOID(cert, '2.5.4.11')
    || x509.getSubjectOID(cert, '2.5.4.10')
    || 'Unknown';
};

/**
 * Test whether a cert is trusted by hashing
 * and looking it up in the trusted map.
 * @param {Object} cert
 * @returns {Buffer}
 */

x509.isTrusted = function isTrusted(cert) {
  const fingerprint = digest.sha256(cert.raw);
  const hash = fingerprint.toString('hex');
  return x509.trusted.has(hash);
};

/**
 * Add root certificates to the trusted map.
 * @param {Buffer[]} certs
 */

x509.setTrust = function setTrust(certs) {
  assert(Array.isArray(certs), 'Certs must be an array.');

  for (let cert of certs) {
    if (typeof cert === 'string') {
      const pem = PEM.decode(cert);
      assert(pem.type === 'certificate', 'Must add certificates to trust.');
      cert = pem.data;
    }

    assert(Buffer.isBuffer(cert), 'Certificates must be PEM or DER.');

    cert = x509.parse(cert);

    const hash = digest.sha256(cert.raw);
    const fingerprint = hash.toString('hex');

    x509.trusted.add(fingerprint);
  }
};

/**
 * Add root certificate fingerprints to the trusted map.
 * @param {Hash[]} hashes
 */

x509.setFingerprints = function setFingerprints(hashes) {
  assert(Array.isArray(hashes), 'Certs must be an array.');

  for (let hash of hashes) {
    if (typeof hash === 'string')
      hash = Buffer.from(hash, 'hex');

    assert(Buffer.isBuffer(hash), 'Fingerprint must be a buffer.');
    assert(hash.length === 32, 'Fingerprint must be a sha256 hash.');

    hash = hash.toString('hex');
    x509.trusted.add(hash);
  }
};

/**
 * Retrieve key algorithm from cert.
 * @param {Object} cert
 * @returns {Object}
 */

x509.getKeyAlgorithm = function getKeyAlgorithm(cert) {
  const oid = cert.tbs.pubkey.alg.alg;
  const alg = x509.oid[oid];

  if (!alg)
    throw new Error(`Unknown key algorithm: ${oid}.`);

  return alg;
};

/**
 * Retrieve signature algorithm from cert.
 * @param {Object} cert
 * @returns {Object}
 */

x509.getSigAlgorithm = function getSigAlgorithm(cert) {
  const oid = cert.sigAlg.alg;
  const alg = x509.oid[oid];

  if (!alg || !alg.hash)
    throw new Error(`Unknown signature algorithm: ${oid}.`);

  return alg;
};

/**
 * Lookup curve based on key parameters.
 * @param {Buffer} params
 * @returns {Object}
 */

x509.getCurve = function getCurve(params) {
  let oid;

  try {
    oid = ASN1.parseOID(params);
  } catch (e) {
    throw new Error('Could not parse curve OID.');
  }

  const curve = x509.curves[oid];

  if (!curve)
    throw new Error(`Unknown ECDSA curve: ${oid}.`);

  return curve;
};

/**
 * Parse a DER formatted cert.
 * @param {Buffer} der
 * @returns {Object|null}
 */

x509.parse = function parse(der) {
  try {
    return ASN1.parseCert(der);
  } catch (e) {
    throw new Error('Could not parse DER certificate.');
  }
};

/**
 * Get cert public key.
 * @param {Object} cert
 * @returns {Object|null}
 */

x509.getPublicKey = function getPublicKey(cert) {
  const alg = x509.getKeyAlgorithm(cert);
  const key = cert.tbs.pubkey.pubkey;
  const params = cert.tbs.pubkey.alg.params;
  let curve = null;

  if (alg.key === 'ecdsa') {
    if (!params)
      throw new Error('No curve selected for ECDSA (cert).');

    curve = x509.getCurve(params);
  }

  return {
    alg: alg.key,
    data: key,
    params: params,
    curve: curve
  };
};

/**
 * Verify cert expiration time.
 * @param {Object} cert
 * @returns {Boolean}
 */

x509.verifyTime = function verifyTime(cert) {
  const time = cert.tbs.validity;
  const now = util.now();
  return now > time.notBefore && now < time.notAfter;
};

/**
 * Get signature key info from cert chain.
 * @param {Buffer} key
 * @param {Buffer[]} chain
 * @returns {Object}
 */

x509.getSigningKey = function getSigningKey(key, chain) {
  assert(chain.length !== 0, 'No chain available.');

  if (typeof key === 'string') {
    let curve = null;

    key = PEM.decode(key);

    if (key.alg === 'ecdsa') {
      if (!key.params)
        throw new Error('No curve selected for ECDSA (key).');

      curve = x509.getCurve(key.params);
    }

    key = {
      alg: key.alg,
      data: key.data,
      params: key.params,
      curve: curve
    };
  } else {
    const cert = x509.parse(chain[0]);
    const pub = x509.getPublicKey(cert);

    key = {
      alg: pub.alg,
      data: key,
      params: pub.params,
      curve: pub.curve
    };
  }

  return key;
};

/**
 * Sign a hash with the chain signing key.
 * @param {String} hash
 * @param {Buffer} msg
 * @param {Buffer} key
 * @param {Buffer[]} chain
 * @returns {Buffer}
 */

x509.signSubject = function signSubject(hash, msg, key, chain) {
  const priv = x509.getSigningKey(key, chain);
  return pk.sign(hash, msg, priv);
};

/**
 * Get chain verification key.
 * @param {Buffer[]} chain
 * @returns {Object|null}
 */

x509.getVerifyKey = function getVerifyKey(chain) {
  if (chain.length === 0)
    throw new Error('No verify key available (cert chain).');

  const cert = x509.parse(chain[0]);

  return x509.getPublicKey(cert);
};

/**
 * Verify a sighash against chain verification key.
 * @param {String} hash
 * @param {Buffer} msg
 * @param {Buffer} sig
 * @param {Buffer[]} chain
 * @returns {Boolean}
 */

x509.verifySubject = function verifySubject(hash, msg, sig, chain) {
  const key = x509.getVerifyKey(chain);
  return pk.verify(hash, msg, sig, key);
};

/**
 * Parse certificate chain.
 * @param {Buffer[]} chain
 * @returns {Object[]}
 */

x509.parseChain = function parseChain(chain) {
  const certs = [];

  for (const item of chain) {
    const cert = x509.parse(item);
    certs.push(cert);
  }

  return certs;
};

/**
 * Verify all expiration times in a certificate chain.
 * @param {Object[]} chain
 * @returns {Boolean}
 */

x509.verifyTimes = function verifyTimes(chain) {
  for (const cert of chain) {
    if (!x509.verifyTime(cert))
      return false;
  }

  return true;
};

/**
 * Verify that at least one parent
 * cert in the chain is trusted.
 * @param {Object[]} chain
 * @returns {Boolean}
 */

x509.verifyTrust = function verifyTrust(chain) {
  // If trust hasn't been
  // setup, just return.
  if (x509.allowUntrusted)
    return true;

  // Make sure we trust one
  // of the certs in the chain.
  for (const cert of chain) {
    // If any certificate in the chain
    // is trusted, assume we also trust
    // the parent.
    if (x509.isTrusted(cert))
      return true;
  }

  // No trusted certs present.
  return false;
};

/**
 * Verify certificate chain.
 * @param {Object[]} certs
 */

x509.verifyChain = function verifyChain(certs) {
  const chain = x509.parseChain(certs);

  // Parse certificates and
  // check validity time.
  if (!x509.verifyTimes(chain))
    throw new Error('Invalid certificate times.');

  // Verify signatures.
  for (let i = 1; i < chain.length; i++) {
    const child = chain[i - 1];
    const parent = chain[i];
    const alg = x509.getSigAlgorithm(child);
    const key = x509.getPublicKey(parent);
    const msg = child.tbs.raw;
    const sig = child.sig;

    if (!pk.verify(alg.hash, msg, sig, key))
      throw new Error(`${alg.key} verification failed for chain.`);
  }

  // Make sure we trust one
  // of the certs in the chain.
  if (!x509.verifyTrust(chain))
    throw new Error('Certificate chain is untrusted.');

  return true;
};

/*
 * Load trusted certs.
 */

x509.setFingerprints(certs);


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * asn1.js - asn1 parsing for wmcc_core.
 *
 * Parts of this software are based on asn1.js.
 * https://github.com/indutny/asn1.js
 *
 * Copyright Fedor Indutny, 2013.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */



const BufferReader = __webpack_require__(2);

/**
 * @exports utils/asn1
 */

const ASN1 = exports;

/**
 * Read next tag.
 * @param {BufferReader} br
 * @returns {Object}
 */

ASN1.readTag = function readTag(br) {
  let type = br.readU8();
  const primitive = (type & 0x20) === 0;

  if ((type & 0x1f) === 0x1f) {
    let oct = type;
    type = 0;
    while ((oct & 0x80) === 0x80) {
      oct = br.readU8();
      type <<= 7;
      type |= oct & 0x7f;
    }
  } else {
    type &= 0x1f;
  }

  return {
    type: type,
    primitive: primitive,
    size: ASN1.readSize(br, primitive)
  };
};

/**
 * Read tag size.
 * @param {BufferReader} br
 * @param {Boolean} primitive
 * @returns {Number}
 * @throws on indefinite size
 */

ASN1.readSize = function readSize(br, primitive) {
  let size = br.readU8();

  // Indefinite form
  if (!primitive && size === 0x80)
    throw new Error('Indefinite size.');

  // Definite form
  if ((size & 0x80) === 0) {
    // Short form
    return size;
  }

  // Long form
  const bytes = size & 0x7f;

  if (bytes > 3)
    throw new Error('Length octet is too long.');

  size = 0;
  for (let i = 0; i < bytes; i++) {
    size <<= 8;
    size |= br.readU8();
  }

  return size;
};

/**
 * Read implicit SEQ.
 * @param {BufferReader} br
 * @returns {Buffer}
 */

ASN1.readSeq = function readSeq(br) {
  const tag = ASN1.implicit(br, 0x10);
  return br.readBytes(tag.size);
};

/**
 * Read next tag and assert implicit.
 * @param {BufferReader} br
 * @param {Number} type
 * @returns {Object}
 * @throws on unexpected tag
 */

ASN1.implicit = function implicit(br, type) {
  const tag = ASN1.readTag(br);

  if (tag.type !== type)
    throw new Error(`Unexpected tag: ${tag.type}.`);

  return tag;
};

/**
 * Read implicit tag.
 * @param {BufferReader} br
 * @param {Number} type
 * @returns {Boolean}
 */

ASN1.explicit = function explicit(br, type) {
  const offset = br.offset;
  const tag = ASN1.readTag(br);

  if (tag.type !== type) {
    br.offset = offset;
    return false;
  }

  return true;
};

/**
 * Read next implicit SEQ and return a new reader.
 * @param {BufferReader} br
 * @returns {BufferReader}
 */

ASN1.seq = function seq(br) {
  return new BufferReader(ASN1.readSeq(br), true);
};

/**
 * Read implicit int.
 * @param {BufferReader} br
 * @param {Boolean?} cast
 * @returns {Buffer|Number}
 */

ASN1.readInt = function readInt(br, cast) {
  const tag = ASN1.implicit(br, 0x02);
  const num = br.readBytes(tag.size);

  if (cast)
    return num.readUIntBE(0, num.length);

  return num;
};

/**
 * Read explicit int.
 * @param {BufferReader} br
 * @param {Number} type
 * @param {Boolean?} readNum
 * @returns {Buffer|Number} `-1` on not present.
 */

ASN1.readExplicitInt = function readExplicitInt(br, type, readNum) {
  if (!ASN1.explicit(br, type))
    return -1;

  return ASN1.readInt(br, readNum);
};

/**
 * Read and align an implicit bitstr.
 * @param {BufferReader} br
 * @returns {Buffer}
 */

ASN1.readBitstr = function readBitstr(br) {
  const tag = ASN1.implicit(br, 0x03);
  const str = br.readBytes(tag.size);
  return ASN1.alignBitstr(str);
};

/**
 * Read an implicit string (any type).
 * @param {BufferReader} br
 * @returns {String}
 */

ASN1.readString = function readString(br) {
  const tag = ASN1.readTag(br);

  switch (tag.type) {
    case 0x03: { // bitstr
      const str = br.readBytes(tag.size);
      return ASN1.alignBitstr(str).toString('utf8');
    }
    // Note:
    // Fuck all these.
    case 0x04: // octstr
    case 0x12: // numstr
    case 0x13: // prinstr
    case 0x14: // t61str
    case 0x15: // videostr
    case 0x16: // ia5str
    case 0x19: // graphstr
    case 0x0c: // utf8str
    case 0x1a: // iso646str
    case 0x1b: // genstr
    case 0x1c: // unistr
    case 0x1d: // charstr
    case 0x1e: { // bmpstr
      return br.readString('utf8', tag.size);
    }
    default: {
      throw new Error(`Unexpected tag: ${tag.type}.`);
    }
  }
};

/**
 * Align a bitstr.
 * @param {Buffer} data
 * @returns {Buffer}
 */

ASN1.alignBitstr = function alignBitstr(data) {
  const padding = data[0];
  const bits = (data.length - 1) * 8 - padding;
  const buf = data.slice(1);
  const shift = 8 - (bits % 8);

  if (shift === 8 || buf.length === 0)
    return buf;

  const out = Buffer.allocUnsafe(buf.length);
  out[0] = buf[0] >>> shift;

  for (let i = 1; i < buf.length; i++) {
    out[i] = buf[i - 1] << (8 - shift);
    out[i] |= buf[i] >>> shift;
  }

  return out;
};

/**
 * Read an entire certificate.
 * @param {BufferReader} br
 * @returns {Object}
 */

ASN1.readCert = function readCert(br) {
  const buf = br;

  buf.start();

  br = ASN1.seq(buf);

  return {
    tbs: ASN1.readTBS(br),
    sigAlg: ASN1.readAlgIdent(br),
    sig: ASN1.readBitstr(br),
    raw: buf.endData(true)
  };
};

/**
 * Read only the TBS certificate.
 * @param {BufferReader} br
 * @returns {Object}
 */

ASN1.readTBS = function readTBS(br) {
  const buf = br;

  buf.start();

  br = ASN1.seq(buf);

  return {
    version: ASN1.readExplicitInt(br, 0x00, true),
    serial: ASN1.readInt(br),
    sig: ASN1.readAlgIdent(br),
    issuer: ASN1.readName(br),
    validity: ASN1.readValidity(br),
    subject: ASN1.readName(br),
    pubkey: ASN1.readPubkey(br),
    raw: buf.endData(true)
  };
};

/**
 * Read an implicit pubkey.
 * @param {BufferReader} br
 * @returns {Object}
 */

ASN1.readPubkey = function readPubkey(br) {
  br = ASN1.seq(br);
  return {
    alg: ASN1.readAlgIdent(br),
    pubkey: ASN1.readBitstr(br)
  };
};

/**
 * Read implicit name.
 * @param {BufferReader} br
 * @returns {Object[]}
 */

ASN1.readName = function readName(br) {
  const values = [];

  br = ASN1.seq(br);

  while (br.left()) {
    ASN1.implicit(br, 0x11); // set
    ASN1.implicit(br, 0x10); // seq
    values.push({
      type: ASN1.readOID(br),
      value: ASN1.readString(br)
    });
  }

  return values;
};

/**
 * Read implicit validity timerange.
 * @param {BufferReader} br
 * @returns {Object}
 */

ASN1.readValidity = function readValidity(br) {
  br = ASN1.seq(br);
  return {
    notBefore: ASN1.readTime(br),
    notAfter: ASN1.readTime(br)
  };
};

/**
 * Read implicit timestamp.
 * @param {BufferReader} br
 * @returns {Number}
 */

ASN1.readTime = function readTime(br) {
  const tag = ASN1.readTag(br);
  const str = br.readString('ascii', tag.size);
  let year, mon, day, hour, min, sec;

  switch (tag.type) {
    case 0x17: // utctime
      year = str.slice(0, 2) | 0;
      mon = str.slice(2, 4) | 0;
      day = str.slice(4, 6) | 0;
      hour = str.slice(6, 8) | 0;
      min = str.slice(8, 10) | 0;
      sec = str.slice(10, 12) | 0;
      if (year < 70)
        year = 2000 + year;
      else
        year = 1900 + year;
      break;
    case 0x18: // gentime
      year = str.slice(0, 4) | 0;
      mon = str.slice(4, 6) | 0;
      day = str.slice(6, 8) | 0;
      hour = str.slice(8, 10) | 0;
      min = str.slice(10, 12) | 0;
      sec = str.slice(12, 14) | 0;
      break;
    default:
      throw new Error(`Unexpected tag: ${tag.type}.`);
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0) / 1000;
};

/**
 * Read and format OID to string.
 * @param {BufferReader} br
 * @returns {String}
 */

ASN1.readOID = function readOID(br) {
  const tag = ASN1.implicit(br, 0x06);
  const data = br.readBytes(tag.size);
  return ASN1.formatOID(data);
};

/**
 * Format an OID buffer to a string.
 * @param {Buffer} data
 * @returns {String}
 */

ASN1.formatOID = function formatOID(data) {
  const br = new BufferReader(data);
  const ids = [];
  let ident = 0;
  let subident = 0;

  while (br.left()) {
    subident = br.readU8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      ids.push(ident);
      ident = 0;
    }
  }

  if (subident & 0x80)
    ids.push(ident);

  const first = (ids[0] / 40) | 0;
  const second = ids[0] % 40;
  const result = [first, second].concat(ids.slice(1));

  return result.join('.');
};

/**
 * Read algorithm identifier.
 * @param {BufferReader} br
 * @returns {Object}
 */

ASN1.readAlgIdent = function readAlgIdent(br) {
  let params = null;

  br = ASN1.seq(br);

  const alg = ASN1.readOID(br);

  if (br.left() > 0) {
    const tag = ASN1.readTag(br);
    params = br.readBytes(tag.size);
    if (params.length === 0)
      params = null;
  }

  return {
    alg: alg,
    params: params
  };
};

/**
 * Read RSA public key.
 * @param {BufferReader} br
 * @returns {Object}
 */

ASN1.readRSAPublic = function readRSAPublic(br) {
  br = ASN1.seq(br);
  return {
    modulus: ASN1.readInt(br),
    publicExponent: ASN1.readInt(br)
  };
};

/**
 * Read RSA private key.
 * @param {BufferReader} br
 * @returns {Object}
 */

ASN1.readRSAPrivate = function readRSAPrivate(br) {
  br = ASN1.seq(br);
  return {
    version: ASN1.readInt(br, true),
    modulus: ASN1.readInt(br),
    publicExponent: ASN1.readInt(br),
    privateExponent: ASN1.readInt(br),
    prime1: ASN1.readInt(br),
    prime2: ASN1.readInt(br),
    exponent1: ASN1.readInt(br),
    exponent2: ASN1.readInt(br),
    coefficient: ASN1.readInt(br)
  };
};

/**
 * Read RSA public key from buffer.
 * @param {Buffer} data
 * @returns {Object}
 */

ASN1.parseRSAPublic = function parseRSAPublic(data) {
  return ASN1.readRSAPublic(new BufferReader(data, true));
};

/**
 * Read RSA private key from buffer.
 * @param {Buffer} data
 * @returns {Object}
 */

ASN1.parseRSAPrivate = function parseRSAPrivate(data) {
  return ASN1.readRSAPrivate(new BufferReader(data, true));
};

/**
 * Read certificate from buffer.
 * @param {Buffer} data
 * @returns {Object}
 */

ASN1.parseCert = function parseCert(data) {
  return ASN1.readCert(new BufferReader(data, true));
};

/**
 * Read TBS certificate from buffer.
 * @param {Buffer} data
 * @returns {Object}
 */

ASN1.parseTBS = function parseTBS(data) {
  return ASN1.readTBS(new BufferReader(data, true));
};


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * pk.js - Public key algorithms for wmcc_core.
 */
 


/**
 * @module bip70/pk
 */

const rsa = __webpack_require__(198);
const ecdsa = __webpack_require__(199);

/**
 * Verify signature with public key.
 * @param {String} hash - Hash algorithm.
 * @param {Buffer} msg
 * @param {Buffer} sig
 * @param {Object} key
 * @returns {Boolean}
 */

exports.verify = function verify(hash, msg, sig, key) {
  switch (key.alg) {
    case 'rsa':
      return rsa.verify(hash, msg, sig, key.data);
    case 'ecdsa':
      return ecdsa.verify(key.curve, hash, msg, sig, key.data);
    default:
      throw new Error('Unsupported algorithm.');
  }
};

/**
 * Sign message with private key.
 * @param {String} hash - Hash algorithm.
 * @param {Buffer} msg
 * @param {Object} key
 * @returns {Buffer}
 */

exports.sign = function sign(hash, msg, key) {
  switch (key.alg) {
    case 'rsa':
      return rsa.sign(hash, msg, key.data);
    case 'ecdsa':
      return ecdsa.sign(key.curve, hash, msg, key.data);
    default:
      throw new Error('Unsupported algorithm.');
  }
};


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * rsa.js - RSA for wmcc_core.
 */



/**
 * @module crypto/rsa
 */

const assert = __webpack_require__(0);
const crypto = __webpack_require__(24);
const PEM = __webpack_require__(100);

/**
 * Verify RSA signature.
 * @param {String} alg - Hash algorithm.
 * @param {Buffer} msg - Signed message.
 * @param {Buffer} sig - Signature.
 * @param {Buffer} key - ASN1 serialized RSA key.
 * @returns {Boolean}
 */

exports.verify = function verify(alg, msg, sig, key) {
  assert(typeof alg === 'string', 'No algorithm selected.');
  assert(Buffer.isBuffer(msg));
  assert(Buffer.isBuffer(sig));
  assert(Buffer.isBuffer(key));

  const name = normalizeAlg('rsa', alg);
  const pem = PEM.encode(key, 'rsa', 'public key');
  const ctx = crypto.createVerify(name);

  try {
    ctx.update(msg);
    return ctx.verify(pem, sig);
  } catch (e) {
    return false;
  }
};

/**
 * Sign message with RSA key.
 * @param {String} alg - Hash algorithm.
 * @param {Buffer} msg - Signed message.
 * @param {Buffer} key - ASN1 serialized RSA key.
 * @returns {Buffer} Signature (DER)
 */

exports.sign = function sign(alg, msg, key) {
  assert(typeof alg === 'string', 'No algorithm selected.');
  assert(Buffer.isBuffer(msg));
  assert(Buffer.isBuffer(key));

  const name = normalizeAlg('rsa', alg);
  const pem = PEM.encode(key, 'rsa', 'private key');
  const ctx = crypto.createSign(name);

  ctx.update(msg);

  return ctx.sign(pem);
};

/*
 * Helpers
 */

function normalizeAlg(alg, hash) {
  return `${alg.toUpperCase()}-${hash.toUpperCase()}`;
}


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * ecdsa.js - ecdsa for wmcc_core.
 */



/**
 * @module crypto/ecdsa
 */

const assert = __webpack_require__(0);
const elliptic = __webpack_require__(9);
const digest = __webpack_require__(5);

/**
 * Verify ECDSA signature.
 * @param {String} curve - Curve name.
 * @param {String} alg - Hash algorithm.
 * @param {Buffer} msg - Signed message.
 * @param {Buffer} sig - Signature.
 * @param {Buffer} key - ASN1 serialized ECDSA key.
 * @returns {Boolean}
 */

exports.verify = function verify(curve, alg, msg, sig, key) {
  assert(typeof curve === 'string', 'No curve selected.');
  assert(typeof alg === 'string', 'No algorithm selected.');
  assert(Buffer.isBuffer(msg));
  assert(Buffer.isBuffer(sig));
  assert(Buffer.isBuffer(key));

  const ec = elliptic.ec(curve);
  const hash = digest.hash(alg, msg);

  try {
    return ec.verify(hash, sig, key);
  } catch (e) {
    return false;
  }
};

/**
 * Sign message with ECDSA key.
 * @memberof module:crypto/pk.ecdsa
 * @param {String} curve - Curve name.
 * @param {String} alg - Hash algorithm.
 * @param {Buffer} msg - Signed message.
 * @param {Buffer} key - ASN1 serialized ECDSA key.
 * @returns {Buffer} Signature (DER)
 */

exports.sign = function sign(curve, alg, msg, key) {
  assert(typeof curve === 'string', 'No curve selected.');
  assert(typeof alg === 'string', 'No algorithm selected.');
  assert(Buffer.isBuffer(msg));
  assert(Buffer.isBuffer(key));

  const ec = elliptic.ec(curve);
  const hash = digest.hash(alg, msg);
  const sig = ec.sign(hash, key, { canonical: true });

  return Buffer.from(sig.toDER());
};


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * lowlevelup.js - LevelUP module for wmcc_core.
 */



const assert = __webpack_require__(0);
const Lock = __webpack_require__(23);
const co = __webpack_require__(17);

const LOW = Buffer.from([0x00]);
const HIGH = Buffer.from([0xff]);

let VERSION_ERROR;

/**
 * Extremely low-level version of levelup.
 *
 * This avoids pulling in extra deps and
 * lowers memory usage.
 *
 * @alias module:db.LowlevelUp
 * @constructor
 * @param {Function} backend - Database backend.
 * @param {String} location - File location.
 * @param {Object?} options - Leveldown options.
 */

function LowlevelUp(backend, location, options) {
  if (!(this instanceof LowlevelUp))
    return new LowlevelUp(backend, location, options);

  assert(typeof backend === 'function', 'Backend is required.');
  assert(typeof location === 'string', 'Filename is required.');

  this.options = new LLUOptions(options);
  this.backend = backend;
  this.location = location;
  this.locker = new Lock();

  this.loading = false;
  this.closing = false;
  this.loaded = false;

  this.db = null;
  this.binding = null;

  this.init();
}

/**
 * Initialize the database.
 * @method
 * @private
 */

LowlevelUp.prototype.init = function init() {
  const Backend = this.backend;
  let db = new Backend(this.location);
  let binding = db;

  // Stay as close to the metal as possible.
  // We want to make calls to C++ directly.
  while (db.db) {
    // Not a database.
    if (typeof db.db.put !== 'function')
      break;

    // Recursive.
    if (db.db === db)
      break;

    // Go deeper.
    db = db.db;
    binding = db;
  }

  // A lower-level binding.
  if (db.binding)
    binding = db.binding;

  this.db = db;
  this.binding = binding;
};

/**
 * Open the database.
 * @method
 * @returns {Promise}
 */

LowlevelUp.prototype.open = async function open() {
  const unlock = await this.locker.lock();
  try {
    return await this._open();
  } finally {
    unlock();
  }
};

/**
 * Open the database (without a lock).
 * @method
 * @private
 * @returns {Promise}
 */

LowlevelUp.prototype._open = async function _open() {
  if (this.loaded)
    throw new Error('Database is already open.');

  assert(!this.loading);
  assert(!this.closing);

  this.loading = true;

  try {
    await this.load();
  } catch (e) {
    this.loading = false;
    throw e;
  }

  this.loading = false;
  this.loaded = true;
};

/**
 * Close the database.
 * @method
 * @returns {Promise}
 */

LowlevelUp.prototype.close = async function close() {
  const unlock = await this.locker.lock();
  try {
    return await this._close();
  } finally {
    unlock();
  }
};

/**
 * Close the database (without a lock).
 * @method
 * @private
 * @returns {Promise}
 */

LowlevelUp.prototype._close = async function _close() {
  if (!this.loaded)
    throw new Error('Database is already closed.');

  assert(!this.loading);
  assert(!this.closing);

  this.loaded = false;
  this.closing = true;

  try {
    await this.unload();
  } catch (e) {
    this.loaded = true;
    this.closing = false;
    throw e;
  }

  this.closing = false;
};

/**
 * Open the database.
 * @private
 * @returns {Promise}
 */

LowlevelUp.prototype.load = function load() {
  return new Promise((resolve, reject) => {
    this.binding.open(this.options, co.wrap(resolve, reject));
  });
};

/**
 * Close the database.
 * @private
 * @returns {Promise}
 */

LowlevelUp.prototype.unload = function unload() {
  return new Promise((resolve, reject) => {
    this.binding.close(co.wrap(resolve, reject));
  });
};

/**
 * Destroy the database.
 * @returns {Promise}
 */

LowlevelUp.prototype.destroy = function destroy() {
  return new Promise((resolve, reject) => {
    if (this.loaded || this.closing) {
      reject(new Error('Cannot destroy open database.'));
      return;
    }

    if (!this.backend.destroy) {
      reject(new Error('Cannot destroy (method not available).'));
      return;
    }

    this.backend.destroy(this.location, co.wrap(resolve, reject));
  });
};

/**
 * Repair the database.
 * @returns {Promise}
 */

LowlevelUp.prototype.repair = function repair() {
  return new Promise((resolve, reject) => {
    if (this.loaded || this.closing) {
      reject(new Error('Cannot repair open database.'));
      return;
    }

    if (!this.backend.repair) {
      reject(new Error('Cannot repair (method not available).'));
      return;
    }

    this.backend.repair(this.location, co.wrap(resolve, reject));
  });
};

/**
 * Backup the database.
 * @param {String} path
 * @returns {Promise}
 */

LowlevelUp.prototype.backup = function backup(path) {
  if (!this.binding.backup)
    return this.clone(path);

  return new Promise((resolve, reject) => {
    if (!this.loaded) {
      reject(new Error('Database is closed.'));
      return;
    }
    this.binding.backup(path, co.wrap(resolve, reject));
  });
};

/**
 * Retrieve a record from the database.
 * @param {String|Buffer} key
 * @returns {Promise} - Returns Buffer.
 */

LowlevelUp.prototype.get = function get(key) {
  return new Promise((resolve, reject) => {
    if (!this.loaded) {
      reject(new Error('Database is closed.'));
      return;
    }
    this.binding.get(key, (err, result) => {
      if (err) {
        if (isNotFound(err)) {
          resolve(null);
          return;
        }
        reject(err);
        return;
      }
      resolve(result);
    });
  });
};

/**
 * Store a record in the database.
 * @param {String|Buffer} key
 * @param {Buffer} value
 * @returns {Promise}
 */

LowlevelUp.prototype.put = function put(key, value) {
  if (!value)
    value = LOW;

  return new Promise((resolve, reject) => {
    if (!this.loaded) {
      reject(new Error('Database is closed.'));
      return;
    }
    this.binding.put(key, value, co.wrap(resolve, reject));
  });
};

/**
 * Remove a record from the database.
 * @param {String|Buffer} key
 * @returns {Promise}
 */

LowlevelUp.prototype.del = function del(key) {
  return new Promise((resolve, reject) => {
    if (!this.loaded) {
      reject(new Error('Database is closed.'));
      return;
    }
    this.binding.del(key, co.wrap(resolve, reject));
  });
};

/**
 * Create an atomic batch.
 * @param {Array?} ops
 * @returns {Batch}
 */

LowlevelUp.prototype.batch = function batch(ops) {
  if (!ops) {
    if (!this.loaded)
      throw new Error('Database is closed.');
    return new Batch(this);
  }

  return new Promise((resolve, reject) => {
    if (!this.loaded) {
      reject(new Error('Database is closed.'));
      return;
    }
    this.binding.batch(ops, co.wrap(resolve, reject));
  });
};

/**
 * Create an iterator.
 * @param {Object} options
 * @returns {Iterator}
 */

LowlevelUp.prototype.iterator = function iterator(options) {
  if (!this.loaded)
    throw new Error('Database is closed.');

  return new Iterator(this, options);
};

/**
 * Get a database property.
 * @param {String} name - Property name.
 * @returns {String}
 */

LowlevelUp.prototype.getProperty = function getProperty(name) {
  if (!this.loaded)
    throw new Error('Database is closed.');

  if (!this.binding.getProperty)
    return '';

  return this.binding.getProperty(name);
};

/**
 * Calculate approximate database size.
 * @param {String|Buffer} start - Start key.
 * @param {String|Buffer} end - End key.
 * @returns {Promise} - Returns Number.
 */

LowlevelUp.prototype.approximateSize = function approximateSize(start, end) {
  return new Promise((resolve, reject) => {
    if (!this.loaded) {
      reject(new Error('Database is closed.'));
      return;
    }

    if (!this.binding.approximateSize) {
      reject(new Error('Cannot get size.'));
      return;
    }

    this.binding.approximateSize(start, end, co.wrap(resolve, reject));
  });
};

/**
 * Compact range of keys.
 * @param {String|Buffer|null} start - Start key.
 * @param {String|Buffer|null} end - End key.
 * @returns {Promise}
 */

LowlevelUp.prototype.compactRange = function compactRange(start, end) {
  if (!start)
    start = LOW;

  if (!end)
    end = HIGH;

  return new Promise((resolve, reject) => {
    if (!this.loaded) {
      reject(new Error('Database is closed.'));
      return;
    }

    if (!this.binding.compactRange) {
      resolve();
      return;
    }

    this.binding.compactRange(start, end, co.wrap(resolve, reject));
  });
};

/**
 * Test whether a key exists.
 * @method
 * @param {String} key
 * @returns {Promise} - Returns Boolean.
 */

LowlevelUp.prototype.has = async function has(key) {
  const value = await this.get(key);
  return value != null;
};

/**
 * Collect all keys from iterator options.
 * @method
 * @param {Object} options - Iterator options.
 * @returns {Promise} - Returns Array.
 */

LowlevelUp.prototype.range = async function range(options) {
  const items = [];
  const parse = options.parse;

  const iter = this.iterator({
    gte: options.gte,
    lte: options.lte,
    keys: true,
    values: true
  });

  for (;;) {
    let item = await iter.next();

    if (!item)
      break;

    if (parse) {
      try {
        item = parse(item.key, item.value);
      } catch (e) {
        await iter.end();
        throw e;
      }
    }

    if (item)
      items.push(item);
  }

  return items;
};

/**
 * Collect all keys from iterator options.
 * @method
 * @param {Object} options - Iterator options.
 * @returns {Promise}
 */

LowlevelUp.prototype.offset = async function offset(options) {
  const parse = options.parse;

  const iter = this.iterator({
    gte: options.gte,
    lte: options.lte,
    reverse: options.reverse,
    keys: true,
    values: false
  });

  for (;;) {
    const item = await iter.next();

    if (!item)
      break;

    let key = item.key;

    if (parse) {
      try {
        key = parse(key);
      } catch (e) {
        await iter.end();
        throw e;
      }
    }
    let stop = false;
    if (key)
      stop = await options.break(key);

    if (stop) {
      await iter.end();
      break;
    }
  }
  return;
};

/**
 * Collect all keys from iterator options.
 * @method
 * @param {Object} options - Iterator options.
 * @returns {Promise} - Returns Array.
 */

LowlevelUp.prototype.keys = async function keys(options) {
  const items = [];
  const parse = options.parse;

  const iter = this.iterator({
    gte: options.gte,
    lte: options.lte,
    limit: options.limit, // check this: add limit
    reverse: options.reverse, // check this: add reverse
    keys: true,
    values: false
  });

  for (;;) {
    const item = await iter.next();

    if (!item)
      break;

    let key = item.key;

    if (parse) {
      try {
        key = parse(key);
      } catch (e) {
        await iter.end();
        throw e;
      }
    }

    if (key)
      items.push(key);
  }

  return items;
};

/**
 * Collect all keys from iterator options.
 * @method
 * @param {Object} options - Iterator options.
 * @returns {Promise} - Returns Array.
 */

LowlevelUp.prototype.values = async function values(options) {
  const items = [];
  const parse = options.parse;

  const iter = this.iterator({
    gte: options.gte,
    lte: options.lte,
    keys: false,
    values: true
  });

  for (;;) {
    const item = await iter.next();

    if (!item)
      break;

    let value = item.value;

    if (parse) {
      try {
        value = parse(value);
      } catch (e) {
        await iter.end();
        throw e;
      }
    }

    if (value)
      items.push(value);
  }

  return items;
};

/**
 * Collect all keys from iterator options.
 * @method
 * @param {Object} options - Iterator options.
 * @returns {Promise} - Returns Number.
 */

LowlevelUp.prototype.count = async function count(options) {
  const iter = this.iterator({
    gte: options.gte,
    lte: options.lte,
    keys: true,
    values: false
  });

  let total = 0;
  for (;;) {
    const item = await iter.next();

    if (!item)
      break;

    total++;
  }

  return total;
};

/**
 * Dump database (for debugging).
 * @method
 * @returns {Promise} - Returns Object.
 */

LowlevelUp.prototype.dump = async function dump() {
  const records = Object.create(null);

  const items = await this.range({
    gte: LOW,
    lte: HIGH
  });

  for (const item of items) {
    const key = item.key.toString('hex');
    const value = item.value.toString('hex');
    records[key] = value;
  }

  return records;
};

/**
 * Write and assert a version number for the database.
 * @method
 * @param {Number} version
 * @returns {Promise}
 */

LowlevelUp.prototype.checkVersion = async function checkVersion(key, version) {
  let data = await this.get(key);

  if (!data) {
    data = Buffer.allocUnsafe(4);
    data.writeUInt32LE(version, 0, true);
    await this.put(key, data);
    return;
  }

  data = data.readUInt32LE(0, true);

  if (data !== version)
    throw new Error(VERSION_ERROR);
};

/**
 * Clone the database.
 * @method
 * @param {String} path
 * @returns {Promise}
 */

LowlevelUp.prototype.clone = async function clone(path) {
  if (!this.loaded)
    throw new Error('Database is closed.');

  const options = new LLUOptions(this.options);
  const hwm = 256 << 20;

  options.createIfMissing = true;
  options.errorIfExists = true;

  const tmp = new LowlevelUp(this.backend, path, options);

  await tmp.open();

  let batch = tmp.batch();
  let total = 0;

  const iter = this.iterator({
    keys: true,
    values: true
  });

  for (;;) {
    const item = await iter.next();

    if (!item)
      break;

    batch.put(item.key, item.value);
    total += item.value.length;

    if (total >= hwm) {
      total = 0;
      try {
        await batch.write();
      } catch (e) {
        await iter.end();
        await tmp.close();
        throw e;
      }
      batch = tmp.batch();
    }
  }

  try {
    await batch.write();
  } finally {
    await tmp.close();
  }
};

/**
 * Batch
 * @constructor
 * @ignore
 * @param {LowlevelUp} db
 */

function Batch(db) {
  this.batch = db.binding.batch();
}

/**
 * Write a value to the batch.
 * @param {String|Buffer} key
 * @param {Buffer} value
 */

Batch.prototype.put = function put(key, value) {
  if (!value)
    value = LOW;

  this.batch.put(key, value);

  return this;
};

/**
 * Delete a value from the batch.
 * @param {String|Buffer} key
 */

Batch.prototype.del = function del(key) {
  this.batch.del(key);
  return this;
};

/**
 * Write batch to database.
 * @returns {Promise}
 */

Batch.prototype.write = function write() {
  return new Promise((resolve, reject) => {
    this.batch.write(co.wrap(resolve, reject));
  });
};

/**
 * Clear the batch.
 */

Batch.prototype.clear = function clear() {
  this.batch.clear();
  return this;
};

/**
 * Iterator
 * @constructor
 * @ignore
 * @param {LowlevelUp} db
 * @param {Object} options
 */

function Iterator(db, options) {
  options = new IteratorOptions(options);
  options.keyAsBuffer = db.options.bufferKeys;

  this.iter = db.db.iterator(options);
}

/**
 * Seek to the next key.
 * @returns {Promise}
 */

Iterator.prototype.next = function next() {
  return new Promise((resolve, reject) => {
    this.iter.next((err, key, value) => {
      if (err) {
        this.iter.end(() => reject(err));
        return;
      }

      if (key === undefined && value === undefined) {
        this.iter.end(co.wrap(resolve, reject));
        return;
      }

      resolve(new IteratorItem(key, value));
    });
  });
};

/**
 * Seek to an arbitrary key.
 * @param {String|Buffer} key
 */

Iterator.prototype.seek = function seek(key) {
  this.iter.seek(key);
};

/**
 * End the iterator.
 * @returns {Promise}
 */

Iterator.prototype.end = function end() {
  return new Promise((resolve, reject) => {
    this.iter.end(co.wrap(resolve, reject));
  });
};

/**
 * Iterator Item
 * @ignore
 * @constructor
 * @param {String|Buffer} key
 * @param {String|Buffer} value
 * @property {String|Buffer} key
 * @property {String|Buffer} value
 */

function IteratorItem(key, value) {
  this.key = key;
  this.value = value;
}

/**
 * LowlevelUp Options
 * @constructor
 * @ignore
 * @param {Object} options
 */

function LLUOptions(options) {
  this.createIfMissing = true;
  this.errorIfExists = false;
  this.compression = true;
  this.cacheSize = 8 << 20;
  this.writeBufferSize = 4 << 20;
  this.maxOpenFiles = 64;
  this.maxFileSize = 2 << 20;
  this.paranoidChecks = false;
  this.memory = false;
  this.sync = false;
  this.mapSize = 256 * (1024 << 20);
  this.writeMap = false;
  this.noSubdir = true;
  this.bufferKeys = true;

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from options.
 * @private
 * @param {Object} options
 * @returns {LLUOptions}
 */

LLUOptions.prototype.fromOptions = function fromOptions(options) {
  assert(options, 'Options are required.');

  if (options.createIfMissing != null) {
    assert(typeof options.createIfMissing === 'boolean',
      '`createIfMissing` must be a boolean.');
    this.createIfMissing = options.createIfMissing;
  }

  if (options.errorIfExists != null) {
    assert(typeof options.errorIfExists === 'boolean',
      '`errorIfExists` must be a boolean.');
    this.errorIfExists = options.errorIfExists;
  }

  if (options.compression != null) {
    assert(typeof options.compression === 'boolean',
      '`compression` must be a boolean.');
    this.compression = options.compression;
  }

  if (options.cacheSize != null) {
    assert(typeof options.cacheSize === 'number',
      '`cacheSize` must be a number.');
    assert(options.cacheSize >= 0);
    this.cacheSize = Math.floor(options.cacheSize / 2);
    this.writeBufferSize = Math.floor(options.cacheSize / 4);
  }

  if (options.maxFiles != null) {
    assert(typeof options.maxFiles === 'number',
      '`maxFiles` must be a number.');
    assert(options.maxFiles >= 0);
    this.maxOpenFiles = options.maxFiles;
  }

  if (options.maxFileSize != null) {
    assert(typeof options.maxFileSize === 'number',
      '`maxFileSize` must be a number.');
    assert(options.maxFileSize >= 0);
    this.maxFileSize = options.maxFileSize;
  }

  if (options.paranoidChecks != null) {
    assert(typeof options.paranoidChecks === 'boolean',
      '`paranoidChecks` must be a boolean.');
    this.paranoidChecks = options.paranoidChecks;
  }

  if (options.memory != null) {
    assert(typeof options.memory === 'boolean',
      '`memory` must be a boolean.');
    this.memory = options.memory;
  }

  if (options.sync != null) {
    assert(typeof options.sync === 'boolean',
      '`sync` must be a boolean.');
    this.sync = options.sync;
  }

  if (options.mapSize != null) {
    assert(typeof options.mapSize === 'number',
      '`mapSize` must be a number.');
    assert(options.mapSize >= 0);
    this.mapSize = options.mapSize;
  }

  if (options.writeMap != null) {
    assert(typeof options.writeMap === 'boolean',
      '`writeMap` must be a boolean.');
    this.writeMap = options.writeMap;
  }

  if (options.noSubdir != null) {
    assert(typeof options.noSubdir === 'boolean',
      '`noSubdir` must be a boolean.');
    this.noSubdir = options.noSubdir;
  }

  if (options.bufferKeys != null) {
    assert(typeof options.bufferKeys === 'boolean',
      '`bufferKeys` must be a boolean.');
    this.bufferKeys = options.bufferKeys;
  }

  return this;
};

/**
 * Iterator Options
 * @constructor
 * @ignore
 * @param {Object} options
 */

function IteratorOptions(options) {
  this.gte = null;
  this.lte = null;
  this.keys = true;
  this.values = false;
  this.fillCache = false;
  this.keyAsBuffer = true;
  this.valueAsBuffer = true;
  this.reverse = false;
  this.highWaterMark = 16 * 1024;

  // Note: do not add this property.
  // this.limit = null;

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from options.
 * @private
 * @param {Object} options
 * @returns {IteratorOptions}
 */

IteratorOptions.prototype.fromOptions = function fromOptions(options) {
  assert(options, 'Options are required.');

  if (options.gte != null) {
    assert(Buffer.isBuffer(options.gte) || typeof options.gte === 'string');
    this.gte = options.gte;
  }

  if (options.lte != null) {
    assert(Buffer.isBuffer(options.lte) || typeof options.lte === 'string');
    this.lte = options.lte;
  }

  if (options.keys != null) {
    assert(typeof options.keys === 'boolean');
    this.keys = options.keys;
  }

  if (options.values != null) {
    assert(typeof options.values === 'boolean');
    this.values = options.values;
  }

  if (options.fillCache != null) {
    assert(typeof options.fillCache === 'boolean');
    this.fillCache = options.fillCache;
  }

  if (options.keyAsBuffer != null) {
    assert(typeof options.keyAsBuffer === 'boolean');
    this.keyAsBuffer = options.keyAsBuffer;
  }

  if (options.valueAsBuffer != null) {
    assert(typeof options.valueAsBuffer === 'boolean');
    this.valueAsBuffer = options.valueAsBuffer;
  }

  if (options.reverse != null) {
    assert(typeof options.reverse === 'boolean');
    this.reverse = options.reverse;
  }

  if (options.limit != null) {
    assert(typeof options.limit === 'number');
    assert(options.limit >= 0);
    this.limit = options.limit;
  }

  if (!this.keys && !this.values)
    throw new Error('Keys and/or values must be chosen.');

  return this;
};

/*
 * Helpers
 */

function isNotFound(err) {
  if (!err)
    return false;

  return err.notFound
    || err.type === 'NotFoundError'
    || /not\s*found/i.test(err.message);
}

VERSION_ERROR = 'Warning:'
  + ' Your database does not match the current database version.'
  + ' This is likely because the database layout or serialization'
  + ' format has changed drastically. If you want to dump your'
  + ' data, downgrade to your previous version first. If you do'
  + ' not think you should be seeing this error, post an issue on'
  + ' the repo.';

/*
 * Expose
 */

module.exports = LowlevelUp;


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * backends.js - database backends for wmcc_core.
 */



exports.get = function get(name) {
  try {
    switch (name) {
      case 'leveldown':
        return __webpack_require__(263);
      case 'rocksdown':
        return __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"rocksdown\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
      case 'lmdb':
        return __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"lmdb\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
      case 'memory':
        return __webpack_require__(202);
      default:
        throw new Error(`Database backend "${name}" not found.`);
    }
  } catch (e) {
    if (e.code === 'MODULE_NOT_FOUND')
      throw new Error(`Database backend "${name}" not found.`);
    throw e;
  }
};


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * memdb.js - in-memory database for wmcc_core.
 */



const assert = __webpack_require__(0);
const RBT = __webpack_require__(203);
const DUMMY = Buffer.alloc(0);

/**
 * In memory database for wmcc_core
 * using a red-black tree backend.
 * @alias module:db.MemDB
 * @constructor
 * @param {String?} location - Phony location.
 * @param {Object?} options
 * @param {Function} options.compare - Comparator.
 */

function MemDB(location) {
  if (!(this instanceof MemDB))
    return new MemDB(location);

  this.location = location || 'memory';
  this.options = {};
  this.tree = new RBT(cmp, true);
}

/**
 * Do a key lookup.
 * @private
 * @param {Buffer|String} key
 * @returns {Buffer?} value
 */

MemDB.prototype.search = function search(key) {
  if (typeof key === 'string')
    key = Buffer.from(key, 'utf8');

  assert(Buffer.isBuffer(key), 'Key must be a Buffer.');

  const node = this.tree.search(key);

  if (!node)
    return undefined;

  return node.value;
};

/**
 * Insert a record.
 * @private
 * @param {Buffer|String} key
 * @param {Buffer} value
 */

MemDB.prototype.insert = function insert(key, value) {
  if (typeof key === 'string')
    key = Buffer.from(key, 'utf8');

  if (typeof value === 'string')
    value = Buffer.from(value, 'utf8');

  if (value == null)
    value = DUMMY;

  assert(Buffer.isBuffer(key), 'Key must be a Buffer.');
  assert(Buffer.isBuffer(value), 'Value must be a Buffer.');

  return this.tree.insert(key, value) != null;
};

/**
 * Remove a record.
 * @private
 * @param {Buffer|String} key
 * @returns {Boolean}
 */

MemDB.prototype.remove = function remove(key) {
  if (typeof key === 'string')
    key = Buffer.from(key, 'utf8');

  assert(Buffer.isBuffer(key), 'Key must be a Buffer.');

  return this.tree.remove(key) != null;
};

/**
 * Traverse between a range of keys and collect records.
 * @private
 * @param {Buffer} min
 * @param {Buffer} max
 * @returns {RBTData[]} Records.
 */

MemDB.prototype.range = function range(min, max) {
  if (typeof min === 'string')
    min = Buffer.from(min, 'utf8');

  if (typeof max === 'string')
    max = Buffer.from(max, 'utf8');

  assert(!min || Buffer.isBuffer(min), 'Key must be a Buffer.');
  assert(!max || Buffer.isBuffer(max), 'Key must be a Buffer.');

  return this.tree.range(min, max);
};

/**
 * Open the database (leveldown method).
 * @param {Object?} options
 * @param {Function} callback
 */

MemDB.prototype.open = function open(options, callback) {
  if (!callback) {
    callback = options;
    options = null;
  }

  if (!options)
    options = {};

  this.options = options;

  setImmediate(callback);
};

/**
 * Close the database (leveldown method).
 * @param {Function} callback
 */

MemDB.prototype.close = function close(callback) {
  setImmediate(callback);
};

/**
 * Retrieve a record (leveldown method).
 * @param {Buffer|String} key
 * @param {Object?} options
 * @param {Function} callback - Returns Buffer.
 */

MemDB.prototype.get = function get(key, options, callback) {
  if (!callback) {
    callback = options;
    options = null;
  }

  if (!options)
    options = {};

  let value = this.search(key);

  if (!value) {
    const err = new Error('MEMDB_NOTFOUND: Key not found.');
    err.notFound = true;
    err.type = 'NotFoundError';
    setImmediate(() => callback(err));
    return;
  }

  if (options.asBuffer === false)
    value = value.toString('utf8');

  setImmediate(() => callback(null, value));
};

/**
 * Insert a record (leveldown method).
 * @param {Buffer|String} key
 * @param {Buffer} value
 * @param {Object?} options
 * @param {Function} callback
 */

MemDB.prototype.put = function put(key, value, options, callback) {
  if (!callback) {
    callback = options;
    options = null;
  }

  this.insert(key, value);

  setImmediate(callback);
};

/**
 * Remove a record (leveldown method).
 * @param {Buffer|String} key
 * @param {Object?} options
 * @param {Function} callback
 */

MemDB.prototype.del = function del(key, options, callback) {
  if (!callback) {
    callback = options;
    options = null;
  }

  this.remove(key);

  setImmediate(callback);
};

/**
 * Create an atomic batch (leveldown method).
 * @see Leveldown.Batch
 * @param {Object[]?} ops
 * @param {Object?} options
 * @param {Function} callback
 */

MemDB.prototype.batch = function batch(ops, options, callback) {
  if (!callback) {
    callback = options;
    options = null;
  }

  const b = new Batch(this, options);

  if (ops) {
    b.ops = ops;
    b.write(callback);
    return undefined;
  }

  return b;
};

/**
 * Create an iterator (leveldown method).
 * @param {Object} options - See {Leveldown.Iterator}.
 * @returns {Leveldown.Iterator}.
 */

MemDB.prototype.iterator = function iterator(options) {
  return new Iterator(this, options);
};

/**
 * Get a database property (leveldown method) (NOP).
 * @param {String} name - Property name.
 * @returns {String}
 */

MemDB.prototype.getProperty = function getProperty(name) {
  return '';
};

/**
 * Calculate approximate database size (leveldown method).
 * @param {Buffer|String} start - Start key.
 * @param {Buffer|String} end - End key.
 * @param {Function} callback - Returns Number.
 */

MemDB.prototype.approximateSize = function approximateSize(start, end, callback) {
  const items = this.range(start, end);
  let size = 0;

  for (const item of items) {
    size += item.key.length;
    size += item.value.length;
  }

  setImmediate(() => callback(null, size));
};

/**
 * Destroy the database (leveldown function) (NOP).
 * @param {String} location
 * @param {Function} callback
 */

MemDB.destroy = function destroy(location, callback) {
  setImmediate(callback);
};

/**
 * Repair the database (leveldown function) (NOP).
 * @param {String} location
 * @param {Function} callback
 */

MemDB.repair = function repair(location, callback) {
  setImmediate(callback);
};

/**
 * Batch
 * @constructor
 * @ignore
 * @private
 * @param {MemDB} db
 * @param {Object?} options
 */

function Batch(db, options) {
  this.options = options || {};
  this.ops = [];
  this.db = db;
  this.written = false;
}

/**
 * Insert a record.
 * @param {Buffer|String} key
 * @param {Buffer} value
 */

Batch.prototype.put = function put(key, value) {
  assert(!this.written, 'Already written.');
  this.ops.push(new BatchOp('put', key, value));
  return this;
};

/**
 * Remove a record.
 * @param {Buffer|String} key
 */

Batch.prototype.del = function del(key) {
  assert(!this.written, 'Already written.');
  this.ops.push(new BatchOp('del', key));
  return this;
};

/**
 * Commit the batch.
 * @param {Function} callback
 */

Batch.prototype.write = function write(callback) {
  if (this.written) {
    setImmediate(() => callback(new Error('Already written.')));
    return this;
  }

  for (const op of this.ops) {
    switch (op.type) {
      case 'put':
        this.db.insert(op.key, op.value);
        break;
      case 'del':
        this.db.remove(op.key);
        break;
      default:
        setImmediate(() => callback(new Error('Bad op.')));
        return this;
    }
  }

  this.ops = [];
  this.written = true;

  setImmediate(callback);

  return this;
};

/**
 * Clear batch of all ops.
 */

Batch.prototype.clear = function clear() {
  assert(!this.written, 'Already written.');
  this.ops = [];
  return this;
};

/**
 * Batch Operation
 * @constructor
 * @ignore
 * @private
 * @param {String} type
 * @param {Buffer} key
 * @param {Buffer|null} value
 */

function BatchOp(type, key, value) {
  this.type = type;
  this.key = key;
  this.value = value;
}

/**
 * Iterator
 * @constructor
 * @ignore
 * @private
 * @param {RBT} db
 * @param {Object?} options
 */

function Iterator(db, options) {
  this.db = db;
  this.options = new IteratorOptions(options);
  this.iter = null;
  this.ended = false;
  this.total = 0;
  this.init();
}

/**
 * Initialize the iterator.
 */

Iterator.prototype.init = function init() {
  const snapshot = this.db.tree.snapshot();
  const iter = this.db.tree.iterator(snapshot);

  if (this.options.reverse) {
    if (this.options.end) {
      iter.seekMax(this.options.end);
      if (this.options.lt && iter.valid()) {
        if (iter.compare(this.options.end) === 0)
          iter.prev();
      }
    } else {
      iter.seekLast();
    }
  } else {
    if (this.options.start) {
      iter.seekMin(this.options.start);
      if (this.options.gt && iter.valid()) {
        if (iter.compare(this.options.start) === 0)
          iter.next();
      }
    } else {
      iter.seekFirst();
    }
  }

  this.iter = iter;
};

/**
 * Seek to the next key.
 * @param {Function} callback
 */

Iterator.prototype.next = function next(callback) {
  const options = this.options;
  const iter = this.iter;

  if (!this.iter) {
    setImmediate(() => callback(new Error('Cannot call next.')));
    return;
  }

  let result;
  if (options.reverse) {
    result = iter.prev();

    // Stop once we hit a key below our gte key.
    if (result && options.start) {
      if (options.gt) {
        if (iter.compare(options.start) <= 0)
          result = false;
      } else {
        if (iter.compare(options.start) < 0)
          result = false;
      }
    }
  } else {
    result = iter.next();

    // Stop once we hit a key above our lte key.
    if (result && options.end) {
      if (options.lt) {
        if (iter.compare(options.end) >= 0)
          result = false;
      } else {
        if (iter.compare(options.end) > 0)
          result = false;
      }
    }
  }

  if (!result) {
    this.iter = null;
    setImmediate(callback);
    return;
  }

  if (options.limit !== -1) {
    if (this.total >= options.limit) {
      this.iter = null;
      setImmediate(callback);
      return;
    }
    this.total += 1;
  }

  let key = iter.key;
  let value = iter.value;

  if (!options.keys)
    key = DUMMY;

  if (!options.values)
    value = DUMMY;

  if (!options.keyAsBuffer)
    key = key.toString('utf8');

  if (!options.valueAsBuffer)
    value = value.toString('utf8');

  setImmediate(() => callback(null, key, value));
};

/**
 * Seek to a key gte to `key`.
 * @param {String|Buffer} key
 */

Iterator.prototype.seek = function seek(key) {
  assert(this.iter, 'Already ended.');

  if (typeof key === 'string')
    key = Buffer.from(key, 'utf8');

  assert(Buffer.isBuffer(key), 'Key must be a Buffer.');

  if (this.options.reverse)
    this.iter.seekMax(key);
  else
    this.iter.seekMin(key);
};

/**
 * End the iterator. Free up snapshot.
 * @param {Function} callback
 */

Iterator.prototype.end = function end(callback) {
  if (this.ended) {
    setImmediate(() => callback(new Error('Already ended.')));
    return;
  }

  this.ended = true;
  this.iter = null;

  setImmediate(callback);
};

/**
 * Iterator Options
 * @constructor
 * @ignore
 * @param {Object} options
 */

function IteratorOptions(options) {
  this.keys = true;
  this.values = true;
  this.start = null;
  this.end = null;
  this.gt = false;
  this.lt = false;
  this.keyAsBuffer = true;
  this.valueAsBuffer = true;
  this.reverse = false;
  this.limit = -1;

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from options.
 * @private
 * @param {Object} options
 * @returns {IteratorOptions}
 */

IteratorOptions.prototype.fromOptions = function fromOptions(options) {
  if (options.keys != null) {
    assert(typeof options.keys === 'boolean');
    this.keys = options.keys;
  }

  if (options.values != null) {
    assert(typeof options.values === 'boolean');
    this.values = options.values;
  }

  if (options.start != null)
    this.start = options.start;

  if (options.end != null)
    this.end = options.end;

  if (options.gte != null)
    this.start = options.gte;

  if (options.lte != null)
    this.end = options.lte;

  if (options.gt != null) {
    this.gt = true;
    this.start = options.gt;
  }

  if (options.lt != null) {
    this.lt = true;
    this.end = options.lt;
  }

  if (this.start != null) {
    if (typeof this.start === 'string')
      this.start = Buffer.from(this.start, 'utf8');
    assert(Buffer.isBuffer(this.start), '`start` must be a Buffer.');
  }

  if (this.end != null) {
    if (typeof this.end === 'string')
      this.end = Buffer.from(this.end, 'utf8');
    assert(Buffer.isBuffer(this.end), '`end` must be a Buffer.');
  }

  if (options.keyAsBuffer != null) {
    assert(typeof options.keyAsBuffer === 'boolean');
    this.keyAsBuffer = options.keyAsBuffer;
  }

  if (options.valueAsBuffer != null) {
    assert(typeof options.valueAsBuffer === 'boolean');
    this.valueAsBuffer = options.valueAsBuffer;
  }

  if (options.reverse != null) {
    assert(typeof options.reverse === 'boolean');
    this.reverse = options.reverse;
  }

  if (options.limit != null) {
    assert(typeof options.limit === 'number');
    this.limit = options.limit;
  }

  return this;
};

/*
 * Helpers
 */

function cmp(a, b) {
  return a.compare(b);
}

/*
 * Expose
 */

module.exports = MemDB;


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * rbt.js - iterative red black tree for wmcc_core.
 */



const assert = __webpack_require__(0);
const RED = 0;
const BLACK = 1;
let SENTINEL;

/**
 * An iterative red black tree.
 * @alias module:utils.RBT
 * @constructor
 * @param {Function} compare - Comparator.
 * @param {Boolean?} unique
 */

function RBT(compare, unique) {
  if (!(this instanceof RBT))
    return new RBT(compare, unique);

  assert(typeof compare === 'function');

  this.root = SENTINEL;
  this.compare = compare;
  this.unique = unique || false;
}

/**
 * Clear the tree.
 */

RBT.prototype.reset = function reset() {
  this.root = SENTINEL;
};

/**
 * Do a key lookup.
 * @param {Buffer|String} key
 * @returns {Buffer?} value
 */

RBT.prototype.search = function search(key) {
  let current = this.root;

  while (!current.isNull()) {
    const cmp = this.compare(key, current.key);

    if (cmp === 0)
      return current;

    if (cmp < 0)
      current = current.left;
    else
      current = current.right;
  }

  return null;
};

/**
 * Insert a record.
 * @param {Buffer|String} key
 * @param {Buffer} value
 */

RBT.prototype.insert = function insert(key, value) {
  let current = this.root;
  let left = false;
  let parent;

  while (!current.isNull()) {
    const cmp = this.compare(key, current.key);

    if (this.unique && cmp === 0) {
      current.key = key;
      current.value = value;
      return current;
    }

    parent = current;

    if (cmp < 0) {
      left = true;
      current = current.left;
    } else {
      left = false;
      current = current.right;
    }
  }

  const node = new RBTNode(key, value);

  if (!parent) {
    this.root = node;
    this.insertFixup(node);
    return node;
  }

  node.parent = parent;

  if (left)
    parent.left = node;
  else
    parent.right = node;

  this.insertFixup(node);

  return node;
};

/**
 * Repaint necessary nodes after insertion.
 * @private
 * @param {RBTNode} x
 */

RBT.prototype.insertFixup = function insertFixup(x) {
  x.color = RED;

  while (x !== this.root && x.parent.color === RED) {
    if (x.parent === x.parent.parent.left) {
      const y = x.parent.parent.right;
      if (!y.isNull() && y.color === RED) {
        x.parent.color = BLACK;
        y.color = BLACK;
        x.parent.parent.color = RED;
        x = x.parent.parent;
      } else {
        if (x === x.parent.right) {
          x = x.parent;
          this.rotl(x);
        }
        x.parent.color = BLACK;
        x.parent.parent.color = RED;
        this.rotr(x.parent.parent);
      }
    } else {
      const y = x.parent.parent.left;
      if (!y.isNull() && y.color === RED) {
        x.parent.color = BLACK;
        y.color = BLACK;
        x.parent.parent.color = RED;
        x = x.parent.parent;
      } else {
        if (x === x.parent.left) {
          x = x.parent;
          this.rotr(x);
        }
        x.parent.color = BLACK;
        x.parent.parent.color = RED;
        this.rotl(x.parent.parent);
      }
    }
  }

  this.root.color = BLACK;
};

/**
 * Remove a record.
 * @param {Buffer|String} key
 * @returns {Boolean}
 */

RBT.prototype.remove = function remove(key) {
  let current = this.root;

  while (!current.isNull()) {
    const cmp = this.compare(key, current.key);

    if (cmp === 0) {
      this.removeNode(current);
      return current;
    }

    if (cmp < 0)
      current = current.left;
    else
      current = current.right;
  }

  return null;
};

/**
 * Remove a single node.
 * @private
 * @param {RBTNode} z
 */

RBT.prototype.removeNode = function removeNode(z) {
  let y = z;

  if (!z.left.isNull() && !z.right.isNull())
    y = this.successor(z);

  const x = y.left.isNull() ? y.right : y.left;
  x.parent = y.parent;

  if (y.parent.isNull()) {
    this.root = x;
  } else {
    if (y === y.parent.left)
      y.parent.left = x;
    else
      y.parent.right = x;
  }

  if (y !== z) {
    z.key = y.key;
    z.value = y.value;
  }

  if (y.color === BLACK)
    this.removeFixup(x);
};

/**
 * Repaint necessary nodes after removal.
 * @private
 * @param {RBTNode} x
 */

RBT.prototype.removeFixup = function removeFixup(x) {
  while (x !== this.root && x.color === BLACK) {
    if (x === x.parent.left) {
      let w = x.parent.right;

      if (w.color === RED) {
        w.color = BLACK;
        x.parent.color = RED;
        this.rotl(x.parent);
        w = x.parent.right;
      }

      if (w.left.color === BLACK && w.right.color === BLACK) {
        w.color = RED;
        x = x.parent;
      } else {
        if (w.right.color === BLACK) {
          w.left.color = BLACK;
          w.color = RED;
          this.rotr(w);
          w = x.parent.right;
        }
        w.color = x.parent.color;
        x.parent.color = BLACK;
        w.right.color = BLACK;
        this.rotl(x.parent);
        x = this.root;
      }
    } else {
      let w = x.parent.left;

      if (w.color === RED) {
        w.color = BLACK;
        x.parent.color = RED;
        this.rotr(x.parent);
        w = x.parent.left;
      }

      if (w.right.color === BLACK && w.left.color === BLACK) {
        w.color = RED;
        x = x.parent;
      } else {
        if (w.left.color === BLACK) {
          w.right.color = BLACK;
          w.color = RED;
          this.rotl(w);
          w = x.parent.left;
        }
        w.color = x.parent.color;
        x.parent.color = BLACK;
        w.left.color = BLACK;
        this.rotr(x.parent);
        x = this.root;
      }
    }
  }

  x.color = BLACK;
};

/**
 * Do a left rotate.
 * @private
 * @param {RBTNode} x
 */

RBT.prototype.rotl = function rotl(x) {
  const y = x.right;

  x.right = y.left;

  if (!y.left.isNull())
    y.left.parent = x;

  y.parent = x.parent;

  if (x.parent.isNull()) {
    this.root = y;
  } else {
    if (x === x.parent.left)
      x.parent.left = y;
    else
      x.parent.right = y;
  }

  y.left = x;
  x.parent = y;
};

/**
 * Do a right rotate.
 * @private
 * @param {RBTNode} x
 */

RBT.prototype.rotr = function rotr(x) {
  const y = x.left;

  x.left = y.right;

  if (!y.right.isNull())
    y.right.parent = x;

  y.parent = x.parent;

  if (x.parent.isNull()) {
    this.root = y;
  } else {
    if (x === x.parent.right)
      x.parent.right = y;
    else
      x.parent.left = y;
  }

  y.right = x;
  x.parent = y;
};

/**
 * Minimum subtree.
 * @private
 * @param {RBTNode} z
 * @returns {RBTNode}
 */

RBT.prototype.min = function min(z) {
  if (z.isNull())
    return z;

  while (!z.left.isNull())
    z = z.left;

  return z;
};

/**
 * Maximum subtree.
 * @private
 * @param {RBTNode} z
 * @returns {RBTNode}
 */

RBT.prototype.max = function max(z) {
  if (z.isNull())
    return z;

  while (!z.right.isNull())
    z = z.right;

  return z;
};

/**
 * Successor node.
 * @private
 * @param {RBTNode} x
 * @returns {RBTNode}
 */

RBT.prototype.successor = function successor(x) {
  if (!x.right.isNull()) {
    x = x.right;

    while (!x.left.isNull())
      x = x.left;

    return x;
  }

  let y = x.parent;
  while (!y.isNull() && x === y.right) {
    x = y;
    y = y.parent;
  }

  return y;
};

/**
 * Predecessor node.
 * @private
 * @param {RBTNode} x
 * @returns {RBTNode}
 */

RBT.prototype.predecessor = function predecessor(x) {
  if (!x.left.isNull()) {
    x = x.left;

    while (!x.right.isNull())
      x = x.right;

    return x;
  }

  let y = x.parent;
  while (!y.isNull() && x === y.left) {
    x = y;
    y = y.parent;
  }

  return y;
};

/**
 * Take a snapshot and return
 * a cloned root node (iterative).
 * @returns {RBTNode}
 */

RBT.prototype.clone = function clone() {
  if (this.root.isNull())
    return SENTINEL;

  const stack = [];

  let current = this.root;
  let left = true;
  let parent, snapshot;

  for (;;) {
    if (!current.isNull()) {
      const copy = current.clone();

      if (parent)
        copy.parent = parent;

      if (left) {
        if (parent)
          parent.left = copy;
        else
          snapshot = copy;
      } else {
        if (parent)
          parent.right = copy;
        else
          snapshot = copy;
      }

      stack.push(copy);
      parent = copy;
      left = true;
      current = current.left;
      continue;
    }

    if (stack.length === 0)
      break;

    current = stack.pop();
    parent = current;
    left = false;
    current = current.right;
  }

  assert(snapshot);

  return snapshot;
};

/**
 * Take a snapshot and return
 * a cloned root node (recursive).
 * @returns {RBTNode}
 */

RBT.prototype.snapshot = function snapshot() {
  if (this.root.isNull())
    return SENTINEL;

  const node = this.root.clone();

  copyLeft(node, node.left);
  copyRight(node, node.right);

  return node;
};

/**
 * Create an iterator.
 * @param {RBTNode?} snapshot
 * @returns {Iterator}
 */

RBT.prototype.iterator = function iterator(snapshot) {
  return new Iterator(this, snapshot || this.root);
};

/**
 * Traverse between a range of keys and collect records.
 * @param {Buffer} min
 * @param {Buffer} max
 * @returns {RBTNode[]} Records.
 */

RBT.prototype.range = function range(min, max) {
  const iter = this.iterator();
  const items = [];

  if (min)
    iter.seekMin(min);
  else
    iter.seekFirst();

  while (iter.next()) {
    if (max && iter.compare(max) > 0)
      break;

    items.push(iter.data());
  }

  return items;
};

/**
 * Iterator
 * @constructor
 * @ignore
 * @param {RBT} tree
 * @param {RBTNode} snapshot
 * @property {RBT} tree
 * @property {RBTNode} current
 * @property {Object} key
 * @property {Object} value
 */

function Iterator(tree, snapshot) {
  this.tree = tree;
  this.root = snapshot;
  this.current = snapshot;
  this.key = null;
  this.value = null;
}

/**
 * Compare keys using tree's comparator.
 * @param {Object} key
 */

Iterator.prototype.compare = function compare(key) {
  assert(this.key != null, 'No key.');
  return this.tree.compare(this.key, key);
};

/**
 * Test whether current node is valid.
 */

Iterator.prototype.valid = function valid() {
  return !this.current.isNull();
};

/**
 * Seek to the root.
 */

Iterator.prototype.reset = function reset() {
  this.current = this.root;
  this.key = null;
  this.value = null;
};

/**
 * Seek to the start of the tree.
 */

Iterator.prototype.seekFirst = function seekFirst() {
  this.current = this.tree.min(this.root);
  this.key = this.current.key;
  this.value = this.current.value;
};

/**
 * Seek to the end of the tree.
 */

Iterator.prototype.seekLast = function seekLast() {
  this.current = this.tree.max(this.root);
  this.key = this.current.key;
  this.value = this.current.value;
};

/**
 * Seek to a key from the current node (gte).
 * @param {String} key
 */

Iterator.prototype.seek = function seek(key) {
  return this.seekMin(key);
};

/**
 * Seek to a key from the current node (gte).
 * @param {String} key
 */

Iterator.prototype.seekMin = function seekMin(key) {
  assert(key != null, 'No key passed to seek.');

  let root = this.current;
  let current = SENTINEL;

  while (!root.isNull()) {
    const cmp = this.tree.compare(root.key, key);

    if (cmp === 0) {
      current = root;
      break;
    }

    if (cmp > 0) {
      current = root;
      root = root.left;
    } else {
      root = root.right;
    }
  }

  this.current = current;
  this.key = current.key;
  this.value = current.value;
};

/**
 * Seek to a key from the current node (lte).
 * @param {String} key
 */

Iterator.prototype.seekMax = function seekMax(key) {
  assert(key != null, 'No key passed to seek.');

  let root = this.current;
  let current = SENTINEL;

  while (!root.isNull()) {
    const cmp = this.tree.compare(root.key, key);

    if (cmp === 0) {
      current = root;
      break;
    }

    if (cmp < 0) {
      current = root;
      root = root.right;
    } else {
      root = root.left;
    }
  }

  this.current = current;
  this.key = current.key;
  this.value = current.value;
};

/**
 * Seek to previous node.
 * @param {String} key
 */

Iterator.prototype.prev = function prev() {
  if (this.current.isNull()) {
    this.key = null;
    this.value = null;
    return false;
  }

  this.key = this.current.key;
  this.value = this.current.value;
  this.current = this.tree.predecessor(this.current);

  return true;
};

/**
 * Seek to next node.
 * @returns {Boolean}
 */

Iterator.prototype.next = function next() {
  if (this.current.isNull()) {
    this.key = null;
    this.value = null;
    return false;
  }

  this.key = this.current.key;
  this.value = this.current.value;
  this.current = this.tree.successor(this.current);

  return true;
};

/**
 * Return the current key/value pair.
 * @returns {RBTData}
 */

Iterator.prototype.data = function data() {
  assert(this.key != null, 'No data available.');
  return new RBTData(this.key, this.value);
};

/**
 * RBT Node
 * @constructor
 * @ignore
 * @private
 * @param {Buffer} key
 * @param {Buffer} value
 * @property {Buffer} key
 * @property {Buffer} value
 * @property {Number} color
 * @property {RBTNode|RBTSentinel} parent
 * @property {RBTNode|RBTSentinel} left
 * @property {RBTNode|RBTSentinel} right
 */

function RBTNode(key, value) {
  this.key = key;
  this.value = value;
  this.color = RED;
  this.parent = SENTINEL;
  this.left = SENTINEL;
  this.right = SENTINEL;
}

/**
 * Clone the node.
 * @returns {RBTNode}
 */

RBTNode.prototype.clone = function clone() {
  const node = new RBTNode(this.key, this.value);
  node.color = this.color;
  node.parent = this.parent;
  node.left = this.left;
  node.right = this.right;
  return node;
};

/**
 * Clone the node (key/value only).
 * @returns {RBTData}
 */

RBTNode.prototype.copy = function copy() {
  return new RBTData(this.key, this.value);
};

/**
 * Inspect the rbt node.
 * @returns {Object}
 */

RBTNode.prototype.inspect = function inspect() {
  return {
    key: this.key,
    value: this.value,
    color: this.color === RED ? 'red' : 'black',
    left: this.left,
    right: this.right
  };
};

/**
 * Test whether the node is a leaf.
 * Always returns false.
 * @returns {Boolean}
 */

RBTNode.prototype.isNull = function isNull() {
  return false;
};

/**
 * RBT Sentinel Node
 * @constructor
 * @ignore
 * @property {null} key
 * @property {null} value
 * @property {Number} [color=BLACK]
 * @property {null} parent
 * @property {null} left
 * @property {null} right
 */

function RBTSentinel() {
  this.key = null;
  this.value = null;
  this.color = BLACK;
  this.parent = null;
  this.left = null;
  this.right = null;
}

/**
 * Inspect the rbt node.
 * @returns {String}
 */

RBTSentinel.prototype.inspect = function inspect() {
  return 'NIL';
};

/**
 * Test whether the node is a leaf.
 * Always returns true.
 * @returns {Boolean}
 */

RBTSentinel.prototype.isNull = function isNull() {
  return true;
};

/**
 * RBT key/value pair
 * @constructor
 * @ignore
 * @param {Buffer} key
 * @param {Buffer} value
 * @property {Buffer} key
 * @property {Buffer} value
 */

function RBTData(key, value) {
  this.key = key;
  this.value = value;
}

/**
 * Inspect the rbt data.
 * @returns {Object}
 */

RBTData.prototype.inspect = function inspect() {
  return {
    key: this.key,
    value: this.value
  };
};

/*
 * Helpers
 */

SENTINEL = new RBTSentinel();

function copyLeft(parent, node) {
  if (!node.isNull()) {
    parent.left = node.clone();
    parent.left.parent = parent;
    copyLeft(parent.left, node.left);
    copyRight(parent.left, node.right);
  }
}

function copyRight(parent, node) {
  if (!node.isNull()) {
    parent.right = node.clone();
    parent.right.parent = parent;
    copyLeft(parent.right, node.left);
    copyRight(parent.right, node.right);
  }
}

/*
 * Expose
 */

module.exports = RBT;


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * layout.js - blockchain data layout for wmcc_core.
 */



const assert = __webpack_require__(0);

/*
 * Database Layout:
 *   R -> tip hash
 *   O -> chain options
 *   e[hash] -> entry
 *   h[hash] -> height
 *   H[height] -> hash
 *   n[hash] -> next hash
 *   p[hash] -> tip index
 *   b[hash] -> block
 *   t[hash] -> extended tx
 *   c[hash] -> coins
 *   u[hash] -> undo coins
 *   v -> versionbits deployments
 *   v[bit][hash] -> versionbits state
 *   T[addr-hash][hash] -> dummy (tx by address)
 *   C[addr-hash][hash][index] -> dummy (coin by address)
 *   W+T[witaddr-hash][hash] -> dummy (tx by address)
 *   W+C[witaddr-hash][hash][index] -> dummy (coin by address)
 */

const layout = {
  binary: true,
  R: Buffer.from([0x52]),
  O: Buffer.from([0x4f]),
  V: Buffer.from([0x76]),
  e: function e(hash) {
    return pair(0x65, hash);
  },
  h: function h(hash) {
    return pair(0x68, hash);
  },
  H: function H(height) {
    return ipair(0x48, height);
  },
  n: function n(hash) {
    return pair(0x6e, hash);
  },
  p: function p(hash) {
    return pair(0x70, hash);
  },
  b: function b(hash) {
    return pair(0x62, hash);
  },
  t: function t(hash) {
    return pair(0x74, hash);
  },
  c: function c(hash, index) {
    return bpair(0x63, hash, index);
  },
  u: function u(hash) {
    return pair(0x75, hash);
  },
  v: function v(bit, hash) {
    const key = Buffer.allocUnsafe(1 + 1 + 32);
    assert(typeof bit === 'number');
    key[0] = 0x76;
    key[1] = bit;
    write(key, hash, 2);
    return key;
  },
  vv: function vv(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length === 34);
    return [key[1], key.toString('hex', 2, 34)];
  },
  T: function T(addr, hash) {
    let len = addr.length;

    if (typeof addr === 'string')
      len /= 2;

    let key;
    if (len === 32) {
      key = Buffer.allocUnsafe(65);
      key[0] = 0xab; // W + T
      write(key, addr, 1);
      write(key, hash, 33);
    } else if (len === 20) {
      key = Buffer.allocUnsafe(53);
      key[0] = 0x54; // T
      write(key, addr, 1);
      write(key, hash, 21);
    } else {
      assert(false);
    }

    return key;
  },
  C: function C(addr, hash, index) {
    let len = addr.length;

    assert(typeof index === 'number');

    if (typeof addr === 'string')
      len /= 2;

    let key;
    if (len === 32) {
      key = Buffer.allocUnsafe(69);
      key[0] = 0x9a; // W + C
      write(key, addr, 1);
      write(key, hash, 33);
      key.writeUInt32BE(index, 65, true);
    } else if (len === 20) {
      key = Buffer.allocUnsafe(57);
      key[0] = 0x43; // C
      write(key, addr, 1);
      write(key, hash, 21);
      key.writeUInt32BE(index, 53, true);
    } else {
      assert(false);
    }

    return key;
  },
  pp: function pp(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length === 33);
    return key.toString('hex', 1, 33);
  },
  Cc: function Cc(key) {
    assert(Buffer.isBuffer(key));

    let hash, index;
    if (key.length === 69) {
      hash = key.toString('hex', 33, 65);
      index = key.readUInt32BE(65, 0);
    } else if (key.length === 57) {
      hash = key.toString('hex', 21, 53);
      index = key.readUInt32BE(53, 0);
    } else {
      assert(false);
    }

    return [hash, index];
  },
  Tt: function Tt(key) {
    assert(Buffer.isBuffer(key));

    if (key.length === 65)
      return key.toString('hex', 33, 65);

    assert(key.length === 53);
    return key.toString('hex', 21, 53);
  }
};

/*
 * Helpers
 */

function write(data, str, off) {
  if (Buffer.isBuffer(str))
    return str.copy(data, off);
  assert(typeof str === 'string');
  return data.write(str, off, 'hex');
}

function pair(prefix, hash) {
  const key = Buffer.allocUnsafe(33);
  key[0] = prefix;
  write(key, hash, 1);
  return key;
}

function ipair(prefix, num) {
  const key = Buffer.allocUnsafe(5);
  assert(typeof num === 'number');
  key[0] = prefix;
  key.writeUInt32BE(num, 1, true);
  return key;
}

function bpair(prefix, hash, index) {
  const key = Buffer.allocUnsafe(37);
  assert(typeof index === 'number');
  key[0] = prefix;
  write(key, hash, 1);
  key.writeUInt32BE(index, 33, true);
  return key;
}

/*
 * Expose
 */

module.exports = layout;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * uri.js - WMCC uri parsing for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const Address = __webpack_require__(11);
const Amount = __webpack_require__(20);

/**
 * Represents a WMCC URI.
 * @alias module:wmcc.URI
 * @constructor
 * @param {Object|String} options
 * @property {Address} address
 * @property {Amount} amount
 * @property {String|null} label
 * @property {String|null} message
 * @property {String|null} request
 */

function URI(options) {
  if (!(this instanceof URI))
    return new URI(options);

  this.address = new Address();
  this.amount = -1;
  this.label = null;
  this.message = null;
  this.request = null;

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from options object.
 * @private
 * @param {Object|String} options
 * @returns {URI}
 */

URI.prototype.fromOptions = function fromOptions(options) {
  if (typeof options === 'string')
    return this.fromString(options);

  if (options.address)
    this.address.fromOptions(options.address);

  if (options.amount != null) {
    assert(util.isU64(options.amount), 'Amount must be a uint64.');
    this.amount = options.amount;
  }

  if (options.label) {
    assert(typeof options.label === 'string', 'Label must be a string.');
    this.label = options.label;
  }

  if (options.message) {
    assert(typeof options.message === 'string', 'Message must be a string.');
    this.message = options.message;
  }

  if (options.request) {
    assert(typeof options.request === 'string', 'Request must be a string.');
    this.request = options.request;
  }

  return this;
};

/**
 * Instantiate URI from options.
 * @param {Object|String} options
 * @returns {URI}
 */

URI.fromOptions = function fromOptions(options) {
  return new URI().fromOptions(options);
};

/**
 * Parse and inject properties from string.
 * @private
 * @param {String} str
 * @param {Network?} network
 * @returns {URI}
 */

URI.prototype.fromString = function fromString(str, network) {
  assert(typeof str === 'string');
  assert(str.length > 8, 'Not a WMCC URI.');

  const prefix = str.substring(0, 8);

  assert(prefix === 'wmcc:', 'Not a WMCC URI.');

  str = str.substring(8);

  const index = str.indexOf('?');

  let addr, qs;
  if (index === -1) {
    addr = str;
  } else {
    addr = str.substring(0, index);
    qs = str.substring(index + 1);
  }

  this.address.fromString(addr, network);

  if (!qs)
    return this;

  const query = parsePairs(qs);

  if (query.amount) {
    assert(query.amount.length > 0, 'Value is empty.');
    assert(query.amount[0] !== '-', 'Value is negative.');
    this.amount = Amount.value(query.amount);
  }

  if (query.label)
    this.label = query.label;

  if (query.message)
    this.message = query.message;

  if (query.r)
    this.request = query.r;

  return this;
};

/**
 * Instantiate uri from string.
 * @param {String} str
 * @param {Network?} network
 * @returns {URI}
 */

URI.fromString = function fromString(str, network) {
  return new URI().fromString(str, network);
};

/**
 * Serialize uri to a string.
 * @returns {String}
 */

URI.prototype.toString = function toString() {
  let str = 'wmcc:';

  str += this.address.toString();

  const query = [];

  if (this.amount !== -1)
    query.push(`amount=${Amount.wmcc(this.amount)}`);

  if (this.label)
    query.push(`label=${escape(this.label)}`);

  if (this.message)
    query.push(`message=${escape(this.message)}`);

  if (this.request)
    query.push(`r=${escape(this.request)}`);

  if (query.length > 0)
    str += '?' + query.join('&');

  return str;
};

/**
 * Inspect wmcc uri.
 * @returns {String}
 */

URI.prototype.inspect = function inspect() {
  return `<URI: ${this.toString()}>`;
};

/*
 * Helpers
 */

function WMCCQuery() {
  this.amount = null;
  this.label = null;
  this.message = null;
  this.r = null;
}

function parsePairs(str) {
  const parts = str.split('&');
  const data = new WMCCQuery();
  let size = 0;

  for (const pair of parts) {
    const index = pair.indexOf('=');
    let key, value;

    if (index === -1) {
      key = pair;
      value = '';
    } else {
      key = pair.substring(0, index);
      value = pair.substring(index + 1);
    }

    if (key.length === 0) {
      assert(value.length === 0, 'Empty key in querystring.');
      continue;
    }

    assert(size < 4, 'Too many keys in querystring.');

    switch (key) {
      case 'amount':
        assert(data.amount == null, 'Duplicate key in querystring (amount).');
        data.amount = unescape(value);
        break;
      case 'label':
        assert(data.label == null, 'Duplicate key in querystring (label).');
        data.label = unescape(value);
        break;
      case 'message':
        assert(data.message == null, 'Duplicate key in querystring (message).');
        data.message = unescape(value);
        break;
      case 'r':
        assert(data.r == null, 'Duplicate key in querystring (r).');
        data.r = unescape(value);
        break;
      default:
        assert(false, `Unknown querystring key: ${value}.`);
        break;
    }

    size++;
  }

  return data;
}

function unescape(str) {
  try {
    str = decodeURIComponent(str);
    str = str.replace(/\+/g, ' ');
  } catch (e) {
    throw new Error('Malformed URI.');
  }

  if (str.indexOf('\0') !== -1)
    throw new Error('Malformed URI.');

  return str;
}

function escape(str) {
  str = encodeURIComponent(str);
  str = str.replace(/%20/g, '+');
  return str;
}

/*
 * Expose
 */

module.exports = URI;


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * aead.js - aead for wmcc_core.
 */



const assert = __webpack_require__(0);
const ChaCha20 = __webpack_require__(166);
const Poly1305 = __webpack_require__(167);

/**
 * AEAD (used for bip151)
 * @alias module:crypto.AEAD
 * @constructor
 * @see https://github.com/openssh/openssh-portable
 * @see https://tools.ietf.org/html/rfc7539#section-2.8
 */

function AEAD() {
  if (!(this instanceof AEAD))
    return new AEAD();

  this.chacha20 = new ChaCha20();
  this.poly1305 = new Poly1305();
  this.aadLen = 0;
  this.cipherLen = 0;
  this.polyKey = null;
}

/**
 * Initialize the AEAD with a key and iv.
 * @param {Buffer} key
 * @param {Buffer} iv - IV / packet sequence number.
 */

AEAD.prototype.init = function init(key, iv) {
  const polyKey = Buffer.allocUnsafe(32);
  polyKey.fill(0);

  this.chacha20.init(key, iv);
  this.chacha20.encrypt(polyKey);
  this.poly1305.init(polyKey);

  // We need to encrypt a full block
  // to get the cipher in the correct state.
  this.chacha20.encrypt(Buffer.allocUnsafe(32));

  // Counter should be one.
  assert(this.chacha20.getCounter() === 1);

  // Expose for debugging.
  this.polyKey = polyKey;

  this.aadLen = 0;
  this.cipherLen = 0;
};

/**
 * Update the aad (will be finalized
 * on an encrypt/decrypt call).
 * @param {Buffer} aad
 */

AEAD.prototype.aad = function aad(data) {
  assert(this.cipherLen === 0, 'Cannot update aad.');
  this.poly1305.update(data);
  this.aadLen += data.length;
};

/**
 * Encrypt a piece of data.
 * @param {Buffer} data
 */

AEAD.prototype.encrypt = function encrypt(data) {
  if (this.cipherLen === 0)
    this.pad16(this.aadLen);

  this.chacha20.encrypt(data);
  this.poly1305.update(data);
  this.cipherLen += data.length;

  return data;
};

/**
 * Decrypt a piece of data.
 * @param {Buffer} data
 */

AEAD.prototype.decrypt = function decrypt(data) {
  if (this.cipherLen === 0)
    this.pad16(this.aadLen);

  this.cipherLen += data.length;
  this.poly1305.update(data);
  this.chacha20.encrypt(data);

  return data;
};

/**
 * Authenticate data without decrypting.
 * @param {Buffer} data
 */

AEAD.prototype.auth = function auth(data) {
  if (this.cipherLen === 0)
    this.pad16(this.aadLen);

  this.cipherLen += data.length;
  this.poly1305.update(data);

  return data;
};

/**
 * Finalize the aead and generate a MAC.
 * @returns {Buffer} MAC
 */

AEAD.prototype.finish = function finish() {
  const len = Buffer.allocUnsafe(16);
  let lo, hi;

  // The RFC says these are supposed to be
  // uint32le, but their own fucking test
  // cases fail unless they are uint64le's.
  lo = this.aadLen % 0x100000000;
  hi = (this.aadLen - lo) / 0x100000000;
  len.writeUInt32LE(lo, 0, true);
  len.writeUInt32LE(hi, 4, true);

  lo = this.cipherLen % 0x100000000;
  hi = (this.cipherLen - lo) / 0x100000000;
  len.writeUInt32LE(lo, 8, true);
  len.writeUInt32LE(hi, 12, true);

  if (this.cipherLen === 0)
    this.pad16(this.aadLen);

  this.pad16(this.cipherLen);
  this.poly1305.update(len);

  return this.poly1305.finish();
};

/**
 * Pad a chunk before updating mac.
 * @private
 * @param {Number} size
 */

AEAD.prototype.pad16 = function pad16(size) {
  size %= 16;

  if (size === 0)
    return;

  const pad = Buffer.allocUnsafe(16 - size);
  pad.fill(0);

  this.poly1305.update(pad);
};

/*
 * Expose
 */

module.exports = AEAD;


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * hkdf.js - hkdf for wmcc_core.
 */



/**
 * @module crypto/hkdf
 */

const digest = __webpack_require__(5);

/**
 * Perform hkdf extraction.
 * @param {Buffer} ikm
 * @param {Buffer} key
 * @param {String} alg
 * @returns {Buffer}
 */

exports.extract = function extract(ikm, key, alg) {
  return digest.hmac(alg, ikm, key);
};

/**
 * Perform hkdf expansion.
 * @param {Buffer} prk
 * @param {Buffer} info
 * @param {Number} len
 * @param {String} alg
 * @returns {Buffer}
 */

exports.expand = function expand(prk, info, len, alg) {
  const size = digest.hash(alg, Buffer.alloc(0)).length;
  const blocks = Math.ceil(len / size);

  if (blocks > 255)
    throw new Error('Too many blocks.');

  const okm = Buffer.allocUnsafe(len);

  if (blocks === 0)
    return okm;

  const buf = Buffer.allocUnsafe(size + info.length + 1);

  // First round:
  info.copy(buf, size);
  buf[buf.length - 1] = 1;

  let out = digest.hmac(alg, buf.slice(size), prk);
  out.copy(okm, 0);

  for (let i = 1; i < blocks; i++) {
    out.copy(buf, 0);
    buf[buf.length - 1]++;
    out = digest.hmac(alg, buf, prk);
    out.copy(okm, i * size);
  }

  return okm;
};


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * hmac-drbg.js - hmac-drbg implementation for wmcc_core.
 * Parts of this software based on hmac-drbg.
 */



const assert = __webpack_require__(0);
const digest = __webpack_require__(5);

/*
 * Constants
 */

const HASH_ALG = 'sha256';
const HASH_SIZE = 32;
const RESEED_INTERVAL = 0x1000000000000;
const POOL33 = Buffer.allocUnsafe(HASH_SIZE + 1);
const POOL112 = Buffer.allocUnsafe(HASH_SIZE * 2 + 48);
const POOL145 = Buffer.allocUnsafe(POOL33.length + POOL112.length);

/**
 * HmacDRBG
 * @constructor
 */

function HmacDRBG(entropy, nonce, pers) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(entropy, nonce, pers);

  this.K = Buffer.allocUnsafe(HASH_SIZE);
  this.V = Buffer.allocUnsafe(HASH_SIZE);
  this.rounds = 0;

  this.init(entropy, nonce, pers);
}

HmacDRBG.prototype.init = function init(entropy, nonce, pers) {
  for (let i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this.reseed(entropy, nonce, pers);
};

HmacDRBG.prototype.reseed = function reseed(entropy, nonce, pers) {
  const seed = POOL112;

  assert(Buffer.isBuffer(entropy));
  assert(Buffer.isBuffer(nonce));
  assert(Buffer.isBuffer(pers));

  assert(entropy.length === HASH_SIZE);
  assert(nonce.length === HASH_SIZE);
  assert(pers.length === 48);

  entropy.copy(seed, 0);
  nonce.copy(seed, HASH_SIZE);
  pers.copy(seed, HASH_SIZE * 2);

  this.update(seed);
  this.rounds = 1;
};

HmacDRBG.prototype.iterate = function iterate() {
  const data = POOL33;

  this.V.copy(data, 0);
  data[HASH_SIZE] = 0x00;

  this.K = digest.hmac(HASH_ALG, data, this.K);
  this.V = digest.hmac(HASH_ALG, this.V, this.K);
};

HmacDRBG.prototype.update = function update(seed) {
  const data = POOL145;

  assert(Buffer.isBuffer(seed));
  assert(seed.length === HASH_SIZE * 2 + 48);

  this.V.copy(data, 0);
  data[HASH_SIZE] = 0x00;
  seed.copy(data, HASH_SIZE + 1);

  this.K = digest.hmac(HASH_ALG, data, this.K);
  this.V = digest.hmac(HASH_ALG, this.V, this.K);

  data[HASH_SIZE] = 0x01;

  this.K = digest.hmac(HASH_ALG, data, this.K);
  this.V = digest.hmac(HASH_ALG, this.V, this.K);
};

HmacDRBG.prototype.generate = function generate(len) {
  if (this.rounds > RESEED_INTERVAL)
    throw new Error('Reseed is required.');

  const data = Buffer.allocUnsafe(len);
  let pos = 0;

  while (pos < len) {
    this.V = digest.hmac(HASH_ALG, this.V, this.K);
    this.V.copy(data, pos);
    pos += HASH_SIZE;
  }

  this.iterate();
  this.rounds++;

  return data;
};

/*
 * Expose
 */

module.exports = HmacDRBG;


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * schnorr.js - schnorr signatures for wmcc_core.
 */



const assert = __webpack_require__(0);
const elliptic = __webpack_require__(9);
const Signature = __webpack_require__(65);
const BN = __webpack_require__(27);
const HmacDRBG = __webpack_require__(208);
const sha256 = __webpack_require__(5).sha256;
const curve = elliptic.ec('secp256k1').curve;
const POOL64 = Buffer.allocUnsafe(64);

/**
 * @exports crypto/schnorr
 */

const schnorr = exports;

/**
 * Hash (r | M).
 * @param {Buffer} msg
 * @param {BN} r
 * @returns {Buffer}
 */

schnorr.hash = function hash(msg, r) {
  const R = r.toArrayLike(Buffer, 'be', 32);
  const B = POOL64;

  R.copy(B, 0);
  msg.copy(B, 32);

  return new BN(sha256(B));
};

/**
 * Sign message.
 * @private
 * @param {Buffer} msg
 * @param {BN} priv
 * @param {BN} k
 * @param {Buffer} pn
 * @returns {Signature|null}
 */

schnorr.trySign = function trySign(msg, prv, k, pn) {
  if (prv.cmpn(0) === 0)
    throw new Error('Bad private key.');

  if (prv.cmp(curve.n) >= 0)
    throw new Error('Bad private key.');

  if (k.cmpn(0) === 0)
    return null;

  if (k.cmp(curve.n) >= 0)
    return null;

  let r = curve.g.mul(k);

  if (pn)
    r = r.add(pn);

  if (r.y.isOdd()) {
    k = k.umod(curve.n);
    k = curve.n.sub(k);
  }

  const h = schnorr.hash(msg, r.getX());

  if (h.cmpn(0) === 0)
    return null;

  if (h.cmp(curve.n) >= 0)
    return null;

  let s = h.imul(prv);
  s = k.isub(s);
  s = s.umod(curve.n);

  if (s.cmpn(0) === 0)
    return null;

  return new Signature({ r: r.getX(), s: s });
};

/**
 * Sign message.
 * @param {Buffer} msg
 * @param {Buffer} key
 * @param {Buffer} pubNonce
 * @returns {Signature}
 */

schnorr.sign = function sign(msg, key, pubNonce) {
  const prv = new BN(key);
  const drbg = schnorr.drbg(msg, key, pubNonce);
  const len = curve.n.byteLength();

  let pn;
  if (pubNonce)
    pn = curve.decodePoint(pubNonce);

  let sig;
  while (!sig) {
    const k = new BN(drbg.generate(len));
    sig = schnorr.trySign(msg, prv, k, pn);
  }

  return sig;
};

/**
 * Verify signature.
 * @param {Buffer} msg
 * @param {Buffer} signature
 * @param {Buffer} key
 * @returns {Buffer}
 */

schnorr.verify = function verify(msg, signature, key) {
  const sig = new Signature(signature);
  const h = schnorr.hash(msg, sig.r);

  if (h.cmp(curve.n) >= 0)
    throw new Error('Invalid hash.');

  if (h.cmpn(0) === 0)
    throw new Error('Invalid hash.');

  if (sig.s.cmp(curve.n) >= 0)
    throw new Error('Invalid S value.');

  if (sig.r.cmp(curve.p) > 0)
    throw new Error('Invalid R value.');

  const k = curve.decodePoint(key);
  const l = k.mul(h);
  const r = curve.g.mul(sig.s);
  const rl = l.add(r);

  if (rl.y.isOdd())
    throw new Error('Odd R value.');

  return rl.getX().cmp(sig.r) === 0;
};

/**
 * Recover public key.
 * @param {Buffer} msg
 * @param {Buffer} signature
 * @returns {Buffer}
 */

schnorr.recover = function recover(signature, msg) {
  const sig = new Signature(signature);
  const h = schnorr.hash(msg, sig.r);

  if (h.cmp(curve.n) >= 0)
    throw new Error('Invalid hash.');

  if (h.cmpn(0) === 0)
    throw new Error('Invalid hash.');

  if (sig.s.cmp(curve.n) >= 0)
    throw new Error('Invalid S value.');

  if (sig.r.cmp(curve.p) > 0)
    throw new Error('Invalid R value.');

  let hinv = h.invm(curve.n);
  hinv = hinv.umod(curve.n);

  let s = sig.s;
  s = curve.n.sub(s);
  s = s.umod(curve.n);

  s = s.imul(hinv);
  s = s.umod(curve.n);

  const R = curve.pointFromX(sig.r, false);
  let l = R.mul(hinv);
  let r = curve.g.mul(s);
  const k = l.add(r);

  l = k.mul(h);
  r = curve.g.mul(sig.s);

  const rl = l.add(r);

  if (rl.y.isOdd())
    throw new Error('Odd R value.');

  if (rl.getX().cmp(sig.r) !== 0)
    throw new Error('Could not recover pubkey.');

  return Buffer.from(k.encode('array', true));
};

/**
 * Combine signatures.
 * @param {Buffer[]} sigs
 * @returns {Signature}
 */

schnorr.combineSigs = function combineSigs(sigs) {
  let s = new BN(0);
  let r, last;

  for (let i = 0; i < sigs.length; i++) {
    const sig = new Signature(sigs[i]);

    if (sig.s.cmpn(0) === 0)
      throw new Error('Bad S value.');

    if (sig.s.cmp(curve.n) >= 0)
      throw new Error('Bad S value.');

    if (!r)
      r = sig.r;

    if (last && last.r.cmp(sig.r) !== 0)
      throw new Error('Bad signature combination.');

    s = s.iadd(sig.s);
    s = s.umod(curve.n);

    last = sig;
  }

  if (s.cmpn(0) === 0)
    throw new Error('Bad combined signature.');

  return new Signature({ r: r, s: s });
};

/**
 * Combine public keys.
 * @param {Buffer[]} keys
 * @returns {Buffer}
 */

schnorr.combineKeys = function combineKeys(keys) {
  if (keys.length === 0)
    throw new Error();

  if (keys.length === 1)
    return keys[0];

  let point = curve.decodePoint(keys[0]);

  for (let i = 1; i < keys.length; i++) {
    const key = curve.decodePoint(keys[i]);
    point = point.add(key);
  }

  return Buffer.from(point.encode('array', true));
};

/**
 * Partially sign.
 * @param {Buffer} msg
 * @param {Buffer} priv
 * @param {Buffer} privNonce
 * @param {Buffer} pubNonce
 * @returns {Buffer}
 */

schnorr.partialSign = function partialSign(msg, priv, privNonce, pubNonce) {
  const prv = new BN(priv);
  const k = new BN(privNonce);
  const pn = curve.decodePoint(pubNonce);
  const sig = schnorr.trySign(msg, prv, k, pn);

  if (!sig)
    throw new Error('Bad K value.');

  return sig;
};

/**
 * Schnorr personalization string.
 * @const {Buffer}
 */

schnorr.alg = Buffer.from('Schnorr+SHA256  ', 'ascii');

/**
 * Instantiate an HMAC-DRBG.
 * @param {Buffer} msg
 * @param {Buffer} priv
 * @param {Buffer} data
 * @returns {HmacDRBG}
 */

schnorr.drbg = function drbg(msg, priv, data) {
  const pers = Buffer.allocUnsafe(48);

  pers.fill(0);

  if (data) {
    assert(data.length === 32);
    data.copy(pers, 0);
  }

  schnorr.alg.copy(pers, 32);

  return new HmacDRBG(priv, msg, pers);
};

/**
 * Generate pub+priv nonce pair.
 * @param {Buffer} msg
 * @param {Buffer} priv
 * @param {Buffer} data
 * @returns {Buffer}
 */

schnorr.generateNoncePair = function generateNoncePair(msg, priv, data) {
  const drbg = schnorr.drbg(msg, priv, data);
  const len = curve.n.byteLength();

  let k;
  for (;;) {
    k = new BN(drbg.generate(len));

    if (k.cmpn(0) === 0)
      continue;

    if (k.cmp(curve.n) >= 0)
      continue;

    break;
  }

  return Buffer.from(curve.g.mul(k).encode('array', true));
};


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2015-2016, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * mnemonic.js - hd mnemonics for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const digest = __webpack_require__(5);
const cleanse = __webpack_require__(70);
const random = __webpack_require__(29);
const pbkdf2 = __webpack_require__(68);
const StaticWriter = __webpack_require__(4);
const BufferReader = __webpack_require__(2);
const encoding = __webpack_require__(3);
const wordlist = __webpack_require__(211);
const common = __webpack_require__(108);
const nfkd = __webpack_require__(212);

/*
 * Constants
 */

const wordlistCache = Object.create(null);

/**
 * HD Mnemonic
 * @alias module:hd.Mnemonic
 * @constructor
 * @param {Object} options
 * @param {Number?} options.bit - Bits of entropy (Must
 * be a multiple of 8) (default=128).
 * @param {Buffer?} options.entropy - Entropy bytes. Will
 * be generated with `options.bits` bits of entropy
 * if not present.
 * @param {String?} options.phrase - Mnemonic phrase (will
 * be generated if not present).
 * @param {String?} options.passphrase - Optional salt for
 * key stretching (empty string if not present).
 * @param {String?} options.language - Language.
 */

function Mnemonic(options) {
  if (!(this instanceof Mnemonic))
    return new Mnemonic(options);

  this.bits = common.MIN_ENTROPY;
  this.language = 'english';
  this.entropy = null;
  this.phrase = null;
  this.passphrase = '';

  if (options)
    this.fromOptions(options);
}

/**
 * List of languages.
 * @const {String[]}
 * @default
 */

Mnemonic.languages = [
  'simplified chinese',
  'traditional chinese',
  'english',
  'french',
  'italian',
  'japanese',
  'spanish'
];

/**
 * Inject properties from options object.
 * @private
 * @param {Object} options
 */

Mnemonic.prototype.fromOptions = function fromOptions(options) {
  if (typeof options === 'string')
    options = { phrase: options };

  if (options.bits != null) {
    assert(util.isU16(options.bits));
    assert(options.bits >= common.MIN_ENTROPY);
    assert(options.bits <= common.MAX_ENTROPY);
    assert(options.bits % 32 === 0);
    this.bits = options.bits;
  }

  if (options.language) {
    assert(typeof options.language === 'string');
    assert(Mnemonic.languages.indexOf(options.language) !== -1);
    this.language = options.language;
  }

  if (options.passphrase) {
    assert(typeof options.passphrase === 'string');
    this.passphrase = options.passphrase;
  }

  if (options.phrase) {
    this.fromPhrase(options.phrase);
    return this;
  }

  if (options.entropy) {
    this.fromEntropy(options.entropy);
    return this;
  }

  return this;
};

/**
 * Instantiate mnemonic from options.
 * @param {Object} options
 * @returns {Mnemonic}
 */

Mnemonic.fromOptions = function fromOptions(options) {
  return new Mnemonic().fromOptions(options);
};

/**
 * Destroy the mnemonic (zeroes entropy).
 */

Mnemonic.prototype.destroy = function destroy() {
  this.bits = common.MIN_ENTROPY;
  this.language = 'english';
  if (this.entropy) {
    cleanse(this.entropy);
    this.entropy = null;
  }
  this.phrase = null;
  this.passphrase = '';
};

/**
 * Generate the seed.
 * @param {String?} passphrase
 * @returns {Buffer} pbkdf2 seed.
 */

Mnemonic.prototype.toSeed = function toSeed(passphrase) {
  if (!passphrase)
    passphrase = this.passphrase;

  this.passphrase = passphrase;

  const phrase = nfkd(this.getPhrase());
  const passwd = nfkd('mnemonic' + passphrase);

  return pbkdf2.derive(
    Buffer.from(phrase, 'utf8'),
    Buffer.from(passwd, 'utf8'),
    2048, 64, 'sha512');
};

/**
 * Get or generate entropy.
 * @returns {Buffer}
 */

Mnemonic.prototype.getEntropy = function getEntropy() {
  if (!this.entropy)
    this.entropy = random.randomBytes(this.bits / 8);

  assert(this.bits / 8 === this.entropy.length);

  return this.entropy;
};

/**
 * Generate a mnemonic phrase from chosen language.
 * @returns {String}
 */

Mnemonic.prototype.getPhrase = function getPhrase() {
  if (this.phrase)
    return this.phrase;

  // Include the first `ENT / 32` bits
  // of the hash (the checksum).
  const wbits = this.bits + (this.bits / 32);

  // Get entropy and checksum.
  const entropy = this.getEntropy();
  const chk = digest.sha256(entropy);

  // Append the hash to the entropy to
  // make things easy when grabbing
  // the checksum bits.
  const size = Math.ceil(wbits / 8);
  const data = Buffer.allocUnsafe(size);
  entropy.copy(data, 0);
  chk.copy(data, entropy.length);

  // Build the mnemonic by reading
  // 11 bit indexes from the entropy.
  const list = Mnemonic.getWordlist(this.language);

  let phrase = [];
  for (let i = 0; i < wbits / 11; i++) {
    let index = 0;
    for (let j = 0; j < 11; j++) {
      const pos = i * 11 + j;
      const bit = pos % 8;
      const oct = (pos - bit) / 8;
      index <<= 1;
      index |= (data[oct] >>> (7 - bit)) & 1;
    }
    phrase.push(list.words[index]);
  }

  // Japanese likes double-width spaces.
  if (this.language === 'japanese')
    phrase = phrase.join('\u3000');
  else
    phrase = phrase.join(' ');

  this.phrase = phrase;

  return phrase;
};

/**
 * Inject properties from phrase.
 * @private
 * @param {String} phrase
 */

Mnemonic.prototype.fromPhrase = function fromPhrase(phrase) {
  assert(typeof phrase === 'string');
  assert(phrase.length <= 1000);

  const words = phrase.trim().split(/[\s\u3000]+/);
  const wbits = words.length * 11;
  const cbits = wbits % 32;

  assert(cbits !== 0, 'Invalid checksum.');

  const bits = wbits - cbits;

  assert(bits >= common.MIN_ENTROPY);
  assert(bits <= common.MAX_ENTROPY);
  assert(bits % 32 === 0);

  const size = Math.ceil(wbits / 8);
  const data = Buffer.allocUnsafe(size);
  data.fill(0);

  const lang = Mnemonic.getLanguage(words[0]);
  const list = Mnemonic.getWordlist(lang);

  // Rebuild entropy bytes.
  for (let i = 0; i < words.length; i++) {
    const word = words[i];
    const index = list.map[word];

    if (index == null)
      throw new Error('Could not find word.');

    for (let j = 0; j < 11; j++) {
      const pos = i * 11 + j;
      const bit = pos % 8;
      const oct = (pos - bit) / 8;
      const val = (index >>> (10 - j)) & 1;
      data[oct] |= val << (7 - bit);
    }
  }

  const cbytes = Math.ceil(cbits / 8);
  const entropy = data.slice(0, data.length - cbytes);
  const chk1 = data.slice(data.length - cbytes);
  const chk2 = digest.sha256(entropy);

  // Verify checksum.
  for (let i = 0; i < cbits; i++) {
    const bit = i % 8;
    const oct = (i - bit) / 8;
    const b1 = (chk1[oct] >>> (7 - bit)) & 1;
    const b2 = (chk2[oct] >>> (7 - bit)) & 1;
    if (b1 !== b2)
      throw new Error('Invalid checksum.');
  }

  assert(bits / 8 === entropy.length);

  this.bits = bits;
  this.language = lang;
  this.entropy = entropy;
  this.phrase = phrase;

  return this;
};

/**
 * Instantiate mnemonic from a phrase (validates checksum).
 * @param {String} phrase
 * @returns {Mnemonic}
 * @throws on bad checksum
 */

Mnemonic.fromPhrase = function fromPhrase(phrase) {
  return new Mnemonic().fromPhrase(phrase);
};

/**
 * Inject properties from entropy.
 * @private
 * @param {Buffer} entropy
 * @param {String?} lang
 */

Mnemonic.prototype.fromEntropy = function fromEntropy(entropy, lang) {
  assert(Buffer.isBuffer(entropy));
  assert(entropy.length * 8 >= common.MIN_ENTROPY);
  assert(entropy.length * 8 <= common.MAX_ENTROPY);
  assert((entropy.length * 8) % 32 === 0);
  assert(!lang || Mnemonic.languages.indexOf(lang) !== -1);

  this.entropy = entropy;
  this.bits = entropy.length * 8;

  if (lang)
    this.language = lang;

  return this;
};

/**
 * Instantiate mnemonic from entropy.
 * @param {Buffer} entropy
 * @param {String?} lang
 * @returns {Mnemonic}
 */

Mnemonic.fromEntropy = function fromEntropy(entropy, lang) {
  return new Mnemonic().fromEntropy(entropy, lang);
};

/**
 * Determine a single word's language.
 * @param {String} word
 * @returns {String} Language.
 * @throws on not found.
 */

Mnemonic.getLanguage = function getLanguage(word) {
  for (const lang of Mnemonic.languages) {
    const list = Mnemonic.getWordlist(lang);
    if (list.map[word] != null)
      return lang;
  }

  throw new Error('Could not determine language.');
};

/**
 * Retrieve the wordlist for a language.
 * @param {String} lang
 * @returns {Object}
 */

Mnemonic.getWordlist = function getWordlist(lang) {
  const cache = wordlistCache[lang];

  if (cache)
    return cache;

  const words = wordlist.get(lang);
  const list = new WordList(words);

  wordlistCache[lang] = list;

  return list;
};

/**
 * Convert mnemonic to a json-friendly object.
 * @returns {Object}
 */

Mnemonic.prototype.toJSON = function toJSON() {
  return {
    bits: this.bits,
    language: this.language,
    entropy: this.getEntropy().toString('hex'),
    phrase: this.getPhrase(),
    passphrase: this.passphrase
  };
};

/**
 * Inject properties from json object.
 * @private
 * @param {Object} json
 */

Mnemonic.prototype.fromJSON = function fromJSON(json) {
  assert(util.isU16(json.bits));
  assert(typeof json.language === 'string');
  assert(typeof json.entropy === 'string');
  assert(typeof json.phrase === 'string');
  assert(typeof json.passphrase === 'string');
  assert(json.bits >= common.MIN_ENTROPY);
  assert(json.bits <= common.MAX_ENTROPY);
  assert(json.bits % 32 === 0);
  assert(json.bits / 8 === json.entropy.length / 2);

  this.bits = json.bits;
  this.language = json.language;
  this.entropy = Buffer.from(json.entropy, 'hex');
  this.phrase = json.phrase;
  this.passphrase = json.passphrase;

  return this;
};

/**
 * Instantiate mnemonic from json object.
 * @param {Object} json
 * @returns {Mnemonic}
 */

Mnemonic.fromJSON = function fromJSON(json) {
  return new Mnemonic().fromJSON(json);
};

/**
 * Calculate serialization size.
 * @returns {Number}
 */

Mnemonic.prototype.getSize = function getSize() {
  let size = 0;
  size += 3;
  size += this.getEntropy().length;
  size += encoding.sizeVarString(this.getPhrase(), 'utf8');
  size += encoding.sizeVarString(this.passphrase, 'utf8');
  return size;
};

/**
 * Write the mnemonic to a buffer writer.
 * @params {BufferWriter} bw
 */

Mnemonic.prototype.toWriter = function toWriter(bw) {
  const lang = Mnemonic.languages.indexOf(this.language);

  assert(lang !== -1);

  bw.writeU16(this.bits);
  bw.writeU8(lang);
  bw.writeBytes(this.getEntropy());
  bw.writeVarString(this.getPhrase(), 'utf8');
  bw.writeVarString(this.passphrase, 'utf8');

  return bw;
};

/**
 * Serialize mnemonic.
 * @returns {Buffer}
 */

Mnemonic.prototype.toRaw = function toRaw(writer) {
  const size = this.getSize();
  return this.toWriter(new StaticWriter(size)).render();
};

/**
 * Inject properties from buffer reader.
 * @private
 * @param {BufferReader} br
 */

Mnemonic.prototype.fromReader = function fromReader(br) {
  const bits = br.readU16();

  assert(bits >= common.MIN_ENTROPY);
  assert(bits <= common.MAX_ENTROPY);
  assert(bits % 32 === 0);

  const language = Mnemonic.languages[br.readU8()];
  assert(language);

  this.bits = bits;
  this.language = language;
  this.entropy = br.readBytes(bits / 8);
  this.phrase = br.readVarString('utf8');
  this.passphrase = br.readVarString('utf8');

  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

Mnemonic.prototype.fromRaw = function fromRaw(data) {
  return this.fromReader(new BufferReader(data));
};

/**
 * Instantiate mnemonic from buffer reader.
 * @param {BufferReader} br
 * @returns {Mnemonic}
 */

Mnemonic.fromReader = function fromReader(br) {
  return new Mnemonic().fromReader(br);
};

/**
 * Instantiate mnemonic from serialized data.
 * @param {Buffer} data
 * @returns {Mnemonic}
 */

Mnemonic.fromRaw = function fromRaw(data) {
  return new Mnemonic().fromRaw(data);
};

/**
 * Convert the mnemonic to a string.
 * @returns {String}
 */

Mnemonic.prototype.toString = function toString() {
  return this.getPhrase();
};

/**
 * Inspect the mnemonic.
 * @returns {String}
 */

Mnemonic.prototype.inspect = function inspect() {
  return `<Mnemonic: ${this.getPhrase()}>`;
};

/**
 * Test whether an object is a Mnemonic.
 * @param {Object} obj
 * @returns {Boolean}
 */

Mnemonic.isMnemonic = function isMnemonic(obj) {
  return obj instanceof Mnemonic;
};

/**
 * Word List
 * @constructor
 * @ignore
 * @param {Array} words
 */

function WordList(words) {
  this.words = words;
  this.map = Object.create(null);

  for (let i = 0; i < words.length; i++) {
    const word = words[i];
    this.map[word] = i;
  }
}

/*
 * Expose
 */

module.exports = Mnemonic;


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2015-2016, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * wordlist.js - wordlists for wmcc_core.
 */



exports.get = function get(name) {
  switch (name) {
    case 'simplified chinese':
      return __webpack_require__(269);
    case 'traditional chinese':
      return __webpack_require__(270);
    case 'english':
      return __webpack_require__(271);
    case 'french':
      return __webpack_require__(272);
    case 'italian':
      return __webpack_require__(273);
    case 'japanese':
      return __webpack_require__(274);
    case 'spanish':
      return __webpack_require__(275);
    default:
      throw new Error(`Unknown language: ${name}.`);
  }
};


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * nfkd.js - unicode normalization for wmcc_core.
 */



/**
 * Normalize unicode string.
 * @alias module:utils.nfkd
 * @param {String} str
 * @returns {String}
 */

function nfkd(str) {
  return str.normalize('NFKD');
}

/*
 * Expose
 */

module.exports = nfkd;


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2015-2016, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * public.js - hd public keys for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const digest = __webpack_require__(5);
const cleanse = __webpack_require__(70);
const secp256k1 = __webpack_require__(12);
const Network = __webpack_require__(6);
const StaticWriter = __webpack_require__(4);
const BufferReader = __webpack_require__(2);
const base58 = __webpack_require__(26);
const encoding = __webpack_require__(3);
const common = __webpack_require__(108);

/**
 * HDPublicKey
 * @alias module:hd.PublicKey
 * @constructor
 * @param {Object|Base58String} options
 * @param {Base58String?} options.xkey - Serialized base58 key.
 * @param {Number?} options.depth
 * @param {Number?} options.parentFingerPrint
 * @param {Number?} options.childIndex
 * @param {Buffer?} options.chainCode
 * @param {Buffer?} options.publicKey
 * @property {Network} network
 * @property {Number} depth
 * @property {Number} parentFingerPrint
 * @property {Number} childIndex
 * @property {Buffer} chainCode
 * @property {Buffer} publicKey
 */

function HDPublicKey(options) {
  if (!(this instanceof HDPublicKey))
    return new HDPublicKey(options);

  this.network = Network.primary;
  this.depth = 0;
  this.parentFingerPrint = 0;
  this.childIndex = 0;
  this.chainCode = encoding.ZERO_HASH;
  this.publicKey = encoding.ZERO_KEY;

  this.fingerPrint = -1;

  this._xpubkey = null;

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from options object.
 * @private
 * @param {Object} options
 */

HDPublicKey.prototype.fromOptions = function fromOptions(options) {
  assert(options, 'No options for HDPublicKey');
  assert(util.isU8(options.depth));
  assert(util.isU32(options.parentFingerPrint));
  assert(util.isU32(options.childIndex));
  assert(Buffer.isBuffer(options.chainCode));
  assert(Buffer.isBuffer(options.publicKey));

  if (options.network)
    this.network = Network.get(options.network);

  this.depth = options.depth;
  this.parentFingerPrint = options.parentFingerPrint;
  this.childIndex = options.childIndex;
  this.chainCode = options.chainCode;
  this.publicKey = options.publicKey;

  return this;
};

/**
 * Instantiate HD public key from options object.
 * @param {Object} options
 * @returns {HDPublicKey}
 */

HDPublicKey.fromOptions = function fromOptions(options) {
  return new HDPublicKey().fromOptions(options);
};

/**
 * Get HD public key (self).
 * @returns {HDPublicKey}
 */

HDPublicKey.prototype.toPublic = function toPublic() {
  return this;
};

/**
 * Get cached base58 xprivkey (always null here).
 * @returns {null}
 */

HDPublicKey.prototype.xprivkey = function xprivkey() {
  return null;
};

/**
 * Get cached base58 xpubkey.
 * @returns {Base58String}
 */

HDPublicKey.prototype.xpubkey = function xpubkey() {
  if (!this._xpubkey)
    this._xpubkey = this.toBase58();
  return this._xpubkey;
};

/**
 * Destroy the key (zeroes chain code and pubkey).
 */

HDPublicKey.prototype.destroy = function destroy() {
  this.depth = 0;
  this.childIndex = 0;
  this.parentFingerPrint = 0;

  cleanse(this.chainCode);
  cleanse(this.publicKey);

  this.fingerPrint = -1;

  this._xpubkey = null;
};

/**
 * Derive a child key.
 * @param {Number} index - Derivation index.
 * @param {Boolean?} hardened - Whether the derivation
 * should be hardened (throws if true).
 * @returns {HDPrivateKey}
 * @throws on `hardened`
 */

HDPublicKey.prototype.derive = function derive(index, hardened) {
  assert(typeof index === 'number');

  if ((index >>> 0) !== index)
    throw new Error('Index out of range.');

  if ((index & common.HARDENED) || hardened)
    throw new Error('Cannot derive hardened.');

  if (this.depth >= 0xff)
    throw new Error('Depth too high.');

  const id = this.getID(index);
  const cache = common.cache.get(id);

  if (cache)
    return cache;

  const bw = StaticWriter.pool(37);

  bw.writeBytes(this.publicKey);
  bw.writeU32BE(index);

  const data = bw.render();

  const hash = digest.hmac('sha512', data, this.chainCode);
  const left = hash.slice(0, 32);
  const right = hash.slice(32, 64);

  let key;
  try {
    key = secp256k1.publicKeyTweakAdd(this.publicKey, left, true);
  } catch (e) {
    return this.derive(index + 1);
  }

  if (this.fingerPrint === -1) {
    const fp = digest.hash160(this.publicKey);
    this.fingerPrint = fp.readUInt32BE(0, true);
  }

  const child = new HDPublicKey();
  child.network = this.network;
  child.depth = this.depth + 1;
  child.parentFingerPrint = this.fingerPrint;
  child.childIndex = index;
  child.chainCode = right;
  child.publicKey = key;

  common.cache.set(id, child);

  return child;
};

/**
 * Unique HD key ID.
 * @private
 * @param {Number} index
 * @returns {String}
 */

HDPublicKey.prototype.getID = function getID(index) {
  return this.network.keyPrefix.xpubkey58
    + this.publicKey.toString('hex')
    + index;
};

/**
 * Derive a BIP44 account key (does not derive, only ensures account key).
 * @method
 * @param {Number} purpose
 * @param {Number} account
 * @returns {HDPublicKey}
 * @throws Error if key is not already an account key.
 */

HDPublicKey.prototype.deriveAccount = function deriveAccount(purpose, account) {
  assert(util.isU32(purpose));
  assert(util.isU32(account));
  assert(this.isAccount(account), 'Cannot derive account index.');
  return this;
};

/**
 * Test whether the key is a master key.
 * @method
 * @returns {Boolean}
 */

HDPublicKey.prototype.isMaster = function isMaster() {
  return common.isMaster(this);
};

/**
 * Test whether the key is (most likely) a BIP44 account key.
 * @method
 * @param {Number?} account
 * @returns {Boolean}
 */

HDPublicKey.prototype.isAccount = function isAccount(account) {
  return common.isAccount(this, account);
};

/**
 * Test whether a string is a valid path.
 * @param {String} path
 * @param {Boolean?} hardened
 * @returns {Boolean}
 */

HDPublicKey.isValidPath = function isValidPath(path) {
  try {
    common.parsePath(path, false);
    return true;
  } catch (e) {
    return false;
  }
};

/**
 * Derive a key from a derivation path.
 * @param {String} path
 * @returns {HDPublicKey}
 * @throws Error if `path` is not a valid path.
 * @throws Error if hardened.
 */

HDPublicKey.prototype.derivePath = function derivePath(path) {
  const indexes = common.parsePath(path, false);

  let key = this;

  for (const index of indexes)
    key = key.derive(index);

  return key;
};

/**
 * Compare a key against an object.
 * @param {Object} obj
 * @returns {Boolean}
 */

HDPublicKey.prototype.equals = function equals(obj) {
  assert(HDPublicKey.isHDPublicKey(obj));

  return this.network === obj.network
    && this.depth === obj.depth
    && this.parentFingerPrint === obj.parentFingerPrint
    && this.childIndex === obj.childIndex
    && this.chainCode.equals(obj.chainCode)
    && this.publicKey.equals(obj.publicKey);
};

/**
 * Compare a key against an object.
 * @param {Object} obj
 * @returns {Boolean}
 */

HDPublicKey.prototype.compare = function compare(key) {
  assert(HDPublicKey.isHDPublicKey(key));

  let cmp = this.depth - key.depth;

  if (cmp !== 0)
    return cmp;

  cmp = this.parentFingerPrint - key.parentFingerPrint;

  if (cmp !== 0)
    return cmp;

  cmp = this.childIndex - key.childIndex;

  if (cmp !== 0)
    return cmp;

  cmp = this.chainCode.compare(key.chainCode);

  if (cmp !== 0)
    return cmp;

  cmp = this.publicKey.compare(key.publicKey);

  if (cmp !== 0)
    return cmp;

  return 0;
};

/**
 * Convert key to a more json-friendly object.
 * @returns {Object}
 */

HDPublicKey.prototype.toJSON = function toJSON() {
  return {
    xpubkey: this.xpubkey()
  };
};

/**
 * Inject properties from json object.
 * @private
 * @param {Object} json
 * @param {Network?} network
 */

HDPublicKey.prototype.fromJSON = function fromJSON(json, network) {
  assert(json.xpubkey, 'Could not handle HD key JSON.');
  this.fromBase58(json.xpubkey, network);
  return this;
};

/**
 * Instantiate an HDPublicKey from a jsonified key object.
 * @param {Object} json - The jsonified transaction object.
 * @param {Network?} network
 * @returns {HDPrivateKey}
 */

HDPublicKey.fromJSON = function fromJSON(json, network) {
  return new HDPublicKey().fromJSON(json, network);
};

/**
 * Test whether an object is in the form of a base58 xpubkey.
 * @param {String} data
 * @param {(Network|NetworkType)?} network
 * @returns {Boolean}
 */

HDPublicKey.isBase58 = function isBase58(data, network) {
  if (typeof data !== 'string')
    return false;

  if (data.length < 4)
    return false;

  const prefix = data.substring(0, 4);

  try {
    Network.fromPublic58(prefix, network);
    return true;
  } catch (e) {
    return false;
  }
};

/**
 * Test whether a buffer has a valid network prefix.
 * @param {Buffer} data
 * @param {(Network|NetworkType)?} network
 * @returns {NetworkType}
 */

HDPublicKey.isRaw = function isRaw(data, network) {
  if (!Buffer.isBuffer(data))
    return false;

  if (data.length < 4)
    return false;

  const version = data.readUInt32BE(0, true);

  try {
    Network.fromPublic(version, network);
    return true;
  } catch (e) {
    return false;
  }
};

/**
 * Inject properties from a base58 key.
 * @private
 * @param {Base58String} xkey
 * @param {Network?} network
 */

HDPublicKey.prototype.fromBase58 = function fromBase58(xkey, network) {
  assert(typeof xkey === 'string');
  this._xpubkey = xkey;
  return this.fromRaw(base58.decode(xkey), network);
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {BufferReader} br
 * @param {(Network|NetworkType)?} network
 */

HDPublicKey.prototype.fromReader = function fromReader(br, network) {
  const version = br.readU32BE();

  this.network = Network.fromPublic(version, network);
  this.depth = br.readU8();
  this.parentFingerPrint = br.readU32BE();
  this.childIndex = br.readU32BE();
  this.chainCode = br.readBytes(32);
  this.publicKey = br.readBytes(33);

  br.verifyChecksum();

  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 * @param {(Network|NetworkType)?} network
 */

HDPublicKey.prototype.fromRaw = function fromRaw(data, network) {
  return this.fromReader(new BufferReader(data), network);
};

/**
 * Serialize key data to base58 extended key.
 * @param {(Network|NetworkType)?} network
 * @returns {Base58String}
 */

HDPublicKey.prototype.toBase58 = function toBase58(network) {
  return base58.encode(this.toRaw(network));
};

/**
 * Write the key to a buffer writer.
 * @param {BufferWriter} bw
 * @param {(Network|NetworkType)?} network
 */

HDPublicKey.prototype.toWriter = function toWriter(bw, network) {
  if (!network)
    network = this.network;

  network = Network.get(network);

  bw.writeU32BE(network.keyPrefix.xpubkey);
  bw.writeU8(this.depth);
  bw.writeU32BE(this.parentFingerPrint);
  bw.writeU32BE(this.childIndex);
  bw.writeBytes(this.chainCode);
  bw.writeBytes(this.publicKey);
  bw.writeChecksum();

  return bw;
};

/**
 * Calculate serialization size.
 * @returns {Number}
 */

HDPublicKey.prototype.getSize = function getSize() {
  return 82;
};

/**
 * Serialize the key.
 * @param {(Network|NetworkType)?} network
 * @returns {Buffer}
 */

HDPublicKey.prototype.toRaw = function toRaw(network) {
  return this.toWriter(new StaticWriter(82), network).render();
};

/**
 * Instantiate an HD public key from a base58 string.
 * @param {Base58String} xkey
 * @param {Network?} network
 * @returns {HDPublicKey}
 */

HDPublicKey.fromBase58 = function fromBase58(xkey, network) {
  return new HDPublicKey().fromBase58(xkey, network);
};

/**
 * Instantiate key from serialized data.
 * @param {BufferReader} br
 * @param {(Network|NetworkType)?} network
 * @returns {HDPublicKey}
 */

HDPublicKey.fromReader = function fromReader(br, network) {
  return new HDPublicKey().fromReader(br, network);
};

/**
 * Instantiate key from serialized data.
 * @param {Buffer} data
 * @param {(Network|NetworkType)?} network
 * @returns {HDPublicKey}
 */

HDPublicKey.fromRaw = function fromRaw(data, network) {
  return new HDPublicKey().fromRaw(data, network);
};

/**
 * Test whether an object is a HDPublicKey.
 * @param {Object} obj
 * @returns {Boolean}
 */

HDPublicKey.isHDPublicKey = function isHDPublicKey(obj) {
  return obj instanceof HDPublicKey;
};

/*
 * Expose
 */

module.exports = HDPublicKey;


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * client.js - http client for wallets.
 */



const assert = __webpack_require__(0);
const Network = __webpack_require__(6);
const AsyncObject = __webpack_require__(31);
const RPCClient = __webpack_require__(215);
const request = __webpack_require__(92);

/**
 * WMCC HTTP client.
 * @alias module:http.Client
 * @constructor
 * @param {String} uri
 * @param {Object?} options
 */

function HTTPClient(options) {
  if (!(this instanceof HTTPClient))
    return new HTTPClient(options);

  if (!options)
    options = {};

  if (typeof options === 'string')
    options = { uri: options };

  AsyncObject.call(this);

  this.options = options;
  this.network = Network.get(options.network);

  this.uri = options.uri || `http://localhost:${this.network.rpcPort}`;
  this.socket = null;
  this.apiKey = options.apiKey;
  this.auth = options.auth;
  this.rpc = new RPCClient(options);
}

Object.setPrototypeOf(HTTPClient.prototype, AsyncObject.prototype);

/**
 * Open the client, wait for socket to connect.
 * @alias HTTPClient#open
 * @returns {Promise}
 */

HTTPClient.prototype._open = async function _open() {
  let IOClient;

  try {
    IOClient = __webpack_require__(217);
  } catch (e) {
    ;
  }

  if (!IOClient)
    return;

  this.socket = new IOClient(this.uri, {
    transports: ['websocket'],
    forceNew: true
  });

  this.socket.on('error', (err) => {
    this.emit('error', err);
  });

  this.socket.on('version', (info) => {
    if (info.network !== this.network.type)
      this.emit('error', new Error('Wrong network.'));
  });

  this.socket.on('wallet tx', (details) => {
    this.emit('tx', details);
  });

  this.socket.on('wallet confirmed', (details) => {
    this.emit('confirmed', details);
  });

  this.socket.on('wallet unconfirmed', (details) => {
    this.emit('unconfirmed', details);
  });

  this.socket.on('wallet conflict', (details) => {
    this.emit('conflict', details);
  });

  this.socket.on('wallet updated', (details) => {
    this.emit('updated', details);
  });

  this.socket.on('wallet address', (receive) => {
    this.emit('address', receive);
  });

  this.socket.on('wallet balance', (balance) => {
    this.emit('balance', balance);
  });

  await this.onConnect();
  await this.sendAuth();
};

/**
 * Close the client, wait for the socket to close.
 * @alias HTTPClient#close
 * @returns {Promise}
 */

HTTPClient.prototype._close = function _close() {
  if (!this.socket)
    return Promise.resolve();

  this.socket.disconnect();
  this.socket = null;

  return Promise.resolve();
};

/**
 * Wait for websocket connection.
 * @private
 * @returns {Promise}
 */

HTTPClient.prototype.onConnect = function onConnect() {
  return new Promise((resolve, reject) => {
    this.socket.once('connect', resolve);
  });
};

/**
 * Wait for websocket auth.
 * @private
 * @returns {Promise}
 */

HTTPClient.prototype.sendAuth = function sendAuth() {
  return new Promise((resolve, reject) => {
    this.socket.emit('auth', this.apiKey, (err) => {
      if (err) {
        reject(new Error(err.message));
        return;
      }
      resolve();
    });
  });
};

/**
 * Wait for websocket auth.
 * @private
 * @returns {Promise}
 */

HTTPClient.prototype.sendWalletAuth = function sendWalletAuth() {
  return new Promise((resolve, reject) => {
    this.socket.emit('wallet auth', this.apiKey, (err) => {
      if (err) {
        reject(new Error(err.message));
        return;
      }
      resolve();
    });
  });
};

/**
 * Wait for websocket disconnection.
 * @private
 * @returns {Promise}
 */

HTTPClient.prototype.onDisconnect = function onDisconnect() {
  return new Promise((resolve, reject) => {
    this.socket.once('disconnect', resolve);
  });
};

/**
 * Make an http request to endpoint.
 * @private
 * @param {String} method
 * @param {String} endpoint - Path.
 * @param {Object} json - Body or query depending on method.
 * @returns {Promise} - Returns Object?.
 */

HTTPClient.prototype._request = async function _request(method, endpoint, json) {
  if (this.token) {
    if (!json)
      json = {};
    json.token = this.token;
  }

  let query;
  if (json && method === 'get') {
    query = json;
    json = null;
  }

  const res = await request({
    method: method,
    uri: this.uri + endpoint,
    pool: true,
    query: query,
    json: json,
    auth: {
      username: 'wmccrpc',
      password: this.apiKey || ''
    }
  });

  if (res.statusCode === 404)
    return null;

  if (res.statusCode === 401)
    throw new Error('Unauthorized (bad API key).');

  if (res.statusCode !== 200)
    throw new Error(`Status code: ${res.statusCode}.`);

  if (res.type !== 'json')
    throw new Error('Bad response (wrong content-type).');

  if (!res.body)
    throw new Error('Bad response (no body).');

  const network = res.headers['x-wmcc-network'];

  if (network && network !== this.network.type)
    throw new Error('Bad response (wrong network).');

  if (res.body.error)
    throw new Error(res.body.error.message);

  return res.body;
};

/**
 * Make a GET http request to endpoint.
 * @private
 * @param {String} endpoint - Path.
 * @param {Object} json - Querystring.
 * @returns {Promise} - Returns Object?.
 */

HTTPClient.prototype._get = function _get(endpoint, json) {
  return this._request('get', endpoint, json);
};

/**
 * Make a POST http request to endpoint.
 * @private
 * @param {String} endpoint - Path.
 * @param {Object} json - Body.
 * @returns {Promise} - Returns Object?.
 */

HTTPClient.prototype._post = function _post(endpoint, json) {
  return this._request('post', endpoint, json);
};

/**
 * Make a PUT http request to endpoint.
 * @private
 * @param {String} endpoint - Path.
 * @param {Object} json - Body.
 * @returns {Promise} - Returns Object?.
 */

HTTPClient.prototype._put = function _put(endpoint, json) {
  return this._request('put', endpoint, json);
};

/**
 * Make a DELETE http request to endpoint.
 * @private
 * @param {String} endpoint - Path.
 * @param {Object} json - Body.
 * @returns {Promise} - Returns Object?.
 */

HTTPClient.prototype._del = function _del(endpoint, json) {
  return this._request('delete', endpoint, json);
};

/**
 * Get a mempool snapshot.
 * @returns {Promise} - Returns {@link Hash}[].
 */

HTTPClient.prototype.getMempool = function getMempool() {
  return this._get('/mempool');
};

/**
 * Get some info about the server (network and version).
 * @returns {Promise} - Returns Object.
 */

HTTPClient.prototype.getInfo = function getInfo() {
  return this._get('/');
};

/**
 * Get coins that pertain to an address from the mempool or chain database.
 * Takes into account spent coins in the mempool.
 * @param {String} address
 * @returns {Promise} - Returns {@link Coin}[].
 */

HTTPClient.prototype.getCoinsByAddress = function getCoinsByAddress(address, after) {
  return this._get(`/coin/address/${address}/${after}`);
};

/**
 * Get coins that pertain to addresses from the mempool or chain database.
 * Takes into account spent coins in the mempool.
 * @param {String[]} addresses
 * @returns {Promise} - Returns {@link Coin}[].
 */

HTTPClient.prototype.getCoinsByAddresses = function getCoinsByAddresses(addresses) {
  return this._post('/coin/address', { addresses });
};

/**
 * Retrieve a coin from the mempool or chain database.
 * Takes into account spent coins in the mempool.
 * @param {Hash} hash
 * @param {Number} index
 * @returns {Promise} - Returns {@link Coin}.
 */

HTTPClient.prototype.getCoin = function getCoin(hash, index) {
  return this._get(`/coin/${hash}/${index}`);
};

/**
 * Retrieve transactions pertaining to an
 * address from the mempool or chain database.
 * @param {String} address
 * @returns {Promise} - Returns {@link TX}[].
 */

HTTPClient.prototype.getTXByAddress = function getTXByAddress(address) {
  return this._get(`/tx/address/${address}`);
};

/**
 * Retrieve transactions pertaining to
 * addresses from the mempool or chain database.
 * @param {String[]} addresses
 * @returns {Promise} - Returns {@link TX}[].
 */

HTTPClient.prototype.getTXByAddresses = function getTXByAddresses(addresses) {
  return this._post('/tx/address', { addresses });
};

/**
 * Retrieve a transaction from the mempool or chain database.
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link TX}.
 */

HTTPClient.prototype.getTX = function getTX(hash) {
  return this._get(`/tx/${hash}`);
};

/**
 * Retrieve a block from the chain database.
 * @param {Hash|Number} block
 * @returns {Promise} - Returns {@link Block}.
 */

HTTPClient.prototype.getBlock = function getBlock(block) {
  return this._get(`/block/${block}`);
};

/**
 * Add a transaction to the mempool and broadcast it.
 * @param {TX} tx
 * @returns {Promise}
 */

HTTPClient.prototype.broadcast = function broadcast(tx) {
  return this._post('/broadcast', { tx: toHex(tx) });
};

/**
 * Rescan the chain.
 * @param {Number} height
 * @returns {Promise}
 */

HTTPClient.prototype.rescan = function rescan(height) {
  return this._post('/wallet/_admin/rescan', { height });
};

/**
 * Reset the chain.
 * @param {Number} height
 * @returns {Promise}
 */

HTTPClient.prototype.reset = function reset(height) {
  return this._post('/reset', { height });
};

/**
 * Resend pending transactions.
 * @returns {Promise}
 */

HTTPClient.prototype.resend = function resend() {
  return this._post('/wallet/_admin/resend', {});
};

/**
 * Backup the walletdb.
 * @param {String} path
 * @returns {Promise}
 */

HTTPClient.prototype.backup = function backup(path) {
  return this._post('/wallet/_admin/backup', { path });
};

/**
 * Listen for events on wallet id.
 * @param {String} id
 * @param {String?} token
 * @returns {Promise}
 */

HTTPClient.prototype.join = function join(id, token) {
  if (!this.socket)
    return Promise.resolve();

  return new Promise((resolve, reject) => {
    this.socket.emit('wallet join', id, token, (err) => {
      if (err) {
        reject(new Error(err.message));
        return;
      }
      resolve();
    });
  });
};

/**
 * Unlisten for events on wallet id.
 * @param {String} id
 */

HTTPClient.prototype.leave = function leave(id) {
  if (!this.socket)
    return Promise.resolve();

  return new Promise((resolve, reject) => {
    this.socket.emit('wallet leave', id, (err) => {
      if (err) {
        reject(new Error(err.message));
        return;
      }
      resolve();
    });
  });
};

/**
 * Get list of all wallet IDs.
 * @returns {Promise}
 */

HTTPClient.prototype.getWallets = function getWallets() {
  return this._get('/wallet/_admin/wallets');
};

/**
 * Create a wallet.
 * @param {Object} options
 * @returns {Promise}
 */

HTTPClient.prototype.createWallet = function createWallet(options) {
  assert(options.id, 'Must pass an id parameter');
  return this._put(`/wallet/${options.id}`, options);
};

/**
 * Get the raw wallet JSON.
 * @param {String} id
 * @returns {Promise}
 */

HTTPClient.prototype.getWallet = function getWallet(id) {
  return this._get(`/wallet/${id}`);
};

/**
 * Get wallet transaction history.
 * @param {String} id
 * @returns {Promise}
 */

HTTPClient.prototype.getHistory = function getHistory(id, account) {
  return this._get(`/wallet/${id}/tx/history`, { account });
};

/**
 * Get wallet coins.
 * @param {String} id
 * @returns {Promise}
 */

HTTPClient.prototype.getCoins = function getCoins(id, account) {
  return this._get(`/wallet/${id}/coin`, { account });
};

/**
 * Get all unconfirmed transactions.
 * @param {String} id
 * @returns {Promise}
 */

HTTPClient.prototype.getPending = function getPending(id, account) {
  return this._get(`/wallet/${id}/tx/unconfirmed`, { account });
};

/**
 * Calculate wallet balance.
 * @param {String} id
 * @returns {Promise}
 */

HTTPClient.prototype.getBalance = function getBalance(id, account) {
  return this._get(`/wallet/${id}/balance`, { account });
};

/**
 * Get last N wallet transactions.
 * @param {String} id
 * @param {Number} limit - Max number of transactions.
 * @returns {Promise}
 */

HTTPClient.prototype.getLast = function getLast(id, account, limit) {
  return this._get(`/wallet/${id}/tx/last`, { account, limit });
};

/**
 * Get wallet transactions by timestamp range.
 * @param {String} id
 * @param {Object} options
 * @param {Number} options.start - Start time.
 * @param {Number} options.end - End time.
 * @param {Number?} options.limit - Max number of records.
 * @param {Boolean?} options.reverse - Reverse order.
 * @returns {Promise}
 */

HTTPClient.prototype.getRange = function getRange(id, account, options) {
  const body = {
    account: account,
    start: options.start,
    end: options.end ,
    limit: options.limit,
    reverse: options.reverse
  };
  return this._get(`/wallet/${id}/tx/range`, body);
};

/**
 * Get transaction (only possible if the transaction
 * is available in the wallet history).
 * @param {String} id
 * @param {Hash} hash
 * @returns {Promise}
 */

HTTPClient.prototype.getWalletTX = function getWalletTX(id, hash) {
  return this._get(`/wallet/${id}/tx/${hash}`);
};

/**
 * Get wallet blocks.
 * @param {String} id
 * @param {Number} height
 * @returns {Promise}
 */

HTTPClient.prototype.getWalletBlocks = function getWalletBlocks(id) {
  return this._get(`/wallet/${id}/block`);
};

/**
 * Get wallet block.
 * @param {String} id
 * @param {Number} height
 * @returns {Promise}
 */

HTTPClient.prototype.getWalletBlock = function getWalletBlock(id, height) {
  return this._get(`/wallet/${id}/block/${height}`);
};

/**
 * Get unspent coin (only possible if the transaction
 * is available in the wallet history).
 * @param {String} id
 * @param {Hash} hash
 * @param {Number} index
 * @returns {Promise}
 */

HTTPClient.prototype.getWalletCoin = function getWalletCoin(id, account, hash, index) {
  return this._get(`/wallet/${id}/coin/${hash}/${index}`, { account });
};

/**
 * Create a transaction, fill, sign, and broadcast.
 * @param {String} id
 * @param {Object} options
 * @param {String} options.address
 * @param {Amount} options.value
 * @returns {Promise}
 */

HTTPClient.prototype.send = function send(id, options) {
  const body = Object.assign({}, options);

  if (!body.outputs)
    body.outputs = [];

  body.outputs = body.outputs.map((output) => {
    return {
      value: output.value,
      address: output.address,
      script: toHex(output.script)
    };
  });

  return this._post(`/wallet/${id}/send`, body);
};

/**
 * Generate a new token.
 * @param {(String|Buffer)?} passphrase
 * @returns {Promise}
 */

HTTPClient.prototype.retoken = async function retoken(id, passphrase) {
  const body = await this._post(`/wallet/${id}/retoken`, { passphrase });
  return body.token;
};

/**
 * Change or set master key's passphrase.
 * @param {(String|Buffer)?} old
 * @param {String|Buffer} new_
 * @returns {Promise}
 */

HTTPClient.prototype.setPassphrase = function setPassphrase(id, old, new_) {
  const body = { old: old, passphrase: new_ };
  return this._post(`/wallet/${id}/passphrase`, body);
};

/**
 * Create a transaction, fill.
 * @param {String} id
 * @param {Object} options
 * @returns {Promise}
 */

HTTPClient.prototype.createTX = function createTX(id, options) {
  const body = Object.assign({}, options);

  if (!body.outputs)
    body.outputs = [];

  body.outputs = body.outputs.map((output) => {
    return {
      value: output.value,
      address: output.address,
      script: toHex(output.script)
    };
  });

  return this._post(`/wallet/${id}/create`, body);
};

/**
 * Sign a transaction.
 * @param {String} id
 * @param {TX} tx
 * @param {Object} options
 * @returns {Promise}
 */

HTTPClient.prototype.sign = function sign(id, tx, options) {
  const body = Object.assign({}, options);
  body.tx = toHex(tx);
  return this._post(`/wallet/${id}/sign`, body);
};

/**
 * @param {String} id
 * @param {Number} now - Current time.
 * @param {Number} age - Age delta (delete transactions older than `now - age`).
 * @returns {Promise}
 */

HTTPClient.prototype.zapWallet = function zapWallet(id, account, age) {
  return this._post(`/wallet/${id}/zap`, { account, age });
};

/**
 * Get wallet key.
 * @param {String} id
 * @param {String} address
 * @returns {Promise}
 */

HTTPClient.prototype.getKey = function getKey(id, address) {
  return this._get(`/wallet/${id}/key/${address}`);
};

/**
 * Get wallet key WIF dump.
 * @param {String} id
 * @param {String} address
 * @param {String?} passphrase
 * @returns {Promise}
 */

HTTPClient.prototype.getWIF = function getWIF(id, address, passphrase) {
  return this._get(`/wallet/${id}/wif/${address}`, { passphrase });
};

/**
 * Add a public account/purpose key to the wallet for multisig.
 * @param {String} id
 * @param {(String|Number)?} account
 * @param {Base58String} key - Account (bip44) or
 * Purpose (bip45) key (can be in base58 form).
 * @returns {Promise}
 */

HTTPClient.prototype.addSharedKey = function addSharedKey(id, account, key) {
  const body = { account: account, accountKey: key };
  return this._put(`/wallet/${id}/shared-key`, body);
};

/**
 * Remove a public account/purpose key to the wallet for multisig.
 * @param {String} id
 * @param {(String|Number)?} account
 * @param {Base58String} key - Account (bip44) or Purpose
 * (bip45) key (can be in base58 form).
 * @returns {Promise}
 */

HTTPClient.prototype.removeSharedKey = function removeSharedKey(id, account, key) {
  const body = { account: account, accountKey: key };
  return this._del(`/wallet/${id}/shared-key`, body);
};

/**
 * Import private key.
 * @param {String} id
 * @param {Number|String} account
 * @param {String} key
 * @returns {Promise}
 */

HTTPClient.prototype.importPrivate = function importPrivate(id, account, key) {
  const body = { account: account, privateKey: key };
  return this._post(`/wallet/${id}/import`, body);
};

/**
 * Import public key.
 * @param {String} id
 * @param {Number|String} account
 * @param {String} key
 * @returns {Promise}
 */

HTTPClient.prototype.importPublic = function importPublic(id, account, key) {
  const body = { account: account, publicKey: key };
  return this._post(`/wallet/${id}/import`, body);
};

/**
 * Import address.
 * @param {String} id
 * @param {Number|String} account
 * @param {String} address
 * @returns {Promise}
 */

HTTPClient.prototype.importAddress = function importAddress(id, account, address) {
  return this._post(`/wallet/${id}/import`, { account, address });
};

/**
 * Lock a coin.
 * @param {String} id
 * @param {String} hash
 * @param {Number} index
 * @returns {Promise}
 */

HTTPClient.prototype.lockCoin = function lockCoin(id, hash, index) {
  return this._put(`/wallet/${id}/coin/locked`, { hash, index });
};

/**
 * Unlock a coin.
 * @param {String} id
 * @param {String} hash
 * @param {Number} index
 * @returns {Promise}
 */

HTTPClient.prototype.unlockCoin = function unlockCoin(id, hash, index) {
  return this._del(`/wallet/${id}/coin/locked`, { hash, index });
};

/**
 * Get locked coins.
 * @param {String} id
 * @returns {Promise}
 */

HTTPClient.prototype.getLocked = function getLocked(id) {
  return this._get(`/wallet/${id}/coin/locked`);
};

/**
 * Lock wallet.
 * @param {String} id
 * @returns {Promise}
 */

HTTPClient.prototype.lock = function lock(id) {
  return this._post(`/wallet/${id}/lock`, {});
};

/**
 * Unlock wallet.
 * @param {String} id
 * @param {String} passphrase
 * @param {Number} timeout
 * @returns {Promise}
 */

HTTPClient.prototype.unlock = function unlock(id, passphrase, timeout) {
  return this._post(`/wallet/${id}/unlock`, { passphrase, timeout });
};

/**
 * Resend pending wallet transactions.
 * @returns {Promise}
 */

HTTPClient.prototype.resendWallet = function resendWallet(id) {
  return this._post(`/wallet/${id}/resend`, {});
};

/**
 * Get wallet accounts.
 * @param {String} id
 * @returns {Promise} - Returns Array.
 */

HTTPClient.prototype.getAccounts = function getAccounts(id) {
  return this._get(`/wallet/${id}/account`);
};

/**
 * Get wallet master key.
 * @param {String} id
 * @returns {Promise}
 */

HTTPClient.prototype.getMaster = function getMaster(id) {
  return this._get(`/wallet/${id}/master`);
};

/**
 * Get wallet account.
 * @param {String} id
 * @param {String} account
 * @returns {Promise}
 */

HTTPClient.prototype.getAccount = function getAccount(id, account) {
  return this._get(`/wallet/${id}/account/${account}`);
};

/**
 * Create account.
 * @param {String} id
 * @param {String} name
 * @param {Object} options
 * @returns {Promise}
 */

HTTPClient.prototype.createAccount = function createAccount(id, name, options) {
  return this._put(`/wallet/${id}/account/${name}`, options || {});
};

/**
 * Create address.
 * @param {String} id
 * @param {Object} options
 * @returns {Promise}
 */

HTTPClient.prototype.createAddress = function createAddress(id, options) {
  if (!options)
    options = {};

  if (typeof options === 'string')
    options = { account: options };

  return this._post(`/wallet/${id}/address`, options);
};

/**
 * Create change address.
 * @param {String} id
 * @param {Object} options
 * @returns {Promise}
 */

HTTPClient.prototype.createChange = function createChange(id, options) {
  if (!options)
    options = {};

  if (typeof options === 'string')
    options = { account: options };

  return this._post(`/wallet/${id}/change`, options);
};

/**
 * Create nested address.
 * @param {String} id
 * @param {Object} options
 * @returns {Promise}
 */

HTTPClient.prototype.createNested = function createNested(id, options) {
  if (!options)
    options = {};

  if (typeof options === 'string')
    options = { account: options };

  return this._post(`/wallet/${id}/nested`, options);
};

/*
 * Helpers
 */

function toHex(obj) {
  if (!obj)
    return null;

  if (obj.toRaw)
    obj = obj.toRaw();

  if (Buffer.isBuffer(obj))
    obj = obj.toString('hex');

  return obj;
}

/*
 * Expose
 */

module.exports = HTTPClient;


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * rpcclient.js - json rpc client for wmcc_core.
 */



const Network = __webpack_require__(6);
const request = __webpack_require__(92);

/**
 * WMCC RPC client.
 * @alias module:http.RPCClient
 * @constructor
 * @param {String} uri
 * @param {Object?} options
 */

function RPCClient(options) {
  if (!(this instanceof RPCClient))
    return new RPCClient(options);

  if (!options)
    options = {};

  if (typeof options === 'string')
    options = { uri: options };

  this.options = options;
  this.network = Network.get(options.network);

  this.uri = options.uri || `http://localhost:${this.network.rpcPort}`;
  this.apiKey = options.apiKey;
  this.id = 0;
}

/**
 * Make a json rpc request.
 * @private
 * @param {String} method - RPC method name.
 * @param {Array} params - RPC parameters.
 * @returns {Promise} - Returns Object?.
 */

RPCClient.prototype.execute = async function execute(method, params) {
  const res = await request({
    method: 'POST',
    uri: this.uri,
    pool: true,
    json: {
      method: method,
      params: params,
      id: this.id++
    },
    auth: {
      username: 'wmccrpc',
      password: this.apiKey || ''
    }
  });

  if (res.statusCode === 401)
    throw new RPCError('Unauthorized (bad API key).', -1);

  if (res.statusCode !== 200)
    throw new Error(`Status code: ${res.statusCode}.`);

  if (res.type !== 'json')
    throw new Error('Bad response (wrong content-type).');

  if (!res.body)
    throw new Error('No body for JSON-RPC response.');

  if (res.body.error)
    throw new RPCError(res.body.error.message, res.body.error.code);

  return res.body.result;
};

/*
 * Helpers
 */

function RPCError(msg, code) {
  Error.call(this);

  this.type = 'RPCError';
  this.message = String(msg);
  this.code = code >>> 0;

  if (Error.captureStackTrace)
    Error.captureStackTrace(this, RPCError);
}

Object.setPrototypeOf(RPCError.prototype, Error.prototype);

/*
 * Expose
 */

module.exports = RPCClient;


/***/ }),
/* 216 */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var url = __webpack_require__(279);
var parser = __webpack_require__(173);
var Manager = __webpack_require__(223);
var debug = __webpack_require__(110)('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup (uri, opts) {
  if (typeof uri === 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.query;
  }
  return io.socket(parsed.path, opts);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = __webpack_require__(223);
exports.Socket = __webpack_require__(236);


/***/ }),
/* 218 */
/***/ (function(module, exports) {

/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(281);

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(285);

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),
/* 221 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 222 */
/***/ (function(module, exports) {


module.exports = isBuf;

var withNativeBuffer = typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function';
var withNativeArrayBuffer = typeof ArrayBuffer === 'function';

var isView = function (obj) {
  return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : (obj.buffer instanceof ArrayBuffer);
};

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (withNativeBuffer && Buffer.isBuffer(obj)) ||
          (withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)));
}


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var eio = __webpack_require__(288);
var Socket = __webpack_require__(236);
var Emitter = __webpack_require__(73);
var parser = __webpack_require__(173);
var on = __webpack_require__(237);
var bind = __webpack_require__(238);
var debug = __webpack_require__(110)('socket.io-client:manager');
var indexOf = __webpack_require__(235);
var Backoff = __webpack_require__(307);

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager (uri, opts) {
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' === typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  var _parser = opts.parser || parser;
  this.encoder = new _parser.Encoder();
  this.decoder = new _parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function () {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function () {
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.generateId(nsp);
    }
  }
};

/**
 * generate `socket.id` for the given `nsp`
 *
 * @param {String} nsp
 * @return {String}
 * @api private
 */

Manager.prototype.generateId = function (nsp) {
  return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function (v) {
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function (v) {
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function (v) {
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function (v) {
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function (v) {
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function (v) {
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function () {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};

/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function (fn, opts) {
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function () {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function (data) {
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function () {
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function () {
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function () {
  this.lastPing = new Date();
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function () {
  this.emitAll('pong', new Date() - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function (data) {
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function (err) {
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function (nsp, opts) {
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp, opts);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function () {
      socket.id = self.generateId(nsp);
    });

    if (this.autoConnect) {
      // manually call here since connecting event is fired before listening
      onConnecting();
    }
  }

  function onConnecting () {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function (socket) {
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function (packet) {
  debug('writing packet %j', packet);
  var self = this;
  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function (encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function () {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function () {
  debug('cleanup');

  var subsLength = this.subs.length;
  for (var i = 0; i < subsLength; i++) {
    var sub = this.subs.shift();
    sub.destroy();
  }

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function () {
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' === this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function (reason) {
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function () {
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function () {
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function (err) {
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function () {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies
 */

var XMLHttpRequest = __webpack_require__(174);
var XHR = __webpack_require__(290);
var JSONP = __webpack_require__(298);
var websocket = __webpack_require__(299);

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling (opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}


/***/ }),
/* 225 */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var Transport = __webpack_require__(175);
var parseqs = __webpack_require__(111);
var parser = __webpack_require__(74);
var inherit = __webpack_require__(112);
var yeast = __webpack_require__(228);
var debug = __webpack_require__(113)('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function () {
  var XMLHttpRequest = __webpack_require__(174);
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function () {
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function (onPause) {
  var self = this;

  this.readyState = 'pausing';

  function pause () {
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function () {
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function () {
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function () {
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function (data) {
  var self = this;
  debug('polling got data %s', data);
  var callback = function (packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' === self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' === packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' !== this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' === this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function () {
  var self = this;

  function close () {
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' === this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function (packets) {
  var self = this;
  this.writable = false;
  var callbackfn = function () {
    self.writable = true;
    self.emit('drain');
  };

  parser.encodePayload(packets, this.supportsBinary, function (data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' === schema && Number(this.port) !== 443) ||
     ('http' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

/* global Blob File */

/*
 * Module requirements.
 */

var isArray = __webpack_require__(292);

var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' ||
                        typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]';
var withNativeFile = typeof File === 'function' ||
                        typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]';

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary (obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }

  if ((typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj)) ||
    (typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
    (withNativeBlob && obj instanceof Blob) ||
    (withNativeFile && obj instanceof File)
  ) {
    return true;
  }

  // see: https://github.com/Automattic/has-binary/pull/4
  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(296);

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const EventEmitter = __webpack_require__(10);
const crypto = __webpack_require__(24);
const https = __webpack_require__(109);
const http = __webpack_require__(72);
const net = __webpack_require__(176);
const tls = __webpack_require__(301);
const url = __webpack_require__(90);

const PerMessageDeflate = __webpack_require__(114);
const EventTarget = __webpack_require__(304);
const extension = __webpack_require__(231);
const constants = __webpack_require__(93);
const Receiver = __webpack_require__(232);
const Sender = __webpack_require__(234);

const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const kWebSocket = constants.kWebSocket;
const protocolVersions = [8, 13];
const closeTimeout = 30 * 1000; // Allow 30 seconds to terminate the connection cleanly.

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|url.Url|url.URL)} address The URL to which to connect
   * @param {(String|String[])} protocols The subprotocols
   * @param {Object} options Connection options
   */
  constructor(address, protocols, options) {
    super();

    this.readyState = WebSocket.CONNECTING;
    this.protocol = '';

    this._binaryType = constants.BINARY_TYPES[0];
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = '';
    this._closeTimer = null;
    this._closeCode = 1006;
    this._extensions = {};
    this._isServer = true;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      if (Array.isArray(protocols)) {
        protocols = protocols.join(', ');
      } else if (typeof protocols === 'object' && protocols !== null) {
        options = protocols;
        protocols = undefined;
      }

      initAsClient.call(this, address, protocols, options);
    }
  }

  get CONNECTING() {
    return WebSocket.CONNECTING;
  }
  get CLOSING() {
    return WebSocket.CLOSING;
  }
  get CLOSED() {
    return WebSocket.CLOSED;
  }
  get OPEN() {
    return WebSocket.OPEN;
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the required
   * default "blob" type (instead we define a custom "nodebuffer" type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!constants.BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return 0;

    //
    // `socket.bufferSize` is `undefined` if the socket is closed.
    //
    return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Number} maxPayload The maximum allowed message size
   * @private
   */
  setSocket(socket, head, maxPayload) {
    const receiver = new Receiver(
      this._binaryType,
      this._extensions,
      maxPayload
    );

    this._sender = new Sender(socket, this._extensions);
    this._receiver = receiver;
    this._socket = socket;

    receiver[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    socket.setTimeout(0);
    socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this.readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    this.readyState = WebSocket.CLOSED;

    if (!this._socket) {
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} code Status code explaining why the connection is closing
   * @param {String} data A string explaining why the connection is closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();
      return;
    }

    this.readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;

      if (this._socket.writable) {
        if (this._closeFrameReceived) this._socket.end();

        //
        // Ensure that the connection is closed even if the closing handshake
        // fails.
        //
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
    });
  }

  /**
   * Send a ping.
   *
   * @param {*} data The data to send
   * @param {Boolean} mask Indicates whether or not to mask `data`
   * @param {Function} cb Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (this.readyState !== WebSocket.OPEN) {
      const err = new Error(
        `WebSocket is not open: readyState ${this.readyState} ` +
          `(${readyStates[this.readyState]})`
      );

      if (cb) return cb(err);
      throw err;
    }

    if (typeof data === 'number') data = data.toString();
    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || constants.EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} data The data to send
   * @param {Boolean} mask Indicates whether or not to mask `data`
   * @param {Function} cb Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (this.readyState !== WebSocket.OPEN) {
      const err = new Error(
        `WebSocket is not open: readyState ${this.readyState} ` +
          `(${readyStates[this.readyState]})`
      );

      if (cb) return cb(err);
      throw err;
    }

    if (typeof data === 'number') data = data.toString();
    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || constants.EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} options.compress Specifies whether or not to compress `data`
   * @param {Boolean} options.binary Specifies whether `data` is binary or text
   * @param {Boolean} options.fin Specifies whether the fragment is the last one
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (this.readyState !== WebSocket.OPEN) {
      const err = new Error(
        `WebSocket is not open: readyState ${this.readyState} ` +
          `(${readyStates[this.readyState]})`
      );

      if (cb) return cb(err);
      throw err;
    }

    if (typeof data === 'number') data = data.toString();

    const opts = Object.assign(
      {
        binary: typeof data !== 'string',
        mask: !this._isServer,
        compress: true,
        fin: true
      },
      options
    );

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || constants.EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this._socket) {
      this.readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

readyStates.forEach((readyState, i) => {
  WebSocket[readyState] = i;
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    /**
     * Return the listener of the event.
     *
     * @return {(Function|undefined)} The event listener or `undefined`
     * @public
     */
    get() {
      const listeners = this.listeners(method);
      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i]._listener) return listeners[i]._listener;
      }

      return undefined;
    },
    /**
     * Add a listener for the event.
     *
     * @param {Function} listener The listener to add
     * @public
     */
    set(listener) {
      const listeners = this.listeners(method);
      for (var i = 0; i < listeners.length; i++) {
        //
        // Remove only the listeners added via `addEventListener`.
        //
        if (listeners[i]._listener) this.removeListener(method, listeners[i]);
      }
      this.addEventListener(method, listener);
    }
  });
});

WebSocket.prototype.addEventListener = EventTarget.addEventListener;
WebSocket.prototype.removeEventListener = EventTarget.removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {(String|url.Url|url.URL)} address The URL to which to connect
 * @param {String} protocols The subprotocols
 * @param {Object} options Connection options
 * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate
 * @param {Number} options.handshakeTimeout Timeout in milliseconds for the handshake request
 * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version` header
 * @param {String} options.origin Value of the `Origin` or `Sec-WebSocket-Origin` header
 * @param {Number} options.maxPayload The maximum allowed message size
 * @private
 */
function initAsClient(address, protocols, options) {
  options = Object.assign(
    {
      protocolVersion: protocolVersions[1],
      perMessageDeflate: true,
      maxPayload: 100 * 1024 * 1024
    },
    options,
    {
      createConnection: undefined,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: undefined,
      auth: undefined,
      host: undefined,
      path: undefined,
      port: undefined
    }
  );

  if (!protocolVersions.includes(options.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${options.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  this._isServer = false;

  var parsedUrl;

  if (typeof address === 'object' && address.href !== undefined) {
    parsedUrl = address;
    this.url = address.href;
  } else {
    //
    // The WHATWG URL constructor is not available on Node.js < 6.13.0
    //
    parsedUrl = url.URL ? new url.URL(address) : url.parse(address);
    this.url = address;
  }

  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';

  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
    throw new Error(`Invalid URL: ${this.url}`);
  }

  const isSecure =
    parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';
  const defaultPort = isSecure ? 443 : 80;
  const key = crypto.randomBytes(16).toString('base64');
  const httpObj = isSecure ? https : http;
  const path = parsedUrl.search
    ? `${parsedUrl.pathname || '/'}${parsedUrl.search}`
    : parsedUrl.pathname || '/';
  var perMessageDeflate;

  options.createConnection = isSecure ? tlsConnect : netConnect;
  options.defaultPort = options.defaultPort || defaultPort;
  options.port = parsedUrl.port || defaultPort;
  options.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  options.headers = Object.assign(
    {
      'Sec-WebSocket-Version': options.protocolVersion,
      'Sec-WebSocket-Key': key,
      Connection: 'Upgrade',
      Upgrade: 'websocket'
    },
    options.headers
  );
  options.path = path;
  options.timeout = options.handshakeTimeout;

  if (options.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      options.perMessageDeflate !== true ? options.perMessageDeflate : {},
      false,
      options.maxPayload
    );
    options.headers['Sec-WebSocket-Extensions'] = extension.format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols) {
    options.headers['Sec-WebSocket-Protocol'] = protocols;
  }
  if (options.origin) {
    if (options.protocolVersion < 13) {
      options.headers['Sec-WebSocket-Origin'] = options.origin;
    } else {
      options.headers.Origin = options.origin;
    }
  }
  if (parsedUrl.auth) {
    options.auth = parsedUrl.auth;
  } else if (parsedUrl.username || parsedUrl.password) {
    options.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isUnixSocket) {
    const parts = path.split(':');

    options.socketPath = parts[0];
    options.path = parts[1];
  }

  var req = (this._req = httpObj.get(options));

  if (options.handshakeTimeout) {
    req.on('timeout', () => {
      abortHandshake(this, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (this._req.aborted) return;

    req = this._req = null;
    this.readyState = WebSocket.CLOSING;
    this.emit('error', err);
    this.emitClose();
  });

  req.on('response', (res) => {
    if (this.emit('unexpected-response', req, res)) return;

    abortHandshake(this, req, `Unexpected server response: ${res.statusCode}`);
  });

  req.on('upgrade', (res, socket, head) => {
    this.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the `upgrade`
    // event.
    //
    if (this.readyState !== WebSocket.CONNECTING) return;

    req = this._req = null;

    const digest = crypto
      .createHash('sha1')
      .update(key + constants.GUID, 'binary')
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(this, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    const protList = (protocols || '').split(/, */);
    var protError;

    if (!protocols && serverProt) {
      protError = 'Server sent a subprotocol but none was requested';
    } else if (protocols && !serverProt) {
      protError = 'Server sent no subprotocol';
    } else if (serverProt && !protList.includes(serverProt)) {
      protError = 'Server sent an invalid subprotocol';
    }

    if (protError) {
      abortHandshake(this, socket, protError);
      return;
    }

    if (serverProt) this.protocol = serverProt;

    if (perMessageDeflate) {
      try {
        const extensions = extension.parse(
          res.headers['sec-websocket-extensions']
        );

        if (extensions[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          this._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        abortHandshake(this, socket, 'Invalid Sec-WebSocket-Extensions header');
        return;
      }
    }

    this.setSocket(socket, head, options.maxPayload);
  });
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  //
  // Override `options.path` only if `options` is a copy of the original options
  // object. This is always true on Node.js >= 8 but not on Node.js 6 where
  // `options.socketPath` might be `undefined` even if the `socketPath` option
  // was originally set.
  //
  if (options.protocolVersion) options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;
  options.servername = options.servername || options.host;
  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the
 *     socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket.readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream.abort();
    stream.once('abort', websocket.emitClose.bind(websocket));
    websocket.emit('error', err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {String} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);
  websocket._socket.resume();

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  this[kWebSocket]._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);

  websocket.readyState = WebSocket.CLOSING;
  websocket._closeCode = err[constants.kStatusCode];
  websocket.emit('error', err);
  websocket._socket.destroy();
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message
 * @private
 */
function receiverOnMessage(data) {
  this[kWebSocket].emit('message', data);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  websocket.pong(data, !websocket._isServer, constants.NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * The listener of the `net.Socket` `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('end', socketOnEnd);

  websocket.readyState = WebSocket.CLOSING;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk and emitted synchronously in a single
  // `'data'` event.
  //
  websocket._socket.read();
  websocket._receiver.end();

  this.removeListener('data', socketOnData);
  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the `net.Socket` `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the `net.Socket` `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket.readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the `net.Socket` `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', constants.NOOP);

  if (websocket) {
    websocket.readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (Object.prototype.hasOwnProperty.call(dest, name)) dest[name].push(elem);
  else dest[name] = [elem];
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = {};

  if (header === undefined || header === '') return offers;

  var params = {};
  var mustUnescape = false;
  var isEscaping = false;
  var inQuotes = false;
  var extensionName;
  var paramName;
  var start = -1;
  var end = -1;

  for (var i = 0; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 /* ' ' */ || code === 0x09 /* '\t' */) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = {};
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = {};
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        var value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = {};
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, {});
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      var configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                var values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const stream = __webpack_require__(216);

const PerMessageDeflate = __webpack_require__(114);
const bufferUtil = __webpack_require__(177);
const validation = __webpack_require__(233);
const constants = __webpack_require__(93);

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;

/**
 * HyBi Receiver implementation.
 *
 * @extends stream.Writable
 */
class Receiver extends stream.Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {String} binaryType The type for binary data
   * @param {Object} extensions An object containing the negotiated extensions
   * @param {Number} maxPayload The maximum allowed message length
   */
  constructor(binaryType, extensions, maxPayload) {
    super();

    this._binaryType = binaryType || constants.BINARY_TYPES[0];
    this[constants.kWebSocket] = undefined;
    this._extensions = extensions || {};
    this._maxPayload = maxPayload | 0;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._state = GET_INFO;
    this._loop = false;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = buf.slice(n);
      return buf.slice(0, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];

      if (n >= buf.length) {
        this._buffers.shift().copy(dst, dst.length - n);
      } else {
        buf.copy(dst, dst.length - n, 0, n);
        this._buffers[0] = buf.slice(n);
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    var err;
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          err = this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          err = this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          err = this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          err = this.getData(cb);
          break;
        default:
          // `INFLATING`
          this._loop = false;
          return;
      }
    } while (this._loop);

    cb(err);
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getInfo() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      this._loop = false;
      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      this._loop = false;
      return error(RangeError, 'RSV1 must be clear', true, 1002);
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (!this._fragmented) {
        this._loop = false;
        return error(RangeError, 'invalid opcode 0', true, 1002);
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        this._loop = false;
        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        this._loop = false;
        return error(RangeError, 'FIN must be set', true, 1002);
      }

      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (this._payloadLength > 0x7d) {
        this._loop = false;
        return error(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002
        );
      }
    } else {
      this._loop = false;
      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else return this.haveLength();
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength16() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    return this.haveLength();
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength64() {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      this._loop = false;
      return error(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009
      );
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    return this.haveLength();
  }

  /**
   * Payload length has been read.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  haveLength() {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        this._loop = false;
        return error(RangeError, 'Max payload size exceeded', false, 1009);
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  getData(cb) {
    var data = constants.EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);
      if (this._masked) bufferUtil.unmask(data, this._mask);
    }

    if (this._opcode > 0x07) return this.controlMessage(data);

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its lenght is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    return this.dataMessage();
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          return cb(
            error(RangeError, 'Max payload size exceeded', false, 1009)
          );
        }

        this._fragments.push(buf);
      }

      const er = this.dataMessage();
      if (er) return cb(er);

      this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @return {(Error|undefined)} A possible error
   * @private
   */
  dataMessage() {
    if (this._fin) {
      const messageLength = this._messageLength;
      const fragments = this._fragments;

      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];

      if (this._opcode === 2) {
        var data;

        if (this._binaryType === 'nodebuffer') {
          data = toBuffer(fragments, messageLength);
        } else if (this._binaryType === 'arraybuffer') {
          data = toArrayBuffer(toBuffer(fragments, messageLength));
        } else {
          data = fragments;
        }

        this.emit('message', data);
      } else {
        const buf = toBuffer(fragments, messageLength);

        if (!validation.isValidUTF8(buf)) {
          this._loop = false;
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('message', buf.toString());
      }
    }

    this._state = GET_INFO;
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data) {
    if (this._opcode === 0x08) {
      this._loop = false;

      if (data.length === 0) {
        this.emit('conclude', 1005, '');
        this.end();
      } else if (data.length === 1) {
        return error(RangeError, 'invalid payload length 1', true, 1002);
      } else {
        const code = data.readUInt16BE(0);

        if (!validation.isValidStatusCode(code)) {
          return error(RangeError, `invalid status code ${code}`, true, 1002);
        }

        const buf = data.slice(2);

        if (!validation.isValidUTF8(buf)) {
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('conclude', code, buf.toString());
        this.end();
      }
    } else if (this._opcode === 0x09) {
      this.emit('ping', data);
    } else {
      this.emit('pong', data);
    }

    this._state = GET_INFO;
  }
}

module.exports = Receiver;

/**
 * Builds an error object.
 *
 * @param {(Error|RangeError)} ErrorCtor The error constructor
 * @param {String} message The error message
 * @param {Boolean} prefix Specifies whether or not to add a default prefix to
 *     `message`
 * @param {Number} statusCode The status code
 * @return {(Error|RangeError)} The error
 * @private
 */
function error(ErrorCtor, message, prefix, statusCode) {
  const err = new ErrorCtor(
    prefix ? `Invalid WebSocket frame: ${message}` : message
  );

  Error.captureStackTrace(err, error);
  err[constants.kStatusCode] = statusCode;
  return err;
}

/**
 * Makes a buffer from a list of fragments.
 *
 * @param {Buffer[]} fragments The list of fragments composing the message
 * @param {Number} messageLength The length of the message
 * @return {Buffer}
 * @private
 */
function toBuffer(fragments, messageLength) {
  if (fragments.length === 1) return fragments[0];
  if (fragments.length > 1) return bufferUtil.concat(fragments, messageLength);
  return constants.EMPTY_BUFFER;
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 */
function toArrayBuffer(buf) {
  if (buf.byteLength === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


try {
  const isValidUTF8 = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"utf-8-validate\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

  exports.isValidUTF8 =
    typeof isValidUTF8 === 'object'
      ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0
      : isValidUTF8;
} catch (e) /* istanbul ignore next */ {
  exports.isValidUTF8 = () => true;
}

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
exports.isValidStatusCode = (code) => {
  return (
    (code >= 1000 &&
      code <= 1013 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
};


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const crypto = __webpack_require__(24);

const PerMessageDeflate = __webpack_require__(114);
const bufferUtil = __webpack_require__(177);
const validation = __webpack_require__(233);
const constants = __webpack_require__(93);

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {net.Socket} socket The connection socket
   * @param {Object} extensions An object containing the negotiated extensions
   */
  constructor(socket, extensions) {
    this._extensions = extensions || {};
    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {Buffer} data The data to frame
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} options.readOnly Specifies whether `data` can be modified
   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit
   * @return {Buffer[]} The framed data as a list of `Buffer` instances
   * @public
   */
  static frame(data, options) {
    const merge = data.length < 1024 || (options.mask && options.readOnly);
    var offset = options.mask ? 6 : 2;
    var payloadLength = data.length;

    if (data.length >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (data.length > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    if (payloadLength === 126) {
      target.writeUInt16BE(data.length, 2);
    } else if (payloadLength === 127) {
      target.writeUInt32BE(0, 2);
      target.writeUInt32BE(data.length, 6);
    }

    if (!options.mask) {
      target[1] = payloadLength;
      if (merge) {
        data.copy(target, offset);
        return [target];
      }

      return [target, data];
    }

    const mask = crypto.randomBytes(4);

    target[1] = payloadLength | 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (merge) {
      bufferUtil.mask(data, mask, target, offset, data.length);
      return [target];
    }

    bufferUtil.mask(data, mask, data, 0, data.length);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {(Number|undefined)} code The status code component of the body
   * @param {String} data The message component of the body
   * @param {Boolean} mask Specifies whether or not to mask the message
   * @param {Function} cb Callback
   * @public
   */
  close(code, data, mask, cb) {
    var buf;

    if (code === undefined) {
      buf = constants.EMPTY_BUFFER;
    } else if (
      typeof code !== 'number' ||
      !validation.isValidStatusCode(code)
    ) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || data === '') {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));
      buf.writeUInt16BE(code, 0);
      buf.write(data, 2);
    }

    if (this._deflating) {
      this.enqueue([this.doClose, buf, mask, cb]);
    } else {
      this.doClose(buf, mask, cb);
    }
  }

  /**
   * Frames and sends a close message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @private
   */
  doClose(data, mask, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x08,
        mask,
        readOnly: false
      }),
      cb
    );
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  ping(data, mask, cb) {
    var readOnly = true;

    if (!Buffer.isBuffer(data)) {
      if (data instanceof ArrayBuffer) {
        data = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        data = viewToBuffer(data);
      } else {
        data = Buffer.from(data);
        readOnly = false;
      }
    }

    if (this._deflating) {
      this.enqueue([this.doPing, data, mask, readOnly, cb]);
    } else {
      this.doPing(data, mask, readOnly, cb);
    }
  }

  /**
   * Frames and sends a ping message.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Boolean} readOnly Specifies whether `data` can be modified
   * @param {Function} cb Callback
   * @private
   */
  doPing(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x09,
        mask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  pong(data, mask, cb) {
    var readOnly = true;

    if (!Buffer.isBuffer(data)) {
      if (data instanceof ArrayBuffer) {
        data = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        data = viewToBuffer(data);
      } else {
        data = Buffer.from(data);
        readOnly = false;
      }
    }

    if (this._deflating) {
      this.enqueue([this.doPong, data, mask, readOnly, cb]);
    } else {
      this.doPong(data, mask, readOnly, cb);
    }
  }

  /**
   * Frames and sends a pong message.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Boolean} readOnly Specifies whether `data` can be modified
   * @param {Function} cb Callback
   * @private
   */
  doPong(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x0a,
        mask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} options.compress Specifies whether or not to compress `data`
   * @param {Boolean} options.binary Specifies whether `data` is binary or text
   * @param {Boolean} options.fin Specifies whether the fragment is the last one
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  send(data, options, cb) {
    var opcode = options.binary ? 2 : 1;
    var rsv1 = options.compress;
    var readOnly = true;

    if (!Buffer.isBuffer(data)) {
      if (data instanceof ArrayBuffer) {
        data = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        data = viewToBuffer(data);
      } else {
        data = Buffer.from(data);
        readOnly = false;
      }
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    if (this._firstFragment) {
      this._firstFragment = false;
      if (rsv1 && perMessageDeflate) {
        rsv1 = data.length >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    if (perMessageDeflate) {
      const opts = {
        fin: options.fin,
        rsv1,
        opcode,
        mask: options.mask,
        readOnly
      };

      if (this._deflating) {
        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
      } else {
        this.dispatch(data, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(
        Sender.frame(data, {
          fin: options.fin,
          rsv1: false,
          opcode,
          mask: options.mask,
          readOnly
        }),
        cb
      );
    }
  }

  /**
   * Dispatches a data message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} compress Specifies whether or not to compress `data`
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} options.readOnly Specifies whether `data` can be modified
   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit
   * @param {Function} cb Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._deflating = true;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      this._deflating = false;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[1].length;
      params[0].apply(this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[1].length;
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} cb Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;

/**
 * Converts an `ArrayBuffer` view into a buffer.
 *
 * @param {(DataView|TypedArray)} view The view to convert
 * @return {Buffer} Converted view
 * @private
 */
function viewToBuffer(view) {
  const buf = Buffer.from(view.buffer);

  if (view.byteLength !== view.buffer.byteLength) {
    return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);
  }

  return buf;
}


/***/ }),
/* 235 */
/***/ (function(module, exports) {


var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var parser = __webpack_require__(173);
var Emitter = __webpack_require__(73);
var toArray = __webpack_require__(306);
var on = __webpack_require__(237);
var bind = __webpack_require__(238);
var debug = __webpack_require__(110)('socket.io-client:socket');
var parseqs = __webpack_require__(111);
var hasBin = __webpack_require__(227);

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket (io, nsp, opts) {
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  this.flags = {};
  if (opts && opts.query) {
    this.query = opts.query;
  }
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function () {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function () {
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' === this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function () {
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function (ev) {
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var packet = {
    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
    data: args
  };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' === typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  this.flags = {};

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function (packet) {
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function () {
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' !== this.nsp) {
    if (this.query) {
      var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;
      debug('sending connect packet with query %s', query);
      this.packet({type: parser.CONNECT, query: query});
    } else {
      this.packet({type: parser.CONNECT});
    }
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function (reason) {
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function (packet) {
  var sameNamespace = packet.nsp === this.nsp;
  var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === '/';

  if (!sameNamespace && !rootNamespaceError) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function (packet) {
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function (id) {
  var self = this;
  var sent = false;
  return function () {
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    self.packet({
      type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function (packet) {
  var ack = this.acks[packet.id];
  if ('function' === typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function () {
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function () {
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function () {
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function () {
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function () {
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function (compress) {
  this.flags.compress = compress;
  return this;
};

/**
 * Sets the binary flag
 *
 * @param {Boolean} whether the emitted data contains binary
 * @return {Socket} self
 * @api public
 */

Socket.prototype.binary = function (binary) {
  this.flags.binary = binary;
  return this;
};


/***/ }),
/* 237 */
/***/ (function(module, exports) {


/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on (obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function () {
      obj.removeListener(ev, fn);
    }
  };
}


/***/ }),
/* 238 */
/***/ (function(module, exports) {

/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * layout.js - mempool data layout for wmcc_core.
 */



const assert = __webpack_require__(0);

/*
 * Database Layout:
 *   R -> tip hash
 *   V -> db version
 *   e[id][hash] -> entry
 */

const layout = {
  binary: true,
  R: Buffer.from([0x52]),
  V: Buffer.from([0x76]),
  F: Buffer.from([0x46]),
  e: function e(hash) {
    const key = Buffer.allocUnsafe(33);
    key[0] = 0x65;
    write(key, hash, 1);
    return key;
  },
  ee: function ee(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length === 33);
    return key.toString('hex', 1, 33);
  }
};

/*
 * Helpers
 */

function write(data, str, off) {
  if (Buffer.isBuffer(str))
    return str.copy(data, off);
  assert(typeof str === 'string');
  return data.write(str, off, 'hex');
}

/*
 * Expose
 */

module.exports = layout;


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * cpuminer.js - inefficient cpu miner for wmcc_core (because we can).
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const co = __webpack_require__(17);
const AsyncObject = __webpack_require__(31);
const mine = __webpack_require__(95);
const Lock = __webpack_require__(23);

/**
 * CPU miner.
 * @alias module:mining.CPUMiner
 * @constructor
 * @param {Miner} miner
 * @emits CPUMiner#block
 * @emits CPUMiner#status
 */

function CPUMiner(miner) {
  if (!(this instanceof CPUMiner))
    return new CPUMiner(miner);

  AsyncObject.call(this);

  this.miner = miner;
  this.network = this.miner.network;
  this.logger = this.miner.logger.context('cpuminer');
  this.workers = this.miner.workers;
  this.chain = this.miner.chain;
  this.locker = new Lock();
  this.locker2 = new Lock();

  this.running = false;
  this.stopping = false;
  this.own = false;
  this.job = null;
  this.stopJob = null;

  this._init();
}

Object.setPrototypeOf(CPUMiner.prototype, AsyncObject.prototype);

/**
 * Nonce range interval.
 * @const {Number}
 * @default
 */

CPUMiner.INTERVAL = 0xffffffff / 1500 | 0;

/**
 * Initialize the miner.
 * @private
 */

CPUMiner.prototype._init = function _init() {
  this.chain.on('tip', async (tip) => {
    if (!this.job)
      return;

    if (this.job.attempt.prevBlock === tip.prevBlock)
      await this.restart();
  });

  this.workers.on('error', async (err) => {
    this.miner.reset(true);
  });
};

/**
 * Open the miner.
 * @method
 * @alias module:mining.CPUMiner#open
 * @returns {Promise}
 */

CPUMiner.prototype._open = async function _open() {
};

/**
 * Close the miner.
 * @method
 * @alias module:mining.CPUMiner#close
 * @returns {Promise}
 */

CPUMiner.prototype._close = async function _close() {
  await this.stop();
};

/**
 * Start mining.
 * @method
 */

CPUMiner.prototype.start = function start() {
  assert(!this.running, 'Miner is already running.');
  this._start().catch(() => {});
};

/**
 * Start mining.
 * @method
 * @private
 * @returns {Promise}
 */

CPUMiner.prototype._start = async function _start() {
  assert(!this.running, 'Miner is already running.');

  this.running = true;
  this.stopping = false;

  for (;;) {
    this.job = null;

    try {
      this.job = await this.createJob();
    } catch (e) {
      if (this.stopping)
        break;
      this.emit('error', e);
      break;
    }

    if (this.stopping)
      break;

    let block;
    try {
      block = await this.mineAsync(this.job);
    } catch (e) {
      if (this.stopping)
        break;
      this.emit('error', e);
      break;
    }

    if (this.stopping)
      break;

    if (!block)
      continue;

    this.own = true;
    let entry;
    try {
      entry = await this.chain.add(block);
    } catch (e) {
      if (this.stopping)
        break;

      if (e.type === 'VerifyError') {
        this.logger.warning('Mined an invalid block!');
        this.logger.error(e);
        continue;
      }

      this.emit('error', e);
      break;
    }

    if (!entry) {
      this.logger.warning('Mined a bad-prevblk (race condition?)');
      continue;
    }

    if (this.stopping)
      break;

    // Log the block hex as a failsafe (in case we can't send it).
    this.logger.info('Found block: %d (%s).', entry.height, entry.rhash());
    this.logger.debug('Raw: %s', block.toRaw().toString('hex'));

    this.emit('block', block, entry);
  }

  const job = this.stopJob;

  if (job) {
    this.stopJob = null;
    job.resolve();
  }
};

/**
 * Stop mining.
 * @method
 * @returns {Promise}
 */

CPUMiner.prototype.stop = async function stop() {
  const unlock = await this.locker.lock();
  try {
    return await this._stop();
  } finally {
    unlock();
  }
};

/**
 * Stop mining (without a lock).
 * @method
 * @returns {Promise}
 */

CPUMiner.prototype._stop = async function _stop() {
  if (!this.running)
    return;

  assert(this.running, 'Miner is not running.');
  assert(!this.stopping, 'Miner is already stopping.');

  this.stopping = true;

  if (this.job) {
    this.job.destroy();
    this.job = null;
    this.workers.destroy();
  }

  await this.wait();

  this.running = false;
  this.stopping = false;
  this.job = null;
};

/**
 * Restart mining.
 * @method
 * @returns {Promise}
 */

CPUMiner.prototype.restart = async function restart() {
  const unlock = await this.locker2.lock();
  try {
    return await this._restart();
  } finally {
    unlock();
  }
};

/**
 * Restart mining (without a lock).
 * @method
 * @returns {Promise}
 */

CPUMiner.prototype._restart = async function _restart() {
  if (this.own) {
    this.own = false;
    return this.job.destroy();
  }

  await this.stop();
  await this.start();
};

/**
 * Wait for `done` event.
 * @private
 * @returns {Promise}
 */

CPUMiner.prototype.wait = function wait() {
  return new Promise((resolve, reject) => {
    assert(!this.stopJob);
    this.stopJob = co.job(resolve, reject);
  });
};

/**
 * Create a mining job.
 * @method
 * @param {ChainEntry?} tip
 * @param {Address?} address
 * @returns {Promise} - Returns {@link Job}.
 */

CPUMiner.prototype.createJob = async function createJob(tip, address) {
  const attempt = await this.miner.createBlock(tip, address);
  return new CPUJob(this, attempt);
};

/**
 * Mine a single block.
 * @method
 * @param {ChainEntry?} tip
 * @param {Address?} address
 * @returns {Promise} - Returns [{@link Block}].
 */

CPUMiner.prototype.mineBlock = async function mineBlock(tip, address) {
  const job = await this.createJob(tip, address);
  return await this.mineAsync(job);
};

/**
 * Notify the miner that a new
 * tx has entered the mempool.
 */

CPUMiner.prototype.notifyEntry = function notifyEntry() {
  if (!this.running)
    return;

  if (!this.job)
    return;

  if (util.now() - this.job.start > 10) {
    this.job.destroy();
    this.job = null;
  }
};

/**
 * Hash until the nonce overflows.
 * @param {CPUJob} job
 * @returns {Number} nonce
 */

CPUMiner.prototype.findNonce = function findNonce(job) {
  const data = job.getHeader();
  const target = job.attempt.target;
  const interval = CPUMiner.INTERVAL;

  let min = 0;
  let max = interval;
  let nonce;

  while (max <= 0xffffffff) {
    nonce = mine(data, target, min, max);

    if (nonce !== -1)
      break;

    this.sendStatus(job, max);

    min += interval;
    max += interval;
  }

  return nonce;
};

/**
 * Hash until the nonce overflows.
 * @method
 * @param {CPUJob} job
 * @returns {Promise} Returns Number.
 */

CPUMiner.prototype.findNonceAsync = async function findNonceAsync(job) {
  if (!this.workers)
    return this.findNonce(job);

  const data = job.getHeader();
  const target = job.attempt.target;
  const interval = CPUMiner.INTERVAL;

  let min = 0;
  let max = interval;
  let nonce;

  while (max <= 0xffffffff) {
    nonce = await this.workers.mine(data, target, min, max);

    if (nonce !== -1)
      break;

    if (job.destroyed)
      return nonce;

    this.sendStatus(job, max);

    min += interval;
    max += interval;
  }

  return nonce;
};

/**
 * Mine synchronously until the block is found.
 * @param {CPUJob} job
 * @returns {Block}
 */

CPUMiner.prototype.mine = function mine(job) {
  job.start = util.now();

  let nonce;
  for (;;) {
    nonce = this.findNonce(job);

    if (nonce !== -1)
      break;

    job.updateNonce();

    this.sendStatus(job, 0);
  }

  return job.commit(nonce);
};

/**
 * Mine asynchronously until the block is found.
 * @method
 * @param {CPUJob} job
 * @returns {Promise} - Returns {@link Block}.
 */

CPUMiner.prototype.mineAsync = async function mineAsync(job) {
  let nonce;

  job.start = util.now();

  for (;;) {
    nonce = await this.findNonceAsync(job);

    if (nonce !== -1)
      break;

    if (job.destroyed)
      return null;

    job.updateNonce();

    this.sendStatus(job, 0);
  }

  return job.commit(nonce);
};

/**
 * Send a progress report (emits `status`).
 * @param {CPUJob} job
 * @param {Number} nonce
 */

CPUMiner.prototype.sendStatus = function sendStatus(job, nonce) {
  const attempt = job.attempt;
  const tip = util.revHex(attempt.prevBlock);
  const hashes = job.getHashes(nonce);
  const hashrate = job.getRate(nonce);

  this.logger.info(
    'Status: hashrate=%dkhs hashes=%d target=%d height=%d tip=%s',
    Math.floor(hashrate / 1000),
    hashes,
    attempt.bits,
    attempt.height,
    tip);

  this.emit('status', job, hashes, hashrate);
};

/**
 * Mining Job
 * @constructor
 * @ignore
 * @param {CPUMiner} miner
 * @param {BlockTemplate} attempt
 */

function CPUJob(miner, attempt) {
  this.miner = miner;
  this.attempt = attempt;
  this.destroyed = false;
  this.committed = false;
  this.start = util.now();
  this.nonce1 = 0;
  this.nonce2 = 0;
  this.refresh();
}

/**
 * Get the raw block header.
 * @param {Number} nonce
 * @returns {Buffer}
 */

CPUJob.prototype.getHeader = function getHeader() {
  const attempt = this.attempt;
  const n1 = this.nonce1;
  const n2 = this.nonce2;
  const time = attempt.time;
  const root = attempt.getRoot(n1, n2);
  const data = attempt.getHeader(root, time, 0);
  return data;
};

/**
 * Commit job and return a block.
 * @param {Number} nonce
 * @returns {Block}
 */

CPUJob.prototype.commit = function commit(nonce) {
  const attempt = this.attempt;
  const n1 = this.nonce1;
  const n2 = this.nonce2;
  const time = attempt.time;

  assert(!this.committed, 'Job already committed.');
  this.committed = true;

  const proof = attempt.getProof(n1, n2, time, nonce);

  return attempt.commit(proof);
};

/**
 * Mine block synchronously.
 * @returns {Block}
 */

CPUJob.prototype.mine = function mine() {
  return this.miner.mine(this);
};

/**
 * Mine block asynchronously.
 * @returns {Promise}
 */

CPUJob.prototype.mineAsync = function mineAsync() {
  return this.miner.mineAsync(this);
};

/**
 * Refresh the block template.
 */

CPUJob.prototype.refresh = function refresh() {
  return this.attempt.refresh();
};

/**
 * Increment the extraNonce.
 */

CPUJob.prototype.updateNonce = function updateNonce() {
  if (++this.nonce2 === 0x100000000) {
    this.nonce2 = 0;
    this.nonce1++;
  }
};

/**
 * Destroy the job.
 */

CPUJob.prototype.destroy = function destroy() {
  assert(!this.destroyed, 'Job already destroyed.');
  this.destroyed = true;
};

/**
 * Calculate number of hashes computed.
 * @param {Number} nonce
 * @returns {Number}
 */

CPUJob.prototype.getHashes = function getHashes(nonce) {
  const extra = this.nonce1 * 0x100000000 + this.nonce2;
  return extra * 0xffffffff + nonce;
};

/**
 * Calculate hashrate.
 * @param {Number} nonce
 * @returns {Number}
 */

CPUJob.prototype.getRate = function getRate(nonce) {
  const hashes = this.getHashes(nonce);
  const seconds = util.now() - this.start;
  return Math.floor(hashes / Math.max(1, seconds));
};

/**
 * Add a transaction to the block.
 * @param {TX} tx
 * @param {CoinView} view
 */

CPUJob.prototype.addTX = function addTX(tx, view) {
  return this.attempt.addTX(tx, view);
};

/**
 * Add a transaction to the block
 * (less verification than addTX).
 * @param {TX} tx
 * @param {CoinView?} view
 */

CPUJob.prototype.pushTX = function pushTX(tx, view) {
  return this.attempt.pushTX(tx, view);
};

/*
 * Expose
 */

module.exports = CPUMiner;


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * memblock.js - memblock block object for wmcc_core.
 */



const AbstractBlock = __webpack_require__(67);
const Block = __webpack_require__(51);
const Headers = __webpack_require__(37);
const Script = __webpack_require__(8);
const BufferReader = __webpack_require__(2);
const DUMMY = Buffer.alloc(0);

/**
 * A block object which is essentially a "placeholder"
 * for a full {@link Block} object. The v8 garbage
 * collector's head will explode if there is too much
 * data on the javascript heap. Blocks can currently
 * be up to 1mb in size. In the future, they may be
 * 2mb, 8mb, or maybe 20mb, who knows? A MemBlock
 * is an optimization in WMCC which defers parsing of
 * the serialized transactions (the block Buffer) until
 * the block has passed through the chain queue and
 * is about to enter the chain. This keeps a lot data
 * off of the javascript heap for most of the time a
 * block even exists in memory, and manages to keep a
 * lot of strain off of the garbage collector. Having
 * 500mb of blocks on the js heap would not be a good
 * thing.
 * @alias module:primitives.MemBlock
 * @constructor
 * @param {NakedBlock} options
 */

function MemBlock() {
  if (!(this instanceof MemBlock))
    return new MemBlock();

  AbstractBlock.call(this);

  this._raw = DUMMY;
}

Object.setPrototypeOf(MemBlock.prototype, AbstractBlock.prototype);

/**
 * Test whether the block is a memblock.
 * @returns {Boolean}
 */

MemBlock.prototype.isMemory = function isMemory() {
  return true;
};

/**
 * Serialize the block headers.
 * @returns {Buffer}
 */

MemBlock.prototype.toHead = function toHead() {
  return this._raw.slice(0, 80);
};

/**
 * Get the full block size.
 * @returns {Number}
 */

MemBlock.prototype.getSize = function getSize() {
  return this._raw.length;
};

/**
 * Verify the block.
 * @returns {Boolean}
 */

MemBlock.prototype.verifyBody = function verifyBody() {
  return true;
};

/**
 * Retrieve the coinbase height
 * from the coinbase input script.
 * @returns {Number} height (-1 if not present).
 */

MemBlock.prototype.getCoinbaseHeight = function getCoinbaseHeight() {
  if (this.version < 2)
    return -1;

  try {
    return this.parseCoinbaseHeight();
  } catch (e) {
    return -1;
  }
};

/**
 * Parse the coinbase height
 * from the coinbase input script.
 * @private
 * @returns {Number} height (-1 if not present).
 */

MemBlock.prototype.parseCoinbaseHeight = function parseCoinbaseHeight() {
  const br = new BufferReader(this._raw, true);

  br.seek(80);

  const txCount = br.readVarint();

  if (txCount === 0)
    return -1;

  br.seek(4);

  let inCount = br.readVarint();

  if (inCount === 0) {
    if (br.readU8() !== 0)
      inCount = br.readVarint();
  }

  if (inCount === 0)
    return -1;

  br.seek(36);

  const script = br.readVarBytes();

  return Script.getCoinbaseHeight(script);
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

MemBlock.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data, true);

  this.readHead(br);

  this._raw = br.data;

  return this;
};

/**
 * Insantiate a memblock from serialized data.
 * @param {Buffer} data
 * @returns {MemBlock}
 */

MemBlock.fromRaw = function fromRaw(data) {
  return new MemBlock().fromRaw(data);
};

/**
 * Return serialized block data.
 * @returns {Buffer}
 */

MemBlock.prototype.toRaw = function toRaw() {
  return this._raw;
};

/**
 * Return serialized block data.
 * @returns {Buffer}
 */

MemBlock.prototype.toNormal = function toNormal() {
  return this._raw;
};

/**
 * Parse the serialized block data
 * and create an actual {@link Block}.
 * @returns {Block}
 * @throws Parse error
 */

MemBlock.prototype.toBlock = function toBlock() {
  const block = Block.fromRaw(this._raw);

  block._hash = this._hash;
  block._hhash = this._hhash;

  return block;
};

/**
 * Convert the block to a headers object.
 * @returns {Headers}
 */

MemBlock.prototype.toHeaders = function toHeaders() {
  return Headers.fromBlock(this);
};

/**
 * Test whether an object is a MemBlock.
 * @param {Object} obj
 * @returns {Boolean}
 */

MemBlock.isMemBlock = function isMemBlock(obj) {
  return obj instanceof MemBlock;
};

/*
 * Expose
 */

module.exports = MemBlock;


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * external.js - external ip address discovery for wmcc_core.
 */



const request = __webpack_require__(92);
const IP = __webpack_require__(46);

/**
 * @exports net/external
 */

const external = exports;

/**
 * Attempt to retrieve external IP from icanhazip.com.
 * @method
 * @returns {Promise}
 */

external.getIPv4 = async function getIPv4() {
  try {
    const res = await request({
      method: 'GET',
      uri: 'http://ipv4.icanhazip.com',
      expect: 'txt',
      timeout: 2000
    });

    const str = res.body.trim();
    const raw = IP.toBuffer(str);

    if (!IP.isIPv4(raw))
      throw new Error('Could not find IPv4.');

    return IP.toString(raw);
  } catch (e) {
    return await external.getIPv42();
  }
};

/**
 * Attempt to retrieve external IP from dyndns.org.
 * @method
 * @ignore
 * @returns {Promise}
 */

external.getIPv42 = async function getIPv42() {
  const res = await request({
    method: 'GET',
    uri: 'http://checkip.dyndns.org',
    expect: 'html',
    timeout: 2000
  });

  const match = /IP Address:\s*([0-9a-f.:]+)/i.exec(res.body);

  if (!match)
    throw new Error('Could not find IPv4.');

  const str = match[1];
  const raw = IP.toBuffer(str);

  if (!IP.isIPv4(raw))
    throw new Error('Could not find IPv4.');

  return IP.toString(raw);
};

/**
 * Attempt to retrieve external IP from icanhazip.com.
 * @method
 * @returns {Promise}
 */

external.getIPv6 = async function getIPv6() {
  const res = await request({
    method: 'GET',
    uri: 'http://ipv6.icanhazip.com',
    expect: 'txt',
    timeout: 2000
  });

  const str = res.body.trim();
  const raw = IP.toBuffer(str);

  if (!IP.isIPv6(raw))
    throw new Error('Could not find IPv6.');

  return IP.toString(raw);
};


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * framer.js - packet framer for wmcc_core.
 */



const assert = __webpack_require__(0);
const Network = __webpack_require__(6);
const digest = __webpack_require__(5);

/**
 * Protocol packet framer
 * @alias module:net.Framer
 * @constructor
 * @param {Network} network
 */

function Framer(network) {
  if (!(this instanceof Framer))
    return new Framer(network);

  this.network = Network.get(network);
}

/**
 * Frame a payload with a header.
 * @param {String} cmd - Packet type.
 * @param {Buffer} payload
 * @param {Buffer?} checksum - Precomputed checksum.
 * @returns {Buffer} Payload with header prepended.
 */

Framer.prototype.packet = function packet(cmd, payload, checksum) {
  assert(payload, 'No payload.');
  assert(cmd.length < 12);
  assert(payload.length <= 0xffffffff);

  const msg = Buffer.allocUnsafe(24 + payload.length);

  // Magic value
  msg.writeUInt32LE(this.network.magic, 0, true);

  // Command
  msg.write(cmd, 4, 'ascii');

  for (let i = 4 + cmd.length; i < 16; i++)
    msg[i] = 0;

  // Payload length
  msg.writeUInt32LE(payload.length, 16, true);

  if (!checksum)
    checksum = digest.hash256(payload);

  // Checksum
  checksum.copy(msg, 20, 0, 4);

  payload.copy(msg, 24);

  return msg;
};

/*
 * Expose
 */

module.exports = Framer;


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * hostlist.js - address management for wmcc_core.
 */



const assert = __webpack_require__(0);
const path = __webpack_require__(25);
const http = __webpack_require__(72);
const util = __webpack_require__(1);
const IP = __webpack_require__(46);
const co = __webpack_require__(17);
const Network = __webpack_require__(6);
const NetAddress = __webpack_require__(75);
const List = __webpack_require__(91);
const murmur3 = __webpack_require__(66);
const common = __webpack_require__(59);
const seeds = __webpack_require__(313);
const dns = __webpack_require__(97);
const Logger = __webpack_require__(34);
const fs = __webpack_require__(58);
const POOL32 = Buffer.allocUnsafe(32);

/**
 * Host List
 * @alias module:net.HostList
 * @constructor
 * @param {Object} options
 */

function HostList(options) {
  if (!(this instanceof HostList))
    return new HostList(options);

  this.options = new HostListOptions(options);
  this.network = this.options.network;
  this.logger = this.options.logger.context('hostlist');
  this.address = this.options.address;
  this.resolve = this.options.resolve;

  this.dnsSeeds = [];
  this.dnsNodes = [];

  this.map = new Map();
  this.fresh = [];
  this.totalFresh = 0;
  this.used = [];
  this.totalUsed = 0;
  this.nodes = [];
  this.local = new Map();
  this.banned = new Map();

  this.timer = null;
  this.needsFlush = false;

  this._init();
}

/**
 * Number of days before considering
 * an address stale.
 * @const {Number}
 * @default
 */

HostList.HORIZON_DAYS = 30;

/**
 * Number of retries (without success)
 * before considering an address stale.
 * @const {Number}
 * @default
 */

HostList.RETRIES = 3;

/**
 * Number of days after reaching
 * MAX_FAILURES to consider an
 * address stale.
 * @const {Number}
 * @default
 */

HostList.MIN_FAIL_DAYS = 7;

/**
 * Maximum number of failures
 * allowed before considering
 * an address stale.
 * @const {Number}
 * @default
 */

HostList.MAX_FAILURES = 10;

/**
 * Maximum number of references
 * in fresh buckets.
 * @const {Number}
 * @default
 */

HostList.MAX_REFS = 8;

/**
 * Serialization version.
 * @const {Number}
 * @default
 */

HostList.VERSION = 0;

/**
 * Local address scores.
 * @enum {Number}
 * @default
 */

HostList.scores = {
  NONE: 0,
  IF: 1,
  BIND: 2,
  UPNP: 3,
  HTTP: 3,
  MANUAL: 4,
  MAX: 5
};

/**
 * Initialize list.
 * @private
 */

HostList.prototype._init = function _init() {
  const options = this.options;
  const scores = HostList.scores;
  const hosts = IP.getPublic();
  const port = this.address.port;

  for (let i = 0; i < this.options.maxBuckets; i++)
    this.fresh.push(new Map());

  for (let i = 0; i < this.options.maxBuckets; i++)
    this.used.push(new List());

  this.setSeeds(options.seeds);
  this.setNodes(options.nodes);

  this.pushLocal(this.address, scores.MANUAL);
  this.addLocal(options.host, options.port, scores.BIND);

  for (const host of hosts)
    this.addLocal(host, port, scores.IF);
};

/**
 * Open hostlist and read hosts file.
 * @method
 * @returns {Promise}
 */

HostList.prototype.open = async function open() {
  try {
    await this.loadFile();
  } catch (e) {
    this.logger.warning('Hosts deserialization failed.');
    this.logger.error(e);
  }

  if (this.size() === 0)
    this.injectSeeds();

  await this.discoverNodes();

  this.start();
};

/**
 * Close hostlist.
 * @method
 * @returns {Promise}
 */

HostList.prototype.close = async function close() {
  this.stop();
  await this.flush();
  this.reset();
};

/**
 * Start flush interval.
 */

HostList.prototype.start = function start() {
  if (!this.options.persistent)
    return;

  if (!this.options.filename)
    return;

  assert(this.timer == null);
  this.timer = co.setInterval(this.flush, this.options.flushInterval, this);
};

/**
 * Stop flush interval.
 */

HostList.prototype.stop = function stop() {
  if (!this.options.persistent)
    return;

  if (!this.options.filename)
    return;

  assert(this.timer != null);
  co.clearInterval(this.timer);
  this.timer = null;
};

/**
 * Read and initialize from hosts file.
 * @method
 * @returns {Promise}
 */

HostList.prototype.injectSeeds = function injectSeeds() {
  const nodes = seeds.get(this.network.type);

  for (const node of nodes) {
    try {
      const addr = NetAddress.fromHostname(node, this.network);

      if (!addr.isRoutable())
        continue;

      if (!this.options.onion && addr.isOnion())
        continue;

      if (addr.port === 0)
        continue;

      this.add(addr);
    } catch (e) {
      this.logger.error(e);
    }
  }
};

/**
 * Read and initialize from hosts file.
 * @method
 * @returns {Promise}
 */

HostList.prototype.loadFile = async function loadFile() {
  const filename = this.options.filename;

  if (fs.unsupported)
    return;

  if (!this.options.persistent)
    return;

  if (!filename)
    return;

  let data;
  try {
    data = await fs.readFile(filename, 'utf8');
  } catch (e) {
    if (e.code === 'ENOENT')
      return;
    throw e;
  }

  const json = JSON.parse(data);

  this.fromJSON(json);
};

/**
 * Flush addrs to hosts file.
 * @method
 * @returns {Promise}
 */

HostList.prototype.flush = async function flush() {
  const filename = this.options.filename;

  if (fs.unsupported)
    return;

  if (!this.options.persistent)
    return;

  if (!filename)
    return;

  if (!this.needsFlush)
    return;

  this.needsFlush = false;

  this.logger.debug('Writing hosts to %s.', filename);

  const json = this.toJSON();
  const data = JSON.stringify(json);

  try {
    await fs.writeFile(filename, data, 'utf8');
  } catch (e) {
    this.logger.warning('Writing hosts failed.');
    this.logger.error(e);
  }
};

/**
 * Get list size.
 * @returns {Number}
 */

HostList.prototype.size = function size() {
  return this.totalFresh + this.totalUsed;
};

/**
 * Test whether the host list is full.
 * @returns {Boolean}
 */

HostList.prototype.isFull = function isFull() {
  const max = this.options.maxBuckets * this.options.maxEntries;
  return this.size() >= max;
};

/**
 * Reset host list.
 */

HostList.prototype.reset = function reset() {
  this.map.clear();

  for (const bucket of this.fresh)
    bucket.clear();

  for (const bucket of this.used)
    bucket.reset();

  this.totalFresh = 0;
  this.totalUsed = 0;

  this.nodes.length = 0;
};

/**
 * Mark a peer as banned.
 * @param {String} host
 */

HostList.prototype.ban = function ban(host) {
  this.banned.set(host, util.now());
};

/**
 * Unban host.
 * @param {String} host
 */

HostList.prototype.unban = function unban(host) {
  this.banned.delete(host);
};

/**
 * Clear banned hosts.
 */

HostList.prototype.clearBanned = function clearBanned() {
  this.banned.clear();
};

/**
 * Test whether the host is banned.
 * @param {String} host
 * @returns {Boolean}
 */

HostList.prototype.isBanned = function isBanned(host) {
  const time = this.banned.get(host);

  if (time == null)
    return false;

  if (util.now() > time + this.options.banTime) {
    this.banned.delete(host);
    return false;
  }

  return true;
};

/**
 * Allocate a new host.
 * @returns {HostEntry}
 */

HostList.prototype.getHost = function getHost() {
  let buckets = null;

  if (this.totalFresh > 0)
    buckets = this.fresh;

  if (this.totalUsed > 0) {
    if (this.totalFresh === 0 || util.random(0, 2) === 0)
      buckets = this.used;
  }

  if (!buckets)
    return null;

  const now = this.network.now();
  let factor = 1;

  for (;;) {
    let index = util.random(0, buckets.length);
    const bucket = buckets[index];

    if (bucket.size === 0)
      continue;

    index = util.random(0, bucket.size);

    let entry;
    if (buckets === this.used) {
      entry = bucket.head;
      while (index--)
        entry = entry.next;
    } else {
      for (entry of bucket.values()) {
        if (index === 0)
          break;
        index--;
      }
    }

    const num = util.random(0, 1 << 30);

    if (num < factor * entry.chance(now) * (1 << 30))
      return entry;

    factor *= 1.2;
  }
};

/**
 * Get fresh bucket for host.
 * @private
 * @param {HostEntry} entry
 * @returns {Map}
 */

HostList.prototype.freshBucket = function freshBucket(entry) {
  const addr = entry.addr;
  const src = entry.src;
  const data = concat32(addr.raw, src.raw);
  const hash = murmur3(data, 0xfba4c795);
  const index = hash % this.fresh.length;
  return this.fresh[index];
};

/**
 * Get used bucket for host.
 * @private
 * @param {HostEntry} entry
 * @returns {List}
 */

HostList.prototype.usedBucket = function usedBucket(entry) {
  const addr = entry.addr;
  const hash = murmur3(addr.raw, 0xfba4c795);
  const index = hash % this.used.length;
  return this.used[index];
};

/**
 * Add host to host list.
 * @param {NetAddress} addr
 * @param {NetAddress?} src
 * @returns {Boolean}
 */

HostList.prototype.add = function add(addr, src) {
  assert(addr.port !== 0);

  let entry = this.map.get(addr.hostname);

  if (entry) {
    const now = this.network.now();
    let penalty = 2 * 60 * 60;
    let interval = 24 * 60 * 60;

    // No source means we're inserting
    // this ourselves. No penalty.
    if (!src)
      penalty = 0;

    // Update services.
    entry.addr.services |= addr.services;
    entry.addr.services >>>= 0;

    // Online?
    if (now - addr.time < 24 * 60 * 60)
      interval = 60 * 60;

    // Periodically update time.
    if (entry.addr.time < addr.time - interval - penalty) {
      entry.addr.time = addr.time;
      this.needsFlush = true;
    }

    // Do not update if no new
    // information is present.
    if (entry.addr.time && addr.time <= entry.addr.time)
      return false;

    // Do not update if the entry was
    // already in the "used" table.
    if (entry.used)
      return false;

    assert(entry.refCount > 0);

    // Do not update if the max
    // reference count is reached.
    if (entry.refCount === HostList.MAX_REFS)
      return false;

    assert(entry.refCount < HostList.MAX_REFS);

    // Stochastic test: previous refCount
    // N: 2^N times harder to increase it.
    let factor = 1;
    for (let i = 0; i < entry.refCount; i++)
      factor *= 2;

    if (util.random(0, factor) !== 0)
      return false;
  } else {
    if (this.isFull())
      return false;

    if (!src)
      src = this.address;

    entry = new HostEntry(addr, src);

    this.totalFresh++;
  }

  const bucket = this.freshBucket(entry);

  if (bucket.has(entry.key()))
    return false;

  if (bucket.size >= this.options.maxEntries)
    this.evictFresh(bucket);

  bucket.set(entry.key(), entry);
  entry.refCount++;

  this.map.set(entry.key(), entry);
  this.needsFlush = true;

  return true;
};

/**
 * Evict a host from fresh bucket.
 * @param {Map} bucket
 */

HostList.prototype.evictFresh = function evictFresh(bucket) {
  let old = null;

  for (const entry of bucket.values()) {
    if (this.isStale(entry)) {
      bucket.delete(entry.key());

      if (--entry.refCount === 0) {
        this.map.delete(entry.key());
        this.totalFresh--;
      }

      continue;
    }

    if (!old) {
      old = entry;
      continue;
    }

    if (entry.addr.time < old.addr.time)
      old = entry;
  }

  if (!old)
    return;

  bucket.delete(old.key());

  if (--old.refCount === 0) {
    this.map.delete(old.key());
    this.totalFresh--;
  }
};

/**
 * Test whether a host is evictable.
 * @param {HostEntry} entry
 * @returns {Boolean}
 */

HostList.prototype.isStale = function isStale(entry) {
  const now = this.network.now();

  if (entry.lastAttempt && entry.lastAttempt >= now - 60)
    return false;

  if (entry.addr.time > now + 10 * 60)
    return true;

  if (entry.addr.time === 0)
    return true;

  if (now - entry.addr.time > HostList.HORIZON_DAYS * 24 * 60 * 60)
    return true;

  if (entry.lastSuccess === 0 && entry.attempts >= HostList.RETRIES)
    return true;

  if (now - entry.lastSuccess > HostList.MIN_FAIL_DAYS * 24 * 60 * 60) {
    if (entry.attempts >= HostList.MAX_FAILURES)
      return true;
  }

  return false;
};

/**
 * Remove host from host list.
 * @param {String} hostname
 * @returns {NetAddress}
 */

HostList.prototype.remove = function remove(hostname) {
  const entry = this.map.get(hostname);

  if (!entry)
    return null;

  if (entry.used) {
    let head = entry;

    assert(entry.refCount === 0);

    while (head.prev)
      head = head.prev;

    for (const bucket of this.used) {
      if (bucket.head === head) {
        bucket.remove(entry);
        this.totalUsed--;
        head = null;
        break;
      }
    }

    assert(!head);
  } else {
    for (const bucket of this.fresh) {
      if (bucket.delete(entry.key()))
        entry.refCount--;
    }

    this.totalFresh--;
    assert(entry.refCount === 0);
  }

  this.map.delete(entry.key());

  return entry.addr;
};

/**
 * Mark host as failed.
 * @param {String} hostname
 */

HostList.prototype.markAttempt = function markAttempt(hostname) {
  const entry = this.map.get(hostname);
  const now = this.network.now();

  if (!entry)
    return;

  entry.attempts++;
  entry.lastAttempt = now;
};

/**
 * Mark host as successfully connected.
 * @param {String} hostname
 */

HostList.prototype.markSuccess = function markSuccess(hostname) {
  const entry = this.map.get(hostname);
  const now = this.network.now();

  if (!entry)
    return;

  if (now - entry.addr.time > 20 * 60)
    entry.addr.time = now;
};

/**
 * Mark host as successfully ack'd.
 * @param {String} hostname
 * @param {Number} services
 */

HostList.prototype.markAck = function markAck(hostname, services) {
  const entry = this.map.get(hostname);

  if (!entry)
    return;

  const now = this.network.now();

  entry.addr.services |= services;
  entry.addr.services >>>= 0;

  entry.lastSuccess = now;
  entry.lastAttempt = now;
  entry.attempts = 0;

  if (entry.used)
    return;

  assert(entry.refCount > 0);

  // Remove from fresh.
  let old;
  for (const bucket of this.fresh) {
    if (bucket.delete(entry.key())) {
      entry.refCount--;
      old = bucket;
    }
  }

  assert(old);
  assert(entry.refCount === 0);
  this.totalFresh--;

  // Find room in used bucket.
  const bucket = this.usedBucket(entry);

  if (bucket.size < this.options.maxEntries) {
    entry.used = true;
    bucket.push(entry);
    this.totalUsed++;
    return;
  }

  // No room. Evict.
  const evicted = this.evictUsed(bucket);
  let fresh = this.freshBucket(evicted);

  // Move to entry's old bucket if no room.
  if (fresh.size >= this.options.maxEntries)
    fresh = old;

  // Swap to evicted's used bucket.
  entry.used = true;
  bucket.replace(evicted, entry);

  // Move evicted to fresh bucket.
  evicted.used = false;
  fresh.set(evicted.key(), evicted);
  assert(evicted.refCount === 0);
  evicted.refCount++;
  this.totalFresh++;
};

/**
 * Pick used for eviction.
 * @param {List} bucket
 */

HostList.prototype.evictUsed = function evictUsed(bucket) {
  let old = bucket.head;

  for (let entry = bucket.head; entry; entry = entry.next) {
    if (entry.addr.time < old.addr.time)
      old = entry;
  }

  return old;
};

/**
 * Convert address list to array.
 * @returns {NetAddress[]}
 */

HostList.prototype.toArray = function toArray() {
  const out = [];

  for (const entry of this.map.values())
    out.push(entry.addr);

  assert.strictEqual(out.length, this.size());

  return out;
};

/**
 * Add a preferred seed.
 * @param {String} host
 */

HostList.prototype.addSeed = function addSeed(host) {
  const ip = IP.fromHostname(host, this.network.port);

  if (ip.type === IP.types.DNS) {
    // Defer for resolution.
    this.dnsSeeds.push(ip);
    return null;
  }

  const addr = NetAddress.fromHost(ip.host, ip.port, this.network);

  this.add(addr);

  return addr;
};

/**
 * Add a priority node.
 * @param {String} host
 * @returns {NetAddress}
 */

HostList.prototype.addNode = function addNode(host) {
  const ip = IP.fromHostname(host, this.network.port);

  if (ip.type === IP.types.DNS) {
    // Defer for resolution.
    this.dnsNodes.push(ip);
    return null;
  }

  const addr = NetAddress.fromHost(ip.host, ip.port, this.network);

  this.nodes.push(addr);
  this.add(addr);

  return addr;
};

/**
 * Remove a priority node.
 * @param {String} host
 * @returns {Boolean}
 */

HostList.prototype.removeNode = function removeNode(host) {
  const addr = IP.fromHostname(host, this.network.port);

  for (let i = 0; i < this.nodes.length; i++) {
    const node = this.nodes[i];

    if (node.host !== addr.host)
      continue;

    if (node.port !== addr.port)
      continue;

    this.nodes.splice(i, 1);

    return true;
  }

  return false;
};

/**
 * Set initial seeds.
 * @param {String[]} seeds
 */

HostList.prototype.setSeeds = function setSeeds(seeds) {
  this.dnsSeeds.length = 0;

  for (const host of seeds)
    this.addSeed(host);
};

/**
 * Set priority nodes.
 * @param {String[]} nodes
 */

HostList.prototype.setNodes = async function setNodes(nodes) {
  this.dnsNodes.length = 0;
  this.nodes.length = 0;

  const remoteseeds = await this.setRemoteSeeds();
  nodes = nodes.concat(remoteseeds);

  for (const host of nodes)
    this.addNode(host);
};

/**
 * Get file list from provider.
 * @method
 * @returns {Promise} Nodes Array
 */

HostList.prototype.setRemoteSeeds = function setRemoteSeeds() {
  const options = {
    host: 'worldmobilecoin.network',
    path: '/seeds.php'
  };

  return new Promise((resolve, reject) => {
    http.get(options, (res) => {
      const chunks = [];
      res.on('data', (chunk) => {
        chunks.push(chunk);
      });
      res.on('end', () => {
        resolve(chunks.join('').split(";"));
      });
    }).on('error', (e) => {
      this.logger.debug('Unable to get seeds list from %s: (%s)', options.host, e);
      resolve([]);
    });
  }).catch(err =>{
    this.logger.debug('Unable to get seeds list from %s: (%s)', options.host, err);
  });
};

/**
 * Add a local address.
 * @param {String} host
 * @param {Number} port
 * @param {Number} score
 * @returns {Boolean}
 */

HostList.prototype.addLocal = function addLocal(host, port, score) {
  const addr = NetAddress.fromHost(host, port, this.network);
  addr.services = this.options.services;
  return this.pushLocal(addr, score);
};

/**
 * Add a local address.
 * @param {NetAddress} addr
 * @param {Number} score
 * @returns {Boolean}
 */

HostList.prototype.pushLocal = function pushLocal(addr, score) {
  if (!addr.isRoutable())
    return false;

  if (this.local.has(addr.hostname))
    return false;

  const local = new LocalAddress(addr, score);

  this.local.set(addr.hostname, local);

  return true;
};

/**
 * Get local address based on reachability.
 * @param {NetAddress?} src
 * @returns {NetAddress}
 */

HostList.prototype.getLocal = function getLocal(src) {
  let bestReach = -1;
  let bestScore = -1;
  let bestDest = null;

  if (!src)
    src = this.address;

  if (this.local.size === 0)
    return null;

  for (const dest of this.local.values()) {
    const reach = src.getReachability(dest.addr);

    if (reach < bestReach)
      continue;

    if (reach > bestReach || dest.score > bestScore) {
      bestReach = reach;
      bestScore = dest.score;
      bestDest = dest.addr;
    }
  }

  bestDest.time = this.network.now();

  return bestDest;
};

/**
 * Mark local address as seen during a handshake.
 * @param {NetAddress} addr
 * @returns {Boolean}
 */

HostList.prototype.markLocal = function markLocal(addr) {
  const local = this.local.get(addr.hostname);

  if (!local)
    return false;

  local.score++;

  return true;
};

/**
 * Discover hosts from seeds.
 * @method
 * @returns {Promise}
 */

HostList.prototype.discoverSeeds = async function discoverSeeds() {
  const jobs = [];

  for (const seed of this.dnsSeeds)
    jobs.push(this.populateSeed(seed));

  await Promise.all(jobs);
};

/**
 * Discover hosts from nodes.
 * @method
 * @returns {Promise}
 */

HostList.prototype.discoverNodes = async function discoverNodes() {
  const jobs = [];

  for (const node of this.dnsNodes)
    jobs.push(this.populateNode(node));

  await Promise.all(jobs);
};

/**
 * Lookup node's domain.
 * @method
 * @param {Object} addr
 * @returns {Promise}
 */

HostList.prototype.populateNode = async function populateNode(addr) {
  const addrs = await this.populate(addr);

  if (addrs.length === 0)
    return;

  this.nodes.push(addrs[0]);
  this.add(addrs[0]);
};

/**
 * Populate from seed.
 * @method
 * @param {Object} seed
 * @returns {Promise}
 */

HostList.prototype.populateSeed = async function populateSeed(seed) {
  const addrs = await this.populate(seed);

  for (const addr of addrs)
    this.add(addr);
};

/**
 * Lookup hosts from dns host.
 * @method
 * @param {Object} target
 * @returns {Promise}
 */

HostList.prototype.populate = async function populate(target) {
  const addrs = [];

  assert(target.type === IP.types.DNS, 'Resolved host passed.');

  this.logger.info('Resolving host: %s.', target.host);

  let hosts;
  try {
    hosts = await this.resolve(target.host);
  } catch (e) {
    this.logger.error(e);
    return addrs;
  }

  for (const host of hosts) {
    const addr = NetAddress.fromHost(host, target.port, this.network);
    addrs.push(addr);
  }

  return addrs;
};

/**
 * Convert host list to json-friendly object.
 * @returns {Object}
 */

HostList.prototype.toJSON = function toJSON() {
  const addrs = [];
  const fresh = [];
  const used = [];

  for (const entry of this.map.values())
    addrs.push(entry.toJSON());

  for (const bucket of this.fresh) {
    const keys = [];
    for (const key of bucket.keys())
      keys.push(key);
    fresh.push(keys);
  }

  for (const bucket of this.used) {
    const keys = [];
    for (let entry = bucket.head; entry; entry = entry.next)
      keys.push(entry.key());
    used.push(keys);
  }

  return {
    version: HostList.VERSION,
    addrs: addrs,
    fresh: fresh,
    used: used
  };
};

/**
 * Inject properties from json object.
 * @private
 * @param {Object} json
 * @returns {HostList}
 */

HostList.prototype.fromJSON = function fromJSON(json) {
  const sources = new Map();
  const map = new Map();
  let totalFresh = 0;
  let totalUsed = 0;
  const fresh = [];
  const used = [];

  assert(json && typeof json === 'object');

  assert(json.version === HostList.VERSION,
    'Bad address serialization version.');

  assert(Array.isArray(json.addrs));

  for (const addr of json.addrs) {
    const entry = HostEntry.fromJSON(addr, this.network);
    let src = sources.get(entry.src.hostname);

    // Save some memory.
    if (!src) {
      src = entry.src;
      sources.set(src.hostname, src);
    }

    entry.src = src;

    map.set(entry.key(), entry);
  }

  assert(Array.isArray(json.fresh));
  assert(json.fresh.length <= this.options.maxBuckets,
    'Buckets mismatch.');

  for (const keys of json.fresh) {
    const bucket = new Map();

    for (const key of keys) {
      const entry = map.get(key);
      assert(entry);
      if (entry.refCount === 0)
        totalFresh++;
      entry.refCount++;
      bucket.set(key, entry);
    }

    assert(bucket.size <= this.options.maxEntries,
      'Bucket size mismatch.');

    fresh.push(bucket);
  }

  assert(fresh.length === this.fresh.length,
    'Buckets mismatch.');

  assert(Array.isArray(json.used));
  assert(json.used.length <= this.options.maxBuckets,
    'Buckets mismatch.');

  for (const keys of json.used) {
    const bucket = new List();

    for (const key of keys) {
      const entry = map.get(key);
      assert(entry);
      assert(entry.refCount === 0);
      assert(!entry.used);
      entry.used = true;
      totalUsed++;
      bucket.push(entry);
    }

    assert(bucket.size <= this.options.maxEntries,
      'Bucket size mismatch.');

    used.push(bucket);
  }

  assert(used.length === this.used.length,
    'Buckets mismatch.');

  for (const entry of map.values())
    assert(entry.used || entry.refCount > 0);

  this.map = map;
  this.fresh = fresh;
  this.totalFresh = totalFresh;
  this.used = used;
  this.totalUsed = totalUsed;

  return this;
};

/**
 * Instantiate host list from json object.
 * @param {Object} options
 * @param {Object} json
 * @returns {HostList}
 */

HostList.fromJSON = function fromJSON(options, json) {
  return new HostEntry(options).fromJSON(json);
};

/**
 * HostEntry
 * @alias module:net.HostEntry
 * @constructor
 * @param {NetAddress} addr
 * @param {NetAddress} src
 */

function HostEntry(addr, src) {
  if (!(this instanceof HostEntry))
    return new HostEntry(addr, src);

  this.addr = addr || new NetAddress();
  this.src = src || new NetAddress();
  this.prev = null;
  this.next = null;
  this.used = false;
  this.refCount = 0;
  this.attempts = 0;
  this.lastSuccess = 0;
  this.lastAttempt = 0;

  if (addr)
    this.fromOptions(addr, src);
}

/**
 * Inject properties from options.
 * @private
 * @param {NetAddress} addr
 * @param {NetAddress} src
 * @returns {HostEntry}
 */

HostEntry.prototype.fromOptions = function fromOptions(addr, src) {
  assert(addr instanceof NetAddress);
  assert(src instanceof NetAddress);
  this.addr = addr;
  this.src = src;
  return this;
};

/**
 * Instantiate host entry from options.
 * @param {NetAddress} addr
 * @param {NetAddress} src
 * @returns {HostEntry}
 */

HostEntry.fromOptions = function fromOptions(addr, src) {
  return new HostEntry().fromOptions(addr, src);
};

/**
 * Get key suitable for a hash table (hostname).
 * @returns {String}
 */

HostEntry.prototype.key = function key() {
  return this.addr.hostname;
};

/**
 * Get host priority.
 * @param {Number} now
 * @returns {Number}
 */

HostEntry.prototype.chance = function chance(now) {
  let c = 1;

  if (now - this.lastAttempt < 60 * 10)
    c *= 0.01;

  c *= Math.pow(0.66, Math.min(this.attempts, 8));

  return c;
};

/**
 * Inspect host address.
 * @returns {Object}
 */

HostEntry.prototype.inspect = function inspect() {
  return {
    addr: this.addr,
    src: this.src,
    used: this.used,
    refCount: this.refCount,
    attempts: this.attempts,
    lastSuccess: util.date(this.lastSuccess),
    lastAttempt: util.date(this.lastAttempt)
  };
};

/**
 * Convert host entry to json-friendly object.
 * @returns {Object}
 */

HostEntry.prototype.toJSON = function toJSON() {
  return {
    addr: this.addr.hostname,
    src: this.src.hostname,
    services: this.addr.services.toString(2),
    time: this.addr.time,
    attempts: this.attempts,
    lastSuccess: this.lastSuccess,
    lastAttempt: this.lastAttempt
  };
};

/**
 * Inject properties from json object.
 * @private
 * @param {Object} json
 * @param {Network} network
 * @returns {HostEntry}
 */

HostEntry.prototype.fromJSON = function fromJSON(json, network) {
  assert(json && typeof json === 'object');
  assert(typeof json.addr === 'string');
  assert(typeof json.src === 'string');

  this.addr.fromHostname(json.addr, network);

  if (json.services != null) {
    assert(typeof json.services === 'string');
    assert(json.services.length > 0);
    assert(json.services.length <= 32);
    const services = parseInt(json.services, 2);
    assert(util.isU32(services));
    this.addr.services = services;
  }

  if (json.time != null && typeof json.time != 'object') {
    assert(util.isU64(json.time));
    this.addr.time = json.time;
  }

  if (json.src != null) {
    assert(typeof json.src === 'string');
    this.src.fromHostname(json.src, network);
  }

  if (json.attempts != null) {
    assert(util.isU64(json.attempts));
    this.attempts = json.attempts;
  }

  if (json.lastSuccess != null && typeof json.lastSuccess != 'object') {
    assert(util.isU64(json.lastSuccess));
    this.lastSuccess = json.lastSuccess;
  }

  if (json.lastAttempt != null && typeof json.lastAttempt != 'object') {
    assert(util.isU64(json.lastAttempt));
    this.lastAttempt = json.lastAttempt;
  }

  return this;
};

/**
 * Instantiate host entry from json object.
 * @param {Object} json
 * @param {Network} network
 * @returns {HostEntry}
 */

HostEntry.fromJSON = function fromJSON(json, network) {
  return new HostEntry().fromJSON(json, network);
};

/**
 * LocalAddress
 * @alias module:net.LocalAddress
 * @constructor
 * @param {NetAddress} addr
 * @param {Number?} score
 */

function LocalAddress(addr, score) {
  this.addr = addr;
  this.score = score || 0;
}

/**
 * Host List Options
 * @alias module:net.HostListOptions
 * @constructor
 * @param {Object?} options
 */

function HostListOptions(options) {
  if (!(this instanceof HostListOptions))
    return new HostListOptions(options);

  this.network = Network.primary;
  this.logger = Logger.global;
  this.resolve = dns.lookup;
  this.host = '0.0.0.0';
  this.port = this.network.port;
  this.services = common.LOCAL_SERVICES;
  this.onion = false;
  this.banTime = common.BAN_TIME;

  this.address = new NetAddress();
  this.address.services = this.services;
  this.address.time = this.network.now();

  this.seeds = this.network.seeds;
  this.nodes = [];

  this.maxBuckets = 20;
  this.maxEntries = 50;

  this.prefix = null;
  this.filename = null;
  this.persistent = false;
  this.flushInterval = 120000;

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from options.
 * @private
 * @param {Object} options
 */

HostListOptions.prototype.fromOptions = function fromOptions(options) {
  assert(options, 'Options are required.');

  if (options.network != null) {
    this.network = Network.get(options.network);
    this.seeds = this.network.seeds;
    this.address.port = this.network.port;
    this.port = this.network.port;
  }

  if (options.logger != null) {
    assert(typeof options.logger === 'object');
    this.logger = options.logger;
  }

  if (options.resolve != null) {
    assert(typeof options.resolve === 'function');
    this.resolve = options.resolve;
  }

  if (options.banTime != null) {
    assert(options.banTime >= 0);
    this.banTime = options.banTime;
  }

  if (options.seeds) {
    assert(Array.isArray(options.seeds));
    this.seeds = options.seeds;
  }

  if (options.nodes) {
    assert(Array.isArray(options.nodes));
    this.nodes = options.nodes;
  }

  if (options.host != null) {
    assert(typeof options.host === 'string');
    const raw = IP.toBuffer(options.host);
    this.host = IP.toString(raw);
    if (IP.isRoutable(raw))
      this.address.setHost(this.host);
  }

  if (options.port != null) {
    assert(typeof options.port === 'number');
    assert(options.port > 0 && options.port <= 0xffff);
    this.port = options.port;
    this.address.setPort(this.port);
  }

  if (options.publicHost != null) {
    assert(typeof options.publicHost === 'string');
    this.address.setHost(options.publicHost);
  }

  if (options.publicPort != null) {
    assert(typeof options.publicPort === 'number');
    assert(options.publicPort > 0 && options.publicPort <= 0xffff);
    this.address.setPort(options.publicPort);
  }

  if (options.services != null) {
    assert(typeof options.services === 'number');
    this.services = options.services;
  }

  if (options.onion != null) {
    assert(typeof options.onion === 'boolean');
    this.onion = options.onion;
  }

  if (options.maxBuckets != null) {
    assert(typeof options.maxBuckets === 'number');
    this.maxBuckets = options.maxBuckets;
  }

  if (options.maxEntries != null) {
    assert(typeof options.maxEntries === 'number');
    this.maxEntries = options.maxEntries;
  }

  if (options.persistent != null) {
    assert(typeof options.persistent === 'boolean');
    this.persistent = options.persistent;
  }

  if (options.prefix != null) {
    assert(typeof options.prefix === 'string');
    this.prefix = options.prefix;
    this.filename = path.join(this.prefix, 'hosts.json');
  }

  if (options.filename != null) {
    assert(typeof options.filename === 'string');
    this.filename = options.filename;
  }

  if (options.flushInterval != null) {
    assert(options.flushInterval >= 0);
    this.flushInterval = options.flushInterval;
  }

  this.address.time = this.network.now();
  this.address.services = this.services;

  return this;
};

/*
 * Helpers
 */

function concat32(left, right) {
  const data = POOL32;
  left.copy(data, 0);
  right.copy(data, 32);
  return data;
}

/*
 * Expose
 */

module.exports = HostList;


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * parser.js - packet parser for wmcc_core.
 */

/* eslint nonblock-statement-body-position: "off" */



const assert = __webpack_require__(0);
const EventEmitter = __webpack_require__(10);
const Network = __webpack_require__(6);
const util = __webpack_require__(1);
const digest = __webpack_require__(5);
const common = __webpack_require__(59);
const packets = __webpack_require__(60);

/**
 * Protocol packet parser
 * @alias module:net.Parser
 * @constructor
 * @param {Network} network
 * @emits Parser#error
 * @emits Parser#packet
 */

function Parser(network) {
  if (!(this instanceof Parser))
    return new Parser(network);

  EventEmitter.call(this);

  this.network = Network.get(network);

  this.pending = [];
  this.total = 0;
  this.waiting = 24;
  this.header = null;
}

Object.setPrototypeOf(Parser.prototype, EventEmitter.prototype);

/**
 * Emit an error.
 * @private
 * @param {...String} msg
 */

Parser.prototype.error = function error() {
  const msg = util.fmt.apply(util, arguments);
  this.emit('error', new Error(msg));
};

/**
 * Feed data to the parser.
 * @param {Buffer} data
 */

Parser.prototype.feed = function feed(data) {
  this.total += data.length;
  this.pending.push(data);

  while (this.total >= this.waiting) {
    const chunk = Buffer.allocUnsafe(this.waiting);
    let off = 0;

    while (off < chunk.length) {
      const len = this.pending[0].copy(chunk, off);
      if (len === this.pending[0].length)
        this.pending.shift();
      else
        this.pending[0] = this.pending[0].slice(len);
      off += len;
    }

    assert.strictEqual(off, chunk.length);

    this.total -= chunk.length;
    this.parse(chunk);
  }
};

/**
 * Parse a fully-buffered chunk.
 * @param {Buffer} chunk
 */

Parser.prototype.parse = function parse(data) {
  assert(data.length <= common.MAX_MESSAGE);

  if (!this.header) {
    this.header = this.parseHeader(data);
    return;
  }

  const checksum = digest.hash256(data).readUInt32LE(0, true);

  if (checksum !== this.header.checksum) {
    this.waiting = 24;
    this.header = null;
    this.error('Invalid checksum: %s.', util.hex32(checksum));
    return;
  }

  let payload;
  try {
    payload = this.parsePayload(this.header.cmd, data);
  } catch (e) {
    this.waiting = 24;
    this.header = null;
    this.emit('error', e);
    return;
  }

  this.waiting = 24;
  this.header = null;

  this.emit('packet', payload);
};

/**
 * Parse buffered packet header.
 * @param {Buffer} data - Header.
 * @returns {Header}
 */

Parser.prototype.parseHeader = function parseHeader(data) {
  const magic = data.readUInt32LE(0, true);

  if (magic !== this.network.magic) {
    this.error('Invalid magic value: %s.', util.hex32(magic));
    return null;
  }

  // Count length of the cmd.
  let i = 0;
  for (; data[i + 4] !== 0 && i < 12; i++);

  if (i === 12) {
    this.error('Non NULL-terminated command.');
    return null;
  }

  const cmd = data.toString('ascii', 4, 4 + i);

  const size = data.readUInt32LE(16, true);

  if (size > common.MAX_MESSAGE) {
    this.waiting = 24;
    this.error('Packet length too large: %dmb.', util.mb(size));
    return null;
  }

  this.waiting = size;

  const checksum = data.readUInt32LE(20, true);

  return new Header(cmd, size, checksum);
};

/**
 * Parse a payload.
 * @param {String} cmd - Packet type.
 * @param {Buffer} data - Payload.
 * @returns {Object}
 */

Parser.prototype.parsePayload = function parsePayload(cmd, data) {
  return packets.fromRaw(cmd, data);
};

/**
 * Packet Header
 * @constructor
 * @ignore
 */

function Header(cmd, size, checksum) {
  this.cmd = cmd;
  this.size = size;
  this.checksum = checksum;
}

/*
 * Expose
 */

module.exports = Parser;


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * upnp.js - upnp for wmcc_core.
 */



const assert = __webpack_require__(0);
const dgram = __webpack_require__(98);
const url = __webpack_require__(90);
const request = __webpack_require__(92);
const co = __webpack_require__(17);
const Lock = __webpack_require__(23);
const IP = __webpack_require__(46);

/**
 * UPNP
 * @alias module:net.UPNP
 * @constructor
 * @param {String?} host - Multicast IP.
 * @param {Number?} port - Multicast port.
 * @param {String?} gateway - Gateway name.
 */

function UPNP(host, port, gateway) {
  if (!(this instanceof UPNP))
    return new UPNP(host, port, gateway);

  this.host = host || '239.255.255.250';
  this.port = port || 1900;
  this.gateway = gateway || UPNP.INTERNET_GATEWAY;
  this.locker = new Lock();
  this.timeout = null;
  this.job = null;
}

/**
 * Default internet gateway string.
 * @const {String}
 * @default
 */

UPNP.INTERNET_GATEWAY = 'urn:schemas-upnp-org:device:InternetGatewayDevice:1';

/**
 * Default service types.
 * @const {String[]}
 * @default
 */

UPNP.WAN_SERVICES = [
  'urn:schemas-upnp-org:service:WANIPConnection:1',
  'urn:schemas-upnp-org:service:WANPPPConnection:1'
];

/**
 * Timeout before killing request.
 * @const {Number}
 * @default
 */

UPNP.RESPONSE_TIMEOUT = 1000;

/**
 * Clean up current job.
 * @private
 * @returns {Job}
 */

UPNP.prototype.cleanupJob = function cleanupJob() {
  const job = this.job;

  assert(this.socket);
  assert(this.job);

  this.job = null;

  this.socket.close();
  this.socket = null;

  this.stopTimeout();

  return job;
};

/**
 * Reject current job.
 * @private
 * @param {Error} err
 */

UPNP.prototype.rejectJob = function rejectJob(err) {
  const job = this.cleanupJob();
  job.reject(err);
};

/**
 * Resolve current job.
 * @private
 * @param {Object} result
 */

UPNP.prototype.resolveJob = function resolveJob(result) {
  const job = this.cleanupJob();
  job.resolve(result);
};

/**
 * Start gateway timeout.
 * @private
 */

UPNP.prototype.startTimeout = function startTimeout() {
  this.stopTimeout();
  this.timeout = setTimeout(() => {
    this.timeout = null;
    this.rejectJob(new Error('Request timed out.'));
  }, UPNP.RESPONSE_TIMEOUT);
};

/**
 * Stop gateway timeout.
 * @private
 */

UPNP.prototype.stopTimeout = function stopTimeout() {
  if (this.timeout != null) {
    clearTimeout(this.timeout);
    this.timeout = null;
  }
};

/**
 * Discover gateway.
 * @returns {Promise} Location string.
 */

UPNP.prototype.discover = async function discover() {
  const unlock = await this.locker.lock();
  try {
    return await this._discover();
  } finally {
    unlock();
  }
};

/**
 * Discover gateway (without a lock).
 * @private
 * @returns {Promise} Location string.
 */

UPNP.prototype._discover = async function _discover() {
  const socket = dgram.createSocket('udp4');

  socket.on('error', (err) => {
    this.rejectJob(err);
  });

  socket.on('message', (data, rinfo) => {
    const msg = data.toString('utf8');
    this.handleMsg(msg);
  });

  this.socket = socket;
  this.startTimeout();

  const msg = ''
    + 'M-SEARCH * HTTP/1.1\r\n'
    + `HOST: ${this.host}:${this.port}\r\n`
    + 'MAN: ssdp:discover\r\n'
    + 'MX: 10\r\n'
    + 'ST: ssdp:all\r\n';

  socket.send(msg, this.port, this.host);

  return await new Promise((resolve, reject) => {
    this.job = co.job(resolve, reject);
  });
};

/**
 * Handle incoming UDP message.
 * @private
 * @param {String} msg
 * @returns {Promise}
 */

UPNP.prototype.handleMsg = async function handleMsg(msg) {
  if (!this.socket)
    return;

  let headers;
  try {
    headers = UPNP.parseHeader(msg);
  } catch (e) {
    return;
  }

  if (!headers.location)
    return;

  if (headers.st !== this.gateway)
    return;

  this.resolveJob(headers.location);
};

/**
 * Resolve service parameters from location.
 * @param {String} location
 * @param {String[]} targets - Target services.
 * @returns {Promise}
 */

UPNP.prototype.resolve = async function resolve(location, targets) {
  const host = parseHost(location);

  if (!targets)
    targets = UPNP.WAN_SERVICES;

  const res = await request({
    method: 'GET',
    uri: location,
    timeout: UPNP.RESPONSE_TIMEOUT,
    expect: 'xml'
  });

  const xml = XMLElement.fromRaw(res.body);

  const services = parseServices(xml);
  assert(services.length > 0, 'No services found.');

  const service = extractServices(services, targets);
  assert(service, 'No service found.');
  assert(service.serviceId, 'No service ID found.');
  assert(service.serviceId.length > 0, 'No service ID found.');
  assert(service.controlURL, 'No control URL found.');
  assert(service.controlURL.length > 0, 'No control URL found.');

  service.controlURL = prependHost(host, service.controlURL);

  if (service.eventSubURL)
    service.eventSubURL = prependHost(host, service.eventSubURL);

  if (service.SCPDURL)
    service.SCPDURL = prependHost(host, service.SCPDURL);

  return service;
};

/**
 * Parse UPNP datagram.
 * @private
 * @param {String} str
 * @returns {Object}
 */

UPNP.parseHeader = function parseHeader(str) {
  const lines = str.split(/\r?\n/);
  const headers = Object.create(null);

  for (let line of lines) {
    line = line.trim();

    if (line.length === 0)
      continue;

    const index = line.indexOf(':');

    if (index === -1) {
      const left = line.toLowerCase();
      headers[left] = '';
      continue;
    }

    let left = line.substring(0, index);
    let right = line.substring(index + 1);

    left = left.trim();
    right = right.trim();

    left = left.toLowerCase();

    headers[left] = right;
  }

  return headers;
};

/**
 * Discover gateway and resolve service.
 * @param {String?} host - Multicast IP.
 * @param {Number?} port - Multicast port.
 * @param {String?} gateway - Gateway type.
 * @param {String[]?} targets - Target service types.
 * @returns {Promise} Service.
 */

UPNP.discover = async function discover(host, port, gateway, targets) {
  const upnp = new UPNP(host, port, gateway);
  const location = await upnp.discover();
  const service = await upnp.resolve(location, targets);
  return new UPNPService(service);
};

/**
 * Gateway Service
 * @constructor
 * @ignore
 * @param {Object} options - Service parameters.
 */

function UPNPService(options) {
  if (!(this instanceof UPNPService))
    return new UPNPService(options);

  this.serviceType = options.serviceType;
  this.serviceId = options.serviceId;
  this.controlURL = options.controlURL;
  this.eventSubURL = options.eventSubURL;
  this.SCPDURL = options.SCPDURL;
}

/**
 * Compile SOAP request.
 * @private
 * @param {String} action
 * @param {String[]} args
 * @returns {String}
 */

UPNPService.prototype.createRequest = function createRequest(action, args) {
  const type = JSON.stringify(this.serviceType);
  let params = '';

  for (const [key, value] of args) {
    params += `<${key}>`;
    if (value != null)
      params += value;
    params += `</${key}>`;
  }

  return ''
    + '<?xml version="1.0"?>'
    + '<s:Envelope'
    + ' xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"'
    + ' s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">'
    + '<s:Body>'
    + `<u:${action} xmlns:u=${type}>`
    + `${params}`
    + `</u:${action}>`
    + '</s:Body>'
    + '</s:Envelope>';
};

/**
 * Send SOAP request and parse XML response.
 * @private
 * @param {String} action
 * @param {String[]} args
 * @returns {XMLElement}
 */

UPNPService.prototype.soapRequest = async function soapRequest(action, args) {
  const type = this.serviceType;
  const req = this.createRequest(action, args);

  const res = await request({
    method: 'POST',
    uri: this.controlURL,
    timeout: UPNP.RESPONSE_TIMEOUT,
    expect: 'xml',
    headers: {
      'Content-Type': 'text/xml; charset="utf-8"',
      'Content-Length': Buffer.byteLength(req, 'utf8').toString(10),
      'Connection': 'close',
      'SOAPAction': JSON.stringify(`${type}#${action}`)
    },
    body: req
  });

  const xml = XMLElement.fromRaw(res.body);
  const err = findError(xml);

  if (err)
    throw err;

  return xml;
};

/**
 * Attempt to get external IP from service (wan).
 * @returns {Promise}
 */

UPNPService.prototype.getExternalIP = async function getExternalIP() {
  const action = 'GetExternalIPAddress';
  const xml = await this.soapRequest(action, []);
  const ip = findIP(xml);

  if (!ip)
    throw new Error('Could not find external IP.');

  return ip;
};

/**
 * Attempt to add port mapping to local IP.
 * @param {String} remote - Remote IP.
 * @param {Number} src - Remote port.
 * @param {Number} dest - Local port.
 * @returns {Promise}
 */

UPNPService.prototype.addPortMapping = async function addPortMapping(remote, src, dest) {
  const action = 'AddPortMapping';
  const local = IP.getPrivate();

  if (local.length === 0)
    throw new Error('Cannot determine local IP.');

  const xml = await this.soapRequest(action, [
    ['NewRemoteHost', remote],
    ['NewExternalPort', src],
    ['NewProtocol', 'TCP'],
    ['NewInternalClient', local[0]],
    ['NewInternalPort', dest],
    ['NewEnabled', 'True'],
    ['NewPortMappingDescription', 'upnp:wmcc'],
    ['NewLeaseDuration', 0]
  ]);

  const child = xml.find('AddPortMappingResponse');

  if (!child)
    throw new Error('Port mapping failed.');

  return child.text;
};

/**
 * Attempt to remove port mapping from local IP.
 * @param {String} remote - Remote IP.
 * @param {Number} port - Remote port.
 * @returns {Promise}
 */

UPNPService.prototype.removePortMapping = async function removePortMapping(remote, port) {
  const action = 'DeletePortMapping';

  const xml = await this.soapRequest(action, [
    ['NewRemoteHost', remote],
    ['NewExternalPort', port],
    ['NewProtocol', 'TCP']
  ]);

  const child = xml.find('DeletePortMappingResponse');

  if (!child)
    throw new Error('Port unmapping failed.');

  return child.text;
};

/**
 * XML Element
 * @constructor
 * @ignore
 */

function XMLElement(name) {
  this.name = name;
  this.type = name.replace(/^[^:]:/, '');
  this.children = [];
  this.text = '';
}

/**
 * Insantiate element from raw XML.
 * @param {String} xml
 * @returns {XMLElement}
 */

XMLElement.fromRaw = function fromRaw(xml) {
  const sentinel = new XMLElement('');
  const stack = [sentinel];

  let current = sentinel;
  let decl = false;

  while (xml.length > 0) {
    let m;

    m = /^<\?xml[^<>]*\?>/i.exec(xml);
    if (m) {
      xml = xml.substring(m[0].length);
      assert(current === sentinel, 'XML declaration inside element.');
      assert(!decl, 'XML declaration seen twice.');
      decl = true;
      continue;
    }

    m = /^<([\w:]+)[^<>]*?(\/?)>/i.exec(xml);
    if (m) {
      xml = xml.substring(m[0].length);

      const name = m[1];
      const trailing = m[2] === '/';
      const element = new XMLElement(name);

      if (trailing) {
        current.add(element);
        continue;
      }

      stack.push(element);
      current.add(element);
      current = element;

      continue;
    }

    m = /^<\/([\w:]+)[^<>]*>/i.exec(xml);
    if (m) {
      xml = xml.substring(m[0].length);

      const name = m[1];

      assert(stack.length !== 1, 'No start tag.');

      const element = stack.pop();

      assert(element.name === name, 'Tag mismatch.');
      current = stack[stack.length - 1];

      if (current === sentinel)
        break;

      continue;
    }

    m = /^([^<]+)/i.exec(xml);
    if (m) {
      xml = xml.substring(m[0].length);
      const text = m[1];
      current.text = text.trim();
      continue;
    }

    throw new Error('XML parse error.');
  }

  assert(sentinel.children.length > 0, 'No root element.');

  return sentinel.children[0];
};

/**
 * Push element onto children.
 * @param {XMLElement} child
 * @returns {Number}
 */

XMLElement.prototype.add = function add(child) {
  return this.children.push(child);
};

/**
 * Collect all descendants with matching name.
 * @param {String} name
 * @returns {XMLElement[]}
 */

XMLElement.prototype.collect = function collect(name) {
  return this._collect(name, []);
};

/**
 * Collect all descendants with matching name.
 * @private
 * @param {String} name
 * @param {XMLElement[]} result
 * @returns {XMLElement[]}
 */

XMLElement.prototype._collect = function _collect(name, result) {
  for (const child of this.children) {
    if (child.type === name) {
      result.push(child);
      continue;
    }

    child._collect(name, result);
  }

  return result;
};

/**
 * Find child element with matching name.
 * @param {String} name
 * @returns {XMLElement|null}
 */

XMLElement.prototype.find = function find(name) {
  //for (let child of this.children) {
  for (const child of this.children) {
    if (child.type === name)
      return child;

    //child = child.find(name);
    const desc = child.find(name);

    //if (child)
    //  return child;
    if (desc)
      return desc;
  }

  return null;
};

/*
 * XML Helpers
 */

function parseServices(el) {
  const children = el.collect('service');
  const services = [];

  for (const child of children)
    services.push(parseService(child));

  return services;
}

function parseService(el) {
  const service = Object.create(null);

  for (const child of el.children) {
    if (child.children.length > 0)
      continue;

    service[child.type] = child.text;
  }

  return service;
}

function findService(services, name) {
  for (const service of services) {
    if (service.serviceType === name)
      return service;
  }

  return null;
}

function extractServices(services, targets) {
  for (const name of targets) {
    const service = findService(services, name);
    if (service)
      return service;
  }

  return null;
}

function findIP(el) {
  const child = el.find('NewExternalIPAddress');

  if (!child)
    return null;

  return IP.normalize(child.text);
}

function findError(el) {
  const child = el.find('UPnPError');

  if (!child)
    return null;

  let code = -1;
  const ccode = child.find('errorCode');

  if (ccode && /^\d+$/.test(ccode.text))
    code = parseInt(ccode.text, 10);

  let desc = 'Unknown';
  const cdesc = child.find('errorDescription');

  if (cdesc)
    desc = cdesc.text;

  return new Error(`UPnPError: ${desc} (${code}).`);
}

/*
 * Helpers
 */

function parseHost(uri) {
  const {protocol, host} = url.parse(uri);

  assert(protocol === 'http:' || protocol === 'https:',
    'Bad URL for location.');

  return `${protocol}//${host}`;
}

function prependHost(host, uri) {
  if (uri.indexOf('://') === -1) {
    if (uri[0] !== '/')
      uri = '/' + uri;
    uri = host + uri;
  }
  return uri;
}

/*
 * Expose
 */

module.exports = UPNP;


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * fullnode.js - full node for wmcc_core.
 */



const Chain = __webpack_require__(104);
const Fees = __webpack_require__(117);
const Mempool = __webpack_require__(182);
const Pool = __webpack_require__(122);
const Miner = __webpack_require__(185);
const HTTPServer = __webpack_require__(180);
const RPC = __webpack_require__(115);
const Node = __webpack_require__(189);

/**
 * Respresents a fullnode complete with a
 * chain, mempool, miner, etc.
 * @alias module:node.FullNode
 * @extends Node
 * @constructor
 * @param {Object?} options
 * @property {Chain} chain
 * @property {PolicyEstimator} fees
 * @property {Mempool} mempool
 * @property {Pool} pool
 * @property {Miner} miner
 * @property {HTTPServer} http
 * @emits FullNode#block
 * @emits FullNode#tx
 * @emits FullNode#connect
 * @emits FullNode#disconnect
 * @emits FullNode#reset
 * @emits FullNode#error
 */

function FullNode(options) {
  if (!(this instanceof FullNode))
    return new FullNode(options);

  Node.call(this, options);

  // SPV flag.
  this.spv = false;

  // Instantiate blockchain.
  this.chain = new Chain({
    network: this.network,
    logger: this.logger,
    workers: this.workers,
    db: this.config.str('db'),
    prefix: this.config.prefix,
    maxFiles: this.config.uint('max-files'),
    cacheSize: this.config.mb('cache-size'),
    forceFlags: this.config.bool('force-flags'),
    bip91: this.config.bool('bip91'),
    bip148: this.config.bool('bip148'),
    prune: this.config.bool('prune'),
    checkpoints: this.config.bool('checkpoints'),
    coinCache: this.config.mb('coin-cache'),
    entryCache: this.config.uint('entry-cache'),
    indexTX: this.config.bool('index-tx'),
    indexAddress: this.config.bool('index-address')
  });

  // Fee estimation.
  this.fees = new Fees(this.logger);
  this.fees.init();

  // Mempool needs access to the chain.
  this.mempool = new Mempool({
    network: this.network,
    logger: this.logger,
    workers: this.workers,
    chain: this.chain,
    fees: this.fees,
    db: this.config.str('db'),
    prefix: this.config.prefix,
    persistent: this.config.bool('persistent-mempool'),
    maxSize: this.config.mb('mempool-size'),
    limitFree: this.config.bool('limit-free'),
    limitFreeRelay: this.config.uint('limit-free-relay'),
    requireStandard: this.config.bool('require-standard'),
    rejectAbsurdFees: this.config.bool('reject-absurd-fees'),
    replaceByFee: this.config.bool('replace-by-fee'),
    indexAddress: this.config.bool('index-address')
  });

  // Pool needs access to the chain and mempool.
  this.pool = new Pool({
    network: this.network,
    logger: this.logger,
    chain: this.chain,
    mempool: this.mempool,
    prefix: this.config.prefix,
    selfish: this.config.bool('selfish'),
    compact: this.config.bool('compact'),
    bip37: this.config.bool('bip37'),
    bip151: this.config.bool('bip151'),
    bip150: this.config.bool('bip150'),
    identityKey: this.config.buf('identity-key'),
    maxOutbound: this.config.uint('max-outbound'),
    maxInbound: this.config.uint('max-inbound'),
    proxy: this.config.str('proxy'),
    onion: this.config.bool('onion'),
    upnp: this.config.bool('upnp'),
    seeds: this.config.array('seeds'),
    nodes: this.config.array('nodes'),
    only: this.config.array('only'),
    publicHost: this.config.str('public-host'),
    publicPort: this.config.uint('public-port'),
    host: this.config.str('host'),
    port: this.config.uint('port'),
    listen: this.config.bool('listen'),
    persistent: this.config.bool('persistent')
  });

  // Miner needs access to the chain and mempool.
  this.miner = new Miner({
    network: this.network,
    logger: this.logger,
    workers: this.workers,
    chain: this.chain,
    mempool: this.mempool,
    address: this.config.array('coinbase-address'),
    coinbaseFlags: this.config.str('coinbase-flags'),
    preverify: this.config.bool('preverify'),
    maxWeight: this.config.uint('max-weight'),
    reservedWeight: this.config.uint('reserved-weight'),
    reservedSigops: this.config.uint('reserved-sigops')
  });

  // RPC needs access to the node.
  this.rpc = new RPC(this);

  // HTTP needs access to the node.
  if (!HTTPServer.unsupported) {
    this.http = new HTTPServer({
      network: this.network,
      logger: this.logger,
      node: this,
      prefix: this.config.prefix,
      ssl: this.config.bool('ssl'),
      keyFile: this.config.path('ssl-key'),
      certFile: this.config.path('ssl-cert'),
      host: this.config.str('http-host'),
      port: this.config.uint('http-port'),
      apiKey: this.config.str('api-key'),
      noAuth: this.config.bool('no-auth')
    });
  }

  this._init();
}

Object.setPrototypeOf(FullNode.prototype, Node.prototype);

/**
 * Initialize the node.
 * @private
 */

FullNode.prototype._init = function _init() {
  // Bind to errors
  this.chain.on('error', err => this.error(err));
  this.mempool.on('error', err => this.error(err));
  this.pool.on('error', err => this.error(err));
  this.miner.on('error', err => this.error(err));

  if (this.http)
    this.http.on('error', err => this.error(err));

  this.mempool.on('tx', (tx) => {
    this.miner.cpu.notifyEntry();
    this.emit('tx', tx);
  });

  this.chain.hook('connect', async (entry, block) => {
    try {
      await this.mempool._addBlock(entry, block.txs);
    } catch (e) {
      this.error(e);
    }
    this.emit('block', block);
    this.emit('connect', entry, block);
  });

  this.chain.hook('disconnect', async (entry, block) => {
    try {
      await this.mempool._removeBlock(entry, block.txs);
    } catch (e) {
      this.error(e);
    }
    this.emit('disconnect', entry, block);
  });

  this.chain.hook('reorganize', async (tip, competitor) => {
    try {
      await this.mempool._handleReorg();
    } catch (e) {
      this.error(e);
    }
    this.emit('reorganize', tip, competitor);
  });

  this.chain.hook('reset', async (tip) => {
    try {
      await this.mempool._reset();
    } catch (e) {
      this.error(e);
    }
    this.emit('reset', tip);
  });

  this.loadPlugins();
};

/**
 * Open the node and all its child objects,
 * wait for the database to load.
 * @alias FullNode#open
 * @returns {Promise}
 */

FullNode.prototype._open = async function _open() {
  await this.chain.open();
  await this.mempool.open();
  await this.miner.open();
  await this.pool.open();

  await this.openPlugins();

  if (this.http)
    await this.http.open();

  this.logger.info('Node is loaded.');
};

/**
 * Close the node, wait for the database to close.
 * @alias FullNode#close
 * @returns {Promise}
 */

FullNode.prototype._close = async function _close() {
  if (this.http)
    await this.http.close();

  await this.closePlugins();

  await this.pool.close();
  await this.miner.close();
  await this.mempool.close();
  await this.chain.close();

  this.logger.info('Node is closed.');
};

/**
 * Rescan for any missed transactions.
 * @param {Number|Hash} start - Start block.
 * @param {Bloom} filter
 * @param {Function} iter - Iterator.
 * @returns {Promise}
 */

FullNode.prototype.scan = function scan(start, filter, iter) {
  return this.chain.scan(start, filter, iter);
};

/**
 * Broadcast a transaction (note that this will _not_ be verified
 * by the mempool - use with care, lest you get banned from
 * wmccd nodes).
 * @param {TX|Block} item
 * @returns {Promise}
 */

FullNode.prototype.broadcast = async function broadcast(item) {
  try {
    await this.pool.broadcast(item);
  } catch (e) {
    this.emit('error', e);
  }
};

/**
 * Add transaction to mempool, broadcast.
 * @param {TX} tx
 */

FullNode.prototype.sendTX = async function sendTX(tx) {
  let missing;

  try {
    missing = await this.mempool.addTX(tx);
  } catch (err) {
    if (err.type === 'VerifyError' && err.score === 0) {
      this.error(err);
      this.logger.warning('Verification failed for tx: %s.', tx.txid());
      this.logger.warning('Attempting to broadcast anyway...');
      this.broadcast(tx);
      return;
    }
    throw err;
  }

  if (missing) {
    this.logger.warning('TX was orphaned in mempool: %s.', tx.txid());
    this.logger.warning('Attempting to broadcast anyway...');
    this.broadcast(tx);
    return;
  }

  // We need to announce by hand if
  // we're running in selfish mode.
  if (this.pool.options.selfish)
    this.pool.broadcast(tx);
};

/**
 * Add transaction to mempool, broadcast. Silence errors.
 * @param {TX} tx
 * @returns {Promise}
 */

FullNode.prototype.relay = async function relay(tx) {
  try {
    await this.sendTX(tx);
  } catch (e) {
    this.error(e);
  }
};

/**
 * Connect to the network.
 * @returns {Promise}
 */

FullNode.prototype.connect = function connect() {
  return this.pool.connect();
};

/**
 * Disconnect from the network.
 * @returns {Promise}
 */

FullNode.prototype.disconnect = function disconnect() {
  return this.pool.disconnect();
};

/**
 * Start the blockchain sync.
 */

FullNode.prototype.startSync = function startSync() {
  return this.pool.startSync();
};

/**
 * Stop syncing the blockchain.
 */

FullNode.prototype.stopSync = function stopSync() {
  return this.pool.stopSync();
};

/**
 * Retrieve a block from the chain database.
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link Block}.
 */

FullNode.prototype.getBlock = function getBlock(hash) {
  return this.chain.getBlock(hash);
};

/**
 * Retrieve a coin from the mempool or chain database.
 * Takes into account spent coins in the mempool.
 * @param {Hash} hash
 * @param {Number} index
 * @returns {Promise} - Returns {@link Coin}.
 */

FullNode.prototype.getCoin = async function getCoin(hash, index) {
  const coin = this.mempool.getCoin(hash, index);

  if (coin)
    return coin;

  if (this.mempool.isSpent(hash, index))
    return null;

  return await this.chain.getCoin(hash, index);
};

/**
 * Get coins that pertain to an address from the mempool or chain database.
 * Takes into account spent coins in the mempool.
 * @param {Address} addrs
 * @param {Number} height after
 * @returns {Promise} - Returns {@link Coin}[].
 */

FullNode.prototype.getCoinsByAddress = async function getCoinsByAddress(addrs, after) {
  const mempool = this.mempool.getCoinsByAddress(addrs);
  const chain = await this.chain.getCoinsByAddress(addrs, after);
  const out = [];

  for (const coin of chain) {
    const spent = this.mempool.isSpent(coin.hash, coin.index);

    if (spent)
      continue;

    out.push(coin);
  }

  for (const coin of mempool)
    out.push(coin);

  return out;
};

/**
 * Retrieve transactions pertaining to an
 * address from the mempool or chain database.
 * @param {Address} addrs
 * @returns {Promise} - Returns {@link TXMeta}[].
 */

FullNode.prototype.getMetaByAddress = async function getMetaByAddress(addrs) {
  const mempool = this.mempool.getMetaByAddress(addrs);
  const chain = await this.chain.getMetaByAddress(addrs);
  return chain.concat(mempool);
};

/**
 * Retrieve a transaction from the mempool or chain database.
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link TXMeta}.
 */

FullNode.prototype.getMeta = async function getMeta(hash) {
  const meta = this.mempool.getMeta(hash);

  if (meta)
    return meta;

  return await this.chain.getMeta(hash);
};

/**
 * Retrieve a spent coin viewpoint from mempool or chain database.
 * @param {TXMeta} meta
 * @returns {Promise} - Returns {@link CoinView}.
 */

FullNode.prototype.getMetaView = async function getMetaView(meta) {
  if (meta.height === -1)
    return this.mempool.getSpentView(meta.tx);
  return this.chain.getSpentView(meta.tx);
};

/**
 * Retrieve transactions pertaining to an
 * address from the mempool or chain database.
 * @param {Address} addrs
 * @returns {Promise} - Returns {@link TX}[].
 */

FullNode.prototype.getTXByAddress = async function getTXByAddress(addrs) {
  const mtxs = await this.getMetaByAddress(addrs);
  const out = [];

  for (const mtx of mtxs)
    out.push(mtx.tx);

  return out;
};

/**
 * Retrieve a transaction from the mempool or chain database.
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link TX}.
 */

FullNode.prototype.getTX = async function getTX(hash) {
  const mtx = await this.getMeta(hash);

  if (!mtx)
    return null;

  return mtx.tx;
};

/**
 * Test whether the mempool or chain contains a transaction.
 * @param {Hash} hash
 * @returns {Promise} - Returns Boolean.
 */

FullNode.prototype.hasTX = async function hasTX(hash) {
  if (this.mempool.hasEntry(hash))
    return true;

  return await this.chain.hasTX(hash);
};

/*
 * Expose
 */

module.exports = FullNode;


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * spvnode.js - spv node for wmcc_core.
 */



const Lock = __webpack_require__(23);
const Chain = __webpack_require__(104);
const Pool = __webpack_require__(122);
const HTTPServer = __webpack_require__(180);
const RPC = __webpack_require__(115);
const Node = __webpack_require__(189);

/**
 * Create an spv node which only maintains
 * a chain, a pool, and an http server.
 * @alias module:node.SPVNode
 * @extends Node
 * @constructor
 * @param {Object?} options
 * @param {Buffer?} options.sslKey
 * @param {Buffer?} options.sslCert
 * @param {Number?} options.httpPort
 * @param {String?} options.httpHost
 * @property {Boolean} loaded
 * @property {Chain} chain
 * @property {Pool} pool
 * @property {HTTPServer} http
 * @emits SPVNode#block
 * @emits SPVNode#tx
 * @emits SPVNode#error
 */

function SPVNode(options) {
  if (!(this instanceof SPVNode))
    return new SPVNode(options);

  Node.call(this, options);

  // SPV flag.
  this.spv = true;

  this.chain = new Chain({
    network: this.network,
    logger: this.logger,
    db: this.config.str('db'),
    prefix: this.config.prefix,
    maxFiles: this.config.uint('max-files'),
    cacheSize: this.config.mb('cache-size'),
    entryCache: this.config.uint('entry-cache'),
    forceFlags: this.config.bool('force-flags'),
    checkpoints: this.config.bool('checkpoints'),
    bip91: this.config.bool('bip91'),
    bip148: this.config.bool('bip148'),
    spv: true
  });

  this.pool = new Pool({
    network: this.network,
    logger: this.logger,
    chain: this.chain,
    prefix: this.config.prefix,
    proxy: this.config.str('proxy'),
    onion: this.config.bool('onion'),
    upnp: this.config.bool('upnp'),
    seeds: this.config.array('seeds'),
    nodes: this.config.array('nodes'),
    only: this.config.array('only'),
    bip151: this.config.bool('bip151'),
    bip150: this.config.bool('bip150'),
    identityKey: this.config.buf('identity-key'),
    maxOutbound: this.config.uint('max-outbound'),
    persistent: this.config.bool('persistent'),
    selfish: true,
    listen: false
  });

  this.rpc = new RPC(this);

  if (!HTTPServer.unsupported) {
    this.http = new HTTPServer({
      network: this.network,
      logger: this.logger,
      node: this,
      prefix: this.config.prefix,
      ssl: this.config.bool('ssl'),
      keyFile: this.config.path('ssl-key'),
      certFile: this.config.path('ssl-cert'),
      host: this.config.str('http-host'),
      port: this.config.uint('http-port'),
      apiKey: this.config.str('api-key'),
      noAuth: this.config.bool('no-auth')
    });
  }

  this.rescanJob = null;
  this.scanLock = new Lock();
  this.watchLock = new Lock();

  this._init();
}

Object.setPrototypeOf(SPVNode.prototype, Node.prototype);

/**
 * Initialize the node.
 * @private
 */

SPVNode.prototype._init = function _init() {
  // Bind to errors
  this.chain.on('error', err => this.error(err));
  this.pool.on('error', err => this.error(err));

  if (this.http)
    this.http.on('error', err => this.error(err));

  this.pool.on('tx', (tx) => {
    if (this.rescanJob)
      return;

    this.emit('tx', tx);
  });

  this.chain.on('block', (block) => {
    this.emit('block', block);
  });

  this.chain.on('connect', async (entry, block) => {
    if (this.rescanJob) {
      try {
        await this.watchBlock(entry, block);
      } catch (e) {
        this.error(e);
      }
      return;
    }

    this.emit('connect', entry, block);
  });

  this.chain.on('disconnect', (entry, block) => {
    //this.emit('disconnect', entry);
    this.emit('disconnect', entry, block);
  });

  this.chain.on('reorganize', (tip, competitor) => {
    this.emit('reorganize', tip, competitor);
  });

  this.chain.on('reset', (tip) => {
    this.emit('reset', tip);
  });

  this.loadPlugins();
};

/**
 * Open the node and all its child objects,
 * wait for the database to load.
 * @alias SPVNode#open
 * @returns {Promise}
 */

SPVNode.prototype._open = async function _open(callback) {
  await this.chain.open();
  await this.pool.open();

  await this.openPlugins();

  if (this.http)
    await this.http.open();

  this.logger.info('Node is loaded.');
};

/**
 * Close the node, wait for the database to close.
 * @alias SPVNode#close
 * @returns {Promise}
 */

SPVNode.prototype._close = async function _close() {
  if (this.http)
    await this.http.close();

  await this.closePlugins();

  await this.pool.close();
  await this.chain.close();
};

/**
 * Scan for any missed transactions.
 * Note that this will replay the blockchain sync.
 * @param {Number|Hash} start - Start block.
 * @param {Bloom} filter
 * @param {Function} iter - Iterator.
 * @returns {Promise}
 */

SPVNode.prototype.scan = async function scan(start, filter, iter) {
  const unlock = await this.scanLock.lock();
  const height = this.chain.height;

  try {
    await this.chain.replay(start);

    if (this.chain.height < height) {
      // We need to somehow defer this.
      // await this.connect();
      // this.startSync();
      // await this.watchUntil(height, iter);
    }
  } finally {
    unlock();
  }
};

/**
 * Watch the blockchain until a certain height.
 * @param {Number} height
 * @param {Function} iter
 * @returns {Promise}
 */

SPVNode.prototype.watchUntil = function watchUntil(height, iter) {
  return new Promise((resolve, reject) => {
    this.rescanJob = new RescanJob(resolve, reject, height, iter);
  });
};

/**
 * Handled watched block.
 * @param {ChainEntry} entry
 * @param {MerkleBlock} block
 * @returns {Promise}
 */

SPVNode.prototype.watchBlock = async function watchBlock(entry, block) {
  const unlock = await this.watchLock.lock();
  try {
    if (entry.height < this.rescanJob.height) {
      await this.rescanJob.iter(entry, block.txs);
      return;
    }
    this.rescanJob.resolve();
    this.rescanJob = null;
  } catch (e) {
    this.rescanJob.reject(e);
    this.rescanJob = null;
  } finally {
    unlock();
  }
};

/**
 * Broadcast a transaction (note that this will _not_ be verified
 * by the mempool - use with care, lest you get banned from
 * wmccd nodes).
 * @param {TX|Block} item
 * @returns {Promise}
 */

SPVNode.prototype.broadcast = async function broadcast(item) {
  try {
    await this.pool.broadcast(item);
  } catch (e) {
    this.emit('error', e);
  }
};

/**
 * Broadcast a transaction (note that this will _not_ be verified
 * by the mempool - use with care, lest you get banned from
 * wmccd nodes).
 * @param {TX} tx
 * @returns {Promise}
 */

SPVNode.prototype.sendTX = function sendTX(tx) {
  return this.broadcast(tx);
};

/**
 * Broadcast a transaction. Silence errors.
 * @param {TX} tx
 * @returns {Promise}
 */

SPVNode.prototype.relay = function relay(tx) {
  return this.broadcast(tx);
};

/**
 * Connect to the network.
 * @returns {Promise}
 */

SPVNode.prototype.connect = function connect() {
  return this.pool.connect();
};

/**
 * Disconnect from the network.
 * @returns {Promise}
 */

SPVNode.prototype.disconnect = function disconnect() {
  return this.pool.disconnect();
};

/**
 * Start the blockchain sync.
 */

SPVNode.prototype.startSync = function startSync() {
  return this.pool.startSync();
};

/**
 * Stop syncing the blockchain.
 */

SPVNode.prototype.stopSync = function stopSync() {
  return this.pool.stopSync();
};

/*
 * Helpers
 */

function RescanJob(resolve, reject, height, iter) {
  this.resolve = resolve;
  this.reject = reject;
  this.height = height;
  this.iter = iter;
}

/*
 * Expose
 */

module.exports = SPVNode;


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * sigcache.js - signature cache for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const secp256k1 = __webpack_require__(12);

/**
 * Signature cache.
 * @alias module:script.SigCache
 * @constructor
 * @param {Number} [size=10000]
 * @property {Number} size
 * @property {Hash[]} keys
 * @property {Object} valid
 */

function SigCache(size) {
  if (!(this instanceof SigCache))
    return new SigCache(size);

  if (size == null)
    size = 10000;

  assert(util.isU32(size));

  this.size = size;
  this.keys = [];
  this.valid = new Map();
}

/**
 * Resize the sigcache.
 * @param {Number} size
 */

SigCache.prototype.resize = function resize(size) {
  assert(util.isU32(size));

  this.size = size;
  this.keys.length = 0;
  this.valid.clear();
};

/**
 * Add item to the sigcache.
 * Potentially evict a random member.
 * @param {Hash} hash - Sig hash.
 * @param {Buffer} sig
 * @param {Buffer} key
 */

SigCache.prototype.add = function add(hash, sig, key) {
  if (this.size === 0)
    return;

  this.valid.set(hash, new SigCacheEntry(sig, key));

  if (this.keys.length >= this.size) {
    const i = Math.floor(Math.random() * this.keys.length);
    const k = this.keys[i];
    this.valid.delete(k);
    this.keys[i] = hash;
  } else {
    this.keys.push(hash);
  }
};

/**
 * Test whether the sig exists.
 * @param {Hash} hash - Sig hash.
 * @param {Buffer} sig
 * @param {Buffer} key
 * @returns {Boolean}
 */

SigCache.prototype.has = function has(hash, sig, key) {
  const entry = this.valid.get(hash);

  if (!entry)
    return false;

  return entry.equals(sig, key);
};

/**
 * Verify a signature, testing
 * it against the cache first.
 * @param {Buffer} msg
 * @param {Buffer} sig
 * @param {Buffer} key
 * @returns {Boolean}
 */

SigCache.prototype.verify = function verify(msg, sig, key) {
  if (this.size === 0)
    return secp256k1.verify(msg, sig, key);

  const hash = msg.toString('hex');

  if (this.has(hash, sig, key))
    return true;

  const result = secp256k1.verify(msg, sig, key);

  if (!result)
    return false;

  this.add(hash, sig, key);

  return true;
};

/**
 * Signature cache entry.
 * @constructor
 * @ignore
 * @param {Buffer} sig
 * @param {Buffer} key
 * @property {Buffer} sig
 * @property {Buffer} key
 */

function SigCacheEntry(sig, key) {
  this.sig = Buffer.from(sig);
  this.key = Buffer.from(key);
}

/**
 * Compare an entry to a sig and key.
 * @param {Buffer} sig
 * @param {Buffer} key
 * @returns {Boolean}
 */

SigCacheEntry.prototype.equals = function equals(sig, key) {
  return this.sig.equals(sig) && this.key.equals(key);
};

/*
 * Expose
 */

module.exports = SigCache;


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * stratum.js - stratum server for wmcc.
 */




const assert = __webpack_require__(0);
const path = __webpack_require__(25);
const os = __webpack_require__(116);
const {StringDecoder} = __webpack_require__(170);
const EventEmitter = __webpack_require__(10);
const {format} = __webpack_require__(38);
const {Lock} = __webpack_require__(322);
const tcp = __webpack_require__(323);
const IP = __webpack_require__(324);
const Logger = __webpack_require__(325);
const fs = __webpack_require__(326);
// todo add wmcc-crypto lib
//const hash256 = require('bcrypto/lib/hash256');
//const ccmp = require('bcrypto/lib/ccmp');
const hash256 = __webpack_require__(327).hash256;
const ccmp = __webpack_require__(52);
const util = __webpack_require__(1);
const consensus = __webpack_require__(7);
const List = __webpack_require__(91);
const Network = __webpack_require__(6);
const common = __webpack_require__(184);

/*
 * Constants
 */

const NONCE_SIZE = 4;

/**
 * Stratum Server
 * @extends {EventEmitter}
 */

class Stratum extends EventEmitter {
  /**
   * Create a stratum server.
   * @constructor
   * @param {Object} options
   */

  constructor(options) {
    super();

    this.options = new StratumOptions(options);

    this.node = this.options.node;
    this.chain = this.options.chain;
    this.network = this.options.network;
    this.logger = this.options.logger.context('stratum');
    this.difficulty = this.options.difficulty;

    this.server = tcp.createServer();
    this.sharedb = new ShareDB(this.options);
    this.userdb = new UserDB(this.options);
    this.locker = new Lock();
    this.jobMap = new Map();
    this.banned = new Map();
    this.jobs = new List();
    this.current = null;
    this.inbound = new List();
    this.lastActive = 0;
    this.subscribed = false;
    this.uid = 0;
    this.suid = 0;

    this._init();
  }

  static init(node) {
    const config = node.config;
    return new Stratum({
      node: node,
      prefix: config.prefix,
      logger: node.logger,
      host: config.str('stratum-host'),
      port: config.uint('stratum-port'),
      publicHost: config.str('stratum-public-host'),
      publicPort: config.uint('stratum-public-port'),
      maxInbound: config.uint('stratum-max-inbound'),
      difficulty: config.uint('stratum-difficulty'),
      dynamic: config.bool('stratum-dynamic'),
      password: config.str('stratum-password'),
      notify: config.uint('stratum-notify-interval')
    });
  }

  sid() {
    const sid = this.suid;
    this.suid += 1;
    this.suid >>>= 0;
    return sid;
  }

  jid() {
    const now = util.now();
    const id = this.uid;
    this.uid += 1;
    this.uid >>>= 0;
    return `${now}:${id}`;
  }

  _init() {
    this.server.on('connection', (socket) => {
      this.handleSocket(socket);
    });

    this.node.on('connect', async () => {
      try {
        await this.handleBlock();
      } catch (e) {
        this.emit('error', e);
      }
    });

    this.node.on('tx', async () => {
      try {
        await this.handleTX();
      } catch (e) {
        this.emit('error', e);
      }
    });
  }

  async handleBlock() {
    const unlock = await this.locker.lock();
    try {
      return await this._handleBlock();
    } finally {
      unlock();
    }
  }

  async _handleBlock() {
    const now = util.now();

    if (!this.subscribed) {
      this.lastActive = now;
      return;
    }

    this.current = null;
    this.lastActive = now;

    await this.notifyAll(true);
  }

  async handleTX() {
    const unlock = await this.locker.lock();
    try {
      return await this._handleTX();
    } finally {
      unlock();
    }
  }

  async _handleTX() {
    const now = util.now();

    if (!this.subscribed) {
      this.lastActive = now;
      return;
    }

    if (now > this.lastActive + Stratum.ACTIVE_TIME) {
      this.current = null;
      this.lastActive = now;

      await this.notifyAll(false);
    }
  }

  async handleSocket(socket) {
    if (!socket.remoteAddress) {
      this.logger.debug('Ignoring disconnected client.');
      socket.destroy();
      return;
    }

    const host = IP.normalize(socket.remoteAddress);

    if (this.inbound.size >= this.options.maxInbound) {
      this.logger.debug('Ignoring client: too many inbound (%s).', host);
      socket.destroy();
      return;
    }

    if (this.isBanned(host)) {
      this.logger.debug('Ignoring banned client (%s).', host);
      socket.destroy();
      return;
    }

    socket.setKeepAlive(true);
    socket.setNoDelay(true);

    this.addClient(socket);
  }

  addClient(socket) {
    const conn = new Connection(this, socket);

    conn.on('error', (err) => {
      this.emit('error', err);
    });

    conn.on('close', () => {
      assert(this.inbound.remove(conn));
    });

    conn.on('ban', () => {
      this.handleBan(conn);
    });

    this.inbound.push(conn);
  }

  handleBan(conn) {
    this.logger.warning('Banning client (%s).', conn.id());
    this.banned.set(conn.host, util.now());
    conn.destroy();
  }

  isBanned(host) {
    const time = this.banned.get(host);

    if (time == null)
      return false;

    if (util.now() - time > Stratum.BAN_TIME) {
      this.banned.delete(host);
      return false;
    }

    return true;
  }

  async listen() {
    this.server.maxConnections = this.options.maxInbound;

    await this.server.listen(this.options.port, this.options.host);

    this.logger.info('Server listening on %d.', this.options.port);
  }

  async open() {
    if (this.node.miner.addresses.length === 0)
      throw new Error('No addresses available for coinbase.');

    await this.userdb.open();
    await this.sharedb.open();
    await this.listen();

    if (this.options.password) {
      if (!this.userdb.get('admin')) {
        this.userdb.add({
          username: 'admin',
          hash: this.options.password
        });
      }
    }

    this.lastActive = util.now();
    this.createJob();
  }

  async close() {
    let conn, next;

    for (conn = this.inbound.head; conn; conn = next) {
      next = conn.next;
      conn.destroy();
    }

    await this.server.close();
    await this.userdb.close();
    await this.sharedb.close();
  }

  notify(conn, msg, sid) {
    setTimeout(async() => {
      if (conn.destroyed)
        return;

      conn.sendResponse(msg, [
        [
          ['mining.notify', sid]
        ],
        sid,
        NONCE_SIZE
      ]);

      this.notify(conn, msg, sid);
    }, Stratum.NOTIFY_INTERVAL * 1000);
  }

  async notifyAll(cleanJob) {
    const job = await this.getJob();
    let conn;

    this.logger.debug('Notifying all clients of new job: %s.', job.id);

    for (conn = this.inbound.head; conn; conn = conn.next) {
      if (conn.sid === -1)
        continue;

      conn.sendJob(job, cleanJob);
    }
  }

  createBlock() {
    if (this.node.miner.addresses.length === 0)
      throw new Error('No addresses available for coinbase.');

    return this.node.miner.createBlock();
  }

  addJob(job) {
    if (this.jobs.size >= Stratum.MAX_JOBS)
      this.removeJob(this.jobs.head);

    assert(this.jobs.push(job));

    assert(!this.jobMap.has(job.id));
    this.jobMap.set(job.id, job);

    this.current = job;
  }

  createJob() {
    const now = util.now();

    setTimeout(async() => {
      if (now >= this.lastActive + Stratum.JOB_TIMEOUT) {
        this.current = null;
        this.lastActive = now;

        await this.notifyAll(false);
      }

      this.createJob();
    }, Stratum.JOB_TIMEOUT * 1000);
  }

  removeJob(job) {
    assert(this.jobs.remove(job));

    assert(this.jobMap.has(job.id));
    this.jobMap.delete(job.id);

    if (job === this.current)
      this.current = null;
  }

  async getJob() {
    if (!this.current) {
      const attempt = await this.createBlock();
      const job = Job.fromTemplate(this.jid(), attempt);

      this.addJob(job);

      this.logger.debug(
        'New job (id=%s, prev=%s).',
        job.id, util.revHex(job.attempt.prevBlock));
    }

    return this.current;
  }

  async tryCommit(entry, block) {
    try {
      await this.sharedb.commit(entry, block);
    } catch (e) {
      this.emit('error', e);
    }
  }

  auth(username, password) {
    const user = this.userdb.get(username);

    if (!user)
      return false;

    const passwd = Buffer.from(password, 'utf8');
    const hash = hash256(passwd);

    if (!ccmp(hash, user.password))
      return false;

    return true;
  }

  authAdmin(password) {
    if (!this.options.password)
      return false;

    const data = Buffer.from(password, 'utf8');
    const hash = hash256(data);

    if (!ccmp(hash, this.options.password))
      return false;

    return true;
  }

  async addBlock(conn, block) {
    // Broadcast immediately.
    this.node.broadcast(block);

    let entry;
    try {
      entry = await this.chain.add(block);
    } catch (e) {
      if (e.type === 'VerifyError') {
        switch (e.reason) {
          case 'high-hash':
            return new StratumError(23, 'high-hash');
          case 'duplicate':
            return new StratumError(22, 'duplicate');
        }
        return new StratumError(20, e.reason);
      }
      throw e;
    }

    if (!entry)
      return new StratumError(21, 'stale-prevblk');

    if (entry.hash !== this.chain.tip.hash)
      return new StratumError(21, 'stale-work');

    this.tryCommit(entry, block);

    this.logger.info('Client found block %s (%d) (%s).',
      entry.rhash(),
      entry.height,
      conn.id());

    return null;
  }

  async handlePacket(conn, msg) {
    const unlock = await this.locker.lock();
    try {
      return await this._handlePacket(conn, msg);
    } finally {
      unlock();
    }
  }

  async _handlePacket(conn, msg) {
    switch (msg.method) {
      case 'mining.authorize':
        return this.handleAuthorize(conn, msg);
      case 'mining.subscribe':
        return this.handleSubscribe(conn, msg);
      case 'mining.extranonce.subscribe':
        return this.handleExtranonceSubscribe(conn, msg);
      case 'mining.submit':
        return this.handleSubmit(conn, msg);
      case 'mining.get_transactions':
        return this.handleTransactions(conn, msg);
      case 'mining.authorize_admin':
        return this.handleAuthAdmin(conn, msg);
      case 'mining.add_user':
        return this.handleAddUser(conn, msg);
      default:
        return this.handleUnknown(conn, msg);
    }
  }

  async handleAuthorize(conn, msg) {
    if (typeof msg.params.length < 2) {
      conn.sendError(msg, 0, 'invalid params');
      return;
    }

    const user = msg.params[0];
    const pass = msg.params[1];

    if (!isUsername(user) || !isPassword(pass)) {
      conn.sendError(msg, 0, 'invalid params');
      return;
    }

    if (!this.auth(user, pass)) {
      this.logger.debug(
        'Client failed auth for user %s (%s).',
        user, conn.id());
      conn.sendResponse(msg, false);
      return;
    }

    this.logger.debug(
      'Client successfully authd for %s (%s).',
      user, conn.id());

    conn.addUser(user);
    conn.sendResponse(msg, true);
  }

  async handleSubscribe(conn, msg) {
    if (!this.chain.synced) {
      conn.sendError(msg, 0, 'not up to date');
      return;
    }

    if (!conn.agent && msg.params.length > 0) {
      if (!isAgent(msg.params[0])) {
        conn.sendError(msg, 0, 'invalid params');
        return;
      }
      conn.agent = msg.params[0];
    }

    if (msg.params.length > 1) {
      if (!isSID(msg.params[1])) {
        conn.sendError(msg, 0, 'invalid params');
        return;
      }
      conn.sid = this.sid();
    } else {
      conn.sid = this.sid();
    }

    if (!this.subscribed) {
      this.logger.debug('First subscriber (%s).', conn.id());
      this.subscribed = true;
    }

    const sid = hex32(conn.sid);
    const job = await this.getJob();

    this.logger.debug(
      'Client is subscribing with sid=%s (%s).',
      sid, conn.id());

    conn.sendResponse(msg, [
      [
        ['mining.notify', sid],
        ['mining.set_difficulty', sid]
      ],
      sid,
      NONCE_SIZE
    ]);

    conn.setDifficulty(this.difficulty);
    conn.sendJob(job, false);

    this.notify(conn, msg, sid);
  }

  async handleExtranonceSubscribe(conn, msg) {
    conn.sendError(msg, 20, 'Not supported.');
  }

  async handleSubmit(conn, msg) {
    const now = this.network.now();

    let subm;
    try {
      subm = Submission.fromPacket(msg);
    } catch (e) {
      conn.sendError(msg, 0, 'invalid params');
      return;
    }

    this.logger.spam(
      'Client submitted job %s (%s).',
      subm.job, conn.id());

    if (!conn.hasUser(subm.username)) {
      conn.sendError(msg, 24, 'unauthorized user');
      return;
    }

    if (conn.sid === -1) {
      conn.sendError(msg, 25, 'not subscribed');
      return;
    }

    const job = this.jobMap.get(subm.job);

    if (!job || job.committed) {
      conn.sendError(msg, 21, 'job not found');
      return;
    }

    if (job !== this.current) {
      this.logger.warning(
        'Client is submitting a stale job %s (%s).',
        job.id, conn.id());
    }

    // Non-consensus sanity check.
    // 2 hours should be less than MTP in 99% of cases.
    if (subm.time < now - 7200) {
      conn.sendError(msg, 20, 'time too old');
      return;
    }

    if (subm.time > now + 7200) {
      conn.sendError(msg, 20, 'time too new');
      return;
    }

    const share = job.check(conn.sid, subm);
    const difficulty = share.getDifficulty();

    if (difficulty < conn.difficulty - 1) {
      this.logger.debug(
        'Client submitted a low share of %d, hash=%s, ban=%d (%s).',
        difficulty, share.rhash(), conn.banScore, conn.id());

      conn.increaseBan(1);
      conn.sendError(msg, 23, 'high-hash');
      conn.sendDifficulty(conn.difficulty);

      return;
    }

    if (!job.insert(share.hash)) {
      this.logger.debug(
        'Client submitted a duplicate share: %s (%s).',
        share.rhash(), conn.id());
      conn.increaseBan(10);
      conn.sendError(msg, 22, 'duplicate');
      return;
    }

    this.sharedb.add(subm.username, difficulty);

    this.logger.debug(
      'Client submitted share of %d, hash=%s (%s).',
      difficulty, share.rhash(), conn.id());

    let error;
    if (share.verify(job.target)) {
      const block = job.commit(share);
      error = await this.addBlock(conn, block);
    }

    if (error) {
      this.logger.warning(
        'Client found an invalid block: %s (%s).',
        error.reason, conn.id());
      conn.sendError(msg, error.code, error.reason);
    } else {
      conn.sendResponse(msg, true);
    }

    if (this.options.dynamic) {
      if (conn.retarget(job.difficulty)) {
        this.logger.debug(
          'Retargeted client to %d (%s).',
          conn.nextDifficulty, conn.id());
      }
    }
  }

  async handleTransactions(conn, msg) {
    if (conn.sid === -1) {
      conn.sendError(msg, 25, 'not subscribed');
      return;
    }

    if (msg.params.length < 1) {
      conn.sendError(msg, 21, 'job not found');
      return;
    }

    const id = msg.params[0];

    if (!isJob(id)) {
      conn.sendError(msg, 21, 'job not found');
      return;
    }

    const job = this.jobMap.get(id);

    if (!job || job.committed) {
      conn.sendError(msg, 21, 'job not found');
      return;
    }

    this.logger.debug(
      'Sending tx list (%s).',
      conn.id());

    const attempt = job.attempt;
    const result = [];

    for (const item of attempt.items)
      result.push(item.tx.hash('hex'));

    conn.sendResponse(msg, result);
  }

  async handleAuthAdmin(conn, msg) {
    if (typeof msg.params.length < 1) {
      conn.sendError(msg, 0, 'invalid params');
      return;
    }

    const password = msg.params[0];

    if (!isPassword(password)) {
      conn.sendError(msg, 0, 'invalid params');
      return;
    }

    if (!this.authAdmin(password)) {
      this.logger.debug(
        'Client sent bad admin password (%s).',
        conn.id());
      conn.increaseBan(10);
      conn.sendError(msg, 0, 'invalid password');
      return;
    }

    conn.admin = true;
    conn.sendResponse(msg, true);
  }

  async handleAddUser(conn, msg) {
    if (typeof msg.params.length < 3) {
      conn.sendError(msg, 0, 'invalid params');
      return;
    }

    const user = msg.params[0];
    const pass = msg.params[1];

    if (!isUsername(user) || !isPassword(pass)) {
      conn.sendError(msg, 0, 'invalid params');
      return;
    }

    if (!conn.admin) {
      this.logger.debug(
        'Client is not an admin (%s).',
        conn.id());
      conn.sendError(msg, 0, 'invalid password');
      return;
    }

    try {
      this.userdb.add({
        username: user,
        password: pass
      });
    } catch (e) {
      conn.sendError(msg, 0, e.message);
      return;
    }

    conn.sendResponse(msg, true);
  }

  async handleUnknown(conn, msg) {
    this.logger.debug(
      'Client sent an unknown message (%s):',
      conn.id());

    this.logger.debug(msg);

    conn.send({
      id: msg.id,
      result: null,
      error: true
    });
  }
}

Stratum.id = 'stratum';

Stratum.ACTIVE_TIME = 60;
Stratum.MAX_JOBS = 6;
Stratum.SHARES_PER_MINUTE = 8;
Stratum.BAN_SCORE = 1000;
Stratum.BAN_TIME = 10 * 60;
Stratum.NOTIFY_INTERVAL = 60;
Stratum.JOB_TIMEOUT = 1 * 60 * 60;

/**
 * Stratum Options
 */

class StratumOptions {
  /**
   * Create stratum options.
   * @constructor
   * @param {Object} options
   */

  constructor(options) {
    this.node = null;
    this.chain = null;
    this.logger = Logger.global;
    this.network = Network.primary;
    this.host = '0.0.0.0';
    this.port = 6880;
    this.publicHost = '127.0.0.1';
    this.publicPort = 6880;
    this.maxInbound = 50;
    this.difficulty = 1;
    this.dynamic = true;
    this.prefix = path.resolve(os.homedir(), '.wmcc', 'stratum');
    this.password = null;
    this.notify = 60;

    this.fromOptions(options);
  }

  fromOptions(options) {
    assert(options, 'Options are required.');
    assert(options.node && typeof options.node === 'object',
      'Node is required.');

    this.node = options.node;
    this.chain = this.node.chain;
    this.network = this.node.network;
    this.logger = this.node.logger;
    this.prefix = this.node.location('stratum');

    if (options.host != null) {
      assert(typeof options.host === 'string');
      this.host = options.host;
    }

    if (options.port != null) {
      assert(typeof options.port === 'number');
      this.port = options.port;
    }

    if (options.publicHost != null) {
      assert(typeof options.publicHost === 'string');
      this.publicHost = options.publicHost;
    }

    if (options.publicPort != null) {
      assert(typeof options.publicPort === 'number');
      this.publicPort = options.publicPort;
    }

    if (options.maxInbound != null) {
      assert(typeof options.maxInbound === 'number');
      this.maxInbound = options.maxInbound;
    }

    if (options.difficulty != null) {
      assert(typeof options.difficulty === 'number');
      this.difficulty = options.difficulty;
    }

    if (options.dynamic != null) {
      assert(typeof options.dynamic === 'boolean');
      this.dynamic = options.dynamic;
    }

    if (options.password != null) {
      assert(isPassword(options.password));
      this.password = hash256(Buffer.from(options.password, 'utf8'));
    }

    if (options.notify != null) {
      assert(typeof options.notify === 'number');
      this.notify = options.notify;
    }

    return this;
  }

  static fromOptions(options) {
    return new this().fromOptions(options);
  }
}

/**
 * Stratum Connection
 */

class Connection extends EventEmitter {
  /**
   * Create a stratum connection.
   * @constructor
   * @param {Stratum} stratum
   * @param {net.Socket} socket
   */

  constructor(stratum, socket) {
    super();

    this.locker = new Lock();
    this.stratum = stratum;
    this.logger = stratum.logger;
    this.socket = socket;
    this.host = IP.normalize(socket.remoteAddress);
    this.port = socket.remotePort;
    this.hostname = IP.toHostname(this.host, this.port);
    this.decoder = new StringDecoder('utf8');
    this.agent = '';
    this.recv = '';
    this.admin = false;
    this.users = new Set();
    this.sid = -1;
    this.difficulty = -1;
    this.nextDifficulty = -1;
    this.banScore = 0;
    this.lastBan = 0;
    this.drainSize = 0;
    this.destroyed = false;
    this.lastRetarget = -1;
    this.submissions = 0;
    this.prev = null;
    this.next = null;
    this.job = null;

    this._init();
  }

  _init() {
    this.on('packet', async (msg) => {
      try {
        await this.readPacket(msg);
      } catch (e) {
        this.error(e);
      }
    });

    this.socket.on('data', (data) => {
      this.feed(data);
    });

    this.socket.on('error', (err) => {
      this.emit('error', err);
    });

    this.socket.on('close', () => {
      //this.error('Socket hangup.');
      this.logger.debug('Client (%s) socket hangup.', this.id());
      this.destroy();
    });

    this.socket.on('drain', () => {
      this.drainSize = 0;
    });

    //this.sendNotify();
  }

  destroy() {
    if (this.destroyed)
      return;

    this.destroyed = true;

    this.locker.destroy();
    this.socket.destroy();
    this.socket = null;

    this.emit('close');
  }

  send(json) {
    if (this.destroyed)
      return;

    json = JSON.stringify(json);
    json += '\n';

    this.write(json);
  }

  write(text) {
    if (this.destroyed)
      return;

    if (this.socket.write(text, 'utf8') === false) {
      this.drainSize += Buffer.byteLength(text, 'utf8');
      if (this.drainSize > (5 << 20)) {
        this.logger.warning(
          'Client is not reading (%s).',
          this.id());
        this.destroy();
      }
    }
  }

  error(err) {
    if (this.destroyed)
      return;

    if (err instanceof Error) {
      err.message += ` (${this.id()})`;
      this.emit('error', err);
      return;
    }

    let msg = format.apply(null, arguments);

    msg += ` (${this.id()})`;

    this.emit('error', new Error(msg));
  }

  redirect() {
    const host = this.stratum.options.publicHost;
    const port = this.stratum.options.publicPort;

    const res = [
      'HTTP/1.1 200 OK',
      `X-Stratum: stratum+tcp://${host}:${port}`,
      'Connection: Close',
      'Content-Type: application/json; charset=utf-8',
      'Content-Length: 38',
      '',
      '',
      '{"error":null,"result":false,"id":0}'
    ];

    this.write(res.join('\r\n'));

    this.logger.debug('Redirecting client (%s).', this.id());

    this.destroy();
  }

  feed(data) {
    this.recv += this.decoder.write(data);

    if (this.recv.length >= 100000) {
      this.error('Too much data buffered (%s).', this.id());
      this.destroy();
      return;
    }

    if (/HTTP\/1\.1/i.test(this.recv)) {
      this.redirect();
      return;
    }

    const lines = this.recv.replace(/\r+/g, '').split(/\n+/);

    this.recv = lines.pop();

    for (const line of lines) {
      if (line.length === 0)
        continue;

      let msg;
      try {
        msg = ClientPacket.fromRaw(line);
      } catch (e) {
        this.error(e);
        continue;
      }

      this.emit('packet', msg);
    }
  }

  async readPacket(msg) {
    const unlock = await this.locker.lock();
    try {
      this.socket.pause();
      await this.handlePacket(msg);
    } finally {
      if (!this.destroyed)
        this.socket.resume();
      unlock();
    }
  }

  async handlePacket(msg) {
    return await this.stratum.handlePacket(this, msg);
  }

  addUser(username) {
    if (this.users.has(username))
      return false;

    this.users.add(username);

    return true;
  }

  hasUser(username) {
    return this.users.has(username);
  }

  increaseBan(score) {
    const now = Date.now();

    this.banScore *= Math.pow(1 - 1 / 60000, now - this.lastBan);
    this.banScore += score;
    this.lastBan = now;

    if (this.banScore >= Stratum.BAN_SCORE) {
      this.logger.debug(
        'Ban score exceeds threshold %d (%s).',
        this.banScore, this.id());
      this.ban();
    }
  }

  ban() {
    this.emit('ban');
  }

  sendError(msg, code, reason) {
    this.logger.spam(
      'Sending error %s (%s).',
      reason, this.id());

    this.send({
      id: msg.id,
      result: null,
      error: [code, reason, false]
    });
  }

  sendResponse(msg, result) {
    this.logger.spam(
      'Sending response %s (%s).',
      msg.id, this.id());

    this.send({
      id: msg.id,
      result: result,
      error: null
    });
  }

  sendMethod(method, params) {
    this.logger.spam(
      'Sending method %s (%s).',
      method, this.id());

    this.send({
      id: null,
      method: method,
      params: params
    });
  }

  sendDifficulty(difficulty) {
    assert(difficulty > 0, 'Difficulty must be at least 1.');

    this.logger.debug(
      'Setting difficulty=%d for client (%s).',
      difficulty, this.id());

    this.sendMethod('mining.set_difficulty', [difficulty]);
  }

  setDifficulty(difficulty) {
    this.nextDifficulty = difficulty;
  }

  sendJob(job, cleanJob) {
    if (!this.job)
      this.job = job;

    this.logger.debug(
      'Sending job %s to client (%s).',
      job.id, this.id());

    if (this.nextDifficulty !== -1) {
      this.submissions = 0;
      this.lastRetarget = Date.now();
      this.sendDifficulty(this.nextDifficulty);
      this.difficulty = this.nextDifficulty;
      this.nextDifficulty = -1;
    }

    this.sendMethod('mining.notify', job.toJSON(cleanJob));
  }

  sendNotify() {
    if (!this.stratum.options.notify)
      return;

    const interval = setInterval(()=>{
      if (this.job) {
        try {
          this.sendJob(this.job);
        } catch (e) {
          clearInterval(interval);
        }
      }
    }, this.stratum.options.notify * 1000);
  }

  retarget(max) {
    const now = Date.now();
    const pm = Stratum.SHARES_PER_MINUTE;

    assert(this.difficulty > 0);
    assert(this.lastRetarget !== -1);

    this.submissions += 1;

    if (this.submissions % pm === 0) {
      const target = (this.submissions / pm) * 60000;
      let actual = now - this.lastRetarget;
      let difficulty = 0x100000000 / this.difficulty;

      if (max > (-1 >>> 0))
        max = -1 >>> 0;

      if (Math.abs(target - actual) <= 5000)
        return false;

      if (actual < target / 4)
        actual = target / 4;

      if (actual > target * 4)
        actual = target * 4;

      difficulty *= actual;
      difficulty /= target;
      difficulty = 0x100000000 / difficulty;
      difficulty >>>= 0;
      difficulty = Math.min(max, difficulty);
      difficulty = Math.max(1, difficulty);

      this.setDifficulty(difficulty);

      return true;
    }

    return false;
  }

  id() {
    let id = this.host;

    if (this.agent)
      id += '/' + this.agent;

    return id;
  }
}

/**
 * User
 */

class User {
  /**
   * Create a user.
   * @constructor
   * @param {Object} options
   */

  constructor(options) {
    this.username = '';
    this.password = consensus.ZERO_HASH;

    if (options)
      this.fromOptions(options);
  }

  fromOptions(options) {
    assert(options, 'Options required.');
    assert(isUsername(options.username), 'Username required.');
    assert(options.hash || options.password, 'Password required.');

    this.setUsername(options.username);

    if (options.hash != null)
      this.setHash(options.hash);

    if (options.password != null)
      this.setPassword(options.password);

    return this;
  }

  static fromOptions(options) {
    return new this().fromOptions(options);
  }

  setUsername(username) {
    assert(isUsername(username), 'Username must be a string.');
    this.username = username;
  }

  setHash(hash) {
    if (typeof hash === 'string') {
      assert(isHex(hash), 'Hash must be a hex string.');
      assert(hash.length === 64, 'Hash must be 32 bytes.');
      //this.password = Buffer.from(hash, 'hex');
      return Buffer.from(hash, 'hex');
    } else {
      assert(Buffer.isBuffer(hash), 'Hash must be a buffer.');
      assert(hash.length === 32, 'Hash must be 32 bytes.');
      //this.password = hash;
      return hash;
    }
  }

  setPassword(password) {
    assert(isPassword(password), 'Password must be a string.');
    password = Buffer.from(password, 'utf8');
    this.password = hash256(password);
  }

  toJSON() {
    return {
      username: this.username,
      password: this.password.toString('hex')
    };
  }

  fromJSON(json) {
    assert(json);
    assert(typeof json.username === 'string');
    this.username = json.username;
    this.password = this.setHash(json.password);//Buffer.from(json.password, 'hex'); //
    return this;
  }

  static fromJSON(json) {
    return new this().fromJSON(json);
  }
}

/**
 * ClientPacket
 */

class ClientPacket {
  /**
   * Create a packet.
   */

  constructor() {
    this.id = null;
    this.method = 'unknown';
    this.params = [];
  }

  static fromRaw(json) {
    const packet = new ClientPacket();
    const msg = JSON.parse(json);

    if (msg.id != null) {
      assert(typeof msg.id === 'string'
        || typeof msg.id === 'number');
      packet.id = msg.id;
    }

    assert(typeof msg.method === 'string');
    assert(msg.method.length <= 50);
    packet.method = msg.method;

    if (msg.params) {
      assert(Array.isArray(msg.params));
      packet.params = msg.params;
    }

    return packet;
  }
}

/**
 * Submission Packet
 */

class Submission {
  /**
   * Create a submission packet.
   */

  constructor() {
    this.username = '';
    this.job = '';
    this.nonce2 = 0;
    this.time = 0;
    this.nonce = 0;
  }

  static fromPacket(msg) {
    const subm = new Submission();

    assert(msg.params.length >= 5, 'Invalid parameters.');

    assert(isUsername(msg.params[0]), 'Name must be a string.');
    assert(isJob(msg.params[1]), 'Job ID must be a string.');

    assert(typeof msg.params[2] === 'string', 'Nonce2 must be a string.');
    assert(msg.params[2].length === NONCE_SIZE * 2, 'Nonce2 must be a string.');
    assert(isHex(msg.params[2]), 'Nonce2 must be a string.');

    assert(typeof msg.params[3] === 'string', 'Time must be a string.');
    assert(msg.params[3].length === 8, 'Time must be a string.');
    assert(isHex(msg.params[3]), 'Time must be a string.');

    assert(typeof msg.params[4] === 'string', 'Nonce must be a string.');
    assert(msg.params[4].length === 8, 'Nonce must be a string.');
    assert(isHex(msg.params[4]), 'Nonce must be a string.');

    subm.username = msg.params[0];
    subm.job = msg.params[1];
    subm.nonce2 = parseInt(msg.params[2], 16);
    subm.time = parseInt(msg.params[3], 16);
    subm.nonce = parseInt(msg.params[4], 16);

    return subm;
  }
}

/**
 * Job
 */

class Job {
  /**
   * Create a job.
   * @constructor
   */

  constructor(id) {
    assert(typeof id === 'string');

    this.id = id;
    this.attempt = null;
    this.target = consensus.ZERO_HASH;
    this.difficulty = 0;
    this.submissions = {};
    this.committed = false;
    this.prev = null;
    this.next = null;
  }

  fromTemplate(attempt) {
    this.attempt = attempt;
    this.attempt.refresh();
    this.target = attempt.target;
    this.difficulty = attempt.getDifficulty();
    return this;
  }

  static fromTemplate(id, attempt) {
    return new this(id).fromTemplate(attempt);
  }

  insert(hash) {
    hash = hash.toString('hex');

    if (this.submissions[hash])
      return false;

    this.submissions[hash] = true;

    return true;
  }

  check(nonce1, subm) {
    const nonce2 = subm.nonce2;
    const ts = subm.time;
    const nonce = subm.nonce;
    return this.attempt.getProof(nonce1, nonce2, ts, nonce);
  }

  commit(share) {
    assert(!this.committed, 'Already committed.');
    this.committed = true;
    return this.attempt.commit(share);
  }

  /*
   * @param {Boolean} cleanJob - Previous work should be aborted cleanJob is true
   */
  toJSON(cleanJob) {
    assert(typeof cleanJob === 'boolean');
    return [
      this.id,
      common.swap32hex(this.attempt.prevBlock),
      this.attempt.left.toString('hex'),
      this.attempt.right.toString('hex'),
      this.attempt.tree.toJSON(),
      hex32(this.attempt.version),
      hex32(this.attempt.bits),
      hex32(Math.max(this.attempt.time, this.attempt.mtp + 1)),
      cleanJob
    ];
  }
}

/**
 * Stratum Error
 */

class StratumError {
  /**
   * Create a stratum error.
   * @constructor
   * @param {Number} code
   * @param {String} reason
   */

  constructor(code, reason) {
    this.code = code;
    this.reason = reason;
  }
}

/**
 * Share DB
 */

class ShareDB {
  /**
   * Create a Share DB
   * @constructor
   * @param {Object} options
   */

  constructor(options) {
    this.network = options.network;
    this.logger = options.logger;
    this.location = path.resolve(options.prefix, 'shares');

    this.map = Object.create(null);
    this.total = 0;
    this.size = 0;
  }

  async open() {
    await fs.mkdirp(this.location);
  }

  async close() {
    ;
  }

  file(entry) {
    const name = entry.height + '-' + entry.rhash();
    return path.resolve(this.location, name + '.json');
  }

  add(username, difficulty) {
    if (!this.map[username]) {
      this.map[username] = 0;
      this.size++;
    }

    this.map[username] += difficulty;
    this.total += difficulty;
  }

  clear() {
    this.map = Object.create(null);
    this.size = 0;
    this.total = 0;
  }

  async commit(entry, block) {
    const cb = block.txs[0];
    const addr = cb.outputs[0].getAddress();

    assert(addr);

    const data = {
      network: this.network.type,
      height: entry.height,
      block: block.rhash(),
      ts: block.time,
      time: util.now(),
      txid: cb.txid(),
      address: addr.toBase58(this.network),
      reward: cb.getOutputValue(),
      size: this.size,
      total: this.total,
      shares: this.map
    };

    this.clear();

    const file = this.file(entry);
    const json = JSON.stringify(data, null, 2);

    this.logger.info(
      'Committing %d payouts to disk for block %d (file=%s).',
      data.size, entry.height, file);

    await fs.writeFile(file, json);
  }
}

/**
 * User DB
 */

class UserDB {
  /**
   * Create a user DB.
   * @constructor
   * @param {Object} options
   */

  constructor(options) {
    this.network = options.network;
    this.logger = options.logger;
    this.location = path.resolve(options.prefix, 'users.json');
    this.locker = new Lock();
    this.lastFail = 0;
    this.stream = null;

    this.map = new Map();
    this.size = 0;
  }

  async open() {
    const unlock = await this.locker.lock();
    try {
      return await this._open();
    } finally {
      unlock();
    }
  }

  async _open() {
    await this.load();
  }

  async close() {
    const unlock = await this.locker.lock();
    try {
      return await this._close();
    } finally {
      unlock();
    }
  }

  async _close() {
    if (!this.stream)
      return;

    try {
      this.stream.close();
    } catch (e) {
      ;
    }

    this.stream = null;
  }

  load() {
    return new Promise((resolve, reject) => {
      this._load(resolve, reject);
    });
  }

  _load(resolve, reject) {
    let buf = '';
    let lineno = 0;

    let stream = fs.createReadStream(this.location, {
      flags: 'r',
      encoding: 'utf8',
      autoClose: true
    });

    const close = () => {
      if (!stream)
        return;

      try {
        stream.close();
      } catch (e) {
        ;
      }

      stream = null;
    };

    stream.on('error', (err) => {
      if (!stream)
        return;

      if (err.code === 'ENOENT') {
        close();
        resolve();
        return;
      }

      close();
      reject(err);
    });

    stream.on('data', (data) => {
      if (!stream)
        return;

      buf += data;

      if (buf.length >= 10000) {
        close();
        reject(new Error(`UserDB parse error. Line: ${lineno}.`));
        return;
      }

      const lines = buf.split(/\n+/);

      buf = lines.pop();

      for (const line of lines) {
        lineno += 1;

        if (line.length === 0)
          continue;

        let json, user;
        try {
          json = JSON.parse(line);
          user = User.fromJSON(json);
        } catch (e) {
          close();
          reject(new Error(`UserDB parse error. Line: ${lineno}.`));
          return;
        }

        if (!this.map.has(user.username))
          this.size += 1;

        this.map.set(user.username, user);
      }
    });

    stream.on('end', () => {
      if (!stream)
        return;

      this.logger.debug(
        'Loaded %d users into memory.',
        this.size);

      stream = null;
      resolve();
    });
  }

  get(username) {
    return this.map.get(username);
  }

  has(username) {
    return this.map.has(username);
  }

  add(options) {
    const user = new User(options);

    assert(!this.map.has(user.username), 'User already exists.');

    this.logger.debug(
      'Adding new user (%s).',
      user.username);

    this.map.set(user.username, user);
    this.size += 1;

    this.write(user.toJSON());
  }

  remove(username) {
    assert(this.map.has(username), 'User not exists.');

    this.logger.debug(
      'Removing user (%s).',
      username);

    this.map.delete(username);
    this.size -= 1;

    this.delete(username);
  }

  setPassword(username, password) {
    const user = this.map.get(username);
    assert(user, 'User does not exist.');
    user.setPassword(password);
    this.write(user.toJSON());
  }

  write(data) {
    const stream = this.getStream();

    if (!stream)
      return;

    const json = JSON.stringify(data) + '\n';
    stream.write(json, 'utf8');
  }

  delete(username) {
    const data = fs.readFileSync(this.location);
    let lines = data.toString().split('\n');
    lines = lines.filter(w => !w.includes(`"${username}"`));
    let joined = lines.join('\n');

    fs.writeFileSync(this.location, joined);
  }

  getStream() {
    if (this.stream)
      return this.stream;

    if (this.lastFail > util.now() - 10)
      return null;

    this.lastFail = 0;

    this.stream = fs.createWriteStream(this.location, { flags: 'a' });

    this.stream.on('error', (err) => {
      this.logger.warning('UserDB file stream died!');
      this.logger.error(err);

      try {
        this.stream.close();
      } catch (e) {
        ;
      }

      // Retry in ten seconds.
      this.stream = null;
      this.lastFail = util.now();
    });

    return this.stream;
  }
}

/*
 * Helpers
 */

function isJob(id) {
  if (typeof id !== 'string')
    return false;

  return id.length >= 12 && id.length <= 21;
}

function isSID(sid) {
  if (typeof sid !== 'string')
    return false;

  return sid.length === 8 && isHex(sid);
}

function isUsername(username) {
  if (typeof username !== 'string')
    return false;

  return username.length > 0 && username.length <= 100;
}

function isPassword(password) {
  if (typeof password !== 'string')
    return false;

  return password.length > 0 && password.length <= 255;
}

function isAgent(agent) {
  if (typeof agent !== 'string')
    return false;

  return agent.length > 0 && agent.length <= 255;
}

function isHex(str) {
  return typeof str === 'string'
    && str.length % 2 === 0
    && /^[0-9A-Fa-f]+$/.test(str);
}

function hex32(num) {
  assert((num >>> 0) === num);
  num = num.toString(16);
  switch (num.length) {
    case 1:
      return `0000000${num}`;
    case 2:
      return `000000${num}`;
    case 3:
      return `00000${num}`;
    case 4:
      return `0000${num}`;
    case 5:
      return `000${num}`;
    case 6:
      return `00${num}`;
    case 7:
      return `0${num}`;
    case 8:
      return `${num}`;
    default:
      throw new Error();
  }
}

/*
 * Expose
 */

module.exports = Stratum;


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * client.js - http client for wallets.
 */



const IOClient = __webpack_require__(217);
const Network = __webpack_require__(6);
const AsyncObject = __webpack_require__(31);
const TX = __webpack_require__(16);
const {BlockMeta} = __webpack_require__(129);
const Headers = __webpack_require__(37);
const util = __webpack_require__(1);
const BufferReader = __webpack_require__(2);

/**
 * WMCC HTTP client.
 * @alias module:wallet.WalletClient
 * @constructor
 * @param {Object|String} options
 */

function WalletClient(options) {
  if (!(this instanceof WalletClient))
    return new WalletClient(options);

  if (!options)
    options = {};

  if (typeof options === 'string')
    options = { uri: options };

  AsyncObject.call(this);

  this.options = options;
  this.network = Network.get(options.network);

  this.uri = options.uri || `http://localhost:${this.network.rpcPort}`;
  this.apiKey = options.apiKey;

  this.socket = null;
}

Object.setPrototypeOf(WalletClient.prototype, AsyncObject.prototype);

/**
 * Open the client, wait for socket to connect.
 * @alias WalletClient#open
 * @returns {Promise}
 */

WalletClient.prototype._open = async function _open() {
  this.socket = new IOClient(this.uri, {
    transports: ['websocket'],
    forceNew: true
  });

  this.socket.on('error', (err) => {
    this.emit('error', err);
  });

  this.socket.on('version', (info) => {
    if (info.network !== this.network.type)
      this.emit('error', new Error('Wrong network.'));
  });

  this.socket.on('block connect', (entry, txs) => {
    let block;

    try {
      block = parseBlock(entry, txs);
    } catch (e) {
      this.emit('error', e);
      return;
    }

    this.emit('block connect', block.entry, block.txs);
  });

  this.socket.on('block disconnect', (entry) => {
    let block;

    try {
      block = parseEntry(entry);
    } catch (e) {
      this.emit('error', e);
      return;
    }

    this.emit('block disconnect', block);
  });

  this.socket.on('block rescan', (entry, txs, cb) => {
    let block;

    try {
      block = parseBlock(entry, txs);
    } catch (e) {
      this.emit('error', e);
      cb();
      return;
    }

    this.fire('block rescan', block.entry, block.txs).then(cb, cb);
  });

  this.socket.on('chain reset', (tip) => {
    let block;

    try {
      block = parseEntry(tip);
    } catch (e) {
      this.emit('error', e);
      return;
    }

    this.emit('chain reset', block);
  });

  this.socket.on('tx', (tx) => {
    try {
      tx = parseTX(tx);
    } catch (e) {
      this.emit('error', e);
      return;
    }
    this.emit('tx', tx);
  });

  await this.onConnect();
  await this.sendAuth();
  await this.watchChain();
  await this.watchMempool();
};

/**
 * Close the client, wait for the socket to close.
 * @alias WalletClient#close
 * @returns {Promise}
 */

WalletClient.prototype._close = function _close() {
  if (!this.socket)
    return Promise.resolve();

  this.socket.disconnect();
  this.socket = null;

  return Promise.resolve();
};

/**
 * Wait for websocket connection.
 * @private
 * @returns {Promise}
 */

WalletClient.prototype.onConnect = function onConnect() {
  return new Promise((resolve, reject) => {
    this.socket.once('connect', resolve);
  });
};

/**
 * Wait for websocket auth.
 * @private
 * @returns {Promise}
 */

WalletClient.prototype.sendAuth = function sendAuth() {
  return new Promise((resolve, reject) => {
    this.socket.emit('auth', this.apiKey, wrap(resolve, reject));
  });
};

/**
 * Watch the blockchain.
 * @private
 * @returns {Promise}
 */

WalletClient.prototype.watchChain = function watchChain() {
  return new Promise((resolve, reject) => {
    this.socket.emit('watch chain', wrap(resolve, reject));
  });
};

/**
 * Watch the blockchain.
 * @private
 * @returns {Promise}
 */

WalletClient.prototype.watchMempool = function watchMempool() {
  return new Promise((resolve, reject) => {
    this.socket.emit('watch mempool', wrap(resolve, reject));
  });
};

/**
 * Get chain tip.
 * @returns {Promise}
 */

WalletClient.prototype.getTip = function getTip() {
  return new Promise((resolve, reject) => {
    this.socket.emit('get tip', wrap(resolve, reject, parseEntry));
  });
};

/**
 * Get chain entry.
 * @param {Hash} hash
 * @returns {Promise}
 */

WalletClient.prototype.getEntry = function getEntry(block) {
  return new Promise((resolve, reject) => {
    if (typeof block === 'string')
      block = util.revHex(block);

    this.socket.emit('get entry', block, wrap(resolve, reject, parseEntry));
  });
};

/**
 * Send a transaction. Do not wait for promise.
 * @param {TX} tx
 * @returns {Promise}
 */

WalletClient.prototype.send = function send(tx) {
  return new Promise((resolve, reject) => {
    this.socket.emit('send', tx.toRaw(), wrap(resolve, reject));
  });
};

/**
 * Set bloom filter.
 * @param {Bloom} filter
 * @returns {Promise}
 */

WalletClient.prototype.setFilter = function setFilter(filter) {
  return new Promise((resolve, reject) => {
    this.socket.emit('set filter', filter.toRaw(), wrap(resolve, reject));
  });
};

/**
 * Add data to filter.
 * @param {Buffer} data
 * @returns {Promise}
 */

WalletClient.prototype.addFilter = function addFilter(chunks) {
  if (!Array.isArray(chunks))
    chunks = [chunks];

  return new Promise((resolve, reject) => {
    this.socket.emit('add filter', chunks, wrap(resolve, reject));
  });
};

/**
 * Reset filter.
 * @returns {Promise}
 */

WalletClient.prototype.resetFilter = function resetFilter() {
  return new Promise((resolve, reject) => {
    this.socket.emit('reset filter', wrap(resolve, reject));
  });
};

/**
 * Esimate smart fee.
 * @param {Number?} blocks
 * @returns {Promise}
 */

WalletClient.prototype.estimateFee = function estimateFee(blocks) {
  return new Promise((resolve, reject) => {
    this.socket.emit('estimate fee', blocks, wrap(resolve, reject));
  });
};

/**
 * Rescan for any missed transactions.
 * @param {Number|Hash} start - Start block.
 * @param {Bloom} filter
 * @param {Function} iter - Iterator.
 * @returns {Promise}
 */

WalletClient.prototype.rescan = function rescan(start) {
  return new Promise((resolve, reject) => {
    if (typeof start === 'string')
      start = util.revHex(start);

    this.socket.emit('rescan', start, wrap(resolve, reject));
  });
};

/*
 * Helpers
 */

function parseEntry(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, 'hex');

  const block = Headers.fromHead(data);

  const br = new BufferReader(data);
  br.seek(80);

  const height = br.readU32();
  const hash = block.hash('hex');

  return new BlockMeta(hash, height, block.time);
}

function parseBlock(entry, txs) {
  const block = parseEntry(entry);
  const out = [];

  for (const raw of txs) {
    const tx = parseTX(raw);
    out.push(tx);
  }

  return new BlockResult(block, out);
}

function parseTX(data) {
  return TX.fromRaw(data, 'hex');
}

function BlockResult(entry, txs) {
  this.entry = entry;
  this.txs = txs;
}

function wrap(resolve, reject, parse) {
  return function(err, result) {
    if (err) {
      reject(new Error(err.message));
      return;
    }

    if (!result) {
      resolve(null);
      return;
    }

    if (!parse) {
      resolve(result);
      return;
    }

    try {
      result = parse(result);
    } catch (e) {
      reject(e);
      return;
    }

    resolve(result);
  };
}

/*
 * Expose
 */

module.exports = WalletClient;


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * server.js - http server for wmcc_core.
 */



const assert = __webpack_require__(0);
const path = __webpack_require__(25);
const HTTPBase = __webpack_require__(169);
const util = __webpack_require__(1);
const base58 = __webpack_require__(26);
const MTX = __webpack_require__(48);
const Outpoint = __webpack_require__(21);
const Script = __webpack_require__(8);
const digest = __webpack_require__(5);
const random = __webpack_require__(29);
const ccmp = __webpack_require__(52);
const Network = __webpack_require__(6);
const Validator = __webpack_require__(71);
const Address = __webpack_require__(11);
const KeyRing = __webpack_require__(47);
const common = __webpack_require__(61);

/**
 * HTTPServer
 * @alias module:wallet.HTTPServer
 * @constructor
 * @param {Object} options
 * @see HTTPBase
 * @emits HTTPServer#socket
 */

function HTTPServer(options) {
  if (!(this instanceof HTTPServer))
    return new HTTPServer(options);

  options = new HTTPOptions(options);

  HTTPBase.call(this, options);

  this.options = options;
  this.network = this.options.network;
  this.logger = this.options.logger.context('http');
  this.walletdb = this.options.walletdb;

  this.server = new HTTPBase(this.options);
  this.rpc = this.walletdb.rpc;

  this.init();
}

Object.setPrototypeOf(HTTPServer.prototype, HTTPBase.prototype);

/**
 * Attach to server.
 * @private
 * @param {HTTPServer} server
 */

HTTPServer.prototype.attach = function attach(server) {
  server.mount('/wallet', this);
};

/**
 * Initialize http server.
 * @private
 */

HTTPServer.prototype.init = function init() {
  this.on('request', (req, res) => {
    if (req.method === 'POST' && req.pathname === '/')
      return;

    this.logger.debug('Request for method=%s path=%s (%s).',
      req.method, req.pathname, req.socket.remoteAddress);
  });

  this.on('listening', (address) => {
    this.logger.info('HTTP server listening on %s (port=%d).',
      address.address, address.port);
  });

  this.initRouter();
  this.initSockets();
};

/**
 * Initialize routes.
 * @private
 */

HTTPServer.prototype.initRouter = function initRouter() {
  this.use(this.cors());

  if (!this.options.noAuth) {
    this.use(this.basicAuth({
      password: this.options.apiKey,
      realm: 'wallet'
    }));
  }

  this.use(this.bodyParser({
    contentType: 'json'
  }));

  this.use(this.jsonRPC(this.rpc));

  this.hook(async (req, res) => {
    const valid = req.valid();

    if (req.path.length === 0)
      return;

    if (req.path[0] === '_admin')
      return;

    if (req.method === 'PUT' && req.path.length === 1)
      return;

    const id = valid.str('id');
    const token = valid.buf('token');

    if (!this.options.walletAuth) {
      const wallet = await this.walletdb.get(id);

      if (!wallet) {
        res.send(404);
        return;
      }

      req.wallet = wallet;

      return;
    }

    let wallet;
    try {
      wallet = await this.walletdb.auth(id, token);
    } catch (err) {
      this.logger.info('Auth failure for %s: %s.', id, err.message);
      res.error(403, err);
      return;
    }

    if (!wallet) {
      res.send(404);
      return;
    }

    req.wallet = wallet;

    this.logger.info('Successful auth for %s.', id);
  });

  // Rescan
  this.post('/_admin/rescan', async (req, res) => {
    const valid = req.valid();
    const height = valid.u32('height');

    res.send(200, { success: true });

    await this.walletdb.rescan(height);
  });

  // Resend
  this.post('/_admin/resend', async (req, res) => {
    await this.walletdb.resend();
    res.send(200, { success: true });
  });

  // Backup WalletDB
  this.post('/_admin/backup', async (req, res) => {
    const valid = req.valid();
    const path = valid.str('path');

    enforce(path, 'Path is required.');

    await this.walletdb.backup(path);

    res.send(200, { success: true });
  });

  // List wallets
  this.get('/_admin/wallets', async (req, res) => {
    const wallets = await this.walletdb.getWallets();
    res.send(200, wallets);
  });

  // Get wallet
  this.get('/:id', (req, res) => {
    res.send(200, req.wallet.toJSON());
  });

  // Get wallet master key
  this.get('/:id/master', (req, res) => {
    res.send(200, req.wallet.master.toJSON(true));
  });

  // Create wallet (compat)
  this.post('/', async (req, res) => {
    const valid = req.valid();

    const wallet = await this.walletdb.create({
      id: valid.str('id'),
      type: valid.str('type'),
      m: valid.u32('m'),
      n: valid.u32('n'),
      passphrase: valid.str('passphrase'),
      master: valid.str('master'),
      mnemonic: valid.str('mnemonic'),
      witness: valid.bool('witness'),
      accountKey: valid.str('accountKey'),
      watchOnly: valid.bool('watchOnly')
    });

    res.send(200, wallet.toJSON());
  });

  // Create wallet
  this.put('/:id', async (req, res) => {
    const valid = req.valid();

    const wallet = await this.walletdb.create({
      id: valid.str('id'),
      type: valid.str('type'),
      m: valid.u32('m'),
      n: valid.u32('n'),
      passphrase: valid.str('passphrase'),
      master: valid.str('master'),
      mnemonic: valid.str('mnemonic'),
      witness: valid.bool('witness'),
      accountKey: valid.str('accountKey'),
      watchOnly: valid.bool('watchOnly')
    });

    res.send(200, wallet.toJSON());
  });

  // List accounts
  this.get('/:id/account', async (req, res) => {
    const accounts = await req.wallet.getAccounts();
    res.send(200, accounts);
  });

  // Get account
  this.get('/:id/account/:account', async (req, res) => {
    const valid = req.valid();
    const acct = valid.str('account');
    const account = await req.wallet.getAccount(acct);

    if (!account) {
      res.send(404);
      return;
    }

    res.send(200, account.toJSON());
  });

  // Create account (compat)
  this.post('/:id/account', async (req, res) => {
    const valid = req.valid();
    const passphrase = valid.str('passphrase');

    const options = {
      name: valid.str(['account', 'name']),
      witness: valid.bool('witness'),
      watchOnly: valid.bool('watchOnly'),
      type: valid.str('type'),
      m: valid.u32('m'),
      n: valid.u32('n'),
      accountKey: valid.str('accountKey'),
      lookahead: valid.u32('lookahead')
    };

    const account = await req.wallet.createAccount(options, passphrase);

    res.send(200, account.toJSON());
  });

  // Create account
  this.put('/:id/account/:account', async (req, res) => {
    const valid = req.valid();
    const passphrase = valid.str('passphrase');

    const options = {
      name: valid.str('account'),
      witness: valid.bool('witness'),
      watchOnly: valid.bool('watchOnly'),
      type: valid.str('type'),
      m: valid.u32('m'),
      n: valid.u32('n'),
      accountKey: valid.str('accountKey'),
      lookahead: valid.u32('lookahead')
    };

    const account = await req.wallet.createAccount(options, passphrase);

    res.send(200, account.toJSON());
  });

  // Change passphrase
  this.post('/:id/passphrase', async (req, res) => {
    const valid = req.valid();
    const old = valid.str('old');
    const new_ = valid.str('new');

    enforce(old || new_, 'Passphrase is required.');

    await req.wallet.setPassphrase(old, new_);

    res.send(200, { success: true });
  });

  // Unlock wallet
  this.post('/:id/unlock', async (req, res) => {
    const valid = req.valid();
    const passphrase = valid.str('passphrase');
    const timeout = valid.u32('timeout');

    enforce(passphrase, 'Passphrase is required.');

    await req.wallet.unlock(passphrase, timeout);

    res.send(200, { success: true });
  });

  // Lock wallet
  this.post('/:id/lock', async (req, res) => {
    await req.wallet.lock();
    res.send(200, { success: true });
  });

  // Import key
  this.post('/:id/import', async (req, res) => {
    const valid = req.valid();
    const acct = valid.str('account');
    const pub = valid.buf('publicKey');
    const priv = valid.str('privateKey');
    const b58 = valid.str('address');

    if (pub) {
      const key = KeyRing.fromPublic(pub, this.network);
      await req.wallet.importKey(acct, key);
      res.send(200, { success: true });
      return;
    }

    if (priv) {
      const key = KeyRing.fromSecret(priv, this.network);
      await req.wallet.importKey(acct, key);
      res.send(200, { success: true });
      return;
    }

    if (b58) {
      const addr = Address.fromString(b58, this.network);
      await req.wallet.importAddress(acct, addr);
      res.send(200, { success: true });
      return;
    }

    enforce(false, 'Key or address is required.');
  });

  // Generate new token
  this.post('/:id/retoken', async (req, res) => {
    const valid = req.valid();
    const passphrase = valid.str('passphrase');
    const token = await req.wallet.retoken(passphrase);

    res.send(200, {
      token: token.toString('hex')
    });
  });

  // Send TX
  this.post('/:id/send', async (req, res) => {
    const valid = req.valid();
    const passphrase = valid.str('passphrase');
    const outputs = valid.array('outputs');

    const options = {
      rate: valid.u64('rate'),
      blocks: valid.u32('blocks'),
      maxFee: valid.u64('maxFee'),
      selection: valid.str('selection'),
      smart: valid.bool('smart'),
      subtractFee: valid.bool('subtractFee'),
      subtractIndex: valid.i32('subtractIndex'),
      depth: valid.u32(['confirmations', 'depth']),
      outputs: []
    };

    for (const output of outputs) {
      const valid = new Validator([output]);
      const raw = valid.buf('script');
      let script = null;

      if (raw)
        script = Script.fromRaw(raw);

      options.outputs.push({
        script: script,
        address: valid.str('address'),
        value: valid.u64('value')
      });
    }

    const tx = await req.wallet.send(options, passphrase);

    const details = await req.wallet.getDetails(tx.hash('hex'));

    res.send(200, details.toJSON());
  });

  // Create TX
  this.post('/:id/create', async (req, res) => {
    const valid = req.valid();
    const passphrase = valid.str('passphrase');
    const outputs = valid.array('outputs');

    const options = {
      rate: valid.u64('rate'),
      maxFee: valid.u64('maxFee'),
      selection: valid.str('selection'),
      smart: valid.bool('smart'),
      subtractFee: valid.bool('subtractFee'),
      subtractIndex: valid.i32('subtractIndex'),
      depth: valid.u32(['confirmations', 'depth']),
      outputs: []
    };

    for (const output of outputs) {
      const valid = new Validator([output]);
      const raw = valid.buf('script');
      let script = null;

      if (raw)
        script = Script.fromRaw(raw);

      options.outputs.push({
        script: script,
        address: valid.str('address'),
        value: valid.u64('value')
      });
    }

    const tx = await req.wallet.createTX(options);

    await req.wallet.sign(tx, passphrase);

    res.send(200, tx.getJSON(this.network));
  });

  // Sign TX
  this.post('/:id/sign', async (req, res) => {
    const valid = req.valid();
    const passphrase = valid.str('passphrase');
    const raw = valid.buf('tx');

    enforce(raw, 'TX is required.');

    const tx = MTX.fromRaw(raw);
    tx.view = await req.wallet.getCoinView(tx);

    await req.wallet.sign(tx, passphrase);

    res.send(200, tx.getJSON(this.network));
  });

  // Zap Wallet TXs
  this.post('/:id/zap', async (req, res) => {
    const valid = req.valid();
    const acct = valid.str('account');
    const age = valid.u32('age');

    enforce(age, 'Age is required.');

    await req.wallet.zap(acct, age);

    res.send(200, { success: true });
  });

  // Abandon Wallet TX
  this.del('/:id/tx/:hash', async (req, res) => {
    const valid = req.valid();
    const hash = valid.hash('hash');

    enforce(hash, 'Hash is required.');

    await req.wallet.abandon(hash);

    res.send(200, { success: true });
  });

  // List blocks
  this.get('/:id/block', async (req, res) => {
    const heights = await req.wallet.getBlocks();
    res.send(200, heights);
  });

  // Get Block Record
  this.get('/:id/block/:height', async (req, res) => {
    const valid = req.valid();
    const height = valid.u32('height');

    enforce(height != null, 'Height is required.');

    const block = await req.wallet.getBlock(height);

    if (!block) {
      res.send(404);
      return;
    }

    res.send(200, block.toJSON());
  });

  // Add key
  this.put('/:id/shared-key', async (req, res) => {
    const valid = req.valid();
    const acct = valid.str('account');
    const key = valid.str('accountKey');

    enforce(key, 'Key is required.');

    await req.wallet.addSharedKey(acct, key);

    res.send(200, { success: true });
  });

  // Remove key
  this.del('/:id/shared-key', async (req, res) => {
    const valid = req.valid();
    const acct = valid.str('account');
    const key = valid.str('accountKey');

    enforce(key, 'Key is required.');

    await req.wallet.removeSharedKey(acct, key);

    res.send(200, { success: true });
  });

  // Get key by address
  this.get('/:id/key/:address', async (req, res) => {
    const valid = req.valid();
    const address = valid.str('address');

    enforce(address, 'Address is required.');

    const key = await req.wallet.getKey(address);

    if (!key) {
      res.send(404);
      return;
    }

    res.send(200, key.toJSON());
  });

  // Get private key
  this.get('/:id/wif/:address', async (req, res) => {
    const valid = req.valid();
    const address = valid.str('address');
    const passphrase = valid.str('passphrase');

    enforce(address, 'Address is required.');

    const key = await req.wallet.getPrivateKey(address, passphrase);

    if (!key) {
      res.send(404);
      return;
    }

    res.send(200, { privateKey: key.toSecret() });
  });

  // Create address
  this.post('/:id/address', async (req, res) => {
    const valid = req.valid();
    const acct = valid.str('account');
    const address = await req.wallet.createReceive(acct);

    res.send(200, address.toJSON());
  });

  // Create change address
  this.post('/:id/change', async (req, res) => {
    const valid = req.valid();
    const acct = valid.str('account');
    const address = await req.wallet.createChange(acct);

    res.send(200, address.toJSON());
  });

  // Create nested address
  this.post('/:id/nested', async (req, res) => {
    const valid = req.valid();
    const acct = valid.str('account');
    const address = await req.wallet.createNested(acct);

    res.send(200, address.toJSON());
  });

  // Wallet Balance
  this.get('/:id/balance', async (req, res) => {
    const valid = req.valid();
    const acct = valid.str('account');
    const balance = await req.wallet.getBalance(acct);

    if (!balance) {
      res.send(404);
      return;
    }

    res.send(200, balance.toJSON());
  });

  // Wallet UTXOs
  this.get('/:id/coin', async (req, res) => {
    const valid = req.valid();
    const acct = valid.str('account');
    const coins = await req.wallet.getCoins(acct);
    const result = [];

    common.sortCoins(coins);

    for (const coin of coins)
      result.push(coin.getJSON(this.network));

    res.send(200, result);
  });

  // Locked coins
  this.get('/:id/locked', async (req, res) => {
    const locked = this.wallet.getLocked();
    const result = [];

    for (const outpoint of locked)
      result.push(outpoint.toJSON());

    res.send(200, result);
  });

  // Lock coin
  this.put('/:id/locked/:hash/:index', async (req, res) => {
    const valid = req.valid();
    const hash = valid.hash('hash');
    const index = valid.u32('index');

    enforce(hash, 'Hash is required.');
    enforce(index != null, 'Index is required.');

    const outpoint = new Outpoint(hash, index);

    this.wallet.lockCoin(outpoint);
  });

  // Unlock coin
  this.del('/:id/locked/:hash/:index', async (req, res) => {
    const valid = req.valid();
    const hash = valid.hash('hash');
    const index = valid.u32('index');

    enforce(hash, 'Hash is required.');
    enforce(index != null, 'Index is required.');

    const outpoint = new Outpoint(hash, index);

    this.wallet.unlockCoin(outpoint);
  });

  // Wallet Coin
  this.get('/:id/coin/:hash/:index', async (req, res) => {
    const valid = req.valid();
    const hash = valid.hash('hash');
    const index = valid.u32('index');

    enforce(hash, 'Hash is required.');
    enforce(index != null, 'Index is required.');

    const coin = await req.wallet.getCoin(hash, index);

    if (!coin) {
      res.send(404);
      return;
    }

    res.send(200, coin.getJSON(this.network));
  });

  // Wallet TXs
  this.get('/:id/tx/history', async (req, res) => {
    const valid = req.valid();
    const acct = valid.str('account');
    const txs = await req.wallet.getHistory(acct);

    common.sortTX(txs);

    const details = await req.wallet.toDetails(txs);

    const result = [];

    for (const item of details)
      result.push(item.toJSON());

    res.send(200, result);
  });

  // Wallet Pending TXs
  this.get('/:id/tx/unconfirmed', async (req, res) => {
    const valid = req.valid();
    const acct = valid.str('account');
    const txs = await req.wallet.getPending(acct);

    common.sortTX(txs);

    const details = await req.wallet.toDetails(txs);

    const result = [];

    for (const item of details)
      result.push(item.toJSON());

    res.send(200, result);
  });

  // Wallet TXs within time range
  this.get('/:id/tx/range', async (req, res) => {
    const valid = req.valid();
    const acct = valid.str('account');

    const options = {
      start: valid.u32('start'),
      end: valid.u32('end'),
      limit: valid.u32('limit'),
      reverse: valid.bool('reverse')
    };

    const txs = await req.wallet.getRange(acct, options);

    const details = await req.wallet.toDetails(txs);

    const result = [];

    for (const item of details)
      result.push(item.toJSON());

    res.send(200, result);
  });

  // Last Wallet TXs
  this.get('/:id/tx/last', async (req, res) => {
    const valid = req.valid();
    const acct = valid.str('account');
    const limit = valid.u32('limit');
    const txs = await req.wallet.getLast(acct, limit);
    const details = await req.wallet.toDetails(txs);
    const result = [];

    for (const item of details)
      result.push(item.toJSON());

    res.send(200, result);
  });

  // Wallet TX
  this.get('/:id/tx/:hash', async (req, res) => {
    const valid = req.valid();
    const hash = valid.hash('hash');

    enforce(hash, 'Hash is required.');

    const tx = await req.wallet.getTX(hash);

    if (!tx) {
      res.send(404);
      return;
    }

    const details = await req.wallet.toDetails(tx);

    res.send(200, details.toJSON());
  });

  // Resend
  this.post('/:id/resend', async (req, res) => {
    await req.wallet.resend();
    res.send(200, { success: true });
  });
};

/**
 * Initialize websockets.
 * @private
 */

HTTPServer.prototype.initSockets = function initSockets() {
  if (!this.io)
    return;

  this.on('socket', (socket) => {
    this.handleSocket(socket);
  });

  this.walletdb.on('tx', (id, tx, details) => {
    const json = details.toJSON();
    this.to(`w:${id}`, 'wallet tx', json);
  });

  this.walletdb.on('confirmed', (id, tx, details) => {
    const json = details.toJSON();
    this.to(`w:${id}`, 'wallet confirmed', json);
  });

  this.walletdb.on('unconfirmed', (id, tx, details) => {
    const json = details.toJSON();
    this.to(`w:${id}`, 'wallet unconfirmed', json);
  });

  this.walletdb.on('conflict', (id, tx, details) => {
    const json = details.toJSON();
    this.to(`w:${id}`, 'wallet conflict', json);
  });

  this.walletdb.on('balance', (id, balance) => {
    const json = balance.toJSON();
    this.to(`w:${id}`, 'wallet balance', json);
  });

  this.walletdb.on('address', (id, receive) => {
    const json = [];

    for (const addr of receive)
      json.push(addr.toJSON());

    this.to(`w:${id}`, 'wallet address', json);
  });
};

/**
 * Handle new websocket.
 * @private
 * @param {WebSocket} socket
 */

HTTPServer.prototype.handleSocket = function handleSocket(socket) {
  socket.hook('wallet auth', (args) => {
    if (socket.auth)
      throw new Error('Already authed.');

    if (!this.options.noAuth) {
      const valid = new Validator([args]);
      const key = valid.str(0, '');

      if (key.length > 255)
        throw new Error('Invalid API key.');

      const data = Buffer.from(key, 'utf8');
      const hash = digest.hash256(data);

      if (!ccmp(hash, this.options.apiHash))
        throw new Error('Invalid API key.');
    }

    socket.auth = true;

    this.logger.info('Successful auth from %s.', socket.host);

    this.handleAuth(socket);

    return null;
  });
};

/**
 * Handle new auth'd websocket.
 * @private
 * @param {WebSocket} socket
 */

HTTPServer.prototype.handleAuth = function handleAuth(socket) {
  socket.hook('wallet join', async (args) => {
    const valid = new Validator([args]);
    const id = valid.str(0, '');
    const token = valid.buf(1);

    if (!id)
      throw new Error('Invalid parameter.');

    if (!this.options.walletAuth) {
      socket.join(`w:${id}`);
      return null;
    }

    if (!token)
      throw new Error('Invalid parameter.');

    let wallet;
    try {
      wallet = await this.walletdb.auth(id, token);
    } catch (e) {
      this.logger.info('Wallet auth failure for %s: %s.', id, e.message);
      throw new Error('Bad token.');
    }

    if (!wallet)
      throw new Error('Wallet does not exist.');

    this.logger.info('Successful wallet auth for %s.', id);

    socket.join(`w:${id}`);

    return null;
  });

  socket.hook('wallet leave', (args) => {
    const valid = new Validator([args]);
    const id = valid.str(0, '');

    if (!id)
      throw new Error('Invalid parameter.');

    socket.leave(`w:${id}`);

    return null;
  });
};

/**
 * HTTPOptions
 * @alias module:http.HTTPOptions
 * @constructor
 * @param {Object} options
 */

function HTTPOptions(options) {
  if (!(this instanceof HTTPOptions))
    return new HTTPOptions(options);

  this.network = Network.primary;
  this.logger = null;
  this.walletdb = null;
  this.apiKey = base58.encode(random.randomBytes(20));
  this.apiHash = digest.hash256(Buffer.from(this.apiKey, 'ascii'));
  this.serviceHash = this.apiHash;
  this.noAuth = false;
  this.walletAuth = false;

  this.prefix = null;
  this.host = '127.0.0.1';
  this.port = 8080;
  this.ssl = false;
  this.keyFile = null;
  this.certFile = null;

  this.fromOptions(options);
}

/**
 * Inject properties from object.
 * @private
 * @param {Object} options
 * @returns {HTTPOptions}
 */

HTTPOptions.prototype.fromOptions = function fromOptions(options) {
  assert(options);
  assert(options.walletdb && typeof options.walletdb === 'object',
    'HTTP Server requires a WalletDB.');

  this.walletdb = options.walletdb;
  this.network = options.walletdb.network;
  this.logger = options.walletdb.logger;
  this.port = this.network.rpcPort + 2;

  if (options.logger != null) {
    assert(typeof options.logger === 'object');
    this.logger = options.logger;
  }

  if (options.apiKey != null) {
    assert(typeof options.apiKey === 'string',
      'API key must be a string.');
    assert(options.apiKey.length <= 255,
      'API key must be under 255 bytes.');
    assert(util.isAscii(options.apiKey),
      'API key must be ASCII.');
    this.apiKey = options.apiKey;
    this.apiHash = digest.hash256(Buffer.from(this.apiKey, 'ascii'));
  }

  if (options.noAuth != null) {
    assert(typeof options.noAuth === 'boolean');
    this.noAuth = options.noAuth;
  }

  if (options.walletAuth != null) {
    assert(typeof options.walletAuth === 'boolean');
    this.walletAuth = options.walletAuth;
  }

  if (options.prefix != null) {
    assert(typeof options.prefix === 'string');
    this.prefix = options.prefix;
    this.keyFile = path.join(this.prefix, 'key.pem');
    this.certFile = path.join(this.prefix, 'cert.pem');
  }

  if (options.host != null) {
    assert(typeof options.host === 'string');
    this.host = options.host;
  }

  if (options.port != null) {
    assert(util.isU16(options.port), 'Port must be a number.');
    this.port = options.port;
  }

  if (options.ssl != null) {
    assert(typeof options.ssl === 'boolean');
    this.ssl = options.ssl;
  }

  if (options.keyFile != null) {
    assert(typeof options.keyFile === 'string');
    this.keyFile = options.keyFile;
  }

  if (options.certFile != null) {
    assert(typeof options.certFile === 'string');
    this.certFile = options.certFile;
  }

  // Allow no-auth implicitly
  // if we're listening locally.
  if (!options.apiKey) {
    if (this.host === '127.0.0.1' || this.host === '::1')
      this.noAuth = true;
  }

  return this;
};

/**
 * Instantiate http options from object.
 * @param {Object} options
 * @returns {HTTPOptions}
 */

HTTPOptions.fromOptions = function fromOptions(options) {
  return new HTTPOptions().fromOptions(options);
};

/*
 * Helpers
 */

function enforce(value, msg) {
  if (!value) {
    const err = new Error(msg);
    err.statusCode = 400;
    throw err;
  }
}

/*
 * Expose
 */

module.exports = HTTPServer;


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * masterkey.js - master bip32 key object for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const Lock = __webpack_require__(23);
const random = __webpack_require__(29);
const cleanse = __webpack_require__(70);
const aes = __webpack_require__(106);
const pbkdf2 = __webpack_require__(68);
const scrypt = __webpack_require__(45);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const encoding = __webpack_require__(3);
const HD = __webpack_require__(107);
const Mnemonic = HD.Mnemonic;

/**
 * Master BIP32 key which can exist
 * in a timed out encrypted state.
 * @alias module:wallet.MasterKey
 * @constructor
 * @param {Object} options
 */

function MasterKey(options) {
  if (!(this instanceof MasterKey))
    return new MasterKey(options);

  this.encrypted = false;
  this.iv = null;
  this.ciphertext = null;
  this.key = null;
  this.mnemonic = null;

  this.alg = MasterKey.alg.PBKDF2;
  this.N = 50000;
  this.r = 0;
  this.p = 0;

  this.aesKey = null;
  this.timer = null;
  this.until = 0;
  this._onTimeout = this.lock.bind(this);
  this.locker = new Lock();

  if (options)
    this.fromOptions(options);
}

/**
 * Key derivation salt.
 * @const {Buffer}
 * @default
 */

MasterKey.SALT = Buffer.from('wmcc', 'ascii');

/**
 * Key derivation algorithms.
 * @enum {Number}
 * @default
 */

MasterKey.alg = {
  PBKDF2: 0,
  SCRYPT: 1
};

/**
 * Key derivation algorithms by value.
 * @enum {String}
 * @default
 */

MasterKey.algByVal = {
  0: 'PBKDF2',
  1: 'SCRYPT'
};

/**
 * Inject properties from options object.
 * @private
 * @param {Object} options
 */

MasterKey.prototype.fromOptions = function fromOptions(options) {
  assert(options);

  if (options.encrypted != null) {
    assert(typeof options.encrypted === 'boolean');
    this.encrypted = options.encrypted;
  }

  if (options.iv) {
    assert(Buffer.isBuffer(options.iv));
    this.iv = options.iv;
  }

  if (options.ciphertext) {
    assert(Buffer.isBuffer(options.ciphertext));
    this.ciphertext = options.ciphertext;
  }

  if (options.key) {
    assert(HD.isPrivate(options.key));
    this.key = options.key;
  }

  if (options.mnemonic) {
    assert(options.mnemonic instanceof Mnemonic);
    this.mnemonic = options.mnemonic;
  }

  if (options.alg != null) {
    if (typeof options.alg === 'string') {
      this.alg = MasterKey.alg[options.alg.toUpperCase()];
      assert(this.alg != null, 'Unknown algorithm.');
    } else {
      assert(typeof options.alg === 'number');
      assert(MasterKey.algByVal[options.alg]);
      this.alg = options.alg;
    }
  }

  if (options.rounds != null) {
    assert(util.isU32(options.rounds));
    this.N = options.rounds;
  }

  if (options.N != null) {
    assert(util.isU32(options.N));
    this.N = options.N;
  }

  if (options.r != null) {
    assert(util.isU32(options.r));
    this.r = options.r;
  }

  if (options.p != null) {
    assert(util.isU32(options.p));
    this.p = options.p;
  }

  assert(this.encrypted ? !this.key : this.key);

  return this;
};

/**
 * Instantiate master key from options.
 * @returns {MasterKey}
 */

MasterKey.fromOptions = function fromOptions(options) {
  return new MasterKey().fromOptions(options);
};

/**
 * Decrypt the key and set a timeout to destroy decrypted data.
 * @param {Buffer|String} passphrase - Zero this yourself.
 * @param {Number} [timeout=60000] timeout in ms.
 * @returns {Promise} - Returns {@link HDPrivateKey}.
 */

MasterKey.prototype.unlock = async function unlock(passphrase, timeout) {
  const _unlock = await this.locker.lock();
  try {
    return await this._unlock(passphrase, timeout);
  } finally {
    _unlock();
  }
};

/**
 * Decrypt the key without a lock.
 * @private
 * @param {Buffer|String} passphrase - Zero this yourself.
 * @param {Number} [timeout=60000] timeout in ms.
 * @returns {Promise} - Returns {@link HDPrivateKey}.
 */

MasterKey.prototype._unlock = async function _unlock(passphrase, timeout) {
  if (this.key) {
    if (this.encrypted) {
      assert(this.timer != null);
      this.start(timeout);
    }
    return this.key;
  }

  if (!passphrase)
    throw new Error('No passphrase.');

  assert(this.encrypted);

  const key = await this.derive(passphrase);
  const data = aes.decipher(this.ciphertext, key, this.iv);

  this.fromKeyRaw(data);

  this.start(timeout);

  this.aesKey = key;

  return this.key;
};

/**
 * Start the destroy timer.
 * @private
 * @param {Number} [timeout=60000] timeout in ms.
 */

MasterKey.prototype.start = function start(timeout) {
  if (!timeout)
    timeout = 60;

  this.stop();

  if (timeout === -1)
    return;

  this.until = util.now() + timeout;
  this.timer = setTimeout(this._onTimeout, timeout * 1000);
};

/**
 * Stop the destroy timer.
 * @private
 */

MasterKey.prototype.stop = function stop() {
  if (this.timer != null) {
    clearTimeout(this.timer);
    this.timer = null;
    this.until = 0;
  }
};

/**
 * Derive an aes key based on params.
 * @param {String|Buffer} passphrase
 * @returns {Promise}
 */

MasterKey.prototype.derive = async function derive(passwd) {
  const salt = MasterKey.SALT;
  const N = this.N;
  const r = this.r;
  const p = this.p;

  if (typeof passwd === 'string')
    passwd = Buffer.from(passwd, 'utf8');

  switch (this.alg) {
    case MasterKey.alg.PBKDF2:
      return await pbkdf2.deriveAsync(passwd, salt, N, 32, 'sha256');
    case MasterKey.alg.SCRYPT:
      return await scrypt.deriveAsync(passwd, salt, N, r, p, 32);
    default:
      throw new Error(`Unknown algorithm: ${this.alg}.`);
  }
};

/**
 * Encrypt data with in-memory aes key.
 * @param {Buffer} data
 * @param {Buffer} iv
 * @returns {Buffer}
 */

MasterKey.prototype.encipher = function encipher(data, iv) {
  if (!this.aesKey)
    return null;

  if (typeof iv === 'string')
    iv = Buffer.from(iv, 'hex');

  return aes.encipher(data, this.aesKey, iv.slice(0, 16));
};

/**
 * Decrypt data with in-memory aes key.
 * @param {Buffer} data
 * @param {Buffer} iv
 * @returns {Buffer}
 */

MasterKey.prototype.decipher = function decipher(data, iv) {
  if (!this.aesKey)
    return null;

  if (typeof iv === 'string')
    iv = Buffer.from(iv, 'hex');

  return aes.decipher(data, this.aesKey, iv.slice(0, 16));
};

/**
 * Destroy the key by zeroing the
 * privateKey and chainCode. Stop
 * the timer if there is one.
 * @returns {Promise}
 */

MasterKey.prototype.lock = async function lock() {
  const unlock = await this.locker.lock();
  try {
    return await this._lock();
  } finally {
    unlock();
  }
};

/**
 * Destroy the key by zeroing the
 * privateKey and chainCode. Stop
 * the timer if there is one.
 */

MasterKey.prototype._lock = function _lock() {
  if (!this.encrypted) {
    assert(this.timer == null);
    assert(this.key);
    return;
  }

  this.stop();

  if (this.key) {
    this.key.destroy(true);
    this.key = null;
  }

  if (this.aesKey) {
    cleanse(this.aesKey);
    this.aesKey = null;
  }
};

/**
 * Destroy the key permanently.
 */

MasterKey.prototype.destroy = async function destroy() {
  await this.lock();
  this.locker.destroy();
};

/**
 * Decrypt the key permanently.
 * @param {Buffer|String} passphrase - Zero this yourself.
 * @returns {Promise}
 */

MasterKey.prototype.decrypt = async function decrypt(passphrase, clean) {
  const unlock = await this.locker.lock();
  try {
    return await this._decrypt(passphrase, clean);
  } finally {
    unlock();
  }
};

/**
 * Decrypt the key permanently without a lock.
 * @private
 * @param {Buffer|String} passphrase - Zero this yourself.
 * @returns {Promise}
 */

MasterKey.prototype._decrypt = async function _decrypt(passphrase, clean) {
  if (!this.encrypted)
    throw new Error('Master key is not encrypted.');

  if (!passphrase)
    throw new Error('No passphrase provided.');

  this._lock();

  const key = await this.derive(passphrase);
  const data = aes.decipher(this.ciphertext, key, this.iv);

  this.fromKeyRaw(data);
  this.encrypted = false;
  this.iv = null;
  this.ciphertext = null;

  if (!clean) {
    cleanse(key);
    return null;
  }

  return key;
};

/**
 * Encrypt the key permanently.
 * @param {Buffer|String} passphrase - Zero this yourself.
 * @returns {Promise}
 */

MasterKey.prototype.encrypt = async function encrypt(passphrase, clean) {
  const unlock = await this.locker.lock();
  try {
    return await this._encrypt(passphrase, clean);
  } finally {
    unlock();
  }
};

/**
 * Encrypt the key permanently without a lock.
 * @private
 * @param {Buffer|String} passphrase - Zero this yourself.
 * @returns {Promise}
 */

MasterKey.prototype._encrypt = async function _encrypt(passphrase, clean) {
  if (this.encrypted)
    throw new Error('Master key is already encrypted.');

  if (!passphrase)
    throw new Error('No passphrase provided.');

  const raw = this.toKeyRaw();
  const iv = random.randomBytes(16);

  this.stop();

  const key = await this.derive(passphrase);
  const data = aes.encipher(raw, key, iv);

  this.key = null;
  this.mnemonic = null;
  this.encrypted = true;
  this.iv = iv;
  this.ciphertext = data;

  if (!clean) {
    cleanse(key);
    return null;
  }

  return key;
};

/**
 * Calculate key serialization size.
 * @returns {Number}
 */

MasterKey.prototype.getKeySize = function getKeySize() {
  let size = 0;

  size += this.key.getSize();
  size += 1;

  if (this.mnemonic)
    size += this.mnemonic.getSize();

  return size;
};

/**
 * Serialize key and menmonic to a single buffer.
 * @returns {Buffer}
 */

MasterKey.prototype.toKeyRaw = function toKeyRaw() {
  const bw = new StaticWriter(this.getKeySize());

  this.key.toWriter(bw);

  if (this.mnemonic) {
    bw.writeU8(1);
    this.mnemonic.toWriter(bw);
  } else {
    bw.writeU8(0);
  }

  return bw.render();
};

/**
 * Inject properties from serialized key.
 * @param {Buffer} data
 */

MasterKey.prototype.fromKeyRaw = function fromKeyRaw(data) {
  const br = new BufferReader(data);

  this.key = HD.PrivateKey.fromReader(br);

  if (br.readU8() === 1)
    this.mnemonic = Mnemonic.fromReader(br);

  return this;
};

/**
 * Calculate serialization size.
 * @returns {Number}
 */

MasterKey.prototype.getSize = function getSize() {
  let size = 0;

  if (this.encrypted) {
    size += 1;
    size += encoding.sizeVarBytes(this.iv);
    size += encoding.sizeVarBytes(this.ciphertext);
    size += 13;
    return size;
  }

  size += 1;
  size += encoding.sizeVarlen(this.getKeySize());

  return size;
};

/**
 * Serialize the key in the form of:
 * `[enc-flag][iv?][ciphertext?][extended-key?]`
 * @returns {Buffer}
 */

MasterKey.prototype.toRaw = function toRaw() {
  const bw = new StaticWriter(this.getSize());

  if (this.encrypted) {
    bw.writeU8(1);
    bw.writeVarBytes(this.iv);
    bw.writeVarBytes(this.ciphertext);

    bw.writeU8(this.alg);
    bw.writeU32(this.N);
    bw.writeU32(this.r);
    bw.writeU32(this.p);

    return bw.render();
  }

  bw.writeU8(0);

  // NOTE: useless varint
  const size = this.getKeySize();
  bw.writeVarint(size);

  bw.writeBytes(this.key.toRaw());

  if (this.mnemonic) {
    bw.writeU8(1);
    this.mnemonic.toWriter(bw);
  } else {
    bw.writeU8(0);
  }

  return bw.render();
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} raw
 */

MasterKey.prototype.fromRaw = function fromRaw(raw) {
  const br = new BufferReader(raw);

  this.encrypted = br.readU8() === 1;

  if (this.encrypted) {
    this.iv = br.readVarBytes();
    this.ciphertext = br.readVarBytes();

    this.alg = br.readU8();

    assert(MasterKey.algByVal[this.alg]);

    this.N = br.readU32();
    this.r = br.readU32();
    this.p = br.readU32();

    return this;
  }

  // NOTE: useless varint
  br.readVarint();

  this.key = HD.PrivateKey.fromRaw(br.readBytes(82));

  if (br.readU8() === 1)
    this.mnemonic = Mnemonic.fromReader(br);

  return this;
};

/**
 * Instantiate master key from serialized data.
 * @returns {MasterKey}
 */

MasterKey.fromRaw = function fromRaw(raw) {
  return new MasterKey().fromRaw(raw);
};

/**
 * Inject properties from an HDPrivateKey.
 * @private
 * @param {HDPrivateKey} key
 * @param {Mnemonic?} mnemonic
 */

MasterKey.prototype.fromKey = function fromKey(key, mnemonic) {
  this.encrypted = false;
  this.iv = null;
  this.ciphertext = null;
  this.key = key;
  this.mnemonic = mnemonic || null;
  return this;
};

/**
 * Instantiate master key from an HDPrivateKey.
 * @param {HDPrivateKey} key
 * @param {Mnemonic?} mnemonic
 * @returns {MasterKey}
 */

MasterKey.fromKey = function fromKey(key, mnemonic) {
  return new MasterKey().fromKey(key, mnemonic);
};

/**
 * Convert master key to a jsonifiable object.
 * @param {Boolean?} unsafe - Whether to include
 * the key data in the JSON.
 * @returns {Object}
 */

MasterKey.prototype.toJSON = function toJSON(unsafe) {
  if (this.encrypted) {
    return {
      encrypted: true,
      until: this.until,
      iv: this.iv.toString('hex'),
      ciphertext: unsafe ? this.ciphertext.toString('hex') : undefined,
      algorithm: MasterKey.algByVal[this.alg].toLowerCase(),
      N: this.N,
      r: this.r,
      p: this.p
    };
  }

  return {
    encrypted: false,
    key: unsafe ? this.key.toJSON() : undefined,
    mnemonic: unsafe && this.mnemonic ? this.mnemonic.toJSON() : undefined
  };
};

/**
 * Inspect the key.
 * @returns {Object}
 */

MasterKey.prototype.inspect = function inspect() {
  const json = this.toJSON(true);

  if (this.key)
    json.key = this.key.toJSON();

  if (this.mnemonic)
    json.mnemonic = this.mnemonic.toJSON();

  return json;
};

/**
 * Test whether an object is a MasterKey.
 * @param {Object} obj
 * @returns {Boolean}
 */

MasterKey.isMasterKey = function isMasterKey(obj) {
  return obj instanceof MasterKey;
};

/*
 * Expose
 */

module.exports = MasterKey;


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * nodeclient.js - node client for wmcc_core.
 */



const AsyncObject = __webpack_require__(31);

/**
 * NodeClient
 * Sort of a fake local client for separation of concerns.
 * @alias module:node.NodeClient
 * @constructor
 */

function NodeClient(node) {
  if (!(this instanceof NodeClient))
    return new NodeClient(node);

  AsyncObject.call(this);

  this.node = node;
  this.network = node.network;
  this.filter = null;
  this.listen = false;

  this._init();
}

Object.setPrototypeOf(NodeClient.prototype, AsyncObject.prototype);

/**
 * Initialize the client.
 * @returns {Promise}
 */

NodeClient.prototype._init = function _init() {
  this.node.on('connect', (entry, block) => {
    if (!this.listen)
      return;

    this.emit('block connect', entry, block.txs);
  });

  this.node.on('disconnect', (entry, block) => {
    if (!this.listen)
      return;

    this.emit('block disconnect', entry);
  });

  this.node.on('tx', (tx) => {
    if (!this.listen)
      return;

    this.emit('tx', tx);
  });

  this.node.on('reset', (tip) => {
    if (!this.listen)
      return;

    this.emit('chain reset', tip);
  });
};

/**
 * Open the client.
 * @returns {Promise}
 */

NodeClient.prototype._open = function _open(options) {
  this.listen = true;
  return Promise.resolve();
};

/**
 * Close the client.
 * @returns {Promise}
 */

NodeClient.prototype._close = function _close() {
  this.listen = false;
  return Promise.resolve();
};

/**
 * Get chain tip.
 * @returns {Promise}
 */

NodeClient.prototype.getTip = function getTip() {
  return Promise.resolve(this.node.chain.tip);
};

/**
 * Get chain entry.
 * @param {Hash} hash
 * @returns {Promise}
 */

NodeClient.prototype.getEntry = async function getEntry(hash) {
  const entry = await this.node.chain.getEntry(hash);

  if (!entry)
    return null;

  if (!await this.node.chain.isMainChain(entry))
    return null;

  return entry;
};

/**
 * Send a transaction. Do not wait for promise.
 * @param {TX} tx
 * @returns {Promise}
 */

NodeClient.prototype.send = function send(tx) {
  this.node.relay(tx);
  return Promise.resolve();
};

/**
 * Set bloom filter.
 * @param {Bloom} filter
 * @returns {Promise}
 */

NodeClient.prototype.setFilter = function setFilter(filter) {
  this.filter = filter;
  this.node.pool.setFilter(filter);
  return Promise.resolve();
};

/**
 * Add data to filter.
 * @param {Buffer} data
 * @returns {Promise}
 */

NodeClient.prototype.addFilter = function addFilter(data) {
  this.node.pool.queueFilterLoad();
  return Promise.resolve();
};

/**
 * Reset filter.
 * @returns {Promise}
 */

NodeClient.prototype.resetFilter = function resetFilter() {
  this.node.pool.queueFilterLoad();
  return Promise.resolve();
};

/**
 * Esimate smart fee.
 * @param {Number?} blocks
 * @returns {Promise}
 */

NodeClient.prototype.estimateFee = async function estimateFee(blocks) {
  if (!this.node.fees)
    return this.network.feeRate;

  return this.node.fees.estimateFee(blocks);
};

/**
 * Rescan for any missed transactions.
 * @param {Number|Hash} start - Start block.
 * @param {Bloom} filter
 * @param {Function} iter - Iterator.
 * @returns {Promise}
 */

NodeClient.prototype.rescan = function rescan(start) {
  return this.node.chain.scan(start, this.filter, (entry, txs) => {
    return this.fire('block rescan', entry, txs);
  });
};

/*
 * Expose
 */

module.exports = NodeClient;


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * wallet.js - wallet object for wmcc_core.
 */



const assert = __webpack_require__(0);
const EventEmitter = __webpack_require__(10);
const Network = __webpack_require__(6);
const util = __webpack_require__(1);
const encoding = __webpack_require__(3);
const Lock = __webpack_require__(23);
const MappedLock = __webpack_require__(190);
const digest = __webpack_require__(5);
const cleanse = __webpack_require__(70);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const base58 = __webpack_require__(26);
const TXDB = __webpack_require__(256);
const Path = __webpack_require__(76);
const common = __webpack_require__(61);
const Address = __webpack_require__(11);
const MTX = __webpack_require__(48);
const Script = __webpack_require__(8);
const WalletKey = __webpack_require__(128);
const HD = __webpack_require__(107);
const Output = __webpack_require__(13);
const Account = __webpack_require__(191);
const MasterKey = __webpack_require__(253);
//const HSM = require('./hsm');
const LRU = __webpack_require__(56);
const policy = __webpack_require__(19);
const consensus = __webpack_require__(7);
const Mnemonic = HD.Mnemonic;

/**
 * BIP44 Wallet
 * @alias module:wallet.Wallet
 * @constructor
 * @param {Object} options
 * @param {WalletDB} options.db
 * present, no coins will be available.
 * @param {(HDPrivateKey|HDPublicKey)?} options.master - Master HD key. If not
 * present, it will be generated.
 * @param {Boolean?} options.witness - Whether to use witness programs.
 * @param {Number?} options.accountIndex - The BIP44 account index (default=0).
 * @param {Number?} options.receiveDepth - The index of the _next_ receiving
 * address.
 * @param {Number?} options.changeDepth - The index of the _next_ change
 * address.
 * @param {String?} options.type - Type of wallet (pubkeyhash, multisig)
 * (default=pubkeyhash).
 * @param {Boolean?} options.compressed - Whether to use compressed
 * public keys (default=true).
 * @param {Number?} options.m - `m` value for multisig.
 * @param {Number?} options.n - `n` value for multisig.
 * @param {String?} options.id - Wallet ID (used for storage)
 * @param {String?} options.mnemonic - mnemonic phrase to use to instantiate an
 * hd private key for wallet
 * (default=account key "address").
 */

function Wallet(db, options) {
  if (!(this instanceof Wallet))
    return new Wallet(db, options);

  EventEmitter.call(this);

  assert(db, 'DB required.');

  this.db = db;
  this.network = db.network;
  this.logger = db.logger;
  this.readLock = new MappedLock();
  this.writeLock = new Lock();
  this.fundLock = new Lock();
  this.indexCache = new LRU(10000);
  this.accountCache = new LRU(10000);
  this.pathCache = new LRU(100000);
  this.current = null;

  this.wid = 0;
  this.id = null;
  this.initialized = false;
  this.watchOnly = false;
  this.accountDepth = 0;
  this.token = encoding.ZERO_HASH;
  this.tokenDepth = 0;
  this.lock = null;
  this.chksum = null;
  this.master = new MasterKey();

  this.txdb = new TXDB(this);
  this.account = null;

  if (options)
    this.fromOptions(options);
}

Object.setPrototypeOf(Wallet.prototype, EventEmitter.prototype);

/**
 * Inject properties from options object.
 * @private
 * @param {Object} options
 */

Wallet.prototype.fromOptions = function fromOptions(options) {
  //const hsm = options.hsm;
  let key = options.master;
  let id, token, mnemonic;
  // TODO: set this in hsm func
  /*if (hsm.lock) {
    if (Array.isArray(hsm.lock)) {
      lock = util.concatArrBuf(hsm.lock);
    } else if (typeof hsm.lock === 'string') {
      assert(util.isHex(hsm.lock));
      lock = Buffer.from(hsm.lock, 'hex');
    } else {
      lock = hsm.lock;
    }
    assert(Buffer.isBuffer(lock));
    this.lock = lock;

    assert(Buffer.isBuffer(hsm.passphrase));
    this.chksum = hsm.passphrase.slice(0, 4);
  }*/

  this.lock = mergeLocks(options.hsm.locks);
  this.chksum = options.hsm.passphrase.slice(0, 4);

  if (key) {
    if (typeof key === 'string')
      key = HD.PrivateKey.fromBase58(key, this.network);

    assert(HD.isPrivate(key),
      'Must create wallet with hd private key.');
  } else {
    mnemonic = new Mnemonic(options.mnemonic);
    key = HD.fromMnemonic(mnemonic, this.network);
  }

  assert(key.network === this.network,
    'Network mismatch for master key.');

  this.master.fromKey(key, mnemonic);

  if (options.wid != null) {
    assert(util.isU32(options.wid));
    this.wid = options.wid;
  }

  if (options.id) {
    assert(common.isName(options.id), 'Bad wallet ID.');
    id = options.id;
  }

  if (options.initialized != null) {
    assert(typeof options.initialized === 'boolean');
    this.initialized = options.initialized;
  }

  if (options.watchOnly != null) {
    assert(typeof options.watchOnly === 'boolean');
    this.watchOnly = options.watchOnly;
  }

  if (options.accountDepth != null) {
    assert(util.isU32(options.accountDepth));
    this.accountDepth = options.accountDepth;
  }

  if (options.token) {
    assert(Buffer.isBuffer(options.token));
    assert(options.token.length === 32);
    token = options.token;
  }

  if (options.tokenDepth != null) {
    assert(util.isU32(options.tokenDepth));
    this.tokenDepth = options.tokenDepth;
  }

  if (!id)
    id = this.getID();

  if (!token)
    token = this.getToken(this.tokenDepth);

  this.id = id;
  this.token = token;

  return this;
};

/**
 * Instantiate wallet from options.
 * @param {WalletDB} db
 * @param {Object} options
 * @returns {Wallet}
 */

Wallet.fromOptions = function fromOptions(db, options) {
  return new Wallet(db).fromOptions(options);
};

/**
 * Attempt to intialize the wallet (generating
 * the first addresses along with the lookahead
 * addresses). Called automatically from the
 * walletdb.
 * @returns {Promise}
 */

Wallet.prototype.init = async function init(options) {
  let passphrase;
  const hsm = options.hsm;

  if (hsm.passphrase) {
    passphrase = hsm.passphrase.toString('hex');
  } else {
    passphrase = options.passphrase;
  }
  //const passphrase = options.passphrase;

  assert(!this.initialized);
  this.initialized = true;

  if (passphrase)
    await this.master.encrypt(passphrase);

  const account = await this._createAccount(options, passphrase);
  assert(account);

  this.account = account;

  this.logger.info('Wallet initialized (%s).', this.id);

  await this.txdb.open();
};

/**
 * Open wallet (done after retrieval).
 * @returns {Promise}
 */

Wallet.prototype.open = async function open() {
  assert(this.initialized);

  const account = await this.getAccount(0);

  if (!account)
    throw new Error('Default account not found.');

  this.account = account;

  this.logger.info('Wallet opened (%s).', this.id);

  await this.txdb.open();
};

/**
 * Close the wallet, unregister with the database.
 * @returns {Promise}
 */

Wallet.prototype.destroy = async function destroy() {
  const unlock1 = await this.writeLock.lock();
  const unlock2 = await this.fundLock.lock();
  try {
    this.db.unregister(this);
    await this.master.destroy();
    this.readLock.destroy();
    this.writeLock.destroy();
    this.fundLock.destroy();
  } finally {
    unlock2();
    unlock1();
  }
};

/**
 * Add a public account key to the wallet (multisig).
 * Saves the key in the wallet database.
 * @param {(Number|String)} acct
 * @param {HDPublicKey} key
 * @returns {Promise}
 */

Wallet.prototype.addSharedKey = async function addSharedKey(acct, key) {
  const unlock = await this.writeLock.lock();
  try {
    return await this._addSharedKey(acct, key);
  } finally {
    unlock();
  }
};

/**
 * Add a public account key to the wallet without a lock.
 * @private
 * @param {(Number|String)} acct
 * @param {HDPublicKey} key
 * @returns {Promise}
 */

Wallet.prototype._addSharedKey = async function _addSharedKey(acct, key) {
  if (!key) {
    key = acct;
    acct = null;
  }

  if (acct == null)
    acct = 0;

  const account = await this.getAccount(acct);

  if (!account)
    throw new Error('Account not found.');

  this.start();

  let result;
  try {
    result = await account.addSharedKey(key);
  } catch (e) {
    this.drop();
    throw e;
  }

  await this.commit();

  return result;
};

/**
 * Remove a public account key from the wallet (multisig).
 * @param {(Number|String)} acct
 * @param {HDPublicKey} key
 * @returns {Promise}
 */

Wallet.prototype.removeSharedKey = async function removeSharedKey(acct, key) {
  const unlock = await this.writeLock.lock();
  try {
    return await this._removeSharedKey(acct, key);
  } finally {
    unlock();
  }
};

/**
 * Remove a public account key from the wallet (multisig).
 * @private
 * @param {(Number|String)} acct
 * @param {HDPublicKey} key
 * @returns {Promise}
 */

Wallet.prototype._removeSharedKey = async function _removeSharedKey(acct, key) {
  if (!key) {
    key = acct;
    acct = null;
  }

  if (acct == null)
    acct = 0;

  const account = await this.getAccount(acct);

  if (!account)
    throw new Error('Account not found.');

  this.start();

  let result;
  try {
    result = await account.removeSharedKey(key);
  } catch (e) {
    this.drop();
    throw e;
  }

  await this.commit();

  return result;
};

/**
 * Change or set master key's passphrase.
 * @param {(String|Buffer)?} old
 * @param {String|Buffer} new_
 * @returns {Promise}
 */

Wallet.prototype.setPassphrase = async function setPassphrase(old, new_) {
  if (new_ == null) {
    new_ = old;
    old = null;
  }

  if (old != null)
    await this.decrypt(old);

  if (new_ != null)
    await this.encrypt(new_);
};

/**
 * Encrypt the wallet permanently.
 * @param {String|Buffer} passphrase
 * @returns {Promise}
 */

Wallet.prototype.encrypt = async function encrypt(passphrase) {
  const unlock = await this.writeLock.lock();
  try {
    return await this._encrypt(passphrase);
  } finally {
    unlock();
  }
};

/**
 * Encrypt the wallet permanently, without a lock.
 * @private
 * @param {String|Buffer} passphrase
 * @returns {Promise}
 */

Wallet.prototype._encrypt = async function _encrypt(passphrase) {
  const key = await this.master.encrypt(passphrase, true);

  this.start();

  try {
    await this.db.encryptKeys(this, key);
  } catch (e) {
    cleanse(key);
    this.drop();
    throw e;
  }

  cleanse(key);

  this.save();

  await this.commit();
};

/**
 * Decrypt the wallet permanently.
 * @param {String|Buffer} passphrase
 * @returns {Promise}
 */

Wallet.prototype.decrypt = async function decrypt(passphrase) {
  const unlock = await this.writeLock.lock();
  try {
    return await this._decrypt(passphrase);
  } finally {
    unlock();
  }
};

/**
 * Decrypt the wallet permanently, without a lock.
 * @private
 * @param {String|Buffer} passphrase
 * @returns {Promise}
 */

Wallet.prototype._decrypt = async function _decrypt(passphrase) {
  const key = await this.master.decrypt(passphrase, true);

  this.start();

  try {
    await this.db.decryptKeys(this, key);
  } catch (e) {
    cleanse(key);
    this.drop();
    throw e;
  }

  cleanse(key);

  this.save();

  await this.commit();
};

/**
 * Generate a new token.
 * @param {(String|Buffer)?} passphrase
 * @returns {Promise}
 */

Wallet.prototype.retoken = async function retoken(passphrase) {
  const unlock = await this.writeLock.lock();
  try {
    return await this._retoken(passphrase);
  } finally {
    unlock();
  }
};

/**
 * Generate a new token without a lock.
 * @private
 * @param {(String|Buffer)?} passphrase
 * @returns {Promise}
 */

Wallet.prototype._retoken = async function _retoken(passphrase) {
  await this.unlock(passphrase);

  this.tokenDepth++;
  this.token = this.getToken(this.tokenDepth);

  this.start();
  this.save();

  await this.commit();

  return this.token;
};

/**
 * Rename the wallet.
 * @param {String} id
 * @returns {Promise}
 */

Wallet.prototype.rename = async function rename(id) {
  const unlock = await this.writeLock.lock();
  try {
    return await this.db.rename(this, id);
  } finally {
    unlock();
  }
};

/**
 * Rename account.
 * @param {(String|Number)?} acct
 * @param {String} name
 * @returns {Promise}
 */

Wallet.prototype.renameAccount = async function renameAccount(acct, name) {
  const unlock = await this.writeLock.lock();
  try {
    return await this._renameAccount(acct, name);
  } finally {
    unlock();
  }
};

/**
 * Rename account without a lock.
 * @private
 * @param {(String|Number)?} acct
 * @param {String} name
 * @returns {Promise}
 */

Wallet.prototype._renameAccount = async function _renameAccount(acct, name) {
  if (!common.isName(name))
    throw new Error('Bad account name.');

  const account = await this.getAccount(acct);

  if (!account)
    throw new Error('Account not found.');

  if (account.accountIndex === 0)
    throw new Error('Cannot rename default account.');

  if (await this.hasAccount(name))
    throw new Error('Account name not available.');

  const old = account.name;

  this.start();

  this.db.renameAccount(account, name);

  await this.commit();

  this.indexCache.remove(old);

  const paths = this.pathCache.values();

  for (const path of paths) {
    if (path.account !== account.accountIndex)
      continue;

    path.name = name;
  }
};

/**
 * Lock the wallet, destroy decrypted key.
 */

Wallet.prototype.lock = async function lock() {
  const unlock1 = await this.writeLock.lock();
  const unlock2 = await this.fundLock.lock();
  try {
    await this.master.lock();
  } finally {
    unlock2();
    unlock1();
  }
};

/**
 * Unlock the key for `timeout` seconds.
 * @param {Buffer|String} passphrase
 * @param {Number?} [timeout=60]
 */

Wallet.prototype.unlock = function unlock(passphrase, timeout) {
  return this.master.unlock(passphrase, timeout);
};

/**
 * Generate the wallet ID if none was passed in.
 * It is represented as HASH160(m/44->public|magic)
 * converted to an "address" with a prefix
 * of `0x03be04` (`WLT` in base58).
 * @private
 * @returns {Base58String}
 */

Wallet.prototype.getID = function getID() {
  assert(this.master.key, 'Cannot derive id.');

  const key = this.master.key.derive(44);

  const bw = new StaticWriter(37);
  bw.writeBytes(key.publicKey);
  bw.writeU32(this.network.magic);

  const hash = digest.hash160(bw.render());

  const b58 = new StaticWriter(27);
  b58.writeU8(0x03);
  b58.writeU8(0xbe);
  b58.writeU8(0x04);
  b58.writeBytes(hash);
  b58.writeChecksum();

  return base58.encode(b58.render());
};

/**
 * Generate the wallet api key if none was passed in.
 * It is represented as HASH256(m/44'->private|nonce).
 * @private
 * @param {HDPrivateKey} master
 * @param {Number} nonce
 * @returns {Buffer}
 */

Wallet.prototype.getToken = function getToken(nonce) {
  assert(this.master.key, 'Cannot derive token.');

  const key = this.master.key.derive(44, true);

  const bw = new StaticWriter(36);
  bw.writeBytes(key.privateKey);
  bw.writeU32(nonce);

  return digest.hash256(bw.render());
};

/**
 * Create an account. Requires passphrase if master key is encrypted.
 * @param {Object} options - See {@link Account} options.
 * @returns {Promise} - Returns {@link Account}.
 */

Wallet.prototype.createAccount = async function createAccount(options, passphrase) {
  const unlock = await this.writeLock.lock();
  try {
    return await this._createAccount(options, passphrase);
  } finally {
    unlock();
  }
};

/**
 * Create an account without a lock.
 * @param {Object} options - See {@link Account} options.
 * @returns {Promise} - Returns {@link Account}.
 */

Wallet.prototype._createAccount = async function _createAccount(options, passphrase) {
  let name = options.name;

  if (!name)
    name = this.accountDepth.toString(10);

  if (await this.hasAccount(name))
    throw new Error('Account already exists.');

  await this.unlock(passphrase);

  let key;
  if (this.watchOnly && options.accountKey) {
    key = options.accountKey;

    if (typeof key === 'string')
      key = HD.PublicKey.fromBase58(key, this.network);

    if (!HD.isPublic(key))
      throw new Error('Must add HD public keys to watch only wallet.');

    assert(key.network === this.network,
      'Network mismatch for watch only key.');
  } else {
    assert(this.master.key);
    key = this.master.key.deriveAccount(44, this.accountDepth);
    key = key.toPublic();
  }

  const opt = {
    wid: this.wid,
    id: this.id,
    name: this.accountDepth === 0 ? 'default' : name,
    witness: options.witness,
    watchOnly: this.watchOnly,
    accountKey: key,
    accountIndex: this.accountDepth,
    type: options.type,
    m: options.m,
    n: options.n,
    keys: options.keys
  };

  this.start();

  let account;
  try {
    account = Account.fromOptions(this.db, opt);
    account.wallet = this;
    await account.init();
  } catch (e) {
    this.drop();
    throw e;
  }

  this.logger.info('Created account %s/%s/%d.',
    account.id,
    account.name,
    account.accountIndex);

  this.accountDepth++;
  this.save();

  await this.commit();

  return account;
};

/**
 * Ensure an account. Requires passphrase if master key is encrypted.
 * @param {Object} options - See {@link Account} options.
 * @returns {Promise} - Returns {@link Account}.
 */

Wallet.prototype.ensureAccount = async function ensureAccount(options, passphrase) {
  const name = options.name;
  const account = await this.getAccount(name);

  if (account)
    return account;

  return await this.createAccount(options, passphrase);
};

/**
 * List account names and indexes from the db.
 * @returns {Promise} - Returns Array.
 */

Wallet.prototype.getAccounts = function getAccounts() {
  return this.db.getAccounts(this.wid);
};

/**
 * Get all wallet address hashes.
 * @param {(String|Number)?} acct
 * @returns {Promise} - Returns Array.
 */

Wallet.prototype.getAddressHashes = function getAddressHashes(acct) {
  if (acct != null)
    return this.getAccountHashes(acct);
  return this.db.getWalletHashes(this.wid);
};

/**
 * Get all account address hashes.
 * @param {String|Number} acct
 * @returns {Promise} - Returns Array.
 */

Wallet.prototype.getAccountHashes = async function getAccountHashes(acct) {
  const index = await this.ensureIndex(acct, true);
  return await this.db.getAccountHashes(this.wid, index);
};

/**
 * Retrieve an account from the database.
 * @param {Number|String} acct
 * @returns {Promise} - Returns {@link Account}.
 */

Wallet.prototype.getAccount = async function getAccount(acct) {
  if (this.account) {
    if (acct === 0 || acct === 'default')
      return this.account;
  }

  const index = await this.getAccountIndex(acct);

  if (index === -1)
    return null;

  const unlock = await this.readLock.lock(index);

  try {
    return await this._getAccount(index);
  } finally {
    unlock();
  }
};

/**
 * Retrieve an account from the database without a lock.
 * @param {Number} index
 * @returns {Promise} - Returns {@link Account}.
 */

Wallet.prototype._getAccount = async function _getAccount(index) {
  const cache = this.accountCache.get(index);

  if (cache)
    return cache;

  const account = await this.db.getAccount(this.wid, index);

  if (!account)
    return null;

  account.wallet = this;
  account.wid = this.wid;
  account.id = this.id;
  account.watchOnly = this.watchOnly;

  await account.open();

  this.accountCache.set(index, account);

  return account;
};

/**
 * Lookup the corresponding account name's index.
 * @param {WalletID} wid
 * @param {String|Number} name - Account name/index.
 * @returns {Promise} - Returns Number.
 */

Wallet.prototype.getAccountIndex = async function getAccountIndex(name) {
  if (name == null)
    return -1;

  if (typeof name === 'number')
    return name;

  const cache = this.indexCache.get(name);

  if (cache != null)
    return cache;

  const index = await this.db.getAccountIndex(this.wid, name);

  if (index === -1)
    return -1;

  this.indexCache.set(name, index);

  return index;
};

/**
 * Lookup the corresponding account index's name.
 * @param {WalletID} wid
 * @param {Number} index - Account index.
 * @returns {Promise} - Returns String.
 */

Wallet.prototype.getAccountName = async function getAccountName(index) {
  if (typeof index === 'string')
    return index;

  const account = this.accountCache.get(index);

  if (account)
    return account.name;

  return await this.db.getAccountName(this.wid, index);
};

/**
 * Test whether an account exists.
 * @param {Number|String} acct
 * @returns {Promise} - Returns {@link Boolean}.
 */

Wallet.prototype.hasAccount = async function hasAccount(acct) {
  const index = await this.getAccountIndex(acct);

  if (index === -1)
    return false;

  if (this.accountCache.has(index))
    return true;

  return await this.db.hasAccount(this.wid, index);
};

/**
 * Create a new receiving address (increments receiveDepth).
 * @param {(Number|String)?} acct
 * @returns {Promise} - Returns {@link WalletKey}.
 */

Wallet.prototype.createReceive = function createReceive(acct) {
  return this.createKey(acct, 0);
};

/**
 * Create a new change address (increments receiveDepth).
 * @param {(Number|String)?} acct
 * @returns {Promise} - Returns {@link WalletKey}.
 */

Wallet.prototype.createChange = function createChange(acct) {
  return this.createKey(acct, 1);
};

/**
 * Create a new nested address (increments receiveDepth).
 * @param {(Number|String)?} acct
 * @returns {Promise} - Returns {@link WalletKey}.
 */

Wallet.prototype.createNested = function createNested(acct) {
  return this.createKey(acct, 2);
};

/**
 * Create a new address (increments depth).
 * @param {(Number|String)?} acct
 * @param {Number} branch
 * @returns {Promise} - Returns {@link WalletKey}.
 */

Wallet.prototype.createKey = async function createKey(acct, branch) {
  const unlock = await this.writeLock.lock();
  try {
    return await this._createKey(acct, branch);
  } finally {
    unlock();
  }
};

/**
 * Create a new address (increments depth) without a lock.
 * @private
 * @param {(Number|String)?} acct
 * @param {Number} branche
 * @returns {Promise} - Returns {@link WalletKey}.
 */

Wallet.prototype._createKey = async function _createKey(acct, branch) {
  if (branch == null) {
    branch = acct;
    acct = null;
  }

  if (acct == null)
    acct = 0;

  const account = await this.getAccount(acct);

  if (!account)
    throw new Error('Account not found.');

  this.start();

  let result;
  try {
    result = await account.createKey(branch);
  } catch (e) {
    this.drop();
    throw e;
  }

  await this.commit();

  return result;
};

/**
 * Save the wallet to the database. Necessary
 * when address depth and keys change.
 * @returns {Promise}
 */

Wallet.prototype.save = function save() {
  return this.db.save(this);
};

/**
 * Start batch.
 * @private
 */

Wallet.prototype.start = function start() {
  return this.db.start(this);
};

/**
 * Drop batch.
 * @private
 */

Wallet.prototype.drop = function drop() {
  return this.db.drop(this);
};

/**
 * Clear batch.
 * @private
 */

Wallet.prototype.clear = function clear() {
  return this.db.clear(this);
};

/**
 * Save batch.
 * @returns {Promise}
 */

Wallet.prototype.commit = function commit() {
  return this.db.commit(this);
};

/**
 * Test whether the wallet possesses an address.
 * @param {Address|Hash} address
 * @returns {Promise} - Returns Boolean.
 */

Wallet.prototype.hasAddress = async function hasAddress(address) {
  const hash = Address.getHash(address, 'hex');
  const path = await this.getPath(hash);
  return path != null;
};

/**
 * Get path by address hash.
 * @param {Address|Hash} address
 * @returns {Promise} - Returns {@link Path}.
 */

Wallet.prototype.getPath = async function getPath(address) {
  const path = await this.readPath(address);

  if (!path)
    return null;

  path.name = await this.getAccountName(path.account);

  assert(path.name);

  this.pathCache.set(path.hash, path);

  return path;
};

/**
 * Get path by address hash (without account name).
 * @private
 * @param {Address|Hash} address
 * @returns {Promise} - Returns {@link Path}.
 */

Wallet.prototype.readPath = async function readPath(address) {
  const hash = Address.getHash(address, 'hex');
  const cache = this.pathCache.get(hash);

  if (cache)
    return cache;

  const path = await this.db.getPath(this.wid, hash);

  if (!path)
    return null;

  path.id = this.id;

  return path;
};

/**
 * Test whether the wallet contains a path.
 * @param {Address|Hash} address
 * @returns {Promise} - Returns {Boolean}.
 */

Wallet.prototype.hasPath = async function hasPath(address) {
  const hash = Address.getHash(address, 'hex');

  if (this.pathCache.has(hash))
    return true;

  return await this.db.hasPath(this.wid, hash);
};

/**
 * Get all wallet paths.
 * @param {(String|Number)?} acct
 * @returns {Promise} - Returns {@link Path}.
 */

Wallet.prototype.getPaths = async function getPaths(acct) {
  if (acct != null)
    return await this.getAccountPaths(acct);

  const paths = await this.db.getWalletPaths(this.wid);
  const result = [];

  for (const path of paths) {
    path.id = this.id;
    path.name = await this.getAccountName(path.account);

    assert(path.name);

    this.pathCache.set(path.hash, path);

    result.push(path);
  }

  return result;
};

/**
 * Get all account paths.
 * @param {String|Number} acct
 * @returns {Promise} - Returns {@link Path}.
 */

Wallet.prototype.getAccountPaths = async function getAccountPaths(acct) {
  const index = await this.ensureIndex(acct, true);
  const hashes = await this.getAccountHashes(index);
  const name = await this.getAccountName(acct);

  assert(name);

  const result = [];

  for (const hash of hashes) {
    const path = await this.readPath(hash);

    assert(path);
    assert(path.account === index);

    path.name = name;

    this.pathCache.set(path.hash, path);

    result.push(path);
  }

  return result;
};

/**
 * Import a keyring (will not exist on derivation chain).
 * Rescanning must be invoked manually.
 * @param {(String|Number)?} acct
 * @param {WalletKey} ring
 * @param {(String|Buffer)?} passphrase
 * @returns {Promise}
 */

Wallet.prototype.importKey = async function importKey(acct, ring, passphrase) {
  const unlock = await this.writeLock.lock();
  try {
    return await this._importKey(acct, ring, passphrase);
  } finally {
    unlock();
  }
};

/**
 * Import a keyring (will not exist on derivation chain) without a lock.
 * @private
 * @param {(String|Number)?} acct
 * @param {WalletKey} ring
 * @param {(String|Buffer)?} passphrase
 * @returns {Promise}
 */

Wallet.prototype._importKey = async function _importKey(acct, ring, passphrase) {
  if (acct && typeof acct === 'object') {
    passphrase = ring;
    ring = acct;
    acct = null;
  }

  if (acct == null)
    acct = 0;

  assert(ring.network === this.network,
    'Network mismatch for key.');

  if (!this.watchOnly) {
    if (!ring.privateKey)
      throw new Error('Cannot import pubkey into non watch-only wallet.');
  } else {
    if (ring.privateKey)
      throw new Error('Cannot import privkey into watch-only wallet.');
  }

  const hash = ring.getHash('hex');

  if (await this.getPath(hash))
    throw new Error('Key already exists.');

  const account = await this.getAccount(acct);

  if (!account)
    throw new Error('Account not found.');

  if (account.type !== Account.types.PUBKEYHASH)
    throw new Error('Cannot import into non-pkh account.');

  await this.unlock(passphrase);

  const key = WalletKey.fromRing(account, ring);
  const path = key.toPath();

  if (this.master.encrypted) {
    path.data = this.master.encipher(path.data, path.hash);
    assert(path.data);
    path.encrypted = true;
  }

  this.start();

  try {
    await account.savePath(path);
  } catch (e) {
    this.drop();
    throw e;
  }

  await this.commit();
};

/**
 * Import a keyring (will not exist on derivation chain).
 * Rescanning must be invoked manually.
 * @param {(String|Number)?} acct
 * @param {WalletKey} ring
 * @param {(String|Buffer)?} passphrase
 * @returns {Promise}
 */

Wallet.prototype.importAddress = async function importAddress(acct, address) {
  const unlock = await this.writeLock.lock();
  try {
    return await this._importAddress(acct, address);
  } finally {
    unlock();
  }
};

/**
 * Import a keyring (will not exist on derivation chain) without a lock.
 * @private
 * @param {(String|Number)?} acct
 * @param {WalletKey} ring
 * @param {(String|Buffer)?} passphrase
 * @returns {Promise}
 */

Wallet.prototype._importAddress = async function _importAddress(acct, address) {
  if (!address) {
    address = acct;
    acct = null;
  }

  if (acct == null)
    acct = 0;

  assert(address.network === this.network,
    'Network mismatch for address.');

  if (!this.watchOnly)
    throw new Error('Cannot import address into non watch-only wallet.');

  if (await this.getPath(address))
    throw new Error('Address already exists.');

  const account = await this.getAccount(acct);

  if (!account)
    throw new Error('Account not found.');

  if (account.type !== Account.types.PUBKEYHASH)
    throw new Error('Cannot import into non-pkh account.');

  const path = Path.fromAddress(account, address);

  this.start();

  try {
    await account.savePath(path);
  } catch (e) {
    this.drop();
    throw e;
  }

  await this.commit();
};

/**
 * Fill a transaction with inputs, estimate
 * transaction size, calculate fee, and add a change output.
 * @see MTX#selectCoins
 * @see MTX#fill
 * @param {MTX} mtx - _Must_ be a mutable transaction.
 * @param {Object?} options
 * @param {(String|Number)?} options.account - If no account is
 * specified, coins from the entire wallet will be filled.
 * @param {String?} options.selection - Coin selection priority. Can
 * be `age`, `random`, or `all`. (default=age).
 * @param {Boolean} options.round - Whether to round to the nearest
 * kilobyte for fee calculation.
 * See {@link TX#getMinFee} vs. {@link TX#getRoundFee}.
 * @param {Rate} options.rate - Rate used for fee calculation.
 * @param {Boolean} options.confirmed - Select only confirmed coins.
 * @param {Boolean} options.free - Do not apply a fee if the
 * transaction priority is high enough to be considered free.
 * @param {Amount?} options.hardFee - Use a hard fee rather than
 * calculating one.
 * @param {Number|Boolean} options.subtractFee - Whether to subtract the
 * fee from existing outputs rather than adding more inputs.
 */

Wallet.prototype.fund = async function fund(mtx, options, force) {
  const unlock = await this.fundLock.lock(force);
  try {
    return await this._fund(mtx, options);
  } finally {
    unlock();
  }
};

/**
 * Fill a transaction with inputs without a lock.
 * @private
 * @see MTX#selectCoins
 * @see MTX#fill
 */

Wallet.prototype._fund = async function _fund(mtx, options) {
  if (!options)
    options = {};

  if (!this.initialized)
    throw new Error('Wallet is not initialized.');

  if (this.watchOnly)
    throw new Error('Cannot fund from watch-only wallet.');

  let account;
  if (options.account != null) {
    account = await this.getAccount(options.account);
    if (!account)
      throw new Error('Account not found.');
  } else {
    account = this.account;
  }

  if (!account.initialized)
    throw new Error('Account is not initialized.');

  let rate = options.rate;
  if (rate == null)
    rate = await this.db.estimateFee(options.blocks);

  let coins;
  if (options.smart) {
    coins = await this.getSmartCoins(options.account);
  } else {
    coins = await this.getCoins(options.account);
    coins = this.txdb.filterLocked(coins);
  }

  await mtx.fund(coins, {
    selection: options.selection,
    round: options.round,
    depth: options.depth,
    hardFee: options.hardFee,
    subtractFee: options.subtractFee,
    subtractIndex: options.subtractIndex,
    changeAddress: account.change.getAddress(),
    height: this.db.state.height,
    rate: rate,
    maxFee: options.maxFee,
    estimate: prev => this.estimateSize(prev)
  });

  assert(mtx.getFee() <= MTX.Selector.MAX_FEE, 'TX exceeds MAX_FEE.');
};

/**
 * Get account by address.
 * @param {Address} address
 * @returns {Account}
 */

Wallet.prototype.getAccountByAddress = async function getAccountByAddress(address) {
  const hash = Address.getHash(address, 'hex');
  const path = await this.getPath(hash);

  if (!path)
    return null;

  return await this.getAccount(path.account);
};

/**
 * Input size estimator for max possible tx size.
 * @param {Script} prev
 * @returns {Number}
 */

Wallet.prototype.estimateSize = async function estimateSize(prev) {
  const scale = consensus.WITNESS_SCALE_FACTOR;
  const address = prev.getAddress();

  if (!address)
    return -1;

  const account = await this.getAccountByAddress(address);

  if (!account)
    return -1;

  let size = 0;

  if (prev.isScripthash()) {
    // Nested bullshit.
    if (account.witness) {
      switch (account.type) {
        case Account.types.PUBKEYHASH:
          size += 23; // redeem script
          size *= 4; // vsize
          break;
        case Account.types.MULTISIG:
          size += 35; // redeem script
          size *= 4; // vsize
          break;
      }
    }
  }

  switch (account.type) {
    case Account.types.PUBKEYHASH:
      // P2PKH
      // OP_PUSHDATA0 [signature]
      size += 1 + 73;
      // OP_PUSHDATA0 [key]
      size += 1 + 33;
      break;
    case Account.types.MULTISIG:
      // P2SH Multisig
      // OP_0
      size += 1;
      // OP_PUSHDATA0 [signature] ...
      size += (1 + 73) * account.m;
      // OP_PUSHDATA2 [redeem]
      size += 3;
      // m value
      size += 1;
      // OP_PUSHDATA0 [key] ...
      size += (1 + 33) * account.n;
      // n value
      size += 1;
      // OP_CHECKMULTISIG
      size += 1;
      break;
  }

  if (account.witness) {
    // Varint witness items length.
    size += 1;
    // Calculate vsize if
    // we're a witness program.
    size = (size + scale - 1) / scale | 0;
  } else {
    // Byte for varint
    // size of input script.
    size += encoding.sizeVarint(size);
  }

  return size;
};

/**
 * Build a transaction, fill it with outputs and inputs,
 * sort the members according to BIP69 (set options.sort=false
 * to avoid sorting), set locktime, and template it.
 * @param {Object} options - See {@link Wallet#fund options}.
 * @param {Object[]} options.outputs - See {@link MTX#addOutput}.
 * @returns {Promise} - Returns {@link MTX}.
 */

Wallet.prototype.createTX = async function createTX(options, force) {
  const outputs = options.outputs;
  const mtx = new MTX();

  assert(Array.isArray(outputs), 'Outputs must be an array.');
  assert(outputs.length > 0, 'No outputs available.');

  // Add the outputs
  for (const obj of outputs) {
    const output = new Output(obj);
    const addr = output.getAddress();

    if (output.isDust())
      throw new Error('Output is dust.');

    if (output.value > 0) {
      if (!addr)
        throw new Error('Cannot send to unknown address.');

      if (addr.isNull())
        throw new Error('Cannot send to null address.');
    }

    mtx.outputs.push(output);
  }

  // Fill the inputs with unspents
  await this.fund(mtx, options, force);

  // Sort members a la BIP69
  if (options.sort !== false)
    mtx.sortMembers();

  // Set the locktime to target value.
  if (options.locktime != null)
    mtx.setLocktime(options.locktime);

  // Consensus sanity checks.
  assert(mtx.isSane(this.db.state.height + 1),
    'TX failed sanity check.'); // check this
  assert(mtx.verifyInputs(this.db.state.height + 1),
    'TX failed context check.');

  const total = await this.template(mtx);

  //if (total === 0)
  //  throw new Error('Templating failed.');

  return mtx;
};

/**
 * Build a transaction, fill it with outputs and inputs,
 * sort the members according to BIP69, set locktime,
 * sign and broadcast. Doing this all in one go prevents
 * coins from being double spent.
 * @param {Object} options - See {@link Wallet#fund options}.
 * @param {Object[]} options.outputs - See {@link MTX#addOutput}.
 * @returns {Promise} - Returns {@link TX}.
 */

Wallet.prototype.send = async function send(options, passphrase) {
  const unlock = await this.fundLock.lock();
  try {
    return await this._send(options, passphrase);
  } finally {
    unlock();
  }
};

/**
 * Build and send a transaction without a lock.
 * @private
 * @param {Object} options - See {@link Wallet#fund options}.
 * @param {Object[]} options.outputs - See {@link MTX#addOutput}.
 * @returns {Promise} - Returns {@link TX}.
 */

Wallet.prototype._send = async function _send(options, passphrase) {
  const mtx = await this.createTX(options, true);

  await this.sign(mtx, passphrase);

  if (!mtx.isSigned())
    throw new Error('TX could not be fully signed.');

  const tx = mtx.toTX();

  // Policy sanity checks.
  if (tx.getSigopsCost(mtx.view) > policy.MAX_TX_SIGOPS_COST)
    throw new Error('TX exceeds policy sigops.');

  if (tx.getWeight() > policy.MAX_TX_WEIGHT)
    throw new Error('TX exceeds policy weight.');

  await this.db.addTX(tx);

  this.logger.debug('Sending wallet tx (%s): %s', this.id, tx.txid());

  await this.db.send(tx);

  return tx;
};

/**
 * Intentionally double-spend outputs by
 * increasing fee for an existing transaction.
 * @param {Hash} hash
 * @param {Rate} rate
 * @param {(String|Buffer)?} passphrase
 * @returns {Promise} - Returns {@link TX}.
 */

Wallet.prototype.increaseFee = async function increaseFee(hash, rate, passphrase) {
  assert(util.isU32(rate), 'Rate must be a number.');

  const wtx = await this.getTX(hash);

  if (!wtx)
    throw new Error('Transaction not found.');

  if (wtx.height !== -1)
    throw new Error('Transaction is confirmed.');

  const tx = wtx.tx;

  if (tx.isCoinbase())
    throw new Error('Transaction is a coinbase.');

  const view = await this.getSpentView(tx);

  if (!tx.hasCoins(view))
    throw new Error('Not all coins available.');

  const oldFee = tx.getFee(view);

  let fee = tx.getMinFee(null, rate);

  if (fee > MTX.Selector.MAX_FEE)
    fee = MTX.Selector.MAX_FEE;

  if (oldFee >= fee)
    throw new Error('Fee is not increasing.');

  const mtx = MTX.fromTX(tx);
  mtx.view = view;

  for (const input of mtx.inputs) {
    input.script.clear();
    input.witness.clear();
  }

  let change;
  for (let i = 0; i < mtx.outputs.length; i++) {
    const output = mtx.outputs[i];
    const addr = output.getAddress();

    if (!addr)
      continue;

    const path = await this.getPath(addr);

    if (!path)
      continue;

    if (path.branch === 1) {
      change = output;
      mtx.changeIndex = i;
      break;
    }
  }

  if (!change)
    throw new Error('No change output.');

  change.value += oldFee;

  if (mtx.getFee() !== 0)
    throw new Error('Arithmetic error for change.');

  change.value -= fee;

  if (change.value < 0)
    throw new Error('Fee is too high.');

  if (change.isDust()) {
    mtx.outputs.splice(mtx.changeIndex, 1);
    mtx.changeIndex = -1;
  }

  await this.sign(mtx, passphrase);

  if (!mtx.isSigned())
    throw new Error('TX could not be fully signed.');

  const ntx = mtx.toTX();

  this.logger.debug(
    'Increasing fee for wallet tx (%s): %s',
    this.id, ntx.txid());

  await this.db.addTX(ntx);
  await this.db.send(ntx);

  return ntx;
};

/**
 * Resend pending wallet transactions.
 * @returns {Promise}
 */

Wallet.prototype.resend = async function resend() {
  const wtxs = await this.getPending();

  if (wtxs.length > 0)
    this.logger.info('Rebroadcasting %d transactions.', wtxs.length);

  const txs = [];

  for (const wtx of wtxs)
    txs.push(wtx.tx);

  const sorted = common.sortDeps(txs);

  for (const tx of sorted)
    await this.db.send(tx);

  return txs;
};

/**
 * Derive necessary addresses for signing a transaction.
 * @param {MTX} mtx
 * @param {Number?} index - Input index.
 * @returns {Promise} - Returns {@link WalletKey}[].
 */

Wallet.prototype.deriveInputs = async function deriveInputs(mtx) {
  assert(mtx.mutable);

  const paths = await this.getInputPaths(mtx);
  const rings = [];

  for (const path of paths) {
    const account = await this.getAccount(path.account);

    if (!account)
      continue;

    const ring = account.derivePath(path, this.master);

    if (ring)
      rings.push(ring);
  }

  return rings;
};

/**
 * Retrieve a single keyring by address.
 * @param {Address|Hash} hash
 * @returns {Promise}
 */

Wallet.prototype.getKey = async function getKey(address) {
  const hash = Address.getHash(address, 'hex');
  const path = await this.getPath(hash);

  if (!path)
    return null;

  const account = await this.getAccount(path.account);

  if (!account)
    return null;

  return account.derivePath(path, this.master);
};

/**
 * Retrieve a single keyring by address
 * (with the private key reference).
 * @param {Address|Hash} hash
 * @param {(Buffer|String)?} passphrase
 * @returns {Promise}
 */

Wallet.prototype.getPrivateKey = async function getPrivateKey(address, passphrase) {
  const hash = Address.getHash(address, 'hex');
  const path = await this.getPath(hash);

  if (!path)
    return null;

  const account = await this.getAccount(path.account);

  if (!account)
    return null;

  await this.unlock(passphrase);

  const key = account.derivePath(path, this.master);

  if (!key.privateKey)
    return null;

  return key;
};

/**
 * Map input addresses to paths.
 * @param {MTX} mtx
 * @returns {Promise} - Returns {@link Path}[].
 */

Wallet.prototype.getInputPaths = async function getInputPaths(mtx) {
  assert(mtx.mutable);

  if (!mtx.hasCoins())
    throw new Error('Not all coins available.');

  const hashes = mtx.getInputHashes('hex');
  const paths = [];

  for (const hash of hashes) {
    const path = await this.getPath(hash);
    if (path)
      paths.push(path);
  }

  return paths;
};

/**
 * Map output addresses to paths.
 * @param {TX} tx
 * @returns {Promise} - Returns {@link Path}[].
 */

Wallet.prototype.getOutputPaths = async function getOutputPaths(tx) {
  const paths = [];
  const hashes = tx.getOutputHashes('hex');

  for (const hash of hashes) {
    const path = await this.getPath(hash);
    if (path)
      paths.push(path);
  }

  return paths;
};

/**
 * Increase lookahead for account.
 * @param {(Number|String)?} account
 * @param {Number} lookahead
 * @returns {Promise}
 */

Wallet.prototype.setLookahead = async function setLookahead(acct, lookahead) {
  const unlock = await this.writeLock.lock();
  try {
    return this._setLookahead(acct, lookahead);
  } finally {
    unlock();
  }
};

/**
 * Increase lookahead for account (without a lock).
 * @private
 * @param {(Number|String)?} account
 * @param {Number} lookahead
 * @returns {Promise}
 */

Wallet.prototype._setLookahead = async function _setLookahead(acct, lookahead) {
  if (lookahead == null) {
    lookahead = acct;
    acct = null;
  }

  if (acct == null)
    acct = 0;

  const account = await this.getAccount(acct);

  if (!account)
    throw new Error('Account not found.');

  this.start();

  try {
    await account.setLookahead(lookahead);
  } catch (e) {
    this.drop();
    throw e;
  }

  await this.commit();
};

/**
 * Sync address depths based on a transaction's outputs.
 * This is used for deriving new addresses when
 * a confirmed transaction is seen.
 * @param {Details} details
 * @returns {Promise}
 */

Wallet.prototype.syncOutputDepth = async function syncOutputDepth(details) {
  const map = new Map();

  for (const output of details.outputs) {
    const path = output.path;

    if (!path)
      continue;

    if (path.index === -1)
      continue;

    if (!map.has(path.account))
      map.set(path.account, []);

    map.get(path.account).push(path);
  }

  const derived = [];

  for (const [acct, paths] of map) {
    let receive = -1;
    let change = -1;
    let nested = -1;

    for (const path of paths) {
      switch (path.branch) {
        case 0:
          if (path.index > receive)
            receive = path.index;
          break;
        case 1:
          if (path.index > change)
            change = path.index;
          break;
        case 2:
          if (path.index > nested)
            nested = path.index;
          break;
      }
    }

    receive += 2;
    change += 2;
    nested += 2;

    const account = await this.getAccount(acct);
    assert(account);

    const ring = await account.syncDepth(receive, change, nested);

    if (ring)
      derived.push(ring);
  }

  return derived;
};

/**
 * Get a redeem script or witness script by hash.
 * @param {Hash} hash - Can be a ripemd160 or a sha256.
 * @returns {Script}
 */

Wallet.prototype.getRedeem = async function getRedeem(hash) {
  if (typeof hash === 'string')
    hash = Buffer.from(hash, 'hex');

  const ring = await this.getKey(hash.toString('hex'));

  if (!ring)
    return null;

  return ring.getRedeem(hash);
};

/**
 * Build input scripts templates for a transaction (does not
 * sign, only creates signature slots). Only builds scripts
 * for inputs that are redeemable by this wallet.
 * @param {MTX} mtx
 * @returns {Promise} - Returns Number
 * (total number of scripts built).
 */

Wallet.prototype.template = async function template(mtx) {
  const rings = await this.deriveInputs(mtx);
  return mtx.template(rings);
};

/**
 * Build input scripts and sign inputs for a transaction. Only attempts
 * to build/sign inputs that are redeemable by this wallet.
 * @param {MTX} tx
 * @param {Object|String|Buffer} options - Options or passphrase.
 * @returns {Promise} - Returns Number (total number
 * of inputs scripts built and signed).
 */

Wallet.prototype.sign = async function sign(mtx, passphrase) {
  if (this.watchOnly)
    throw new Error('Cannot sign from a watch-only wallet.');

  await this.unlock(passphrase);

  const rings = await this.deriveInputs(mtx);

  return await mtx.signAsync(rings, Script.hashType.ALL, this.db.workers);
};

/**
 * Get a coin viewpoint.
 * @param {TX} tx
 * @returns {Promise} - Returns {@link CoinView}.
 */

Wallet.prototype.getCoinView = function getCoinView(tx) {
  return this.txdb.getCoinView(tx);
};

/**
 * Get a historical coin viewpoint.
 * @param {TX} tx
 * @returns {Promise} - Returns {@link CoinView}.
 */

Wallet.prototype.getSpentView = function getSpentView(tx) {
  return this.txdb.getSpentView(tx);
};

/**
 * Convert transaction to transaction details.
 * @param {TXRecord} wtx
 * @returns {Promise} - Returns {@link Details}.
 */

Wallet.prototype.toDetails = function toDetails(wtx) {
  return this.txdb.toDetails(wtx);
};

/**
 * Get transaction details.
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link Details}.
 */

Wallet.prototype.getDetails = function getDetails(hash) {
  return this.txdb.getDetails(hash);
};

/**
 * Get a coin from the wallet.
 * @param {Hash} hash
 * @param {Number} index
 * @returns {Promise} - Returns {@link Coin}.
 */

Wallet.prototype.getCoin = function getCoin(hash, index) {
  return this.txdb.getCoin(hash, index);
};

/**
 * Get a transaction from the wallet.
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link TX}.
 */

Wallet.prototype.getTX = function getTX(hash) {
  return this.txdb.getTX(hash);
};

/**
 * List blocks for the wallet.
 * @returns {Promise} - Returns {@link BlockRecord}.
 */

Wallet.prototype.getBlocks = function getBlocks() {
  return this.txdb.getBlocks();
};

/**
 * Get a block from the wallet.
 * @param {Number} height
 * @returns {Promise} - Returns {@link BlockRecord}.
 */

Wallet.prototype.getBlock = function getBlock(height) {
  return this.txdb.getBlock(height);
};

/**
 * Add a transaction to the wallets TX history.
 * @param {TX} tx
 * @returns {Promise}
 */

Wallet.prototype.add = async function add(tx, block) {
  const unlock = await this.writeLock.lock();
  try {
    return await this._add(tx, block);
  } finally {
    unlock();
  }
};

/**
 * Add a transaction to the wallet without a lock.
 * Potentially resolves orphans.
 * @private
 * @param {TX} tx
 * @returns {Promise}
 */

Wallet.prototype._add = async function _add(tx, block) {
  this.txdb.start();

  let details, derived;
  try {
    details = await this.txdb._add(tx, block);
    if (details)
      derived = await this.syncOutputDepth(details);
  } catch (e) {
    this.txdb.drop();
    throw e;
  }

  await this.txdb.commit();

  if (derived && derived.length > 0) {
    this.db.emit('address', this.id, derived);
    this.emit('address', derived);
  }

  return details;
};

/**
 * Unconfirm a wallet transcation.
 * @param {Hash} hash
 * @returns {Promise}
 */

Wallet.prototype.unconfirm = async function unconfirm(hash) {
  const unlock = await this.writeLock.lock();
  try {
    return await this.txdb.unconfirm(hash);
  } finally {
    unlock();
  }
};

/**
 * Remove a wallet transaction.
 * @param {Hash} hash
 * @returns {Promise}
 */

Wallet.prototype.remove = async function remove(hash) {
  const unlock = await this.writeLock.lock();
  try {
    return await this.txdb.remove(hash);
  } finally {
    unlock();
  }
};

/**
 * Zap stale TXs from wallet.
 * @param {(Number|String)?} acct
 * @param {Number} age - Age threshold (unix time, default=72 hours).
 * @returns {Promise}
 */

Wallet.prototype.zap = async function zap(acct, age) {
  const unlock = await this.writeLock.lock();
  try {
    return await this._zap(acct, age);
  } finally {
    unlock();
  }
};

/**
 * Zap stale TXs from wallet without a lock.
 * @private
 * @param {(Number|String)?} acct
 * @param {Number} age
 * @returns {Promise}
 */

Wallet.prototype._zap = async function _zap(acct, age) {
  const account = await this.ensureIndex(acct);
  return await this.txdb.zap(account, age);
};

/**
 * Abandon transaction.
 * @param {Hash} hash
 * @returns {Promise}
 */

Wallet.prototype.abandon = async function abandon(hash) {
  const unlock = await this.writeLock.lock();
  try {
    return await this._abandon(hash);
  } finally {
    unlock();
  }
};

/**
 * Abandon transaction without a lock.
 * @private
 * @param {Hash} hash
 * @returns {Promise}
 */

Wallet.prototype._abandon = function _abandon(hash) {
  return this.txdb.abandon(hash);
};

/**
 * Lock a single coin.
 * @param {Coin|Outpoint} coin
 */

Wallet.prototype.lockCoin = function lockCoin(coin) {
  return this.txdb.lockCoin(coin);
};

/**
 * Unlock a single coin.
 * @param {Coin|Outpoint} coin
 */

Wallet.prototype.unlockCoin = function unlockCoin(coin) {
  return this.txdb.unlockCoin(coin);
};

/**
 * Test locked status of a single coin.
 * @param {Coin|Outpoint} coin
 */

Wallet.prototype.isLocked = function isLocked(coin) {
  return this.txdb.isLocked(coin);
};

/**
 * Return an array of all locked outpoints.
 * @returns {Outpoint[]}
 */

Wallet.prototype.getLocked = function getLocked() {
  return this.txdb.getLocked();
};

/**
 * Get all transactions in transaction history.
 * @param {(String|Number)?} acct
 * @returns {Promise} - Returns {@link TX}[].
 */

Wallet.prototype.getHistory = async function getHistory(acct) {
  const account = await this.ensureIndex(acct);
  return this.txdb.getHistory(account);
};

/**
 * Get all available coins.
 * @param {(String|Number)?} account
 * @returns {Promise} - Returns {@link Coin}[].
 */

Wallet.prototype.getCoins = async function getCoins(acct) {
  const account = await this.ensureIndex(acct);
  return await this.txdb.getCoins(account);
};

/**
 * Get all available credits.
 * @param {(String|Number)?} account
 * @returns {Promise} - Returns {@link Credit}[].
 */

Wallet.prototype.getCredits = async function getCredits(acct) {
  const account = await this.ensureIndex(acct);
  return await this.txdb.getCredits(account);
};

/**
 * Get "smart" coins.
 * @param {(String|Number)?} account
 * @returns {Promise} - Returns {@link Coin}[].
 */

Wallet.prototype.getSmartCoins = async function getSmartCoins(acct) {
  const credits = await this.getCredits(acct);
  const coins = [];

  for (const credit of credits) {
    const coin = credit.coin;

    if (credit.spent)
      continue;

    if (this.txdb.isLocked(coin))
      continue;

    // Always used confirmed coins.
    if (coin.height !== -1) {
      coins.push(coin);
      continue;
    }

    // Use unconfirmed only if they were
    // created as a result of one of our
    // _own_ transactions. i.e. they're
    // not low-fee and not in danger of
    // being double-spent by a bad actor.
    if (!credit.own)
      continue;

    coins.push(coin);
  }

  return coins;
};

/**
 * Get all pending/unconfirmed transactions.
 * @param {(String|Number)?} acct
 * @returns {Promise} - Returns {@link TX}[].
 */

Wallet.prototype.getPending = async function getPending(acct) {
  const account = await this.ensureIndex(acct);
  return await this.txdb.getPending(account);
};

/**
 * Get all pending/unconfirmed transactions.
 * @param {(String|Number)?} acct
 * @returns {Promise} - Returns {@link TXDetails}[].
 */

Wallet.prototype.getPendingDetails = async function getPendingDetails(acct) {
  const account = await this.ensureIndex(acct);
  return await this.txdb.getPendingDetails(account);
};

/**
 * Get wallet balance.
 * @param {(String|Number)?} acct
 * @returns {Promise} - Returns {@link Balance}.
 */

Wallet.prototype.getBalance = async function getBalance(acct) {
  const account = await this.ensureIndex(acct);
  return await this.txdb.getBalance(account);
};

/**
 * Get wallet balance details.
 * @param {(String|Number)?} acct
 * @returns {Promise} - Returns {@link BalanceDetails}.
 */

Wallet.prototype.getBalanceDetails = async function getBalanceDetails(acct) {
  const account = await this.ensureIndex(acct);
  return await this.txdb.getBalanceDetails(account);
};

/**
 * Get a range of transactions between two timestamps.
 * @param {(String|Number)?} acct
 * @param {Object} options
 * @param {Number} options.start
 * @param {Number} options.end
 * @returns {Promise} - Returns {@link TX}[].
 */

Wallet.prototype.getRange = async function getRange(acct, options) {
  if (acct && typeof acct === 'object') {
    options = acct;
    acct = null;
  }
  const account = await this.ensureIndex(acct);
  return await this.txdb.getRange(account, options);
};

/**
 * Get the last N transactions.
 * @param {(String|Number)?} acct
 * @param {Number} limit
 * @returns {Promise} - Returns {@link TX}[].
 */

Wallet.prototype.getLast = async function getLast(acct, limit) {
  const account = await this.ensureIndex(acct);
  return await this.txdb.getLast(account, limit);
};

/**
 * Get last N start from M of the transactions.
 * @param {(String|Number)?} acct
 * @param {Number} limit
 * @param {Number} offset
 * @returns {Promise} - Returns {@link TX}[].
 */

Wallet.prototype.getTransactions = async function getTransactions(acct, limit, offset) {
  const account = await this.ensureIndex(acct);
  return await this.txdb.getTransactions(account, limit, offset);
};

/**
 * Get total number of transactions.
 * @param {(String|Number)?} acct
 * @returns {Promise} - Returns Number.
 */

Wallet.prototype.getTotal = async function getTotal(acct) {
  const account = await this.ensureIndex(acct);
  return await this.txdb.getTotal(account);
};

/**
 * Resolve account index.
 * @private
 * @param {(Number|String)?} acct
 * @param {Function} errback - Returns [Error].
 * @returns {Promise}
 */

Wallet.prototype.ensureIndex = async function ensureIndex(acct, enforce) {
  if (acct == null) {
    if (enforce)
      throw new Error('No account provided.');
    return null;
  }

  const index = await this.getAccountIndex(acct);

  if (index === -1)
    throw new Error('Account not found.');

  return index;
};

/**
 * Get current receive address.
 * @param {String?} enc - `"base58"` or `null`.
 * @returns {Address|Base58Address}
 */

Wallet.prototype.getAddress = function getAddress(enc) {
  return this.account.getAddress(enc);
};

/**
 * Get current receive address.
 * @param {String?} enc - `"base58"` or `null`.
 * @returns {Address|Base58Address}
 */

Wallet.prototype.getReceive = function getReceive(enc) {
  return this.account.getReceive(enc);
};

/**
 * Get current change address.
 * @param {String?} enc - `"base58"` or `null`.
 * @returns {Address|Base58Address}
 */

Wallet.prototype.getChange = function getChange(enc) {
  return this.account.getChange(enc);
};

/**
 * Get current nested address.
 * @param {String?} enc - `"base58"` or `null`.
 * @returns {Address|Base58Address}
 */

Wallet.prototype.getNested = function getNested(enc) {
  return this.account.getNested(enc);
};

/**
 * Get unsave receive address.
 * @param {String?} enc - `"base58"` or `null`.
 * @returns {Address|Base58Address}
 */

Wallet.prototype.getTempReceive = function getTempReceive(enc) {
  return this.account.getTempReceive(enc);
};

/**
 * Convert the wallet to a more inspection-friendly object.
 * @returns {Object}
 */

Wallet.prototype.inspect = function inspect() {
  return {
    wid: this.wid,
    id: this.id,
    network: this.network.type,
    initialized: this.initialized,
    accountDepth: this.accountDepth,
    token: this.token.toString('hex'),
    tokenDepth: this.tokenDepth,
    lock: this.lock.toString('hex'),
    chksum: this.chksum.toString('hex'),
    state: this.txdb.state ? this.txdb.state.toJSON(true) : null,
    master: this.master,
    account: this.account
  };
};

/**
 * Convert the wallet to an object suitable for
 * serialization.
 * @param {Boolean?} unsafe - Whether to include
 * the master key in the JSON.
 * @returns {Object}
 */

Wallet.prototype.toJSON = function toJSON(unsafe) {
  return {
    network: this.network.type,
    wid: this.wid,
    id: this.id,
    initialized: this.initialized,
    watchOnly: this.watchOnly,
    accountDepth: this.accountDepth,
    token: this.token.toString('hex'),
    tokenDepth: this.tokenDepth,
    lock: this.lock.toString('hex'),
    chksum: this.chksum.toString('hex'),
    state: this.txdb.state.toJSON(true),
    master: this.master.toJSON(unsafe),
    account: this.account.toJSON(true)
  };
};

/**
 * Calculate serialization size.
 * @returns {Number}
 */

Wallet.prototype.getSize = function getSize() {
  let size = 0;
  size += 54; // +4 chksum
  size += encoding.sizeVarBytes(this.lock); // check this
  size += encoding.sizeVarString(this.id, 'ascii');
  size += encoding.sizeVarlen(this.master.getSize());
  return size;
};

/**
 * Serialize the wallet.
 * @returns {Buffer}
 */

Wallet.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  const bw = new StaticWriter(size);

  bw.writeU32(this.network.magic);
  bw.writeU32(this.wid);
  bw.writeVarString(this.id, 'ascii');
  bw.writeU8(this.initialized ? 1 : 0);
  bw.writeU8(this.watchOnly ? 1 : 0);
  bw.writeU32(this.accountDepth);
  bw.writeBytes(this.token);
  bw.writeU32(this.tokenDepth);
  bw.writeVarBytes(this.lock); // check
  bw.writeBytes(this.chksum); // check
  bw.writeVarBytes(this.master.toRaw());

  return bw.render();
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

Wallet.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data);
  const network = Network.fromMagic(br.readU32());

  this.wid = br.readU32();
  this.id = br.readVarString('ascii');
  this.initialized = br.readU8() === 1;
  this.watchOnly = br.readU8() === 1;
  this.accountDepth = br.readU32();
  this.token = br.readBytes(32);
  this.tokenDepth = br.readU32();
  this.lock = br.readVarBytes(); // check
  this.chksum = br.readBytes(4);
  this.master.fromRaw(br.readVarBytes());

  assert(network === this.db.network, 'Wallet network mismatch.');

  return this;
};

/**
 * Instantiate a wallet from serialized data.
 * @param {Buffer} data
 * @returns {Wallet}
 */

Wallet.fromRaw = function fromRaw(db, data) {
  return new Wallet(db).fromRaw(data);
};

/**
 * Test an object to see if it is a Wallet.
 * @param {Object} obj
 * @returns {Boolean}
 */

Wallet.isWallet = function isWallet(obj) {
  return obj instanceof Wallet;
};

/* Helper */
function mergeLocks(locks) {
  if (Array.isArray(locks)) {
    return util.concatArrBuf(locks);
  } else if (typeof locks === 'string') {
    assert(util.isHex(locks));
    return Buffer.from(locks, 'hex');
  }
  assert(Buffer.isBuffer(locks));
  return locks;
};

/*
 * Expose
 */

module.exports = Wallet;


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * txdb.js - persistent transaction pool.
 */



const util = __webpack_require__(1);
const LRU = __webpack_require__(56);
const assert = __webpack_require__(0);
const BufferReader = __webpack_require__(2);
const StaticWriter = __webpack_require__(4);
const Amount = __webpack_require__(20);
const CoinView = __webpack_require__(30);
const Coin = __webpack_require__(44);
const Outpoint = __webpack_require__(21);
const records = __webpack_require__(129);
const layout = __webpack_require__(192).txdb;
const encoding = __webpack_require__(3);
const consensus = __webpack_require__(7);
const policy = __webpack_require__(19);
const Script = __webpack_require__(8);
const BlockMapRecord = records.BlockMapRecord;
const OutpointMapRecord = records.OutpointMapRecord;
const TXRecord = records.TXRecord;

/**
 * TXDB
 * @alias module:wallet.TXDB
 * @constructor
 * @param {Wallet} wallet
 */

function TXDB(wallet) {
  if (!(this instanceof TXDB))
    return new TXDB(wallet);

  this.wallet = wallet;
  this.walletdb = wallet.db;
  this.db = wallet.db.db;
  this.logger = wallet.db.logger;
  this.network = wallet.db.network;
  this.options = wallet.db.options;
  this.coinCache = new LRU(10000);

  this.locked = new Set();
  this.state = null;
  this.pending = null;
  this.events = [];
}

/**
 * Database layout.
 * @type {Object}
 */

TXDB.layout = layout;

/**
 * Open TXDB.
 * @returns {Promise}
 */

TXDB.prototype.open = async function open() {
  const state = await this.getState();

  if (state) {
    this.state = state;
    this.logger.info('TXDB loaded for %s.', this.wallet.id);
  } else {
    this.state = new TXDBState(this.wallet.wid, this.wallet.id);
    this.logger.info('TXDB created for %s.', this.wallet.id);
  }

  this.logger.info('TXDB State: tx=%d coin=%s.',
    this.state.tx, this.state.coin);

  this.logger.info(
    'Balance: unconfirmed=%s confirmed=%s.',
    Amount.wmcc(this.state.unconfirmed),
    Amount.wmcc(this.state.confirmed));
};

/**
 * Start batch.
 * @private
 */

TXDB.prototype.start = function start() {
  this.pending = this.state.clone();
  this.coinCache.start();
  return this.wallet.start();
};

/**
 * Drop batch.
 * @private
 */

TXDB.prototype.drop = function drop() {
  this.pending = null;
  this.events.length = 0;
  this.coinCache.drop();
  return this.wallet.drop();
};

/**
 * Clear batch.
 * @private
 */

TXDB.prototype.clear = function clear() {
  this.pending = this.state.clone();
  this.events.length = 0;
  this.coinCache.clear();
  return this.wallet.clear();
};

/**
 * Save batch.
 * @returns {Promise}
 */

TXDB.prototype.commit = async function commit() {
  try {
    await this.wallet.commit();
  } catch (e) {
    this.pending = null;
    this.events.length = 0;
    this.coinCache.drop();
    throw e;
  }

  // Overwrite the entire state
  // with our new committed state.
  if (this.pending.committed) {
    this.state = this.pending;

    // Emit buffered events now that
    // we know everything is written.
    for (const [event, data, details] of this.events) {
      this.walletdb.emit(event, this.wallet.id, data, details);
      this.wallet.emit(event, data, details);
    }
  }

  this.pending = null;
  this.events.length = 0;
  this.coinCache.commit();
};

/**
 * Emit transaction event.
 * @private
 * @param {String} event
 * @param {Object} data
 * @param {Details} details
 */

TXDB.prototype.emit = function emit(event, data, details) {
  this.events.push([event, data, details]);
};

/**
 * Prefix a key.
 * @param {Buffer} key
 * @returns {Buffer} Prefixed key.
 */

TXDB.prototype.prefix = function prefix(key) {
  assert(this.wallet.wid);
  return layout.prefix(this.wallet.wid, key);
};

/**
 * Put key and value to current batch.
 * @param {String} key
 * @param {Buffer} value
 */

TXDB.prototype.put = function put(key, value) {
  assert(this.wallet.current);
  this.wallet.current.put(this.prefix(key), value);
};

/**
 * Delete key from current batch.
 * @param {String} key
 */

TXDB.prototype.del = function del(key) {
  assert(this.wallet.current);
  this.wallet.current.del(this.prefix(key));
};

/**
 * Get.
 * @param {String} key
 */

TXDB.prototype.get = function get(key) {
  return this.db.get(this.prefix(key));
};

/**
 * Has.
 * @param {String} key
 */

TXDB.prototype.has = function has(key) {
  return this.db.has(this.prefix(key));
};

/**
 * Iterate.
 * @param {Object} options
 * @returns {Promise}
 */

TXDB.prototype.range = function range(options) {
  if (options.gte)
    options.gte = this.prefix(options.gte);

  if (options.lte)
    options.lte = this.prefix(options.lte);

  return this.db.range(options);
};

/**
 * Iterate.
 * @param {Object} options
 * @returns {Promise}
 */

TXDB.prototype.offset = function offset(options) {
  if (options.gte)
    options.gte = this.prefix(options.gte);

  if (options.lte)
    options.lte = this.prefix(options.lte);

  return this.db.offset(options);
};

/**
 * Iterate.
 * @param {Object} options
 * @returns {Promise}
 */

TXDB.prototype.keys = function keys(options) {
  if (options.gte)
    options.gte = this.prefix(options.gte);

  if (options.lte)
    options.lte = this.prefix(options.lte);

  return this.db.keys(options);
};

/**
 * Iterate.
 * @param {Object} options
 * @returns {Promise}
 */

TXDB.prototype.values = function values(options) {
  if (options.gte)
    options.gte = this.prefix(options.gte);

  if (options.lte)
    options.lte = this.prefix(options.lte);

  return this.db.values(options);
};

/**
 * Iterate.
 * @param {Object} options
 * @returns {Promise}
 */

TXDB.prototype.total = function total(options) {
  if (options.gte)
    options.gte = this.prefix(options.gte);

  if (options.lte)
    options.lte = this.prefix(options.lte);

  return this.db.count(options);
};

/**
 * Get wallet path for output.
 * @param {Output} output
 * @returns {Promise} - Returns {@link Path}.
 */

TXDB.prototype.getPath = async function getPath(output) {
  const addr = output.getAddress();

  if (!addr)
    return null;

  return await this.wallet.getPath(addr);
};

/**
 * Test whether path exists for output.
 * @param {Output} output
 * @returns {Promise} - Returns Boolean.
 */

TXDB.prototype.hasPath = async function hasPath(output) {
  const addr = output.getAddress();

  if (!addr)
    return false;

  return await this.wallet.hasPath(addr);
};

/**
 * Save credit.
 * @param {Credit} credit
 * @param {Path} path
 */

TXDB.prototype.saveCredit = async function saveCredit(credit, path) {
  const coin = credit.coin;
  const key = coin.toKey();
  const raw = credit.toRaw();

  await this.addOutpointMap(coin.hash, coin.index);

  this.put(layout.c(coin.hash, coin.index), raw);
  this.put(layout.C(path.account, coin.hash, coin.index), null);

  this.coinCache.push(key, raw);
};

/**
 * Remove credit.
 * @param {Credit} credit
 * @param {Path} path
 */

TXDB.prototype.removeCredit = async function removeCredit(credit, path) {
  const coin = credit.coin;
  const key = coin.toKey();

  await this.removeOutpointMap(coin.hash, coin.index);

  this.del(layout.c(coin.hash, coin.index));
  this.del(layout.C(path.account, coin.hash, coin.index));

  this.coinCache.unpush(key);
};

/**
 * Spend credit.
 * @param {Credit} credit
 * @param {TX} tx
 * @param {Number} index
 */

TXDB.prototype.spendCredit = function spendCredit(credit, tx, index) {
  const prevout = tx.inputs[index].prevout;
  const spender = Outpoint.fromTX(tx, index);
  this.put(layout.s(prevout.hash, prevout.index), spender.toRaw());
  this.put(layout.d(spender.hash, spender.index), credit.coin.toRaw());
};

/**
 * Unspend credit.
 * @param {TX} tx
 * @param {Number} index
 */

TXDB.prototype.unspendCredit = function unspendCredit(tx, index) {
  const prevout = tx.inputs[index].prevout;
  const spender = Outpoint.fromTX(tx, index);
  this.del(layout.s(prevout.hash, prevout.index));
  this.del(layout.d(spender.hash, spender.index));
};

/**
 * Write input record.
 * @param {TX} tx
 * @param {Number} index
 */

TXDB.prototype.writeInput = function writeInput(tx, index) {
  const prevout = tx.inputs[index].prevout;
  const spender = Outpoint.fromTX(tx, index);
  this.put(layout.s(prevout.hash, prevout.index), spender.toRaw());
};

/**
 * Remove input record.
 * @param {TX} tx
 * @param {Number} index
 */

TXDB.prototype.removeInput = function removeInput(tx, index) {
  const prevout = tx.inputs[index].prevout;
  this.del(layout.s(prevout.hash, prevout.index));
};

/**
 * Resolve orphan input.
 * @param {TX} tx
 * @param {Number} index
 * @param {Number} height
 * @param {Path} path
 * @returns {Boolean}
 */

TXDB.prototype.resolveInput = async function resolveInput(tx, index, height, path, own) {
  const hash = tx.hash('hex');
  const spent = await this.getSpent(hash, index);

  if (!spent)
    return false;

  // If we have an undo coin, we
  // already knew about this input.
  if (await this.hasSpentCoin(spent))
    return false;

  // Get the spending transaction so
  // we can properly add the undo coin.
  const stx = await this.getTX(spent.hash);
  assert(stx);

  // Crete the credit and add the undo coin.
  const credit = Credit.fromTX(tx, index, height);
  credit.own = own;

  this.spendCredit(credit, stx.tx, spent.index);

  // If the spender is unconfirmed, save
  // the credit as well, and mark it as
  // unspent in the mempool. This is the
  // same behavior `insert` would have
  // done for inputs. We're just doing
  // it retroactively.
  if (stx.height === -1) {
    credit.spent = true;
    await this.saveCredit(credit, path);
    if (height !== -1)
      this.pending.confirmed += credit.coin.value;
  }

  return true;
};

/**
 * Test an entire transaction to see
 * if any of its outpoints are a double-spend.
 * @param {TX} tx
 * @returns {Promise} - Returns Boolean.
 */

TXDB.prototype.isDoubleSpend = async function isDoubleSpend(tx) {
  for (const {prevout} of tx.inputs) {
    const spent = await this.isSpent(prevout.hash, prevout.index);
    if (spent)
      return true;
  }

  return false;
};

/**
 * Test an entire transaction to see
 * if any of its outpoints are replace by fee.
 * @param {TX} tx
 * @returns {Promise} - Returns Boolean.
 */

TXDB.prototype.isRBF = async function isRBF(tx) {
  if (tx.isRBF())
    return true;

  for (const {prevout} of tx.inputs) {
    const key = layout.r(prevout.hash);
    if (await this.has(key))
      return true;
  }

  return false;
};

/**
 * Test a whether a coin has been spent.
 * @param {Hash} hash
 * @param {Number} index
 * @returns {Promise} - Returns Boolean.
 */

TXDB.prototype.getSpent = async function getSpent(hash, index) {
  const data = await this.get(layout.s(hash, index));

  if (!data)
    return null;

  return Outpoint.fromRaw(data);
};

/**
 * Test a whether a coin has been spent.
 * @param {Hash} hash
 * @param {Number} index
 * @returns {Promise} - Returns Boolean.
 */

TXDB.prototype.isSpent = function isSpent(hash, index) {
  return this.has(layout.s(hash, index));
};

/**
 * Append to the global unspent record.
 * @param {Hash} hash
 * @param {Number} index
 * @returns {Promise}
 */

TXDB.prototype.addOutpointMap = async function addOutpointMap(hash, i) {
  let map = await this.walletdb.getOutpointMap(hash, i);

  if (!map)
    map = new OutpointMapRecord(hash, i);

  if (!map.add(this.wallet.wid))
    return;

  this.walletdb.writeOutpointMap(this.wallet, hash, i, map);
};

/**
 * Remove from the global unspent record.
 * @param {Hash} hash
 * @param {Number} index
 * @returns {Promise}
 */

TXDB.prototype.removeOutpointMap = async function removeOutpointMap(hash, i) {
  const map = await this.walletdb.getOutpointMap(hash, i);

  if (!map)
    return;

  if (!map.remove(this.wallet.wid))
    return;

  if (map.wids.size === 0) {
    this.walletdb.unwriteOutpointMap(this.wallet, hash, i);
    return;
  }

  this.walletdb.writeOutpointMap(this.wallet, hash, i, map);
};

/**
 * Append to the global block record.
 * @param {Hash} hash
 * @param {Number} height
 * @returns {Promise}
 */

TXDB.prototype.addBlockMap = async function addBlockMap(hash, height) {
  let block = await this.walletdb.getBlockMap(height);

  if (!block)
    block = new BlockMapRecord(height);

  if (!block.add(hash, this.wallet.wid))
    return;

  this.walletdb.writeBlockMap(this.wallet, height, block);
};

/**
 * Remove from the global block record.
 * @param {Hash} hash
 * @param {Number} height
 * @returns {Promise}
 */

TXDB.prototype.removeBlockMap = async function removeBlockMap(hash, height) {
  const block = await this.walletdb.getBlockMap(height);

  if (!block)
    return;

  if (!block.remove(hash, this.wallet.wid))
    return;

  if (block.txs.size === 0) {
    this.walletdb.unwriteBlockMap(this.wallet, height);
    return;
  }

  this.walletdb.writeBlockMap(this.wallet, height, block);
};

/**
 * List block records.
 * @returns {Promise}
 */

TXDB.prototype.getBlocks = function getBlocks() {
  return this.keys({
    gte: layout.b(0),
    lte: layout.b(0xffffffff),
    parse: key => layout.bb(key)
  });
};

/**
 * Get block record.
 * @param {Number} height
 * @returns {Promise}
 */

TXDB.prototype.getBlock = async function getBlock(height) {
  const data = await this.get(layout.b(height));

  if (!data)
    return null;

  return BlockRecord.fromRaw(data);
};

/**
 * Append to the global block record.
 * @param {Hash} hash
 * @param {BlockMeta} meta
 * @returns {Promise}
 */

TXDB.prototype.addBlock = async function addBlock(hash, meta) {
  const key = layout.b(meta.height);
  let data = await this.get(key);
  let block;

  if (!data) {
    block = BlockRecord.fromMeta(meta);
    data = block.toRaw();
  }

  block = Buffer.allocUnsafe(data.length + 32);
  data.copy(block, 0);

  const size = block.readUInt32LE(40, true);
  block.writeUInt32LE(size + 1, 40, true);
  hash.copy(block, data.length);

  this.put(key, block);
};

/**
 * Remove from the global block record.
 * @param {Hash} hash
 * @param {Number} height
 * @returns {Promise}
 */

TXDB.prototype.removeBlock = async function removeBlock(hash, height) {
  const key = layout.b(height);
  const data = await this.get(key);

  if (!data)
    return;

  const size = data.readUInt32LE(40, true);

  assert(size > 0);
  assert(data.slice(-32).equals(hash));

  if (size === 1) {
    this.del(key);
    return;
  }

  const block = data.slice(0, -32);
  block.writeUInt32LE(size - 1, 40, true);

  this.put(key, block);
};

/**
 * Append to the global block record.
 * @param {Hash} hash
 * @param {BlockMeta} meta
 * @returns {Promise}
 */

TXDB.prototype.addBlockSlow = async function addBlockSlow(hash, meta) {
  let block = await this.getBlock(meta.height);

  if (!block)
    block = BlockRecord.fromMeta(meta);

  if (!block.add(hash))
    return;

  this.put(layout.b(meta.height), block.toRaw());
};

/**
 * Remove from the global block record.
 * @param {Hash} hash
 * @param {Number} height
 * @returns {Promise}
 */

TXDB.prototype.removeBlockSlow = async function removeBlockSlow(hash, height) {
  const block = await this.getBlock(height);

  if (!block)
    return;

  if (!block.remove(hash))
    return;

  if (block.hashes.length === 0) {
    this.del(layout.b(height));
    return;
  }

  this.put(layout.b(height), block.toRaw());
};

/**
 * Add transaction, potentially runs
 * `confirm()` and `removeConflicts()`.
 * @param {TX} tx
 * @param {BlockMeta} block
 * @returns {Promise}
 */

TXDB.prototype.add = async function add(tx, block) {
  this.start();

  let result;
  try {
    result = await this._add(tx, block);
  } catch (e) {
    this.drop();
    throw e;
  }

  await this.commit();

  return result;
};

/**
 * Add transaction without a batch.
 * @private
 * @param {TX} tx
 * @returns {Promise}
 */

TXDB.prototype._add = async function _add(tx, block) {
  const hash = tx.hash('hex');
  const existing = await this.getTX(hash);

  assert(!tx.mutable, 'Cannot add mutable TX to wallet.');

  if (existing) {
    // Existing tx is already confirmed. Ignore.
    if (existing.height !== -1)
      return null;

    // The incoming tx won't confirm the
    // existing one anyway. Ignore.
    if (!block)
      return null;

    // Confirm transaction.
    return await this._confirm(existing, block);
  }

  const wtx = TXRecord.fromTX(tx, block);

  if (!block) {
    // We ignore any unconfirmed txs
    // that are replace-by-fee.
    if (await this.isRBF(tx)) {
      // We need to index every spender
      // hash to detect "passive"
      // replace-by-fee.
      this.put(layout.r(hash), null);
      return null;
    }

    // Potentially remove double-spenders.
    // Only remove if they're not confirmed.
    if (!await this.removeConflicts(tx, true))
      return null;
  } else {
    // Potentially remove double-spenders.
    await this.removeConflicts(tx, false);

    // Delete the replace-by-fee record.
    this.del(layout.r(hash));
  }

  // Finally we can do a regular insertion.
  return await this.insert(wtx, block);
};

/**
 * Insert transaction.
 * @private
 * @param {TXRecord} wtx
 * @param {BlockMeta} block
 * @returns {Promise}
 */

TXDB.prototype.insert = async function insert(wtx, block) {
  const tx = wtx.tx;
  const hash = wtx.hash;
  const height = block ? block.height : -1;
  const details = new Details(this, wtx, block);
  const accounts = new Set();
  let own = false;
  let updated = false;

  if (!tx.isCoinbase()) {
    // We need to potentially spend some coins here.
    for (let i = 0; i < tx.inputs.length; i++) {
      const input = tx.inputs[i];
      const prevout = input.prevout;
      const credit = await this.getCredit(prevout.hash, prevout.index);

      if (!credit) {
        // Maintain an stxo list for every
        // spent input (even ones we don't
        // recognize). This is used for
        // detecting double-spends (as best
        // we can), as well as resolving
        // inputs we didn't know were ours
        // at the time. This built-in error
        // correction is not technically
        // necessary assuming no messages
        // are ever missed from the mempool,
        // but shit happens.
        this.writeInput(tx, i);
        continue;
      }

      const coin = credit.coin;

      // Do some verification.
      if (!block) {
        if (!await this.verifyInput(tx, i, coin)) {
          this.clear();
          return null;
        }
      }

      const path = await this.getPath(coin);
      assert(path);

      // Build the tx details object
      // as we go, for speed.
      details.setInput(i, path, coin);
      accounts.add(path.account);

      // Write an undo coin for the credit
      // and add it to the stxo set.
      this.spendCredit(credit, tx, i);

      // Unconfirmed balance should always
      // be updated as it reflects the on-chain
      // balance _and_ mempool balance assuming
      // everything in the mempool were to confirm.
      this.pending.coin--;
      this.pending.unconfirmed -= coin.value;

      if (!block) {
        // If the tx is not mined, we do not
        // disconnect the coin, we simply mark
        // a `spent` flag on the credit. This
        // effectively prevents the mempool
        // from altering our utxo state
        // permanently. It also makes it
        // possible to compare the on-chain
        // state vs. the mempool state.
        credit.spent = true;
        await this.saveCredit(credit, path);
      } else {
        // If the tx is mined, we can safely
        // remove the coin being spent. This
        // coin will be indexed as an undo
        // coin so it can be reconnected
        // later during a reorg.
        this.pending.confirmed -= coin.value;
        await this.removeCredit(credit, path);
      }

      updated = true;
      own = true;
    }
  }

  // Potentially add coins to the utxo set.
  for (let i = 0; i < tx.outputs.length; i++) {
    const output = tx.outputs[i];
    const path = await this.getPath(output);

    if (!path)
      continue;

    details.setOutput(i, path);
    accounts.add(path.account);

    // Attempt to resolve an input we
    // did not know was ours at the time.
    if (await this.resolveInput(tx, i, height, path, own)) {
      updated = true;
      continue;
    }

    const credit = Credit.fromTX(tx, i, height);
    credit.own = own;

    this.pending.coin++;
    this.pending.unconfirmed += output.value;

    if (block)
      this.pending.confirmed += output.value;

    await this.saveCredit(credit, path);

    updated = true;
  }

  // If this didn't update any coins,
  // it's not our transaction.
  if (!updated) {
    // Clear the spent list inserts.
    this.clear();
    return null;
  }

  // Save and index the transaction record.
  this.put(layout.t(hash), wtx.toRaw());
  this.put(layout.m(wtx.mtime, hash), null);

  if (!block)
    this.put(layout.p(hash), null);
  else
    this.put(layout.h(height, hash), null);

  // Do some secondary indexing for account-based
  // queries. This saves us a lot of time for
  // queries later.
  for (const account of accounts) {
    this.put(layout.T(account, hash), null);
    this.put(layout.M(account, wtx.mtime, hash), null);

    if (!block)
      this.put(layout.P(account, hash), null);
    else
      this.put(layout.H(account, height, hash), null);
  }

  // Update block records.
  if (block) {
    await this.addBlockMap(hash, height);
    await this.addBlock(tx.hash(), block);
  }

  // Update the transaction counter and
  // commit the new state. This state will
  // only overwrite the best state once
  // the batch has actually been written
  // to disk.
  this.pending.tx++;
  this.put(layout.R, this.pending.commit());

  // This transaction may unlock some
  // coins now that we've seen it.
  this.unlockTX(tx);

  // Emit events for potential local and
  // websocket listeners. Note that these
  // will only be emitted if the batch is
  // successfully written to disk.
  this.emit('tx', tx, details);
  this.emit('balance', this.pending.toBalance(), details);

  return details;
};

/**
 * Attempt to confirm a transaction.
 * @private
 * @param {TX} tx
 * @param {BlockMeta} block
 * @returns {Promise}
 */

TXDB.prototype.confirm = async function confirm(hash, block) {
  const wtx = await this.getTX(hash);

  if (!wtx)
    return null;

  if (wtx.height !== -1)
    throw new Error('TX is already confirmed.');

  assert(block);

  this.start();

  let details;

  try {
    details = await this._confirm(wtx, block);
  } catch (e) {
    this.drop();
    throw e;
  }

  await this.commit();

  return details;
};

/**
 * Attempt to confirm a transaction.
 * @private
 * @param {TXRecord} wtx
 * @param {BlockMeta} block
 * @returns {Promise}
 */

TXDB.prototype._confirm = async function _confirm(wtx, block) {
  const tx = wtx.tx;
  const hash = wtx.hash;
  const height = block.height;
  const details = new Details(this, wtx, block);
  const accounts = new Set();

  wtx.setBlock(block);

  if (!tx.isCoinbase()) {
    const credits = await this.getSpentCredits(tx);

    // Potentially spend coins. Now that the tx
    // is mined, we can actually _remove_ coins
    // from the utxo state.
    for (let i = 0; i < tx.inputs.length; i++) {
      const input = tx.inputs[i];
      const prevout = input.prevout;
      let credit = credits[i];

      // There may be new credits available
      // that we haven't seen yet.
      if (!credit) {
        credit = await this.getCredit(prevout.hash, prevout.index);

        if (!credit)
          continue;

        // Add a spend record and undo coin
        // for the coin we now know is ours.
        // We don't need to remove the coin
        // since it was never added in the
        // first place.
        this.spendCredit(credit, tx, i);

        this.pending.coin--;
        this.pending.unconfirmed -= credit.coin.value;
      }

      const coin = credit.coin;

      assert(coin.height !== -1);

      const path = await this.getPath(coin);
      assert(path);

      details.setInput(i, path, coin);
      accounts.add(path.account);

      // We can now safely remove the credit
      // entirely, now that we know it's also
      // been removed on-chain.
      this.pending.confirmed -= coin.value;

      await this.removeCredit(credit, path);
    }
  }

  // Update credit heights, including undo coins.
  for (let i = 0; i < tx.outputs.length; i++) {
    const output = tx.outputs[i];
    const path = await this.getPath(output);

    if (!path)
      continue;

    details.setOutput(i, path);
    accounts.add(path.account);

    const credit = await this.getCredit(hash, i);
    assert(credit);

    // Credits spent in the mempool add an
    // undo coin for ease. If this credit is
    // spent in the mempool, we need to
    // update the undo coin's height.
    if (credit.spent)
      await this.updateSpentCoin(tx, i, height);

    // Update coin height and confirmed
    // balance. Save once again.
    const coin = credit.coin;
    coin.height = height;

    this.pending.confirmed += output.value;

    await this.saveCredit(credit, path);
  }

  // Remove the RBF index if we have one.
  this.del(layout.r(hash));

  // Save the new serialized transaction as
  // the block-related properties have been
  // updated. Also reindex for height.
  this.put(layout.t(hash), wtx.toRaw());
  this.del(layout.p(hash));
  this.put(layout.h(height, hash), null);

  // Secondary indexing also needs to change.
  for (const account of accounts) {
    this.del(layout.P(account, hash));
    this.put(layout.H(account, height, hash), null);
  }

  if (block) {
    await this.addBlockMap(hash, height);
    await this.addBlock(tx.hash(), block);
  }

  // Commit the new state. The balance has updated.
  this.put(layout.R, this.pending.commit());

  this.unlockTX(tx);

  this.emit('confirmed', tx, details);
  this.emit('balance', this.pending.toBalance(), details);

  return details;
};

/**
 * Recursively remove a transaction
 * from the database.
 * @param {Hash} hash
 * @returns {Promise}
 */

TXDB.prototype.remove = async function remove(hash) {
  const wtx = await this.getTX(hash);

  if (!wtx)
    return null;

  return await this.removeRecursive(wtx);
};

/**
 * Remove a transaction from the
 * database. Disconnect inputs.
 * @private
 * @param {TXRecord} wtx
 * @returns {Promise}
 */

TXDB.prototype.erase = async function erase(wtx, block) {
  const tx = wtx.tx;
  const hash = wtx.hash;
  const height = block ? block.height : -1;
  const details = new Details(this, wtx, block);
  const accounts = new Set();

  if (!tx.isCoinbase()) {
    // We need to undo every part of the
    // state this transaction ever touched.
    // Start by getting the undo coins.
    const credits = await this.getSpentCredits(tx);

    for (let i = 0; i < tx.inputs.length; i++) {
      const credit = credits[i];

      if (!credit) {
        // This input never had an undo
        // coin, but remove it from the
        // stxo set.
        this.removeInput(tx, i);
        continue;
      }

      const coin = credit.coin;
      const path = await this.getPath(coin);
      assert(path);

      details.setInput(i, path, coin);
      accounts.add(path.account);

      // Recalculate the balance, remove
      // from stxo set, remove the undo
      // coin, and resave the credit.
      this.pending.coin++;
      this.pending.unconfirmed += coin.value;

      if (block)
        this.pending.confirmed += coin.value;

      this.unspendCredit(tx, i);
      await this.saveCredit(credit, path);
    }
  }

  // We need to remove all credits
  // this transaction created.
  for (let i = 0; i < tx.outputs.length; i++) {
    const output = tx.outputs[i];
    const path = await this.getPath(output);

    if (!path)
      continue;

    details.setOutput(i, path);
    accounts.add(path.account);

    const credit = Credit.fromTX(tx, i, height);

    this.pending.coin--;
    this.pending.unconfirmed -= output.value;

    if (block)
      this.pending.confirmed -= output.value;

    await this.removeCredit(credit, path);
  }

  // Remove the RBF index if we have one.
  this.del(layout.r(hash));

  // Remove the transaction data
  // itself as well as unindex.
  this.del(layout.t(hash));
  this.del(layout.m(wtx.mtime, hash));

  if (!block)
    this.del(layout.p(hash));
  else
    this.del(layout.h(height, hash));

  // Remove all secondary indexing.
  for (const account of accounts) {
    this.del(layout.T(account, hash));
    this.del(layout.M(account, wtx.mtime, hash));

    if (!block)
      this.del(layout.P(account, hash));
    else
      this.del(layout.H(account, height, hash));
  }

  // Update block records.
  if (block) {
    await this.removeBlockMap(hash, height);
    await this.removeBlockSlow(hash, height);
  }

  // Update the transaction counter
  // and commit new state due to
  // balance change.
  this.pending.tx--;
  this.put(layout.R, this.pending.commit());

  this.emit('remove tx', tx, details);
  this.emit('balance', this.pending.toBalance(), details);

  return details;
};

/**
 * Remove a transaction and recursively
 * remove all of its spenders.
 * @private
 * @param {TXRecord} wtx
 * @returns {Promise}
 */

TXDB.prototype.removeRecursive = async function removeRecursive(wtx) {
  const tx = wtx.tx;
  const hash = wtx.hash;

  for (let i = 0; i < tx.outputs.length; i++) {
    const spent = await this.getSpent(hash, i);

    if (!spent)
      continue;

    // Remove all of the spender's spenders first.
    const stx = await this.getTX(spent.hash);

    assert(stx);

    await this.removeRecursive(stx);
  }

  this.start();

  // Remove the spender.
  const details = await this.erase(wtx, wtx.getBlock());

  assert(details);

  await this.commit();

  return details;
};

/**
 * Unconfirm a transaction. Necessary after a reorg.
 * @param {Hash} hash
 * @returns {Promise}
 */

TXDB.prototype.unconfirm = async function unconfirm(hash) {
  this.start();

  let details;
  try {
    details = await this._unconfirm(hash);
  } catch (e) {
    this.drop();
    throw e;
  }

  await this.commit();

  return details;
};

/**
 * Unconfirm a transaction without a batch.
 * @private
 * @param {Hash} hash
 * @returns {Promise}
 */

TXDB.prototype._unconfirm = async function _unconfirm(hash) {
  const wtx = await this.getTX(hash);

  if (!wtx)
    return null;

  if (wtx.height === -1)
    return null;

  return await this.disconnect(wtx, wtx.getBlock());
};

/**
 * Unconfirm a transaction. Necessary after a reorg.
 * @param {TXRecord} wtx
 * @returns {Promise}
 */

TXDB.prototype.disconnect = async function disconnect(wtx, block) {
  const tx = wtx.tx;
  const hash = wtx.hash;
  const height = block.height;
  const details = new Details(this, wtx, block);
  const accounts = new Set();

  assert(block);

  wtx.unsetBlock();

  if (!tx.isCoinbase()) {
    // We need to reconnect the coins. Start
    // by getting all of the undo coins we know
    // about.
    const credits = await this.getSpentCredits(tx);

    for (let i = 0; i < tx.inputs.length; i++) {
      const credit = credits[i];

      if (!credit)
        continue;

      const coin = credit.coin;

      assert(coin.height !== -1);

      const path = await this.getPath(coin);
      assert(path);

      details.setInput(i, path, coin);
      accounts.add(path.account);

      this.pending.confirmed += coin.value;

      // Resave the credit and mark it
      // as spent in the mempool instead.
      credit.spent = true;
      await this.saveCredit(credit, path);
    }
  }

  // We need to remove heights on
  // the credits and undo coins.
  for (let i = 0; i < tx.outputs.length; i++) {
    const output = tx.outputs[i];
    const path = await this.getPath(output);

    if (!path)
      continue;

    const credit = await this.getCredit(hash, i);

    // Potentially update undo coin height.
    if (!credit) {
      await this.updateSpentCoin(tx, i, height);
      continue;
    }

    if (credit.spent)
      await this.updateSpentCoin(tx, i, height);

    details.setOutput(i, path);
    accounts.add(path.account);

    // Update coin height and confirmed
    // balance. Save once again.
    const coin = credit.coin;
    coin.height = -1;

    this.pending.confirmed -= output.value;

    await this.saveCredit(credit, path);
  }

  await this.removeBlockMap(hash, height);
  await this.removeBlock(tx.hash(), height);

  // We need to update the now-removed
  // block properties and reindex due
  // to the height change.
  this.put(layout.t(hash), wtx.toRaw());
  this.put(layout.p(hash), null);
  this.del(layout.h(height, hash));

  // Secondary indexing also needs to change.
  for (const account of accounts) {
    this.put(layout.P(account, hash), null);
    this.del(layout.H(account, height, hash));
  }

  // Commit state due to unconfirmed
  // vs. confirmed balance change.
  this.put(layout.R, this.pending.commit());

  this.emit('unconfirmed', tx, details);
  this.emit('balance', this.pending.toBalance(), details);

  return details;
};

/**
 * Remove spenders that have not been confirmed. We do this in the
 * odd case of stuck transactions or when a coin is double-spent
 * by a newer transaction. All previously-spending transactions
 * of that coin that are _not_ confirmed will be removed from
 * the database.
 * @private
 * @param {Hash} hash
 * @param {TX} ref - Reference tx, the tx that double-spent.
 * @returns {Promise} - Returns Boolean.
 */

TXDB.prototype.removeConflict = async function removeConflict(wtx) {
  const tx = wtx.tx;

  this.logger.warning('Handling conflicting tx: %s.', tx.txid());

  this.drop();

  const details = await this.removeRecursive(wtx);

  this.start();

  this.logger.warning('Removed conflict: %s.', tx.txid());

  // Emit the _removed_ transaction.
  this.emit('conflict', tx, details);

  return details;
};

/**
 * Retrieve coins for own inputs, remove
 * double spenders, and verify inputs.
 * @private
 * @param {TX} tx
 * @returns {Promise}
 */

TXDB.prototype.removeConflicts = async function removeConflicts(tx, conf) {
  const hash = tx.hash('hex');
  const spends = [];

  if (tx.isCoinbase())
    return true;

  // Gather all spent records first.
  for (let i = 0; i < tx.inputs.length; i++) {
    const input = tx.inputs[i];
    const prevout = input.prevout;

    // Is it already spent?
    const spent = await this.getSpent(prevout.hash, prevout.index);

    if (!spent)
      continue;

    // Did _we_ spend it?
    if (spent.hash === hash)
      continue;

    const spender = await this.getTX(spent.hash);
    assert(spender);

    const block = spender.getBlock();

    if (conf && block)
      return false;

    spends[i] = spender;
  }

  // Once we know we're not going to
  // screw things up, remove the double
  // spenders.
  for (const spender of spends) {
    if (!spender)
      continue;

    // Remove the double spender.
    await this.removeConflict(spender);
  }

  return true;
};

/**
 * Attempt to verify an input.
 * @private
 * @param {TX} tx
 * @param {Number} index
 * @param {Coin} coin
 * @returns {Promise}
 */

TXDB.prototype.verifyInput = async function verifyInput(tx, index, coin) {
  const flags = Script.flags.MANDATORY_VERIFY_FLAGS;

  if (!this.options.verify)
    return true;

  return await tx.verifyInputAsync(index, coin, flags);
};

/**
 * Lock all coins in a transaction.
 * @param {TX} tx
 */

TXDB.prototype.lockTX = function lockTX(tx) {
  if (tx.isCoinbase())
    return;

  for (const input of tx.inputs)
    this.lockCoin(input.prevout);
};

/**
 * Unlock all coins in a transaction.
 * @param {TX} tx
 */

TXDB.prototype.unlockTX = function unlockTX(tx) {
  if (tx.isCoinbase())
    return;

  for (const input of tx.inputs)
    this.unlockCoin(input.prevout);
};

/**
 * Lock a single coin.
 * @param {Coin|Outpoint} coin
 */

TXDB.prototype.lockCoin = function lockCoin(coin) {
  const key = coin.toKey();
  this.locked.add(key);
};

/**
 * Unlock a single coin.
 * @param {Coin|Outpoint} coin
 */

TXDB.prototype.unlockCoin = function unlockCoin(coin) {
  const key = coin.toKey();
  return this.locked.delete(key);
};

/**
 * Test locked status of a single coin.
 * @param {Coin|Outpoint} coin
 */

TXDB.prototype.isLocked = function isLocked(coin) {
  const key = coin.toKey();
  return this.locked.has(key);
};

/**
 * Filter array of coins or outpoints
 * for only unlocked ones.
 * @param {Coin[]|Outpoint[]}
 * @returns {Array}
 */

TXDB.prototype.filterLocked = function filterLocked(coins) {
  const out = [];

  for (const coin of coins) {
    if (!this.isLocked(coin))
      out.push(coin);
  }

  return out;
};

/**
 * Return an array of all locked outpoints.
 * @returns {Outpoint[]}
 */

TXDB.prototype.getLocked = function getLocked() {
  const outpoints = [];

  for (const key of this.locked.keys())
    outpoints.push(Outpoint.fromKey(key));

  return outpoints;
};

/**
 * Get hashes of all transactions in the database.
 * @param {Number?} account
 * @returns {Promise} - Returns {@link Hash}[].
 */

TXDB.prototype.getAccountHistoryHashes = function getAccountHistoryHashes(account) {
  return this.keys({
    gte: layout.T(account, encoding.NULL_HASH),
    lte: layout.T(account, encoding.HIGH_HASH),
    parse: (key) => {
      const [, hash] = layout.Tt(key);
      return hash;
    }
  });
};

/**
 * Get hashes of all transactions in the database.
 * @param {Number?} account
 * @returns {Promise} - Returns {@link Hash}[].
 */

TXDB.prototype.getHistoryHashes = function getHistoryHashes(account) {
  if (account != null)
    return this.getAccountHistoryHashes(account);

  return this.keys({
    gte: layout.t(encoding.NULL_HASH),
    lte: layout.t(encoding.HIGH_HASH),
    parse: key => layout.tt(key)
  });
};

/**
 * Get hashes of all unconfirmed transactions in the database.
 * @param {Number?} account
 * @returns {Promise} - Returns {@link Hash}[].
 */

TXDB.prototype.getAccountPendingHashes = function getAccountPendingHashes(account) {
  return this.keys({
    gte: layout.P(account, encoding.NULL_HASH),
    lte: layout.P(account, encoding.HIGH_HASH),
    parse: (key) => {
      const [, hash] = layout.Pp(key);
      return hash;
    }
  });
};

/**
 * Get hashes of all unconfirmed transactions in the database.
 * @param {Number?} account
 * @returns {Promise} - Returns {@link Hash}[].
 */

TXDB.prototype.getPendingHashes = function getPendingHashes(account) {
  if (account != null)
    return this.getAccountPendingHashes(account);

  return this.keys({
    gte: layout.p(encoding.NULL_HASH),
    lte: layout.p(encoding.HIGH_HASH),
    parse: key => layout.pp(key)
  });
};

/**
 * Get all coin hashes in the database.
 * @param {Number?} account
 * @returns {Promise} - Returns {@link Hash}[].
 */

TXDB.prototype.getAccountOutpoints = function getAccountOutpoints(account) {
  return this.keys({
    gte: layout.C(account, encoding.NULL_HASH, 0),
    lte: layout.C(account, encoding.HIGH_HASH, 0xffffffff),
    parse: (key) => {
      const [, hash, index] = layout.Cc(key);
      return new Outpoint(hash, index);
    }
  });
};

/**
 * Get all coin hashes in the database.
 * @param {Number?} account
 * @returns {Promise} - Returns {@link Hash}[].
 */

TXDB.prototype.getOutpoints = function getOutpoints(account) {
  if (account != null)
    return this.getAccountOutpoints(account);

  return this.keys({
    gte: layout.c(encoding.NULL_HASH, 0),
    lte: layout.c(encoding.HIGH_HASH, 0xffffffff),
    parse: (key) => {
      const [hash, index] = layout.cc(key);
      return new Outpoint(hash, index);
    }
  });
};

/**
 * Get TX hashes by height range.
 * @param {Number?} account
 * @param {Object} options
 * @param {Number} options.start - Start height.
 * @param {Number} options.end - End height.
 * @param {Number?} options.limit - Max number of records.
 * @param {Boolean?} options.reverse - Reverse order.
 * @returns {Promise} - Returns {@link Hash}[].
 */

TXDB.prototype.getAccountHeightRangeHashes = function getAccountHeightRangeHashes(account, options) {
  const start = options.start || 0;
  const end = options.end || 0xffffffff;

  return this.keys({
    gte: layout.H(account, start, encoding.NULL_HASH),
    lte: layout.H(account, end, encoding.HIGH_HASH),
    limit: options.limit,
    reverse: options.reverse,
    parse: (key) => {
      const [,, hash] = layout.Hh(key);
      return hash;
    }
  });
};

/**
 * Get TX hashes by height range.
 * @param {Number?} account
 * @param {Object} options
 * @param {Number} options.start - Start height.
 * @param {Number} options.end - End height.
 * @param {Number?} options.limit - Max number of records.
 * @param {Boolean?} options.reverse - Reverse order.
 * @returns {Promise} - Returns {@link Hash}[].
 */

TXDB.prototype.getHeightRangeHashes = function getHeightRangeHashes(account, options) {
  if (account && typeof account === 'object') {
    options = account;
    account = null;
  }

  if (account != null)
    return this.getAccountHeightRangeHashes(account, options);

  const start = options.start || 0;
  const end = options.end || 0xffffffff;

  return this.keys({
    gte: layout.h(start, encoding.NULL_HASH),
    lte: layout.h(end, encoding.HIGH_HASH),
    limit: options.limit,
    reverse: options.reverse,
    parse: (key) => {
      const [, hash] = layout.hh(key);
      return hash;
    }
  });
};

/**
 * Get TX hashes by height.
 * @param {Number} height
 * @returns {Promise} - Returns {@link Hash}[].
 */

TXDB.prototype.getHeightHashes = function getHeightHashes(height) {
  return this.getHeightRangeHashes({ start: height, end: height });
};

/**
 * Get TX hashes by timestamp range.
 * @param {Number?} account
 * @param {Object} options
 * @param {Number} options.start - Start height.
 * @param {Number} options.end - End height.
 * @param {Number?} options.limit - Max number of records.
 * @param {Boolean?} options.reverse - Reverse order.
 * @returns {Promise} - Returns {@link Hash}[].
 */

TXDB.prototype.getAccountRangeHashes = function getAccountRangeHashes(account, options) {
  const start = options.start || 0;
  const end = options.end || 0xffffffff;

  return this.keys({
    gte: layout.M(account, start, encoding.NULL_HASH),
    lte: layout.M(account, end, encoding.HIGH_HASH),
    limit: options.limit,
    reverse: options.reverse,
    parse: (key) => {
      const [,, hash] = layout.Mm(key);
      return hash;
    }
  });
};

/**
 * Get TX hashes by timestamp range.
 * @param {Number?} account
 * @param {Object} options
 * @param {Number} options.start - Start height.
 * @param {Number} options.end - End height.
 * @param {Number?} options.limit - Max number of records.
 * @param {Boolean?} options.reverse - Reverse order.
 * @returns {Promise} - Returns {@link Hash}[].
 */

TXDB.prototype.getRangeHashes = function getRangeHashes(account, options) {
  if (account && typeof account === 'object') {
    options = account;
    account = null;
  }

  if (account != null)
    return this.getAccountRangeHashes(account, options);

  const start = options.start || 0;
  const end = options.end || 0xffffffff;

  return this.keys({
    gte: layout.m(start, encoding.NULL_HASH),
    lte: layout.m(end, encoding.HIGH_HASH),
    limit: options.limit,
    reverse: options.reverse,
    parse: (key) => {
      const [, hash] = layout.mm(key);
      return hash;
    }
  });
};

/**
 * Get transactions by timestamp range.
 * @param {Number?} account
 * @param {Object} options
 * @param {Number} options.start - Start time.
 * @param {Number} options.end - End time.
 * @param {Number?} options.limit - Max number of records.
 * @param {Boolean?} options.reverse - Reverse order.
 * @returns {Promise} - Returns {@link TX}[].
 */

TXDB.prototype.getRange = async function getRange(account, options) {
  const txs = [];

  if (account && typeof account === 'object') {
    options = account;
    account = null;
  }

  const hashes = await this.getRangeHashes(account, options);

  for (const hash of hashes) {
    const tx = await this.getTX(hash);
    assert(tx);
    txs.push(tx);
  }

  return txs;
};

/**
 * Get TX hashes by timestamp offset range.
 * @param {Number?} account
 * @param {Object} options
 * @param {Number} options.start - Start height.
 * @param {Number} options.end - End height.
 * @param {Number?} options.limit - Max number of records.
 * @param {Number} options.offset - Start of transactions.
 * @param {Boolean?} options.reverse - Reverse order.
 * @returns {Promise} - Returns {@link TXDetails}[].
 */

TXDB.prototype.getAccountOffsetHashes = async function getAccountOffsetHashes(account, options) {
  const start = options.start || 0;
  const end = options.end || 0xffffffff;
  const details = [];
  let count = 0,
      added = 0;

  await this.offset({
    gte: layout.M(account, start, encoding.NULL_HASH),
    lte: layout.M(account, end, encoding.HIGH_HASH),
    reverse: options.reverse,
    parse: (key) => {
      const [,, hash] = layout.Mm(key);
      return hash;
    },
    break: async (hash) => {
      const tx = await this.getTX(hash);
      assert(tx);
      const detail = await this.toDetails(tx);
      if (detail.block) {
        count++;
        if (count > options.offset) {
          details.push(detail);
          added++;
        }
      }

      if (added >= options.limit)
        return true;
      return false;
    }
  });

  return details;
};

/**
 * Get TX hashes by timestamp offset range.
 * @param {Number?} account
 * @param {Object} options
 * @param {Number} options.start - Start height.
 * @param {Number} options.end - End height.
 * @param {Number?} options.limit - Max number of records.
 * @param {Number} options.offset - Start of transactions.
 * @param {Boolean?} options.reverse - Reverse order.
 * @returns {Promise} - Returns {@link TXDetails}[].
 */

TXDB.prototype.getOffsetHashes = async function getOffsetHashes(account, options) {
  if (account && typeof account === 'object') {
    options = account;
    account = null;
  }

  if (account != null)
    return this.getAccountOffsetHashes(account, options);

  const start = options.start || 0;
  const end = options.end || 0xffffffff;
  const details = [];
  let count = 0,
      added = 0;

  await this.offset({
    gte: layout.m(start, encoding.NULL_HASH),
    lte: layout.m(end, encoding.HIGH_HASH),
    reverse: options.reverse,
    parse: (key) => {
      const [, hash] = layout.mm(key);
      return hash;
    },
    break: async (hash) => {
      const tx = await this.getTX(hash);
      assert(tx);
      const detail = await this.toDetails(tx);
      if (detail.block) {
        count++;
        if (count > options.offset) {
          details.push(detail);
          added++;
        }
      }

      if (added >= options.limit)
        return true;
      return false;
    }
  });

  return details;
};

/**
 * Get transactions by timestamp offset range.
 * @param {Number?} account
 * @param {Object} options
 * @param {Number} options.start - Start time.
 * @param {Number} options.end - End time.
 * @param {Number?} options.limit - Max number of records.
 * @param {Number} options.offset - Start of transactions.
 * @param {Boolean?} options.reverse - Reverse order.
 * @returns {Promise} - Returns {@link TXDetails}[].
 */

TXDB.prototype.getOffset = async function getOffset(account, options) {
  if (account && typeof account === 'object') {
    options = account;
    account = null;
  }

  return await this.getOffsetHashes(account, options);
};

/**
 * Get last N transactions.
 * @param {Number?} account
 * @param {Number} limit - Max number of transactions.
 * @returns {Promise} - Returns {@link TX}[].
 */

TXDB.prototype.getLast = function getLast(account, limit) {
  return this.getRange(account, {
    start: 0,
    end: 0xffffffff,
    reverse: true,
    limit: limit || 10
  });
};

/**
 * Get last N start from M of the sent and delivered transactions.
 * @param {Number?} account
 * @param {Number} limit - Max number of transactions.
 * @param {Number} offset - Start of transactions.
 * @returns {Promise} - Returns {@link TX}[].
 */

TXDB.prototype.getTransactions = function getTransactions(account, limit, offset) {
  return this.getOffset(account, {
    start: 0,
    end: 0xffffffff,
    reverse: true,
    offset: offset || 0,
    limit: limit || 10
  });
};

/**
 * Get all transactions.
 * @param {Number?} account
 * @returns {Promise} - Returns {@link TX}[].
 */

TXDB.prototype.getHistory = function getHistory(account) {
  // Slow case
  if (account != null)
    return this.getAccountHistory(account);

  // Fast case
  return this.values({
    gte: layout.t(encoding.NULL_HASH),
    lte: layout.t(encoding.HIGH_HASH),
    parse: TXRecord.fromRaw
  });
};

/**
 * Get all account transactions.
 * @param {Number?} account
 * @returns {Promise} - Returns {@link TX}[].
 */

TXDB.prototype.getAccountHistory = async function getAccountHistory(account) {
  const hashes = await this.getHistoryHashes(account);
  const txs = [];

  for (const hash of hashes) {
    const tx = await this.getTX(hash);
    assert(tx);
    txs.push(tx);
  }

  return txs;
};

/**
 * Get unconfirmed transactions.
 * @param {Number?} account
 * @returns {Promise} - Returns {@link TX}[].
 */

TXDB.prototype.getPending = async function getPending(account) {
  const hashes = await this.getPendingHashes(account);
  const txs = [];

  for (const hash of hashes) {
    const tx = await this.getTX(hash);
    assert(tx);
    txs.push(tx);
  }

  return txs;
};

/**
 * Get unconfirmed transactions details.
 * @param {Number?} account
 * @returns {Promise} - Returns {@link TXDetails}[].
 */

TXDB.prototype.getPendingDetails = async function getPendingDetails(account) {
  const hashes = await this.getPendingHashes(account);
  const details = [];

  for (const hash of hashes) {
    const tx = await this.getTX(hash);
    assert(tx);
    const detail = await this.toDetails(tx);
    details.push(detail);
  }

  return details;
};

/**
 * Get coins.
 * @param {Number?} account
 * @returns {Promise} - Returns {@link Coin}[].
 */

TXDB.prototype.getCredits = function getCredits(account) {
  // Slow case
  if (account != null)
    return this.getAccountCredits(account);

  // Fast case
  return this.range({
    gte: layout.c(encoding.NULL_HASH, 0x00000000),
    lte: layout.c(encoding.HIGH_HASH, 0xffffffff),
    parse: (key, value) => {
      const [hash, index] = layout.cc(key);
      const credit = Credit.fromRaw(value);
      const ckey = Outpoint.toKey(hash, index);
      credit.coin.hash = hash;
      credit.coin.index = index;
      this.coinCache.set(ckey, value);
      return credit;
    }
  });
};

/**
 * Get coins by account.
 * @param {Number} account
 * @returns {Promise} - Returns {@link Coin}[].
 */

TXDB.prototype.getAccountCredits = async function getAccountCredits(account) {
  const outpoints = await this.getOutpoints(account);
  const credits = [];

  for (const prevout of outpoints) {
    const credit = await this.getCredit(prevout.hash, prevout.index);
    assert(credit);
    credits.push(credit);
  }

  return credits;
};

/**
 * Fill a transaction with coins (all historical coins).
 * @param {TX} tx
 * @returns {Promise} - Returns {@link TX}.
 */

TXDB.prototype.getSpentCredits = async function getSpentCredits(tx) {
  if (tx.isCoinbase())
    return [];

  const hash = tx.hash('hex');
  const credits = [];

  for (let i = 0; i < tx.inputs.length; i++)
    credits.push(null);

  await this.range({
    gte: layout.d(hash, 0x00000000),
    lte: layout.d(hash, 0xffffffff),
    parse: (key, value) => {
      const [, index] = layout.dd(key);
      const coin = Coin.fromRaw(value);
      const input = tx.inputs[index];
      assert(input);
      coin.hash = input.prevout.hash;
      coin.index = input.prevout.index;
      credits[index] = new Credit(coin);
    }
  });

  return credits;
};

/**
 * Get coins.
 * @param {Number?} account
 * @returns {Promise} - Returns {@link Coin}[].
 */

TXDB.prototype.getCoins = async function getCoins(account) {
  const credits = await this.getCredits(account);
  const coins = [];

  for (const credit of credits) {
    if (credit.spent)
      continue;

    coins.push(credit.coin);
  }

  return coins;
};

/**
 * Get coins by account.
 * @param {Number} account
 * @returns {Promise} - Returns {@link Coin}[].
 */

TXDB.prototype.getAccountCoins = async function getAccountCoins(account) {
  const credits = await this.getAccountCredits(account);
  const coins = [];

  for (const credit of credits) {
    if (credit.spent)
      continue;

    coins.push(credit.coin);
  }

  return coins;
};

/**
 * Get historical coins for a transaction.
 * @param {TX} tx
 * @returns {Promise} - Returns {@link TX}.
 */

TXDB.prototype.getSpentCoins = async function getSpentCoins(tx) {
  if (tx.isCoinbase())
    return [];

  const credits = await this.getSpentCredits(tx);
  const coins = [];

  for (const credit of credits) {
    if (!credit) {
      coins.push(null);
      continue;
    }

    coins.push(credit.coin);
  }

  return coins;
};

/**
 * Get a coin viewpoint.
 * @param {TX} tx
 * @returns {Promise} - Returns {@link CoinView}.
 */

TXDB.prototype.getCoinView = async function getCoinView(tx) {
  const view = new CoinView();

  if (tx.isCoinbase())
    return view;

  for (const input of tx.inputs) {
    const prevout = input.prevout;
    const coin = await this.getCoin(prevout.hash, prevout.index);

    if (!coin)
      continue;

    view.addCoin(coin);
  }

  return view;
};

/**
 * Get historical coin viewpoint.
 * @param {TX} tx
 * @returns {Promise} - Returns {@link CoinView}.
 */

TXDB.prototype.getSpentView = async function getSpentView(tx) {
  const view = new CoinView();

  if (tx.isCoinbase())
    return view;

  const coins = await this.getSpentCoins(tx);

  for (const coin of coins) {
    if (!coin)
      continue;

    view.addCoin(coin);
  }

  return view;
};

/**
 * Get TXDB state.
 * @returns {Promise}
 */

TXDB.prototype.getState = async function getState() {
  const data = await this.get(layout.R);

  if (!data)
    return null;

  return TXDBState.fromRaw(this.wallet.wid, this.wallet.id, data);
};

/**
 * Get transaction.
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link TX}.
 */

TXDB.prototype.getTX = async function getTX(hash) {
  const raw = await this.get(layout.t(hash));

  if (!raw)
    return null;

  return TXRecord.fromRaw(raw);
};

/**
 * Get transaction details.
 * @param {Hash} hash
 * @returns {Promise} - Returns {@link TXDetails}.
 */

TXDB.prototype.getDetails = async function getDetails(hash) {
  const wtx = await this.getTX(hash);

  if (!wtx)
    return null;

  return await this.toDetails(wtx);
};

/**
 * Convert transaction to transaction details.
 * @param {TXRecord[]} wtxs
 * @returns {Promise}
 */

TXDB.prototype.toDetails = async function toDetails(wtxs) {
  const out = [];

  if (!Array.isArray(wtxs))
    return await this._toDetails(wtxs);

  for (const wtx of wtxs) {
    const details = await this._toDetails(wtx);

    if (!details)
      continue;

    out.push(details);
  }

  return out;
};

/**
 * Convert transaction to transaction details.
 * @private
 * @param {TXRecord} wtx
 * @returns {Promise}
 */

TXDB.prototype._toDetails = async function _toDetails(wtx) {
  const tx = wtx.tx;
  const block = wtx.getBlock();
  const details = new Details(this, wtx, block);
  const coins = await this.getSpentCoins(tx);

  for (let i = 0; i < tx.inputs.length; i++) {
    const coin = coins[i];
    let path = null;

    if (coin)
      path = await this.getPath(coin);

    details.setInput(i, path, coin);
  }

  for (let i = 0; i < tx.outputs.length; i++) {
    const output = tx.outputs[i];
    const path = await this.getPath(output);
    details.setOutput(i, path);
  }

  return details;
};

/**
 * Test whether the database has a transaction.
 * @param {Hash} hash
 * @returns {Promise} - Returns Boolean.
 */

TXDB.prototype.hasTX = function hasTX(hash) {
  return this.has(layout.t(hash));
};

/**
 * Get coin.
 * @param {Hash} hash
 * @param {Number} index
 * @returns {Promise} - Returns {@link Coin}.
 */

TXDB.prototype.getCoin = async function getCoin(hash, index) {
  const credit = await this.getCredit(hash, index);

  if (!credit)
    return null;

  return credit.coin;
};

/**
 * Get coin.
 * @param {Hash} hash
 * @param {Number} index
 * @returns {Promise} - Returns {@link Coin}.
 */

TXDB.prototype.getCredit = async function getCredit(hash, index) {
  const state = this.state;
  const key = Outpoint.toKey(hash, index);
  const cache = this.coinCache.get(key);

  if (cache) {
    const credit = Credit.fromRaw(cache);
    credit.coin.hash = hash;
    credit.coin.index = index;
    return credit;
  }

  const data = await this.get(layout.c(hash, index));

  if (!data)
    return null;

  const credit = Credit.fromRaw(data);
  credit.coin.hash = hash;
  credit.coin.index = index;

  if (state === this.state)
    this.coinCache.set(key, data);

  return credit;
};

/**
 * Get spender coin.
 * @param {Outpoint} spent
 * @param {Outpoint} prevout
 * @returns {Promise} - Returns {@link Coin}.
 */

TXDB.prototype.getSpentCoin = async function getSpentCoin(spent, prevout) {
  const data = await this.get(layout.d(spent.hash, spent.index));

  if (!data)
    return null;

  const coin = Coin.fromRaw(data);
  coin.hash = prevout.hash;
  coin.index = prevout.index;

  return coin;
};

/**
 * Test whether the database has a spent coin.
 * @param {Outpoint} spent
 * @returns {Promise} - Returns {@link Coin}.
 */

TXDB.prototype.hasSpentCoin = function hasSpentCoin(spent) {
  return this.has(layout.d(spent.hash, spent.index));
};

/**
 * Update spent coin height in storage.
 * @param {TX} tx - Sending transaction.
 * @param {Number} index
 * @param {Number} height
 * @returns {Promise}
 */

TXDB.prototype.updateSpentCoin = async function updateSpentCoin(tx, index, height) {
  const prevout = Outpoint.fromTX(tx, index);
  const spent = await this.getSpent(prevout.hash, prevout.index);

  if (!spent)
    return;

  const coin = await this.getSpentCoin(spent, prevout);

  if (!coin)
    return;

  coin.height = height;

  this.put(layout.d(spent.hash, spent.index), coin.toRaw());
};

/**
 * Test whether the database has a transaction.
 * @param {Hash} hash
 * @returns {Promise} - Returns Boolean.
 */

TXDB.prototype.hasCoin = async function hasCoin(hash, index) {
  const key = Outpoint.toKey(hash, index);

  if (this.coinCache.has(key))
    return true;

  return await this.has(layout.c(hash, index));
};

/**
 * Calculate balance.
 * @param {Number?} account
 * @returns {Promise} - Returns {@link Balance}.
 */

TXDB.prototype.getBalance = async function getBalance(account) {
  // Slow case
  if (account != null)
    return await this.getAccountBalance(account);

  // Fast case
  return this.state.toBalance();
};

/**
 * Calculate balance.
 * @param {Number?} account
 * @returns {Promise} - Returns {@link Balance}.
 */

TXDB.prototype.getWalletBalance = async function getWalletBalance() {
  const credits = await this.getCredits();
  const balance = new Balance(this.wallet.wid, this.wallet.id, -1);

  for (const credit of credits) {
    const coin = credit.coin;

    if (coin.height !== -1)
      balance.confirmed += coin.value;

    if (!credit.spent)
      balance.unconfirmed += coin.value;
  }

  return balance;
};

/**
 * Calculate balance by account.
 * @param {Number} account
 * @returns {Promise} - Returns {@link Balance}.
 */

TXDB.prototype.getAccountBalance = async function getAccountBalance(account) {
  const credits = await this.getAccountCredits(account);
  const balance = new Balance(this.wallet.wid, this.wallet.id, account);

  for (const credit of credits) {
    const coin = credit.coin;

    if (coin.height !== -1)
      balance.confirmed += coin.value;

    if (!credit.spent)
      balance.unconfirmed += coin.value;
  }

  return balance;
};

/**
 * Calculate balance details.
 * @param {Number?} account
 * @returns {Promise} - Returns {@link BalanceDetails}.
 */

TXDB.prototype.getBalanceDetails = async function getBalanceDetails(account) {
  // Slow case
  if (account != null)
    return await this.getAccountBalanceDetails(account);

  // Fast case
  return this.state.toBalanceDetails(); // todo::now
};

/**
 * Calculate balance details.
 * @param {Number?} account
 * @returns {Promise} - Returns {@link BalanceDetails}.
 */

TXDB.prototype.getWalletBalanceDetails = async function getWalletBalanceDetails() {
  const credits = await this.getCredits();
  const balance = new BalanceDetails(this.wallet.wid, this.wallet.id, -1);

  for (const credit of credits) {
    const coin = credit.coin;

    if (coin.height !== -1)
      balance.confirmed += coin.value;

    if (!credit.spent)
      balance.unconfirmed += coin.value;
  }

  return balance;
};

/**
 * Calculate balance details by account.
 * @param {Number} account
 * @returns {Promise} - Returns {@link BalanceDetails}.
 */

TXDB.prototype.getAccountBalanceDetails = async function getAccountBalanceDetails(account) {
  const credits = await this.getAccountCredits(account);
  const balance = new BalanceDetails(this, this.wallet.wid, this.wallet.id, account);
  const txs = await this.getPendingDetails(account);
  //const hashes = await this.getPendingHashes(account);
  const maturity = 1 + balance.chainHeight - consensus.COINBASE_MATURITY;

  for (const credit of credits) {
    const coin = credit.coin;
    
    if (coin.coinbase && maturity < coin.height) {
      balance.immature += coin.value;
    } else {
      /*if (credit.own && credit.spent)
        balance.pending -= coin.value;*/

      if (!credit.own && !credit.spent)
        balance.available += coin.value;

      if (credit.own && !credit.spent)
        balance.available += coin.value;

      /*if (hashes.includes(coin.hash)) {
        if (credit.own)
          balance.pending += coin.value;
        else
          balance.pending += coin.value;
      }*/
    }
  }
  for (const tx of txs) {
    for (const input of tx.inputs) {
      if (input.path)
        balance.pending -= input.value;
    }
    for (const output of tx.outputs) {
      if (output.path)
        balance.pending += output.value;
    }
  }
  balance.available -= balance.pending;
  balance.total = balance.available + balance.pending + balance.immature;

  return balance;
};

/**
 * Zap pending transactions older than `age`.
 * @param {Number?} account
 * @param {Number} age - Age delta (delete transactions older than `now - age`).
 * @returns {Promise}
 */

TXDB.prototype.zap = async function zap(account, age) {
  assert(util.isU32(age));

  const now = util.now();

  const txs = await this.getRange(account, {
    start: 0,
    end: now - age
  });

  const hashes = [];

  for (const wtx of txs) {
    if (wtx.height !== -1)
      continue;

    assert(now - wtx.mtime >= age);

    this.logger.debug('Zapping TX: %s (%s)',
      wtx.tx.txid(), this.wallet.id);

    await this.remove(wtx.hash);

    hashes.push(wtx.hash);
  }

  return hashes;
};

/**
 * Abandon transaction.
 * @param {Hash} hash
 * @returns {Promise}
 */

TXDB.prototype.abandon = async function abandon(hash) {
  const result = await this.has(layout.p(hash));

  if (!result)
    throw new Error('TX not eligible.');

  return await this.remove(hash);
};

/**
 * Get total number of transactions.
 * @param {Number?} account
 * @returns {Promise} - Returns Number.
 */

TXDB.prototype.getAccountTotal = function getAccountTotal(account) {
  return this.total({
    gte: layout.M(account, 0, encoding.NULL_HASH),
    lte: layout.M(account, 0xffffffff, encoding.HIGH_HASH)
  });
};

/**
 * Get total number of transactions.
 * @param {Number?} account
 * @returns {Promise} - Returns Number.
 */

TXDB.prototype.getTotal = function getTotal(account) {
  if (account != null)
    return this.getAccountTotal(account);

  return this.total({
    gte: layout.m(0, encoding.NULL_HASH),
    lte: layout.m(0xffffffff, encoding.HIGH_HASH)
  });
};

/**
 * Balance
 * @alias module:wallet.Balance
 * @constructor
 * @param {WalletID} wid
 * @param {String} id
 * @param {Number} account
 */

function Balance(wid, id, account) {
  if (!(this instanceof Balance))
    return new Balance(wid, id, account);

  this.wid = wid;
  this.id = id;
  this.account = account;
  this.unconfirmed = 0;
  this.confirmed = 0;
}

/**
 * Test whether a balance is equal.
 * @param {Balance} balance
 * @returns {Boolean}
 */

Balance.prototype.equal = function equal(balance) {
  return this.wid === balance.wid
    && this.confirmed === balance.confirmed
    && this.unconfirmed === balance.unconfirmed;
};

/**
 * Convert balance to a more json-friendly object.
 * @param {Boolean?} minimal
 * @returns {Object}
 */

Balance.prototype.toJSON = function toJSON(minimal) {
  return {
    wid: !minimal ? this.wid : undefined,
    id: !minimal ? this.id : undefined,
    account: !minimal ? this.account : undefined,
    unconfirmed: this.unconfirmed,
    confirmed: this.confirmed
  };
};

/**
 * Convert balance to human-readable string.
 * @returns {String}
 */

Balance.prototype.toString = function toString() {
  return '<Balance'
    + ` unconfirmed=${Amount.wmcc(this.unconfirmed)}`
    + ` confirmed=${Amount.wmcc(this.confirmed)}`
    + '>';
};

/**
 * Inspect balance.
 * @param {String}
 */

Balance.prototype.inspect = function inspect() {
  return this.toString();
};

/**
 * Balance Details
 * @alias module:wallet.BalanceDetails
 * @constructor
 * @param {WalletID} wid
 * @param {String} id
 * @param {Number} account
 */

function BalanceDetails(txdb, wid, id, account) {
  if (!(this instanceof BalanceDetails))
    return new BalanceDetails(wid, id, account);

  this.wid = wid;
  this.id = id;
  this.account = account;
  this.chainHeight = txdb.walletdb.state.height;
  this.total = 0;
  this.available = 0;
  this.pending = 0;
  this.immature = 0;
}

/**
 * Test whether a balance details is equal.
 * @param {BalanceDetails} balance details
 * @returns {Boolean}
 */

BalanceDetails.prototype.equal = function equal(balance) {
  return this.wid === balance.wid
    && this.chainHeight === balance.chainHeight
    && this.total === balance.total
    && this.available === balance.available
    && this.pending === balance.pending
    && this.immature === balance.immature;
};

/**
 * Convert balance details to a more json-friendly object.
 * @param {Boolean?} minimal
 * @returns {Object}
 */

BalanceDetails.prototype.toJSON = function toJSON(minimal) {
  return {
    wid: !minimal ? this.wid : undefined,
    id: !minimal ? this.id : undefined,
    account: !minimal ? this.account : undefined,
    chainHeight: !minimal ? this.chainHeight : undefined,
    available: this.available,
    total: this.total,
    pending: this.pending,
    immature: this.immature
  };
};

/**
 * Convert balance details to human-readable string.
 * @returns {String}
 */

BalanceDetails.prototype.toString = function toString() {
  return '<BalanceDetails'
    + ` total=${Amount.wmcc(this.total)}`
    + ` available=${Amount.wmcc(this.available)}`
    + ` pending=${Amount.wmcc(this.pending)}`
    + ` immature=${Amount.wmcc(this.immature)}`
    + '>';
};

/**
 * Inspect balance details.
 * @param {String}
 */

BalanceDetails.prototype.inspect = function inspect() {
  return this.toString();
};

/**
 * Chain State
 * @alias module:wallet.ChainState
 * @constructor
 * @param {WalletID} wid
 * @param {String} id
 */

function TXDBState(wid, id) {
  this.wid = wid;
  this.id = id;
  this.tx = 0;
  this.coin = 0;
  this.unconfirmed = 0;
  this.confirmed = 0;
  this.committed = false;
}

/**
 * Clone the state.
 * @returns {TXDBState}
 */

TXDBState.prototype.clone = function clone() {
  const state = new TXDBState(this.wid, this.id);
  state.tx = this.tx;
  state.coin = this.coin;
  state.unconfirmed = this.unconfirmed;
  state.confirmed = this.confirmed;
  return state;
};

/**
 * Commit and serialize state.
 * @returns {Buffer}
 */

TXDBState.prototype.commit = function commit() {
  this.committed = true;
  return this.toRaw();
};

/**
 * Convert state to a balance object.
 * @returns {Balance}
 */

TXDBState.prototype.toBalance = function toBalance() {
  const balance = new Balance(this.wid, this.id, -1);
  balance.unconfirmed = this.unconfirmed;
  balance.confirmed = this.confirmed;
  return balance;
};

/**
 * Serialize state.
 * @returns {Buffer}
 */

TXDBState.prototype.toRaw = function toRaw() {
  const bw = new StaticWriter(32);

  bw.writeU64(this.tx);
  bw.writeU64(this.coin);
  bw.writeU64(this.unconfirmed);
  bw.writeU64(this.confirmed);

  return bw.render();
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 * @returns {TXDBState}
 */

TXDBState.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data);
  this.tx = br.readU64();
  this.coin = br.readU64();
  this.unconfirmed = br.readU64();
  this.confirmed = br.readU64();
  return this;
};

/**
 * Instantiate txdb state from serialized data.
 * @param {Buffer} data
 * @returns {TXDBState}
 */

TXDBState.fromRaw = function fromRaw(wid, id, data) {
  return new TXDBState(wid, id).fromRaw(data);
};

/**
 * Convert state to a more json-friendly object.
 * @param {Boolean?} minimal
 * @returns {Object}
 */

TXDBState.prototype.toJSON = function toJSON(minimal) {
  return {
    wid: !minimal ? this.wid : undefined,
    id: !minimal ? this.id : undefined,
    tx: this.tx,
    coin: this.coin,
    unconfirmed: this.unconfirmed,
    confirmed: this.confirmed
  };
};

/**
 * Inspect the state.
 * @returns {Object}
 */

TXDBState.prototype.inspect = function inspect() {
  return this.toJSON();
};

/**
 * Credit (wrapped coin)
 * @alias module:wallet.Credit
 * @constructor
 * @param {Coin} coin
 * @param {Boolean?} spent
 * @property {Coin} coin
 * @property {Boolean} spent
 */

function Credit(coin, spent) {
  if (!(this instanceof Credit))
    return new Credit(coin, spent);

  this.coin = coin || new Coin();
  this.spent = spent || false;
  this.own = false;
}

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 */

Credit.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data);
  this.coin.fromReader(br);
  this.spent = br.readU8() === 1;
  this.own = true;

  // Note: soft-fork
  if (br.left() > 0)
    this.own = br.readU8() === 1;

  return this;
};

/**
 * Instantiate credit from serialized data.
 * @param {Buffer} data
 * @returns {Credit}
 */

Credit.fromRaw = function fromRaw(data) {
  return new Credit().fromRaw(data);
};

/**
 * Get serialization size.
 * @returns {Number}
 */

Credit.prototype.getSize = function getSize() {
  return this.coin.getSize() + 2;
};

/**
 * Serialize credit.
 * @returns {Buffer}
 */

Credit.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  const bw = new StaticWriter(size);
  this.coin.toWriter(bw);
  bw.writeU8(this.spent ? 1 : 0);
  bw.writeU8(this.own ? 1 : 0);
  return bw.render();
};

/**
 * Inject properties from tx object.
 * @private
 * @param {TX} tx
 * @param {Number} index
 * @returns {Credit}
 */

Credit.prototype.fromTX = function fromTX(tx, index, height) {
  this.coin.fromTX(tx, index, height);
  this.spent = false;
  this.own = false;
  return this;
};

/**
 * Instantiate credit from transaction.
 * @param {TX} tx
 * @param {Number} index
 * @returns {Credit}
 */

Credit.fromTX = function fromTX(tx, index, height) {
  return new Credit().fromTX(tx, index, height);
};

/**
 * Transaction Details
 * @alias module:wallet.Details
 * @constructor
 * @param {TXDB} txdb
 * @param {TX} tx
 */

function Details(txdb, wtx, block) {
  if (!(this instanceof Details))
    return new Details(txdb, wtx, block);

  this.wallet = txdb.wallet;
  this.network = this.wallet.network;
  this.wid = this.wallet.wid;
  this.id = this.wallet.id;

  this.chainHeight = txdb.walletdb.state.height;

  this.hash = wtx.hash;
  this.tx = wtx.tx;
  this.mtime = wtx.mtime;
  this.size = this.tx.getSize();
  this.vsize = this.tx.getVirtualSize();

  this.block = null;
  this.height = -1;
  this.time = 0;

  if (block) {
    this.block = block.hash;
    this.height = block.height;
    this.time = block.time;
  }

  this.inputs = [];
  this.outputs = [];

  this.init();
}

/**
 * Initialize transaction details.
 * @private
 */

Details.prototype.init = function init() {
  for (const input of this.tx.inputs) {
    const member = new DetailsMember();
    member.address = input.getAddress();
    this.inputs.push(member);
  }

  for (const output of this.tx.outputs) {
    const member = new DetailsMember();
    member.value = output.value;
    member.address = output.getAddress();
    this.outputs.push(member);
  }
};

/**
 * Add necessary info to input member.
 * @param {Number} i
 * @param {Path} path
 * @param {Coin} coin
 */

Details.prototype.setInput = function setInput(i, path, coin) {
  const member = this.inputs[i];

  if (coin) {
    member.value = coin.value;
    member.address = coin.getAddress();
  }

  if (path)
    member.path = path;
};

/**
 * Add necessary info to output member.
 * @param {Number} i
 * @param {Path} path
 */

Details.prototype.setOutput = function setOutput(i, path) {
  const member = this.outputs[i];

  if (path)
    member.path = path;
};

/**
 * Calculate confirmations.
 * @returns {Number}
 */

Details.prototype.getDepth = function getDepth() {
  if (this.height === -1)
    return 0;

  const depth = this.chainHeight - this.height;

  if (depth < 0)
    return 0;

  return depth + 1;
};

/**
 * Calculate fee. Only works if wallet
 * owns all inputs. Returns 0 otherwise.
 * @returns {Amount}
 */

Details.prototype.getFee = function getFee() {
  let inputValue = 0;
  let outputValue = 0;

  for (const input of this.inputs) {
    if (!input.path)
      return 0;

    inputValue += input.value;
  }

  for (const output of this.outputs)
    outputValue += output.value;

  return inputValue - outputValue;
};

/**
 * Calculate fee rate. Only works if wallet
 * owns all inputs. Returns 0 otherwise.
 * @param {Amount} fee
 * @returns {Rate}
 */

Details.prototype.getRate = function getRate(fee) {
  return policy.getRate(this.vsize, fee);
};

/**
 * Convert details to a more json-friendly object.
 * @returns {Object}
 */

Details.prototype.toJSON = function toJSON() {
  const fee = this.getFee();
  let rate = this.getRate(fee);

  // Rate can exceed 53 bits in testing.
  if (!Number.isSafeInteger(rate))
    rate = 0;

  return {
    wid: this.wid,
    id: this.id,
    hash: util.revHex(this.hash),
    height: this.height,
    block: this.block ? util.revHex(this.block) : null,
    time: this.time,
    mtime: this.mtime,
    date: util.date(this.time || this.mtime),
    size: this.size,
    virtualSize: this.vsize,
    fee: fee,
    rate: rate,
    confirmations: this.getDepth(),
    inputs: this.inputs.map((input) => {
      return input.getJSON(this.network);
    }),
    outputs: this.outputs.map((output) => {
      return output.getJSON(this.network);
    }),
    tx: this.tx.toRaw().toString('hex')
  };
};

/**
 * Transaction Details Member
 * @alias module:wallet.DetailsMember
 * @constructor
 * @property {Number} value
 * @property {Address} address
 * @property {Path} path
 */

function DetailsMember() {
  if (!(this instanceof DetailsMember))
    return new DetailsMember();

  this.value = 0;
  this.address = null;
  this.path = null;
}

/**
 * Convert the member to a more json-friendly object.
 * @returns {Object}
 */

DetailsMember.prototype.toJSON = function toJSON() {
  return this.getJSON();
};

/**
 * Convert the member to a more json-friendly object.
 * @param {Network} network
 * @returns {Object}
 */

DetailsMember.prototype.getJSON = function getJSON(network) {
  return {
    value: this.value,
    address: this.address
      ? this.address.toString(network)
      : null,
    path: this.path
      ? this.path.toJSON()
      : null
  };
};

/**
 * Block Record
 * @alias module:wallet.BlockRecord
 * @constructor
 * @param {Hash} hash
 * @param {Number} height
 * @param {Number} time
 */

function BlockRecord(hash, height, time) {
  if (!(this instanceof BlockRecord))
    return new BlockRecord(hash, height, time);

  this.hash = hash || encoding.NULL_HASH;
  this.height = height != null ? height : -1;
  this.time = time || 0;
  this.hashes = [];
  this.index = new Set();
}

/**
 * Add transaction to block record.
 * @param {Hash} hash
 * @returns {Boolean}
 */

BlockRecord.prototype.add = function add(hash) {
  if (this.index.has(hash))
    return false;

  this.index.add(hash);
  this.hashes.push(hash);

  return true;
};

/**
 * Remove transaction from block record.
 * @param {Hash} hash
 * @returns {Boolean}
 */

BlockRecord.prototype.remove = function remove(hash) {
  if (!this.index.has(hash))
    return false;

  this.index.delete(hash);

  // Fast case
  if (this.hashes[this.hashes.length - 1] === hash) {
    this.hashes.pop();
    return true;
  }

  const index = this.hashes.indexOf(hash);

  assert(index !== -1);

  this.hashes.splice(index, 1);

  return true;
};

/**
 * Instantiate wallet block from serialized tip data.
 * @private
 * @param {Buffer} data
 */

BlockRecord.prototype.fromRaw = function fromRaw(data) {
  const br = new BufferReader(data);

  this.hash = br.readHash('hex');
  this.height = br.readU32();
  this.time = br.readU32();

  const count = br.readU32();

  for (let i = 0; i < count; i++) {
    const hash = br.readHash('hex');
    this.index.add(hash);
    this.hashes.push(hash);
  }

  return this;
};

/**
 * Instantiate wallet block from serialized data.
 * @param {Buffer} data
 * @returns {BlockRecord}
 */

BlockRecord.fromRaw = function fromRaw(data) {
  return new BlockRecord().fromRaw(data);
};

/**
 * Get serialization size.
 * @returns {Number}
 */

BlockRecord.prototype.getSize = function getSize() {
  return 44 + this.hashes.length * 32;
};

/**
 * Serialize the wallet block as a tip (hash and height).
 * @returns {Buffer}
 */

BlockRecord.prototype.toRaw = function toRaw() {
  const size = this.getSize();
  const bw = new StaticWriter(size);

  bw.writeHash(this.hash);
  bw.writeU32(this.height);
  bw.writeU32(this.time);

  bw.writeU32(this.hashes.length);

  for (const hash of this.hashes)
    bw.writeHash(hash);

  return bw.render();
};

/**
 * Convert the block to a more json-friendly object.
 * @returns {Object}
 */

BlockRecord.prototype.toJSON = function toJSON() {
  return {
    hash: util.revHex(this.hash),
    height: this.height,
    time: this.time,
    hashes: this.hashes.map(util.revHex)
  };
};

/**
 * Instantiate wallet block from block meta.
 * @private
 * @param {BlockMeta} block
 */

BlockRecord.prototype.fromMeta = function fromMeta(block) {
  this.hash = block.hash;
  this.height = block.height;
  this.time = block.time;
  return this;
};

/**
 * Instantiate wallet block from block meta.
 * @param {BlockMeta} block
 * @returns {BlockRecord}
 */

BlockRecord.fromMeta = function fromMeta(block) {
  return new BlockRecord().fromMeta(block);
};

/*
 * Expose
 */

module.exports = TXDB;


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * rpc.js - wmccd-compatible json rpc for wmcc_core.
 */



const assert = __webpack_require__(0);
const fs = __webpack_require__(58);
const util = __webpack_require__(1);
const digest = __webpack_require__(5);
const Amount = __webpack_require__(20);
const Script = __webpack_require__(8);
const Address = __webpack_require__(11);
const KeyRing = __webpack_require__(47);
const MerkleBlock = __webpack_require__(69);
const MTX = __webpack_require__(48);
const Outpoint = __webpack_require__(21);
const Output = __webpack_require__(13);
const TX = __webpack_require__(16);
const encoding = __webpack_require__(3);
const RPCBase = __webpack_require__(178);
const pkg = __webpack_require__(94);
const Validator = __webpack_require__(71);
const common = __webpack_require__(61);
const RPCError = RPCBase.RPCError;
const errs = RPCBase.errors;
const MAGIC_STRING = RPCBase.MAGIC_STRING;

/**
 * WMCC Core RPC
 * @alias module:wallet.RPC
 * @constructor
 * @param {WalletDB} wdb
 */

function RPC(wdb) {
  if (!(this instanceof RPC))
    return new RPC(wdb);

  RPCBase.call(this);

  assert(wdb, 'RPC requires a WalletDB.');

  this.wdb = wdb;
  this.network = wdb.network;
  this.logger = wdb.logger.context('rpc');
  this.client = wdb.client;

  this.wallet = null;

  this.init();
}

Object.setPrototypeOf(RPC.prototype, RPCBase.prototype);

RPC.prototype.init = function init() {
  this.add('help', this.help);
  this.add('stop', this.stop);
  this.add('fundrawtransaction', this.fundRawTransaction);
  this.add('resendwallettransactions', this.resendWalletTransactions);
  this.add('abandontransaction', this.abandonTransaction);
  this.add('addmultisigaddress', this.addMultisigAddress);
  this.add('addwitnessaddress', this.addWitnessAddress);
  this.add('backupwallet', this.backupWallet);
  this.add('dumpprivkey', this.dumpPrivKey);
  this.add('dumpwallet', this.dumpWallet);
  this.add('encryptwallet', this.encryptWallet);
  this.add('getaccountaddress', this.getAccountAddress);
  this.add('getaccount', this.getAccount);
  this.add('getaddressesbyaccount', this.getAddressesByAccount);
  this.add('getbalance', this.getBalance);
  this.add('getnewaddress', this.getNewAddress);
  this.add('getrawchangeaddress', this.getRawChangeAddress);
  this.add('getreceivedbyaccount', this.getReceivedByAccount);
  this.add('getreceivedbyaddress', this.getReceivedByAddress);
  this.add('gettransaction', this.getTransaction);
  this.add('getunconfirmedbalance', this.getUnconfirmedBalance);
  this.add('getwalletinfo', this.getWalletInfo);
  this.add('importprivkey', this.importPrivKey);
  this.add('importwallet', this.importWallet);
  this.add('importaddress', this.importAddress);
  this.add('importprunedfunds', this.importPrunedFunds);
  this.add('importpubkey', this.importPubkey);
  this.add('keypoolrefill', this.keyPoolRefill);
  this.add('listaccounts', this.listAccounts);
  this.add('listaddressgroupings', this.listAddressGroupings);
  this.add('listlockunspent', this.listLockUnspent);
  this.add('listreceivedbyaccount', this.listReceivedByAccount);
  this.add('listreceivedbyaddress', this.listReceivedByAddress);
  this.add('listsinceblock', this.listSinceBlock);
  this.add('listtransactions', this.listTransactions);
  this.add('listunspent', this.listUnspent);
  this.add('lockunspent', this.lockUnspent);
  this.add('move', this.move);
  this.add('sendfrom', this.sendFrom);
  this.add('sendmany', this.sendMany);
  this.add('sendtoaddress', this.sendToAddress);
  this.add('setaccount', this.setAccount);
  this.add('settxfee', this.setTXFee);
  this.add('signmessage', this.signMessage);
  this.add('walletlock', this.walletLock);
  this.add('walletpassphrasechange', this.walletPassphraseChange);
  this.add('walletpassphrase', this.walletPassphrase);
  this.add('removeprunedfunds', this.removePrunedFunds);
  this.add('selectwallet', this.selectWallet);
  this.add('getmemoryinfo', this.getMemoryInfo);
  this.add('setloglevel', this.setLogLevel);
};

RPC.prototype.help = async function help(args, _help) {
  if (args.length === 0)
    return 'Select a command.';

  const json = {
    method: args[0],
    params: []
  };

  return await this.execute(json, true);
};

RPC.prototype.stop = async function stop(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'stop');

  this.wdb.close();

  return 'Stopping.';
};

RPC.prototype.fundRawTransaction = async function fundRawTransaction(args, help) {
  if (help || args.length < 1 || args.length > 2) {
    throw new RPCError(errs.MISC_ERROR,
      'fundrawtransaction "hexstring" ( options )');
  }

  const wallet = this.wallet;
  const valid = new Validator([args]);
  const data = valid.buf(0);
  const options = valid.obj(1);

  if (!data)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid hex string.');

  const tx = MTX.fromRaw(data);

  if (tx.outputs.length === 0) {
    throw new RPCError(errs.INVALID_PARAMETER,
      'TX must have at least one output.');
  }

  let rate = null;
  let change = null;

  if (options) {
    const valid = new Validator([options]);

    rate = valid.ufixed('feeRate', 8);
    change = valid.str('changeAddress');

    if (change)
      change = parseAddress(change, this.network);
  }

  await wallet.fund(tx, {
    rate: rate,
    changeAddress: change
  });

  return {
    hex: tx.toRaw().toString('hex'),
    changepos: tx.changeIndex,
    fee: Amount.wmcc(tx.getFee(), true)
  };
};

/*
 * Wallet
 */

RPC.prototype.resendWalletTransactions = async function resendWalletTransactions(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'resendwallettransactions');

  const wallet = this.wallet;
  const txs = await wallet.resend();
  const hashes = [];

  for (const tx of txs)
    hashes.push(tx.txid());

  return hashes;
};

RPC.prototype.addMultisigAddress = async function addMultisigAddress(args, help) {
  if (help || args.length < 2 || args.length > 3) {
    throw new RPCError(errs.MISC_ERROR,
      'addmultisigaddress nrequired ["key",...] ( "account" )');
  }

  // Impossible to implement in wmcc_core (no address book).
  throw new Error('Not implemented.');
};

RPC.prototype.addWitnessAddress = async function addWitnessAddress(args, help) {
  if (help || args.length < 1 || args.length > 1)
    throw new RPCError(errs.MISC_ERROR, 'addwitnessaddress "address"');

  // Unlikely to be implemented.
  throw new Error('Not implemented.');
};

RPC.prototype.backupWallet = async function backupWallet(args, help) {
  const valid = new Validator([args]);
  const dest = valid.str(0);

  if (help || args.length !== 1 || !dest)
    throw new RPCError(errs.MISC_ERROR, 'backupwallet "destination"');

  await this.wdb.backup(dest);

  return null;
};

RPC.prototype.dumpPrivKey = async function dumpPrivKey(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'dumpprivkey "wmccaddress"');

  const wallet = this.wallet;
  const valid = new Validator([args]);
  const addr = valid.str(0, '');

  const hash = parseHash(addr, this.network);
  const ring = await wallet.getPrivateKey(hash);

  if (!ring)
    throw new RPCError(errs.MISC_ERROR, 'Key not found.');

  return ring.toSecret();
};

RPC.prototype.dumpWallet = async function dumpWallet(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'dumpwallet "filename"');

  const wallet = this.wallet;
  const valid = new Validator([args]);
  const file = valid.str(0);

  if (!file)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid parameter.');

  const tip = await this.wdb.getTip();
  const time = util.date();

  const out = [
    util.fmt('# Wallet Dump created by WMCC_Core %s', pkg.version),
    util.fmt('# * Created on %s', time),
    util.fmt('# * Best block at time of backup was %d (%s).',
      tip.height, util.revHex(tip.hash)),
    util.fmt('# * File: %s', file),
    ''
  ];

  const hashes = await wallet.getAddressHashes();

  for (const hash of hashes) {
    const ring = await wallet.getPrivateKey(hash);

    if (!ring)
      continue;

    const addr = ring.getAddress('string');

    let fmt = '%s %s label= addr=%s';

    if (ring.branch === 1)
      fmt = '%s %s change=1 addr=%s';

    const str = util.fmt(fmt, ring.toSecret(), time, addr);

    out.push(str);
  }

  out.push('');
  out.push('# End of dump');
  out.push('');

  const dump = out.join('\n');

  if (fs.unsupported)
    return dump;

  await fs.writeFile(file, dump, 'utf8');

  return null;
};

RPC.prototype.encryptWallet = async function encryptWallet(args, help) {
  const wallet = this.wallet;

  if (!wallet.master.encrypted && (help || args.length !== 1))
    throw new RPCError(errs.MISC_ERROR, 'encryptwallet "passphrase"');

  const valid = new Validator([args]);
  const passphrase = valid.str(0, '');

  if (wallet.master.encrypted) {
    throw new RPCError(errs.WALLET_WRONG_ENC_STATE,
      'Already running with an encrypted wallet.');
  }

  if (passphrase.length < 1)
    throw new RPCError(errs.MISC_ERROR, 'encryptwallet "passphrase"');

  try {
    await wallet.setPassphrase(passphrase);
  } catch (e) {
    throw new RPCError(errs.WALLET_ENCRYPTION_FAILED, 'Encryption failed.');
  }

  return 'wallet encrypted; we do not need to stop!';
};

RPC.prototype.getAccountAddress = async function getAccountAddress(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'getaccountaddress "account"');

  const wallet = this.wallet;
  const valid = new Validator([args]);
  let name = valid.str(0, '');

  if (!name)
    name = 'default';

  const account = await wallet.getAccount(name);

  if (!account)
    return '';

  return account.receive.getAddress('string');
};

RPC.prototype.getAccount = async function getAccount(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'getaccount "wmccaddress"');

  const wallet = this.wallet;
  const valid = new Validator([args]);
  const addr = valid.str(0, '');

  const hash = parseHash(addr, this.network);
  const path = await wallet.getPath(hash);

  if (!path)
    return '';

  return path.name;
};

RPC.prototype.getAddressesByAccount = async function getAddressesByAccount(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'getaddressesbyaccount "account"');

  const wallet = this.wallet;
  const valid = new Validator([args]);
  let name = valid.str(0, '');
  const addrs = [];

  if (name === '')
    name = 'default';

  const paths = await wallet.getPaths(name);

  for (const path of paths) {
    const addr = path.toAddress();
    addrs.push(addr.toString(this.network));
  }

  return addrs;
};

RPC.prototype.getBalance = async function getBalance(args, help) {
  if (help || args.length > 3) {
    throw new RPCError(errs.MISC_ERROR,
      'getbalance ( "account" minconf includeWatchonly )');
  }

  const wallet = this.wallet;
  const valid = new Validator([args]);
  let name = valid.str(0);
  const minconf = valid.u32(1, 0);
  const watchOnly = valid.bool(2, false);

  if (name === '')
    name = 'default';

  if (name === '*')
    name = null;

  if (wallet.watchOnly !== watchOnly)
    return 0;

  const balance = await wallet.getBalance(name);

  let value;
  if (minconf > 0)
    value = balance.confirmed;
  else
    value = balance.unconfirmed;

  return Amount.wmcc(value, true);
};

RPC.prototype.getNewAddress = async function getNewAddress(args, help) {
  if (help || args.length > 1)
    throw new RPCError(errs.MISC_ERROR, 'getnewaddress ( "account" )');

  const wallet = this.wallet;
  const valid = new Validator([args]);
  let name = valid.str(0);

  if (name === '')
    name = 'default';

  const addr = await wallet.createReceive(name);

  return addr.getAddress('string');
};

RPC.prototype.getRawChangeAddress = async function getRawChangeAddress(args, help) {
  if (help || args.length > 1)
    throw new RPCError(errs.MISC_ERROR, 'getrawchangeaddress');

  const wallet = this.wallet;
  const addr = await wallet.createChange();

  return addr.getAddress('string');
};

RPC.prototype.getReceivedByAccount = async function getReceivedByAccount(args, help) {
  if (help || args.length < 1 || args.length > 2) {
    throw new RPCError(errs.MISC_ERROR,
      'getreceivedbyaccount "account" ( minconf )');
  }

  const wallet = this.wallet;
  const valid = new Validator([args]);
  let name = valid.str(0);
  const minconf = valid.u32(1, 0);
  const height = this.wdb.state.height;

  if (name === '')
    name = 'default';

  const paths = await wallet.getPaths(name);
  const filter = new Set();

  for (const path of paths)
    filter.add(path.hash);

  const txs = await wallet.getHistory(name);

  let total = 0;
  let lastConf = -1;

  for (const wtx of txs) {
    const conf = wtx.getDepth(height);

    if (conf < minconf)
      continue;

    if (lastConf === -1 || conf < lastConf)
      lastConf = conf;

    for (const output of wtx.tx.outputs) {
      const hash = output.getHash('hex');
      if (hash && filter.has(hash))
        total += output.value;
    }
  }

  return Amount.wmcc(total, true);
};

RPC.prototype.getReceivedByAddress = async function getReceivedByAddress(args, help) {
  if (help || args.length < 1 || args.length > 2) {
    throw new RPCError(errs.MISC_ERROR,
      'getreceivedbyaddress "wmccaddress" ( minconf )');
  }

  const wallet = this.wallet;
  const valid = new Validator([args]);
  const addr = valid.str(0, '');
  const minconf = valid.u32(1, 0);
  const height = this.wdb.state.height;

  const hash = parseHash(addr, this.network);
  const txs = await wallet.getHistory();

  let total = 0;

  for (const wtx of txs) {
    if (wtx.getDepth(height) < minconf)
      continue;

    for (const output of wtx.tx.outputs) {
      if (output.getHash('hex') === hash)
        total += output.value;
    }
  }

  return Amount.wmcc(total, true);
};

RPC.prototype._toWalletTX = async function _toWalletTX(wtx) {
  const wallet = this.wallet;
  const details = await wallet.toDetails(wtx);

  if (!details)
    throw new RPCError(errs.WALLET_ERROR, 'TX not found.');

  let receive = true;
  for (const member of details.inputs) {
    if (member.path) {
      receive = false;
      break;
    }
  }

  const det = [];
  let sent = 0;
  let received = 0;

  for (let i = 0; i < details.outputs.length; i++) {
    const member = details.outputs[i];

    if (member.path) {
      if (member.path.branch === 1)
        continue;

      det.push({
        account: member.path.name,
        address: member.address.toString(this.network),
        category: 'receive',
        amount: Amount.wmcc(member.value, true),
        label: member.path.name,
        vout: i
      });

      received += member.value;

      continue;
    }

    if (receive)
      continue;

    det.push({
      account: '',
      address: member.address
        ? member.address.toString(this.network)
        : null,
      category: 'send',
      amount: -(Amount.wmcc(member.value, true)),
      fee: -(Amount.wmcc(details.fee, true)),
      vout: i
    });

    sent += member.value;
  }

  return {
    amount: Amount.wmcc(receive ? received : -sent, true),
    confirmations: details.confirmations,
    blockhash: details.block ? util.revHex(details.block) : null,
    blockindex: details.index,
    blocktime: details.time,
    txid: util.revHex(details.hash),
    walletconflicts: [],
    time: details.mtime,
    timereceived: details.mtime,
    'bip125-replaceable': 'no',
    details: det,
    hex: details.tx.toRaw().toString('hex')
  };
};

RPC.prototype.getTransaction = async function getTransaction(args, help) {
  if (help || args.length < 1 || args.length > 2) {
    throw new RPCError(errs.MISC_ERROR,
      'gettransaction "txid" ( includeWatchonly )');
  }

  const wallet = this.wallet;
  const valid = new Validator([args]);
  const hash = valid.hash(0);
  const watchOnly = valid.bool(1, false);

  if (!hash)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid parameter');

  const wtx = await wallet.getTX(hash);

  if (!wtx)
    throw new RPCError(errs.WALLET_ERROR, 'TX not found.');

  return await this._toWalletTX(wtx, watchOnly);
};

RPC.prototype.abandonTransaction = async function abandonTransaction(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'abandontransaction "txid"');

  const wallet = this.wallet;
  const valid = new Validator([args]);
  const hash = valid.hash(0);

  if (!hash)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid parameter.');

  const result = await wallet.abandon(hash);

  if (!result)
    throw new RPCError(errs.WALLET_ERROR, 'Transaction not in wallet.');

  return null;
};

RPC.prototype.getUnconfirmedBalance = async function getUnconfirmedBalance(args, help) {
  if (help || args.length > 0)
    throw new RPCError(errs.MISC_ERROR, 'getunconfirmedbalance');

  const wallet = this.wallet;
  const balance = await wallet.getBalance();

  return Amount.wmcc(balance.unconfirmed, true);
};

RPC.prototype.getWalletInfo = async function getWalletInfo(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'getwalletinfo');

  const wallet = this.wallet;
  const balance = await wallet.getBalance();

  return {
    walletid: wallet.id,
    walletversion: 6,
    balance: Amount.wmcc(balance.unconfirmed, true),
    unconfirmed_balance: Amount.wmcc(balance.unconfirmed, true),
    txcount: wallet.txdb.state.tx,
    keypoololdest: 0,
    keypoolsize: 0,
    unlocked_until: wallet.master.until,
    paytxfee: Amount.wmcc(this.wdb.feeRate, true)
  };
};

RPC.prototype.importPrivKey = async function importPrivKey(args, help) {
  if (help || args.length < 1 || args.length > 3) {
    throw new RPCError(errs.MISC_ERROR,
      'importprivkey "wmccprivkey" ( "label" rescan )');
  }

  const wallet = this.wallet;
  const valid = new Validator([args]);
  const secret = valid.str(0);
  const rescan = valid.bool(2, false);

  const key = parseSecret(secret, this.network);

  await wallet.importKey(0, key);

  if (rescan)
    await this.wdb.rescan(0);

  return null;
};

RPC.prototype.importWallet = async function importWallet(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'importwallet "filename" ( rescan )');

  const wallet = this.wallet;
  const valid = new Validator([args]);
  const file = valid.str(0);
  const rescan = valid.bool(1, false);

  if (fs.unsupported)
    throw new RPCError(errs.INTERNAL_ERROR, 'FS not available.');

  const data = await fs.readFile(file, 'utf8');
  const lines = data.split(/\n+/);
  const keys = [];

  for (let line of lines) {
    line = line.trim();

    if (line.length === 0)
      continue;

    if (/^\s*#/.test(line))
      continue;

    const parts = line.split(/\s+/);

    if (parts.length < 4)
      throw new RPCError(errs.DESERIALIZATION_ERROR, 'Malformed wallet.');

    const secret = parseSecret(parts[0], this.network);

    keys.push(secret);
  }

  for (const key of keys)
    await wallet.importKey(0, key);

  if (rescan)
    await this.wdb.rescan(0);

  return null;
};

RPC.prototype.importAddress = async function importAddress(args, help) {
  if (help || args.length < 1 || args.length > 4) {
    throw new RPCError(errs.MISC_ERROR,
      'importaddress "address" ( "label" rescan p2sh )');
  }

  const wallet = this.wallet;
  const valid = new Validator([args]);
  let addr = valid.str(0, '');
  const rescan = valid.bool(2, false);
  const p2sh = valid.bool(3, false);

  if (p2sh) {
    let script = valid.buf(0);

    if (!script)
      throw new RPCError(errs.TYPE_ERROR, 'Invalid parameters.');

    script = Script.fromRaw(script);
    script = Script.fromScripthash(script.hash160());

    addr = script.getAddress();
  } else {
    addr = parseAddress(addr, this.network);
  }

  await wallet.importAddress(0, addr);

  if (rescan)
    await this.wdb.rescan(0);

  return null;
};

RPC.prototype.importPubkey = async function importPubkey(args, help) {
  if (help || args.length < 1 || args.length > 4) {
    throw new RPCError(errs.MISC_ERROR,
      'importpubkey "pubkey" ( "label" rescan )');
  }

  const wallet = this.wallet;
  const valid = new Validator([args]);
  const data = valid.buf(0);
  const rescan = valid.bool(2, false);

  if (!data)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid parameter.');

  const key = KeyRing.fromPublic(data, this.network);

  await wallet.importKey(0, key);

  if (rescan)
    await this.wdb.rescan(0);

  return null;
};

RPC.prototype.keyPoolRefill = async function keyPoolRefill(args, help) {
  if (help || args.length > 1)
    throw new RPCError(errs.MISC_ERROR, 'keypoolrefill ( newsize )');
  return null;
};

RPC.prototype.listAccounts = async function listAccounts(args, help) {
  if (help || args.length > 2) {
    throw new RPCError(errs.MISC_ERROR,
      'listaccounts ( minconf includeWatchonly)');
  }

  const wallet = this.wallet;
  const valid = new Validator([args]);
  const minconf = valid.u32(0, 0);
  const watchOnly = valid.bool(1, false);

  const accounts = await wallet.getAccounts();
  const map = {};

  for (const account of accounts) {
    const balance = await wallet.getBalance(account);
    let value = balance.unconfirmed;

    if (minconf > 0)
      value = balance.confirmed;

    if (wallet.watchOnly !== watchOnly)
      value = 0;

    map[account] = Amount.wmcc(value, true);
  }

  return map;
};

RPC.prototype.listAddressGroupings = async function listAddressGroupings(args, help) {
  if (help)
    throw new RPCError(errs.MISC_ERROR, 'listaddressgroupings');
  throw new Error('Not implemented.');
};

RPC.prototype.listLockUnspent = async function listLockUnspent(args, help) {
  if (help || args.length > 0)
    throw new RPCError(errs.MISC_ERROR, 'listlockunspent');

  const wallet = this.wallet;
  const outpoints = wallet.getLocked();
  const out = [];

  for (const outpoint of outpoints) {
    out.push({
      txid: outpoint.txid(),
      vout: outpoint.index
    });
  }

  return out;
};

RPC.prototype.listReceivedByAccount = async function listReceivedByAccount(args, help) {
  if (help || args.length > 3) {
    throw new RPCError(errs.MISC_ERROR,
      'listreceivedbyaccount ( minconf includeempty includeWatchonly )');
  }

  const valid = new Validator([args]);
  const minconf = valid.u32(0, 0);
  const includeEmpty = valid.bool(1, false);
  const watchOnly = valid.bool(2, false);

  return await this._listReceived(minconf, includeEmpty, watchOnly, true);
};

RPC.prototype.listReceivedByAddress = async function listReceivedByAddress(args, help) {
  if (help || args.length > 3) {
    throw new RPCError(errs.MISC_ERROR,
      'listreceivedbyaddress ( minconf includeempty includeWatchonly )');
  }

  const valid = new Validator([args]);
  const minconf = valid.u32(0, 0);
  const includeEmpty = valid.bool(1, false);
  const watchOnly = valid.bool(2, false);

  return await this._listReceived(minconf, includeEmpty, watchOnly, false);
};

RPC.prototype._listReceived = async function _listReceived(minconf, empty, watchOnly, account) {
  const wallet = this.wallet;
  const paths = await wallet.getPaths();
  const height = this.wdb.state.height;

  const map = new Map();
  for (const path of paths) {
    const addr = path.toAddress();
    map.set(path.hash, {
      involvesWatchonly: wallet.watchOnly,
      address: addr.toString(this.network),
      account: path.name,
      amount: 0,
      confirmations: -1,
      label: ''
    });
  }

  const txs = await wallet.getHistory();

  for (const wtx of txs) {
    const conf = wtx.getDepth(height);

    if (conf < minconf)
      continue;

    for (const output of wtx.tx.outputs) {
      const addr = output.getAddress();

      if (!addr)
        continue;

      const hash = addr.getHash('hex');
      const entry = map.get(hash);

      if (entry) {
        if (entry.confirmations === -1 || conf < entry.confirmations)
          entry.confirmations = conf;
        entry.address = addr.toString(this.network);
        entry.amount += output.value;
      }
    }
  }

  let out = [];
  for (const entry of map.values())
    out.push(entry);

  if (account) {
    const map = new Map();

    for (const entry of out) {
      const item = map.get(entry.account);
      if (!item) {
        map.set(entry.account, entry);
        entry.address = undefined;
        continue;
      }
      item.amount += entry.amount;
    }

    out = [];

    for (const entry of map.values())
      out.push(entry);
  }

  const result = [];
  for (const entry of out) {
    if (!empty && entry.amount === 0)
      continue;

    if (entry.confirmations === -1)
      entry.confirmations = 0;

    entry.amount = Amount.wmcc(entry.amount, true);
    result.push(entry);
  }

  return result;
};

RPC.prototype.listSinceBlock = async function listSinceBlock(args, help) {
  const wallet = this.wallet;
  const chainHeight = this.wdb.state.height;
  const valid = new Validator([args]);
  const block = valid.hash(0);
  const minconf = valid.u32(1, 0);
  const watchOnly = valid.bool(2, false);

  if (help) {
    throw new RPCError(errs.MISC_ERROR,
      'listsinceblock ( "blockhash" target-confirmations includeWatchonly)');
  }

  if (wallet.watchOnly !== watchOnly)
    return [];

  let height = -1;
  if (block) {
    const entry = await this.client.getEntry(block);
    if (entry)
      height = entry.height;
  }

  if (height === -1)
    height = this.chain.height;

  const txs = await wallet.getHistory();

  const out = [];
  let highest;
  for (const wtx of txs) {
    if (wtx.height < height)
      continue;

    if (wtx.getDepth(chainHeight) < minconf)
      continue;

    if (!highest || wtx.height > highest)
      highest = wtx;

    const json = await this._toListTX(wtx);

    out.push(json);
  }

  return {
    transactions: out,
    lastblock: highest && highest.block
      ? util.revHex(highest.block)
      : encoding.NULL_HASH
  };
};

RPC.prototype._toListTX = async function _toListTX(wtx) {
  const wallet = this.wallet;
  const details = await wallet.toDetails(wtx);

  if (!details)
    throw new RPCError(errs.WALLET_ERROR, 'TX not found.');

  let receive = true;
  for (const member of details.inputs) {
    if (member.path) {
      receive = false;
      break;
    }
  }

  let sent = 0;
  let received = 0;
  let sendMember, recMember, sendIndex, recIndex;
  for (let i = 0; i < details.outputs.length; i++) {
    const member = details.outputs[i];

    if (member.path) {
      if (member.path.branch === 1)
        continue;
      received += member.value;
      recMember = member;
      recIndex = i;
      continue;
    }

    sent += member.value;
    sendMember = member;
    sendIndex = i;
  }

  let member, index;
  if (receive) {
    member = recMember;
    index = recIndex;
  } else {
    member = sendMember;
    index = sendIndex;
  }

  // In the odd case where we send to ourselves.
  if (!member) {
    assert(!receive);
    member = recMember;
    index = recIndex;
  }

  return {
    account: member.path ? member.path.name : '',
    address: member.address
      ? member.address.toString(this.network)
      : null,
    category: receive ? 'receive' : 'send',
    amount: Amount.wmcc(receive ? received : -sent, true),
    label: member.path ? member.path.name : undefined,
    vout: index,
    confirmations: details.getDepth(),
    blockhash: details.block ? util.revHex(details.block) : null,
    blockindex: details.index,
    blocktime: details.time,
    txid: util.revHex(details.hash),
    walletconflicts: [],
    time: details.mtime,
    timereceived: details.mtime,
    'bip125-replaceable': 'no'
  };
};

RPC.prototype.listTransactions = async function listTransactions(args, help) {
  if (help || args.length > 4) {
    throw new RPCError(errs.MISC_ERROR,
      'listtransactions ( "account" count from includeWatchonly)');
  }

  const wallet = this.wallet;
  const valid = new Validator([args]);
  let name = valid.str(0);
  const count = valid.u32(1, 10);
  const from = valid.u32(2, 0);
  const watchOnly = valid.bool(3, false);

  if (wallet.watchOnly !== watchOnly)
    return [];

  if (name === '')
    name = 'default';

  const txs = await wallet.getHistory();

  common.sortTX(txs);

  const end = from + count;
  const to = Math.min(end, txs.length);
  const out = [];

  for (let i = from; i < to; i++) {
    const wtx = txs[i];
    const json = await this._toListTX(wtx);
    out.push(json);
  }

  return out;
};

RPC.prototype.listUnspent = async function listUnspent(args, help) {
  if (help || args.length > 3) {
    throw new RPCError(errs.MISC_ERROR,
      'listunspent ( minconf maxconf  ["address",...] )');
  }

  const wallet = this.wallet;
  const valid = new Validator([args]);
  const minDepth = valid.u32(0, 1);
  const maxDepth = valid.u32(1, 9999999);
  const addrs = valid.array(2);
  const height = this.wdb.state.height;

  const map = new Set();

  if (addrs) {
    const valid = new Validator([addrs]);
    for (let i = 0; i < addrs.length; i++) {
      const addr = valid.str(i, '');
      const hash = parseHash(addr, this.network);

      if (map.has(hash))
        throw new RPCError(errs.INVALID_PARAMETER, 'Duplicate address.');

      map.add(hash);
    }
  }

  const coins = await wallet.getCoins();

  common.sortCoins(coins);

  const out = [];

  for (const coin of coins) {
    const depth = coin.getDepth(height);

    if (depth < minDepth || depth > maxDepth)
      continue;

    const addr = coin.getAddress();

    if (!addr)
      continue;

    const hash = coin.getHash('hex');

    if (addrs) {
      if (!hash || !map.has(hash))
        continue;
    }

    const ring = await wallet.getKey(hash);

    out.push({
      txid: coin.txid(),
      vout: coin.index,
      address: addr ? addr.toString(this.network) : null,
      account: ring ? ring.name : undefined,
      redeemScript: ring && ring.script
        ? ring.script.toJSON()
        : undefined,
      scriptPubKey: coin.script.toJSON(),
      amount: Amount.wmcc(coin.value, true),
      confirmations: depth,
      spendable: !wallet.isLocked(coin),
      solvable: true
    });
  }

  return out;
};

RPC.prototype.lockUnspent = async function lockUnspent(args, help) {
  if (help || args.length < 1 || args.length > 2) {
    throw new RPCError(errs.MISC_ERROR,
      'lockunspent unlock ([{"txid":"txid","vout":n},...])');
  }

  const wallet = this.wallet;
  const valid = new Validator([args]);
  const unlock = valid.bool(0, false);
  const outputs = valid.array(1);

  if (args.length === 1) {
    if (unlock)
      wallet.unlockCoins();
    return true;
  }

  if (!outputs)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid parameter.');

  for (const output of outputs) {
    const valid = new Validator([output]);
    const hash = valid.hash('txid');
    const index = valid.u32('vout');

    if (hash == null || index == null)
      throw new RPCError(errs.INVALID_PARAMETER, 'Invalid parameter.');

    const outpoint = new Outpoint(hash, index);

    if (unlock) {
      wallet.unlockCoin(outpoint);
      continue;
    }

    wallet.lockCoin(outpoint);
  }

  return true;
};

RPC.prototype.move = async function move(args, help) {
  // Not implementing: stupid and deprecated.
  throw new Error('Not implemented.');
};

RPC.prototype.sendFrom = async function sendFrom(args, help) {
  if (help || args.length < 3 || args.length > 6) {
    throw new RPCError(errs.MISC_ERROR,
      'sendfrom "fromaccount" "towmccaddress"'
      + ' amount ( minconf "comment" "comment-to" )');
  }

  const wallet = this.wallet;
  const valid = new Validator([args]);
  let name = valid.str(0);
  const str = valid.str(1);
  const value = valid.ufixed(2, 8);
  const minconf = valid.u32(3, 0);

  const addr = parseAddress(str, this.network);

  if (!addr || value == null)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid parameter.');

  if (name === '')
    name = 'default';

  const options = {
    account: name,
    depth: minconf,
    outputs: [{
      address: addr,
      value: value
    }]
  };

  const tx = await wallet.send(options);

  return tx.txid();
};

RPC.prototype.sendMany = async function sendMany(args, help) {
  if (help || args.length < 2 || args.length > 5) {
    throw new RPCError(errs.MISC_ERROR,
      'sendmany "fromaccount" {"address":amount,...}'
      + ' ( minconf "comment" ["address",...] )');
  }

  const wallet = this.wallet;
  const valid = new Validator([args]);
  let name = valid.str(0);
  const sendTo = valid.obj(1);
  const minconf = valid.u32(2, 1);
  const subtract = valid.bool(4, false);

  if (name === '')
    name = 'default';

  if (!sendTo)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid parameter.');

  const to = new Validator([sendTo]);
  const uniq = new Set();
  const outputs = [];

  for (const key of Object.keys(sendTo)) {
    const value = to.ufixed(key, 8);
    const addr = parseAddress(key, this.network);
    const hash = addr.getHash('hex');

    if (value == null)
      throw new RPCError(errs.INVALID_PARAMETER, 'Invalid parameter.');

    if (uniq.has(hash))
      throw new RPCError(errs.INVALID_PARAMETER, 'Invalid parameter.');

    uniq.add(hash);

    const output = new Output();
    output.value = value;
    output.script.fromAddress(addr);
    outputs.push(output);
  }

  const options = {
    outputs: outputs,
    subtractFee: subtract,
    account: name,
    depth: minconf
  };

  const tx = await wallet.send(options);

  return tx.txid();
};

RPC.prototype.sendToAddress = async function sendToAddress(args, help) {
  if (help || args.length < 2 || args.length > 5) {
    throw new RPCError(errs.MISC_ERROR,
      'sendtoaddress "wmccaddress" amount'
      + ' ( "comment" "comment-to" subtractfeefromamount )');
  }

  const wallet = this.wallet;
  const valid = new Validator([args]);
  const str = valid.str(0);
  const value = valid.ufixed(1, 8);
  const subtract = valid.bool(4, false);

  const addr = parseAddress(str, this.network);

  if (!addr || value == null)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid parameter.');

  const options = {
    subtractFee: subtract,
    outputs: [{
      address: addr,
      value: value
    }]
  };

  const tx = await wallet.send(options);

  return tx.txid();
};

RPC.prototype.setAccount = async function setAccount(args, help) {
  if (help || args.length < 1 || args.length > 2) {
    throw new RPCError(errs.MISC_ERROR,
      'setaccount "wmccaddress" "account"');
  }

  // Impossible to implement in wmcc_core:
  throw new Error('Not implemented.');
};

RPC.prototype.setTXFee = async function setTXFee(args, help) {
  const valid = new Validator([args]);
  const rate = valid.ufixed(0, 8);

  if (help || args.length < 1 || args.length > 1)
    throw new RPCError(errs.MISC_ERROR, 'settxfee amount');

  if (rate == null)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid parameter.');

  this.wdb.feeRate = rate;

  return true;
};

RPC.prototype.signMessage = async function signMessage(args, help) {
  if (help || args.length !== 2) {
    throw new RPCError(errs.MISC_ERROR,
      'signmessage "wmccaddress" "message"');
  }

  const wallet = this.wallet;
  const valid = new Validator([args]);
  const b58 = valid.str(0, '');
  const str = valid.str(1, '');

  const addr = parseHash(b58, this.network);

  const ring = await wallet.getKey(addr);

  if (!ring)
    throw new RPCError(errs.WALLET_ERROR, 'Address not found.');

  if (!wallet.master.key)
    throw new RPCError(errs.WALLET_UNLOCK_NEEDED, 'Wallet is locked.');

  const msg = Buffer.from(MAGIC_STRING + str, 'utf8');
  const hash = digest.hash256(msg);

  const sig = ring.sign(hash);

  return sig.toString('base64');
};

RPC.prototype.walletLock = async function walletLock(args, help) {
  const wallet = this.wallet;

  if (help || (wallet.master.encrypted && args.length !== 0))
    throw new RPCError(errs.MISC_ERROR, 'walletlock');

  if (!wallet.master.encrypted)
    throw new RPCError(errs.WALLET_WRONG_ENC_STATE, 'Wallet is not encrypted.');

  await wallet.lock();

  return null;
};

RPC.prototype.walletPassphraseChange = async function walletPassphraseChange(args, help) {
  const wallet = this.wallet;

  if (help || (wallet.master.encrypted && args.length !== 2)) {
    throw new RPCError(errs.MISC_ERROR, 'walletpassphrasechange'
      + ' "oldpassphrase" "newpassphrase"');
  }

  const valid = new Validator([args]);
  const old = valid.str(0, '');
  const new_ = valid.str(1, '');

  if (!wallet.master.encrypted)
    throw new RPCError(errs.WALLET_WRONG_ENC_STATE, 'Wallet is not encrypted.');

  if (old.length < 1 || new_.length < 1)
    throw new RPCError(errs.INVALID_PARAMETER, 'Invalid parameter');

  await wallet.setPassphrase(old, new_);

  return null;
};

RPC.prototype.walletPassphrase = async function walletPassphrase(args, help) {
  const wallet = this.wallet;
  const valid = new Validator([args]);
  const passphrase = valid.str(0, '');
  const timeout = valid.u32(1);

  if (help || (wallet.master.encrypted && args.length !== 2)) {
    throw new RPCError(errs.MISC_ERROR,
      'walletpassphrase "passphrase" timeout');
  }

  if (!wallet.master.encrypted)
    throw new RPCError(errs.WALLET_WRONG_ENC_STATE, 'Wallet is not encrypted.');

  if (passphrase.length < 1)
    throw new RPCError(errs.INVALID_PARAMETER, 'Invalid parameter');

  if (timeout == null)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid parameter');

  await wallet.unlock(passphrase, timeout);

  return null;
};

RPC.prototype.importPrunedFunds = async function importPrunedFunds(args, help) {
  if (help || args.length < 2 || args.length > 3) {
    throw new RPCError(errs.MISC_ERROR,
      'importprunedfunds "rawtransaction" "txoutproof" ( "label" )');
  }

  const valid = new Validator([args]);
  const txRaw = valid.buf(0);
  const blockRaw = valid.buf(1);

  if (!txRaw || !blockRaw)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid parameter.');

  const tx = TX.fromRaw(txRaw);
  const block = MerkleBlock.fromRaw(blockRaw);
  const hash = block.hash('hex');

  if (!block.verify())
    throw new RPCError(errs.VERIFY_ERROR, 'Invalid proof.');

  if (!block.hasTX(tx.hash('hex')))
    throw new RPCError(errs.VERIFY_ERROR, 'Invalid proof.');

  const height = await this.client.getEntry(hash);

  if (height === -1)
    throw new RPCError(errs.VERIFY_ERROR, 'Invalid proof.');

  const entry = {
    hash: hash,
    time: block.time,
    height: height
  };

  if (!await this.wdb.addTX(tx, entry))
    throw new RPCError(errs.WALLET_ERROR, 'No tracked address for TX.');

  return null;
};

RPC.prototype.removePrunedFunds = async function removePrunedFunds(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'removeprunedfunds "txid"');

  const wallet = this.wallet;
  const valid = new Validator([args]);
  const hash = valid.hash(0);

  if (!hash)
    throw new RPCError(errs.TYPE_ERROR, 'Invalid parameter.');

  if (!await wallet.remove(hash))
    throw new RPCError(errs.WALLET_ERROR, 'Transaction not in wallet.');

  return null;
};

RPC.prototype.selectWallet = async function selectWallet(args, help) {
  const valid = new Validator([args]);
  const id = valid.str(0);

  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'selectwallet "id"');

  const wallet = await this.wdb.get(id);

  if (!wallet)
    throw new RPCError(errs.WALLET_ERROR, 'Wallet not found.');

  this.wallet = wallet;

  return null;
};

RPC.prototype.getMemoryInfo = async function getMemoryInfo(args, help) {
  if (help || args.length !== 0)
    throw new RPCError(errs.MISC_ERROR, 'getmemoryinfo');

  return util.memoryUsage();
};

RPC.prototype.setLogLevel = async function setLogLevel(args, help) {
  if (help || args.length !== 1)
    throw new RPCError(errs.MISC_ERROR, 'setloglevel "level"');

  const valid = new Validator([args]);
  const level = valid.str(0, '');

  this.logger.setLevel(level);

  return null;
};

/*
 * Helpers
 */

function parseHash(raw, network) {
  const addr = parseAddress(raw, network);
  return addr.getHash('hex');
}

function parseAddress(raw, network) {
  try {
    return Address.fromString(raw, network);
  } catch (e) {
    throw new RPCError(errs.INVALID_ADDRESS_OR_KEY, 'Invalid address.');
  }
}

function parseSecret(raw, network) {
  try {
    return KeyRing.fromSecret(raw, network);
  } catch (e) {
    throw new RPCError(errs.INVALID_ADDRESS_OR_KEY, 'Invalid key.');
  }
}

/*
 * Expose
 */

module.exports = RPC;


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * wmcc-core.js - a javascript WorldMobileCoin (WMCC) Core library.
 */



/**
 * A wmcc_core "environment" which exposes all
 * constructors for primitives, the blockchain,
 * mempool, wallet, etc. It also exposes a
 * global worker pool.
 *
 * @exports wmcc_core
 * @type {Object}
 *
 * @property {Function} bn - See {@url https://github.com/indutny/bn.js}.
 * @property {Object} elliptic - See {@url https://github.com/indutny/elliptic}.
 *
 * @property {Object} bip70 - See {@link module:bip70}.
 *
 * @property {Object} blockchain - See {@link module:blockchain}.
 * @property {Function} chain - See {@link module:blockchain.Chain}.
 * @property {Function} chaindb - See {@link module:blockchain.ChainDB}.
 * @property {Function} chainentry - See {@link module:blockchain.ChainEntry}.
 *
 * @property {Object} wmcc
 * @property {Function} amount
 * @property {Function} uri
 *
 * @property {Object} coins
 * @property {Function} coinview
 *
 * @property {Object} crypto
 * @property {Object} secp256k1
 * @property {Object} schnorr
 *
 * @property {Object} db
 * @property {Object} ldb
 *
 * @property {Object} hd
 *
 * @property {Object} http
 * @property {Object} rpc
 *
 * @property {Object} txmempool
 * @property {Object} fees
 * @property {Object} mempool
 * @property {Object} mempoolentry
 *
 * @property {Object} mining
 * @property {Object} miner
 * @property {Object} minerblock
 *
 * @property {Object} net
 * @property {Object} bip150
 * @property {Object} bip151
 * @property {Object} bip152
 * @property {Object} dns
 * @property {Object} packets
 * @property {Object} peer
 * @property {Object} pool
 * @property {Object} tcp
 *
 * @property {Object} node
 * @property {Object} config
 * @property {Object} fullnode
 * @property {Object} logger
 * @property {Object} spvnode
 *
 * @property {Object} primitives
 * @property {Object} address
 * @property {Object} block
 * @property {Object} coin
 * @property {Object} headers
 * @property {Object} input
 * @property {Object} invitem
 * @property {Object} keyring
 * @property {Object} merkleblock
 * @property {Object} mtx
 * @property {Object} netaddress
 * @property {Object} outpoint
 * @property {Object} output
 * @property {Object} tx
 *
 * @property {Object} protocol
 * @property {Object} consensus
 * @property {Object} errors
 * @property {Object} network
 * @property {Object} networks
 * @property {Object} policy
 * @property {Object} timedata
 *
 * @property {Object} txscript
 * @property {Object} opcodes
 * @property {Object} program
 * @property {Object} script
 * @property {Object} sigcache
 * @property {Object} stack
 * @property {Object} witness
 *
 * @property {Object} utils
 * @property {Object} base32
 * @property {Object} base58
 * @property {Object} bloom
 * @property {Object} co
 * @property {Object} encoding
 * @property {Object} lock
 * @property {Object} reader
 * @property {Object} staticwriter
 * @property {Object} util
 * @property {Object} writer
 *
 * @property {Object} wallet
 * @property {Object} path
 * @property {Object} walletkey
 * @property {Object} walletdb
 *
 * @property {Object} workers
 * @property {Object} workerpool
 */

const wmcc_core = exports;

/**
 * Set the default network.
 * @param {String} network
 */

wmcc_core.set = function set(network) {
  wmcc_core.network.set(network);
  return wmcc_core;
};

/**
 * Cache all necessary modules.
 */

wmcc_core.cache = function cache() {
  ;
};

/*
 * Expose
 */

// Horrible BIP
wmcc_core.bip70 = __webpack_require__(259);

// Blockchain
wmcc_core.blockchain = __webpack_require__(262);
wmcc_core.chain = __webpack_require__(104);
wmcc_core.chaindb = __webpack_require__(163);
wmcc_core.chainentry = __webpack_require__(103);

// WMCC
wmcc_core.wmcc = __webpack_require__(264);
wmcc_core.amount = __webpack_require__(20);
wmcc_core.uri = __webpack_require__(205);

// Coins
wmcc_core.coins = __webpack_require__(265);
wmcc_core.coinview = __webpack_require__(30);

// Crypto
wmcc_core.crypto = __webpack_require__(266);
wmcc_core.bn = __webpack_require__(27);
wmcc_core.secp256k1 = __webpack_require__(12);
wmcc_core.schnorr = __webpack_require__(209);

// DB
wmcc_core.db = __webpack_require__(267);
wmcc_core.ldb = __webpack_require__(88);

// HD
wmcc_core.hd = __webpack_require__(268);

// HTTP
wmcc_core.http = __webpack_require__(277);
wmcc_core.rpc = __webpack_require__(115);

// Mempool
wmcc_core.txmempool = __webpack_require__(309);
wmcc_core.fees = __webpack_require__(117);
wmcc_core.mempool = __webpack_require__(182);
wmcc_core.mempoolentry = __webpack_require__(181);

// Miner
wmcc_core.mining = __webpack_require__(310);
wmcc_core.miner = __webpack_require__(185);
wmcc_core.template = __webpack_require__(186);

// Net
wmcc_core.net = __webpack_require__(311);
wmcc_core.bip150 = __webpack_require__(119);
wmcc_core.bip151 = __webpack_require__(120);
wmcc_core.bip152 = __webpack_require__(96);
wmcc_core.dns = __webpack_require__(97);
wmcc_core.packets = __webpack_require__(60);
wmcc_core.peer = __webpack_require__(188);
wmcc_core.pool = __webpack_require__(122);
wmcc_core.tcp = __webpack_require__(121);

// Node
wmcc_core.node = __webpack_require__(316);
wmcc_core.config = __webpack_require__(123);
wmcc_core.fullnode = __webpack_require__(247);
wmcc_core.logger = __webpack_require__(34);
wmcc_core.spvnode = __webpack_require__(248);

// Primitives
wmcc_core.primitives = __webpack_require__(318);
wmcc_core.address = __webpack_require__(11);
wmcc_core.block = __webpack_require__(51);
wmcc_core.coin = __webpack_require__(44);
wmcc_core.headers = __webpack_require__(37);
wmcc_core.input = __webpack_require__(42);
wmcc_core.invitem = __webpack_require__(36);
wmcc_core.keyring = __webpack_require__(47);
wmcc_core.merkleblock = __webpack_require__(69);
wmcc_core.mtx = __webpack_require__(48);
wmcc_core.netaddress = __webpack_require__(75);
wmcc_core.outpoint = __webpack_require__(21);
wmcc_core.output = __webpack_require__(13);
wmcc_core.tx = __webpack_require__(16);

// Protocol
wmcc_core.protocol = __webpack_require__(319);
wmcc_core.consensus = __webpack_require__(7);
wmcc_core.errors = __webpack_require__(105);
wmcc_core.network = __webpack_require__(6);
wmcc_core.networks = __webpack_require__(79);
wmcc_core.policy = __webpack_require__(19);
wmcc_core.timedata = __webpack_require__(80);

// Script
wmcc_core.txscript = __webpack_require__(320);
wmcc_core.opcode = __webpack_require__(86);
wmcc_core.program = __webpack_require__(81);
wmcc_core.script = __webpack_require__(8);
wmcc_core.scriptnum = __webpack_require__(33);
wmcc_core.sigcache = __webpack_require__(249);
wmcc_core.stack = __webpack_require__(41);
wmcc_core.witness = __webpack_require__(55);

//Stratum
wmcc_core.stratum = __webpack_require__(321);
wmcc_core.stratumserver = __webpack_require__(250);

// Utils
wmcc_core.utils = __webpack_require__(328);
wmcc_core.base32 = __webpack_require__(179);
wmcc_core.base58 = __webpack_require__(26);
wmcc_core.bloom = __webpack_require__(43);
wmcc_core.co = __webpack_require__(17);
wmcc_core.encoding = __webpack_require__(3);
wmcc_core.int64 = __webpack_require__(49);
wmcc_core.lock = __webpack_require__(23);
wmcc_core.reader = __webpack_require__(2);
wmcc_core.staticwriter = __webpack_require__(4);
wmcc_core.util = __webpack_require__(1);
wmcc_core.writer = __webpack_require__(62);

// Wallet
wmcc_core.wallet = __webpack_require__(331);
wmcc_core.common = __webpack_require__(61);
wmcc_core.path = __webpack_require__(76);
wmcc_core.walletkey = __webpack_require__(128);
wmcc_core.walletdb = __webpack_require__(130);

// Workers
wmcc_core.workers = __webpack_require__(334);
wmcc_core.workerpool = __webpack_require__(124);

// Package Info
wmcc_core.pkg = __webpack_require__(94);

// Native
wmcc_core.native = __webpack_require__(18);

/*
 * Expose Globally
 */

global.wmcc_core = wmcc_core;


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * bip70/index.js - BIP70 for wmcc_core.
 */



/**
 * @module bip70
 */

exports.certs = __webpack_require__(193);
exports.PaymentACK = __webpack_require__(260);
exports.PaymentDetails = __webpack_require__(162);
exports.Payment = __webpack_require__(194);
exports.PaymentRequest = __webpack_require__(261);
exports.pk = __webpack_require__(197);
exports.x509 = __webpack_require__(195);


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * paymentack.js - BIP70 paymentack for wmcc_core.
 */



const assert = __webpack_require__(0);
const ProtoReader = __webpack_require__(77);
const ProtoWriter = __webpack_require__(78);
const Payment = __webpack_require__(194);

/**
 * Represents a BIP70 payment ack.
 * @alias module:bip70.PaymentACK
 * @constructor
 * @param {Object?} options
 * @property {Payment} payment
 * @property {String|null} memo
 */

function PaymentACK(options) {
  if (!(this instanceof PaymentACK))
    return new PaymentACK(options);

  this.payment = new Payment();
  this.memo = null;

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from options.
 * @private
 * @param {Object} options
 * @returns {PaymentACK}
 */

PaymentACK.prototype.fromOptions = function fromOptions(options) {
  if (options.payment)
    this.payment.fromOptions(options.payment);

  if (options.memo != null) {
    assert(typeof options.memo === 'string');
    this.memo = options.memo;
  }

  return this;
};

/**
 * Instantiate payment ack from options.
 * @param {Object} options
 * @returns {PaymentACK}
 */

PaymentACK.fromOptions = function fromOptions(options) {
  return new PaymentACK().fromOptions(options);
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 * @returns {PaymentACK}
 */

PaymentACK.prototype.fromRaw = function fromRaw(data) {
  const br = new ProtoReader(data);

  this.payment.fromRaw(br.readFieldBytes(1));
  this.memo = br.readFieldString(2, true);

  return this;
};

/**
 * Instantiate payment ack from serialized data.
 * @param {Buffer} data
 * @returns {PaymentACK}
 */

PaymentACK.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new PaymentACK().fromRaw(data);
};

/**
 * Serialize the payment ack (protobuf).
 * @returns {Buffer}
 */

PaymentACK.prototype.toRaw = function toRaw() {
  const bw = new ProtoWriter();

  bw.writeFieldBytes(1, this.payment.toRaw());

  if (this.memo != null)
    bw.writeFieldString(2, this.memo);

  return bw.render();
};

/*
 * Expose
 */

module.exports = PaymentACK;


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * paymentrequest.js - BIP70 paymentrequest for wmcc_core.
 */
 


const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const digest = __webpack_require__(5);
const x509 = __webpack_require__(195);
const PEM = __webpack_require__(100);
const ProtoReader = __webpack_require__(77);
const ProtoWriter = __webpack_require__(78);
const PaymentDetails = __webpack_require__(162);

/**
 * Represents a BIP70 payment request.
 * @alias module:bip70.PaymentRequest
 * @constructor
 * @param {Object?} options
 * @property {Number} version
 * @property {String|null} pkiType
 * @property {Buffer|null} pkiData
 * @property {PaymentDetails} paymentDetails
 * @property {Buffer|null} signature
 */

function PaymentRequest(options) {
  if (!(this instanceof PaymentRequest))
    return new PaymentRequest(options);

  this.version = -1;
  this.pkiType = null;
  this.pkiData = null;
  this.paymentDetails = new PaymentDetails();
  this.signature = null;

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from options.
 * @private
 * @param {Object} options
 * @returns {PaymentRequest}
 */

PaymentRequest.prototype.fromOptions = function fromOptions(options) {
  if (options.version != null) {
    assert(util.isInt(options.version));
    this.version = options.version;
  }

  if (options.pkiType != null) {
    assert(typeof options.pkiType === 'string');
    this.pkiType = options.pkiType;
  }

  if (options.pkiData) {
    assert(Buffer.isBuffer(options.pkiData));
    this.pkiData = options.pkiData;
  }

  if (options.paymentDetails)
    this.paymentDetails.fromOptions(options.paymentDetails);

  if (options.signature) {
    assert(Buffer.isBuffer(options.signature));
    this.signature = options.signature;
  }

  if (options.chain)
    this.setChain(options.chain);

  return this;
};

/**
 * Instantiate payment request from options.
 * @param {Object} options
 * @returns {PaymentRequest}
 */

PaymentRequest.fromOptions = function fromOptions(options) {
  return new PaymentRequest().fromOptions(options);
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 * @returns {PaymentRequest}
 */

PaymentRequest.prototype.fromRaw = function fromRaw(data) {
  const br = new ProtoReader(data);

  this.version = br.readFieldU32(1, true);
  this.pkiType = br.readFieldString(2, true);
  this.pkiData = br.readFieldBytes(3, true);
  this.paymentDetails.fromRaw(br.readFieldBytes(4));
  this.signature = br.readFieldBytes(5, true);

  return this;
};

/**
 * Instantiate payment request from serialized data.
 * @param {Buffer} data
 * @returns {PaymentRequest}
 */

PaymentRequest.fromRaw = function fromRaw(data, enc) {
  if (typeof data === 'string')
    data = Buffer.from(data, enc);
  return new PaymentRequest().fromRaw(data);
};

/**
 * Serialize the payment request (protobuf).
 * @returns {Buffer}
 */

PaymentRequest.prototype.toRaw = function toRaw() {
  const bw = new ProtoWriter();

  if (this.version !== -1)
    bw.writeFieldU32(1, this.version);

  if (this.pkiType != null)
    bw.writeFieldString(2, this.pkiType);

  if (this.pkiData)
    bw.writeFieldBytes(3, this.pkiData);

  bw.writeFieldBytes(4, this.paymentDetails.toRaw());

  if (this.signature)
    bw.writeFieldBytes(5, this.signature);

  return bw.render();
};

/**
 * Get payment request signature algorithm.
 * @returns {Object|null}
 */

PaymentRequest.prototype.getAlgorithm = function getAlgorithm() {
  if (!this.pkiType)
    throw new Error('No PKI type available.');

  const parts = this.pkiType.split('+');

  if (parts.length !== 2)
    throw new Error('Could not parse PKI algorithm.');

  if (parts[0] !== 'x509')
    throw new Error(`Unknown PKI type: ${parts[0]}.`);

  if (parts[1] !== 'sha1' && parts[1] !== 'sha256')
    throw new Error(`Unknown hash algorithm: ${parts[1]}.`);

  return new Algorithm(parts[0], parts[1]);
};

/**
 * Serialize payment request for sighash.
 * @returns {Buffer}
 */

PaymentRequest.prototype.signatureData = function signatureData() {
  const signature = this.signature;

  this.signature = Buffer.alloc(0);

  const data = this.toRaw();

  this.signature = signature;

  return data;
};

/**
 * Get signature hash.
 * @returns {Hash}
 */

PaymentRequest.prototype.signatureHash = function signatureHash() {
  const alg = this.getAlgorithm();
  return digest.hash(alg.hash, this.signatureData());
};

/**
 * Set x509 certificate chain.
 * @param {Buffer[]} chain
 */

PaymentRequest.prototype.setChain = function setChain(chain) {
  const bw = new ProtoWriter();

  assert(Array.isArray(chain), 'Chain must be an array.');

  for (let cert of chain) {
    if (typeof cert === 'string') {
      const pem = PEM.decode(cert);
      assert(pem.type === 'certificate', 'Bad certificate PEM.');
      cert = pem.data;
    }
    assert(Buffer.isBuffer(cert), 'Certificates must be PEM or DER.');
    bw.writeFieldBytes(1, cert);
  }

  this.pkiData = bw.render();
};

/**
 * Get x509 certificate chain.
 * @returns {Buffer[]}
 */

PaymentRequest.prototype.getChain = function getChain() {
  const chain = [];

  if (!this.pkiData)
    return chain;

  const br = new ProtoReader(this.pkiData);

  while (br.nextTag() === 1)
    chain.push(br.readFieldBytes(1));

  return chain;
};

/**
 * Sign payment request (chain must be set).
 * @param {Buffer} key
 * @param {Buffer[]?} certs
 */

PaymentRequest.prototype.sign = function sign(key, certs) {
  if (certs)
    this.setChain(certs);

  if (!this.pkiType)
    this.pkiType = 'x509+sha256';

  const alg = this.getAlgorithm();
  const msg = this.signatureData();
  const chain = this.getChain();

  this.signature = x509.signSubject(alg.hash, msg, key, chain);
};

/**
 * Verify payment request signature.
 * @returns {Boolean}
 */

PaymentRequest.prototype.verify = function verify() {
  if (!this.pkiType || this.pkiType === 'none')
    return false;

  if (!this.signature)
    return false;

  let alg;
  try {
    alg = this.getAlgorithm();
  } catch (e) {
    return false;
  }

  const msg = this.signatureData();
  const sig = this.signature;
  const chain = this.getChain();

  try {
    return x509.verifySubject(alg.hash, msg, sig, chain);
  } catch (e) {
    return false;
  }
};

/**
 * Verify x509 certificate chain.
 * @returns {Boolean}
 */

PaymentRequest.prototype.verifyChain = function verifyChain() {
  if (!this.pkiType || this.pkiType === 'none')
    return false;

  try {
    return x509.verifyChain(this.getChain());
  } catch (e) {
    return false;
  }
};

/**
 * Get root certificate authority.
 * @returns {Object|null}
 */

PaymentRequest.prototype.getCA = function getCA() {
  if (!this.pkiType || this.pkiType === 'none')
    throw new Error('No CA found (pkiType).');

  const chain = this.getChain();

  if (chain.length === 0)
    throw new Error('No CA found (chain).');

  const root = x509.parse(chain[chain.length - 1]);

  return new CA(root);
};

/**
 * Algorithm
 * @constructor
 * @ignore
 */

function Algorithm(key, hash) {
  this.key = key;
  this.hash = hash;
}

/**
 * CA
 * @constructor
 * @ignore
 */

function CA(root) {
  this.name = x509.getCAName(root);
  this.trusted = x509.isTrusted(root);
  this.cert = root;
}

/*
 * Expose
 */

module.exports = PaymentRequest;


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * blockchain/index.js - blockchain for wmcc_core.
 */



/**
 * @module blockchain
 */

exports.ChainDB = __webpack_require__(163);
exports.ChainEntry = __webpack_require__(103);
exports.Chain = __webpack_require__(104);
exports.common = __webpack_require__(89);
exports.layout = __webpack_require__(204);


/***/ }),
/* 263 */
/***/ (function(module, exports) {

module.exports = require("leveldown");

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * wmcc/index.js - high-level wmcc objects for wmcc_core.
 */



/**
 * @module wmcc
 */

exports.Amount = __webpack_require__(20);
exports.URI = __webpack_require__(205);


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * coins/index.js - utxo management for wmcc_core.
 */



/**
 * @module coins
 */

exports.Coins = __webpack_require__(101);
exports.CoinView = __webpack_require__(30);
exports.compress = __webpack_require__(102);
exports.UndoCoins = __webpack_require__(87);


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * crypto/index.js - crypto for wmcc_core.
 */



/**
 * @module crypto
 */

const digest = __webpack_require__(5);
const random = __webpack_require__(29);
const aes = __webpack_require__(106);

exports.aes = __webpack_require__(106);
exports.AEAD = __webpack_require__(206);
exports.BN = __webpack_require__(27);
exports.ccmp = __webpack_require__(52);
exports.ChaCha20 = __webpack_require__(166);
exports.cleanse = __webpack_require__(70);
exports.digest = __webpack_require__(5);
exports.ecdsa = __webpack_require__(199);
exports.hkdf = __webpack_require__(207);
exports.HmacDRBG = __webpack_require__(208);
exports.merkle = __webpack_require__(63);
exports.pbkdf2 = __webpack_require__(68);
exports.Poly1305 = __webpack_require__(167);
exports.random = __webpack_require__(29);
exports.rsa = __webpack_require__(198);
exports.schnorr = __webpack_require__(209);
exports.scrypt = __webpack_require__(45);
exports.secp256k1 = __webpack_require__(12);
exports.siphash = __webpack_require__(168);
exports.X15 = __webpack_require__(57);

exports.hash = digest.hash;
exports.ripemd160 = digest.ripemd160;
exports.sha1 = digest.sha1;
exports.sha256 = digest.sha256;
exports.hash160 = digest.hash160;
exports.hash256 = digest.hash256;
exports.root256 = digest.root256;
exports.hmac = digest.hmac;

exports.encipher = aes.encipher;
exports.decipher = aes.decipher;

exports.randomBytes = random.randomBytes;
exports.randomInt = random.randomInt;
exports.randomRange = random.randomRange;


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * db/index.js - data management for wmcc_core.
 */



/**
 * @module db
 */

exports.backends = __webpack_require__(201);
exports.LDB = __webpack_require__(88);
exports.LowlevelUp = __webpack_require__(200);
exports.MemDB = __webpack_require__(202);


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2016, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * hd/index.js - hd keys for wmcc_core.
 */



module.exports = __webpack_require__(107);


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = [
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  ''
];


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = [
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  ''
];


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = [
  'abandon',
  'ability',
  'able',
  'about',
  'above',
  'absent',
  'absorb',
  'abstract',
  'absurd',
  'abuse',
  'access',
  'accident',
  'account',
  'accuse',
  'achieve',
  'acid',
  'acoustic',
  'acquire',
  'across',
  'act',
  'action',
  'actor',
  'actress',
  'actual',
  'adapt',
  'add',
  'addict',
  'address',
  'adjust',
  'admit',
  'adult',
  'advance',
  'advice',
  'aerobic',
  'affair',
  'afford',
  'afraid',
  'again',
  'age',
  'agent',
  'agree',
  'ahead',
  'aim',
  'air',
  'airport',
  'aisle',
  'alarm',
  'album',
  'alcohol',
  'alert',
  'alien',
  'all',
  'alley',
  'allow',
  'almost',
  'alone',
  'alpha',
  'already',
  'also',
  'alter',
  'always',
  'amateur',
  'amazing',
  'among',
  'amount',
  'amused',
  'analyst',
  'anchor',
  'ancient',
  'anger',
  'angle',
  'angry',
  'animal',
  'ankle',
  'announce',
  'annual',
  'another',
  'answer',
  'antenna',
  'antique',
  'anxiety',
  'any',
  'apart',
  'apology',
  'appear',
  'apple',
  'approve',
  'april',
  'arch',
  'arctic',
  'area',
  'arena',
  'argue',
  'arm',
  'armed',
  'armor',
  'army',
  'around',
  'arrange',
  'arrest',
  'arrive',
  'arrow',
  'art',
  'artefact',
  'artist',
  'artwork',
  'ask',
  'aspect',
  'assault',
  'asset',
  'assist',
  'assume',
  'asthma',
  'athlete',
  'atom',
  'attack',
  'attend',
  'attitude',
  'attract',
  'auction',
  'audit',
  'august',
  'aunt',
  'author',
  'auto',
  'autumn',
  'average',
  'avocado',
  'avoid',
  'awake',
  'aware',
  'away',
  'awesome',
  'awful',
  'awkward',
  'axis',
  'baby',
  'bachelor',
  'bacon',
  'badge',
  'bag',
  'balance',
  'balcony',
  'ball',
  'bamboo',
  'banana',
  'banner',
  'bar',
  'barely',
  'bargain',
  'barrel',
  'base',
  'basic',
  'basket',
  'battle',
  'beach',
  'bean',
  'beauty',
  'because',
  'become',
  'beef',
  'before',
  'begin',
  'behave',
  'behind',
  'believe',
  'below',
  'belt',
  'bench',
  'benefit',
  'best',
  'betray',
  'better',
  'between',
  'beyond',
  'bicycle',
  'bid',
  'bike',
  'bind',
  'biology',
  'bird',
  'birth',
  'bitter',
  'black',
  'blade',
  'blame',
  'blanket',
  'blast',
  'bleak',
  'bless',
  'blind',
  'blood',
  'blossom',
  'blouse',
  'blue',
  'blur',
  'blush',
  'board',
  'boat',
  'body',
  'boil',
  'bomb',
  'bone',
  'bonus',
  'book',
  'boost',
  'border',
  'boring',
  'borrow',
  'boss',
  'bottom',
  'bounce',
  'box',
  'boy',
  'bracket',
  'brain',
  'brand',
  'brass',
  'brave',
  'bread',
  'breeze',
  'brick',
  'bridge',
  'brief',
  'bright',
  'bring',
  'brisk',
  'broccoli',
  'broken',
  'bronze',
  'broom',
  'brother',
  'brown',
  'brush',
  'bubble',
  'buddy',
  'budget',
  'buffalo',
  'build',
  'bulb',
  'bulk',
  'bullet',
  'bundle',
  'bunker',
  'burden',
  'burger',
  'burst',
  'bus',
  'business',
  'busy',
  'butter',
  'buyer',
  'buzz',
  'cabbage',
  'cabin',
  'cable',
  'cactus',
  'cage',
  'cake',
  'call',
  'calm',
  'camera',
  'camp',
  'can',
  'canal',
  'cancel',
  'candy',
  'cannon',
  'canoe',
  'canvas',
  'canyon',
  'capable',
  'capital',
  'captain',
  'car',
  'carbon',
  'card',
  'cargo',
  'carpet',
  'carry',
  'cart',
  'case',
  'cash',
  'casino',
  'castle',
  'casual',
  'cat',
  'catalog',
  'catch',
  'category',
  'cattle',
  'caught',
  'cause',
  'caution',
  'cave',
  'ceiling',
  'celery',
  'cement',
  'census',
  'century',
  'cereal',
  'certain',
  'chair',
  'chalk',
  'champion',
  'change',
  'chaos',
  'chapter',
  'charge',
  'chase',
  'chat',
  'cheap',
  'check',
  'cheese',
  'chef',
  'cherry',
  'chest',
  'chicken',
  'chief',
  'child',
  'chimney',
  'choice',
  'choose',
  'chronic',
  'chuckle',
  'chunk',
  'churn',
  'cigar',
  'cinnamon',
  'circle',
  'citizen',
  'city',
  'civil',
  'claim',
  'clap',
  'clarify',
  'claw',
  'clay',
  'clean',
  'clerk',
  'clever',
  'click',
  'client',
  'cliff',
  'climb',
  'clinic',
  'clip',
  'clock',
  'clog',
  'close',
  'cloth',
  'cloud',
  'clown',
  'club',
  'clump',
  'cluster',
  'clutch',
  'coach',
  'coast',
  'coconut',
  'code',
  'coffee',
  'coil',
  'coin',
  'collect',
  'color',
  'column',
  'combine',
  'come',
  'comfort',
  'comic',
  'common',
  'company',
  'concert',
  'conduct',
  'confirm',
  'congress',
  'connect',
  'consider',
  'control',
  'convince',
  'cook',
  'cool',
  'copper',
  'copy',
  'coral',
  'core',
  'corn',
  'correct',
  'cost',
  'cotton',
  'couch',
  'country',
  'couple',
  'course',
  'cousin',
  'cover',
  'coyote',
  'crack',
  'cradle',
  'craft',
  'cram',
  'crane',
  'crash',
  'crater',
  'crawl',
  'crazy',
  'cream',
  'credit',
  'creek',
  'crew',
  'cricket',
  'crime',
  'crisp',
  'critic',
  'crop',
  'cross',
  'crouch',
  'crowd',
  'crucial',
  'cruel',
  'cruise',
  'crumble',
  'crunch',
  'crush',
  'cry',
  'crystal',
  'cube',
  'culture',
  'cup',
  'cupboard',
  'curious',
  'current',
  'curtain',
  'curve',
  'cushion',
  'custom',
  'cute',
  'cycle',
  'dad',
  'damage',
  'damp',
  'dance',
  'danger',
  'daring',
  'dash',
  'daughter',
  'dawn',
  'day',
  'deal',
  'debate',
  'debris',
  'decade',
  'december',
  'decide',
  'decline',
  'decorate',
  'decrease',
  'deer',
  'defense',
  'define',
  'defy',
  'degree',
  'delay',
  'deliver',
  'demand',
  'demise',
  'denial',
  'dentist',
  'deny',
  'depart',
  'depend',
  'deposit',
  'depth',
  'deputy',
  'derive',
  'describe',
  'desert',
  'design',
  'desk',
  'despair',
  'destroy',
  'detail',
  'detect',
  'develop',
  'device',
  'devote',
  'diagram',
  'dial',
  'diamond',
  'diary',
  'dice',
  'diesel',
  'diet',
  'differ',
  'digital',
  'dignity',
  'dilemma',
  'dinner',
  'dinosaur',
  'direct',
  'dirt',
  'disagree',
  'discover',
  'disease',
  'dish',
  'dismiss',
  'disorder',
  'display',
  'distance',
  'divert',
  'divide',
  'divorce',
  'dizzy',
  'doctor',
  'document',
  'dog',
  'doll',
  'dolphin',
  'domain',
  'donate',
  'donkey',
  'donor',
  'door',
  'dose',
  'double',
  'dove',
  'draft',
  'dragon',
  'drama',
  'drastic',
  'draw',
  'dream',
  'dress',
  'drift',
  'drill',
  'drink',
  'drip',
  'drive',
  'drop',
  'drum',
  'dry',
  'duck',
  'dumb',
  'dune',
  'during',
  'dust',
  'dutch',
  'duty',
  'dwarf',
  'dynamic',
  'eager',
  'eagle',
  'early',
  'earn',
  'earth',
  'easily',
  'east',
  'easy',
  'echo',
  'ecology',
  'economy',
  'edge',
  'edit',
  'educate',
  'effort',
  'egg',
  'eight',
  'either',
  'elbow',
  'elder',
  'electric',
  'elegant',
  'element',
  'elephant',
  'elevator',
  'elite',
  'else',
  'embark',
  'embody',
  'embrace',
  'emerge',
  'emotion',
  'employ',
  'empower',
  'empty',
  'enable',
  'enact',
  'end',
  'endless',
  'endorse',
  'enemy',
  'energy',
  'enforce',
  'engage',
  'engine',
  'enhance',
  'enjoy',
  'enlist',
  'enough',
  'enrich',
  'enroll',
  'ensure',
  'enter',
  'entire',
  'entry',
  'envelope',
  'episode',
  'equal',
  'equip',
  'era',
  'erase',
  'erode',
  'erosion',
  'error',
  'erupt',
  'escape',
  'essay',
  'essence',
  'estate',
  'eternal',
  'ethics',
  'evidence',
  'evil',
  'evoke',
  'evolve',
  'exact',
  'example',
  'excess',
  'exchange',
  'excite',
  'exclude',
  'excuse',
  'execute',
  'exercise',
  'exhaust',
  'exhibit',
  'exile',
  'exist',
  'exit',
  'exotic',
  'expand',
  'expect',
  'expire',
  'explain',
  'expose',
  'express',
  'extend',
  'extra',
  'eye',
  'eyebrow',
  'fabric',
  'face',
  'faculty',
  'fade',
  'faint',
  'faith',
  'fall',
  'false',
  'fame',
  'family',
  'famous',
  'fan',
  'fancy',
  'fantasy',
  'farm',
  'fashion',
  'fat',
  'fatal',
  'father',
  'fatigue',
  'fault',
  'favorite',
  'feature',
  'february',
  'federal',
  'fee',
  'feed',
  'feel',
  'female',
  'fence',
  'festival',
  'fetch',
  'fever',
  'few',
  'fiber',
  'fiction',
  'field',
  'figure',
  'file',
  'film',
  'filter',
  'final',
  'find',
  'fine',
  'finger',
  'finish',
  'fire',
  'firm',
  'first',
  'fiscal',
  'fish',
  'fit',
  'fitness',
  'fix',
  'flag',
  'flame',
  'flash',
  'flat',
  'flavor',
  'flee',
  'flight',
  'flip',
  'float',
  'flock',
  'floor',
  'flower',
  'fluid',
  'flush',
  'fly',
  'foam',
  'focus',
  'fog',
  'foil',
  'fold',
  'follow',
  'food',
  'foot',
  'force',
  'forest',
  'forget',
  'fork',
  'fortune',
  'forum',
  'forward',
  'fossil',
  'foster',
  'found',
  'fox',
  'fragile',
  'frame',
  'frequent',
  'fresh',
  'friend',
  'fringe',
  'frog',
  'front',
  'frost',
  'frown',
  'frozen',
  'fruit',
  'fuel',
  'fun',
  'funny',
  'furnace',
  'fury',
  'future',
  'gadget',
  'gain',
  'galaxy',
  'gallery',
  'game',
  'gap',
  'garage',
  'garbage',
  'garden',
  'garlic',
  'garment',
  'gas',
  'gasp',
  'gate',
  'gather',
  'gauge',
  'gaze',
  'general',
  'genius',
  'genre',
  'gentle',
  'genuine',
  'gesture',
  'ghost',
  'giant',
  'gift',
  'giggle',
  'ginger',
  'giraffe',
  'girl',
  'give',
  'glad',
  'glance',
  'glare',
  'glass',
  'glide',
  'glimpse',
  'globe',
  'gloom',
  'glory',
  'glove',
  'glow',
  'glue',
  'goat',
  'goddess',
  'gold',
  'good',
  'goose',
  'gorilla',
  'gospel',
  'gossip',
  'govern',
  'gown',
  'grab',
  'grace',
  'grain',
  'grant',
  'grape',
  'grass',
  'gravity',
  'great',
  'green',
  'grid',
  'grief',
  'grit',
  'grocery',
  'group',
  'grow',
  'grunt',
  'guard',
  'guess',
  'guide',
  'guilt',
  'guitar',
  'gun',
  'gym',
  'habit',
  'hair',
  'half',
  'hammer',
  'hamster',
  'hand',
  'happy',
  'harbor',
  'hard',
  'harsh',
  'harvest',
  'hat',
  'have',
  'hawk',
  'hazard',
  'head',
  'health',
  'heart',
  'heavy',
  'hedgehog',
  'height',
  'hello',
  'helmet',
  'help',
  'hen',
  'hero',
  'hidden',
  'high',
  'hill',
  'hint',
  'hip',
  'hire',
  'history',
  'hobby',
  'hockey',
  'hold',
  'hole',
  'holiday',
  'hollow',
  'home',
  'honey',
  'hood',
  'hope',
  'horn',
  'horror',
  'horse',
  'hospital',
  'host',
  'hotel',
  'hour',
  'hover',
  'hub',
  'huge',
  'human',
  'humble',
  'humor',
  'hundred',
  'hungry',
  'hunt',
  'hurdle',
  'hurry',
  'hurt',
  'husband',
  'hybrid',
  'ice',
  'icon',
  'idea',
  'identify',
  'idle',
  'ignore',
  'ill',
  'illegal',
  'illness',
  'image',
  'imitate',
  'immense',
  'immune',
  'impact',
  'impose',
  'improve',
  'impulse',
  'inch',
  'include',
  'income',
  'increase',
  'index',
  'indicate',
  'indoor',
  'industry',
  'infant',
  'inflict',
  'inform',
  'inhale',
  'inherit',
  'initial',
  'inject',
  'injury',
  'inmate',
  'inner',
  'innocent',
  'input',
  'inquiry',
  'insane',
  'insect',
  'inside',
  'inspire',
  'install',
  'intact',
  'interest',
  'into',
  'invest',
  'invite',
  'involve',
  'iron',
  'island',
  'isolate',
  'issue',
  'item',
  'ivory',
  'jacket',
  'jaguar',
  'jar',
  'jazz',
  'jealous',
  'jeans',
  'jelly',
  'jewel',
  'job',
  'join',
  'joke',
  'journey',
  'joy',
  'judge',
  'juice',
  'jump',
  'jungle',
  'junior',
  'junk',
  'just',
  'kangaroo',
  'keen',
  'keep',
  'ketchup',
  'key',
  'kick',
  'kid',
  'kidney',
  'kind',
  'kingdom',
  'kiss',
  'kit',
  'kitchen',
  'kite',
  'kitten',
  'kiwi',
  'knee',
  'knife',
  'knock',
  'know',
  'lab',
  'label',
  'labor',
  'ladder',
  'lady',
  'lake',
  'lamp',
  'language',
  'laptop',
  'large',
  'later',
  'latin',
  'laugh',
  'laundry',
  'lava',
  'law',
  'lawn',
  'lawsuit',
  'layer',
  'lazy',
  'leader',
  'leaf',
  'learn',
  'leave',
  'lecture',
  'left',
  'leg',
  'legal',
  'legend',
  'leisure',
  'lemon',
  'lend',
  'length',
  'lens',
  'leopard',
  'lesson',
  'letter',
  'level',
  'liar',
  'liberty',
  'library',
  'license',
  'life',
  'lift',
  'light',
  'like',
  'limb',
  'limit',
  'link',
  'lion',
  'liquid',
  'list',
  'little',
  'live',
  'lizard',
  'load',
  'loan',
  'lobster',
  'local',
  'lock',
  'logic',
  'lonely',
  'long',
  'loop',
  'lottery',
  'loud',
  'lounge',
  'love',
  'loyal',
  'lucky',
  'luggage',
  'lumber',
  'lunar',
  'lunch',
  'luxury',
  'lyrics',
  'machine',
  'mad',
  'magic',
  'magnet',
  'maid',
  'mail',
  'main',
  'major',
  'make',
  'mammal',
  'man',
  'manage',
  'mandate',
  'mango',
  'mansion',
  'manual',
  'maple',
  'marble',
  'march',
  'margin',
  'marine',
  'market',
  'marriage',
  'mask',
  'mass',
  'master',
  'match',
  'material',
  'math',
  'matrix',
  'matter',
  'maximum',
  'maze',
  'meadow',
  'mean',
  'measure',
  'meat',
  'mechanic',
  'medal',
  'media',
  'melody',
  'melt',
  'member',
  'memory',
  'mention',
  'menu',
  'mercy',
  'merge',
  'merit',
  'merry',
  'mesh',
  'message',
  'metal',
  'method',
  'middle',
  'midnight',
  'milk',
  'million',
  'mimic',
  'mind',
  'minimum',
  'minor',
  'minute',
  'miracle',
  'mirror',
  'misery',
  'miss',
  'mistake',
  'mix',
  'mixed',
  'mixture',
  'mobile',
  'model',
  'modify',
  'mom',
  'moment',
  'monitor',
  'monkey',
  'monster',
  'month',
  'moon',
  'moral',
  'more',
  'morning',
  'mosquito',
  'mother',
  'motion',
  'motor',
  'mountain',
  'mouse',
  'move',
  'movie',
  'much',
  'muffin',
  'mule',
  'multiply',
  'muscle',
  'museum',
  'mushroom',
  'music',
  'must',
  'mutual',
  'myself',
  'mystery',
  'myth',
  'naive',
  'name',
  'napkin',
  'narrow',
  'nasty',
  'nation',
  'nature',
  'near',
  'neck',
  'need',
  'negative',
  'neglect',
  'neither',
  'nephew',
  'nerve',
  'nest',
  'net',
  'network',
  'neutral',
  'never',
  'news',
  'next',
  'nice',
  'night',
  'noble',
  'noise',
  'nominee',
  'noodle',
  'normal',
  'north',
  'nose',
  'notable',
  'note',
  'nothing',
  'notice',
  'novel',
  'now',
  'nuclear',
  'number',
  'nurse',
  'nut',
  'oak',
  'obey',
  'object',
  'oblige',
  'obscure',
  'observe',
  'obtain',
  'obvious',
  'occur',
  'ocean',
  'october',
  'odor',
  'off',
  'offer',
  'office',
  'often',
  'oil',
  'okay',
  'old',
  'olive',
  'olympic',
  'omit',
  'once',
  'one',
  'onion',
  'online',
  'only',
  'open',
  'opera',
  'opinion',
  'oppose',
  'option',
  'orange',
  'orbit',
  'orchard',
  'order',
  'ordinary',
  'organ',
  'orient',
  'original',
  'orphan',
  'ostrich',
  'other',
  'outdoor',
  'outer',
  'output',
  'outside',
  'oval',
  'oven',
  'over',
  'own',
  'owner',
  'oxygen',
  'oyster',
  'ozone',
  'pact',
  'paddle',
  'page',
  'pair',
  'palace',
  'palm',
  'panda',
  'panel',
  'panic',
  'panther',
  'paper',
  'parade',
  'parent',
  'park',
  'parrot',
  'party',
  'pass',
  'patch',
  'path',
  'patient',
  'patrol',
  'pattern',
  'pause',
  'pave',
  'payment',
  'peace',
  'peanut',
  'pear',
  'peasant',
  'pelican',
  'pen',
  'penalty',
  'pencil',
  'people',
  'pepper',
  'perfect',
  'permit',
  'person',
  'pet',
  'phone',
  'photo',
  'phrase',
  'physical',
  'piano',
  'picnic',
  'picture',
  'piece',
  'pig',
  'pigeon',
  'pill',
  'pilot',
  'pink',
  'pioneer',
  'pipe',
  'pistol',
  'pitch',
  'pizza',
  'place',
  'planet',
  'plastic',
  'plate',
  'play',
  'please',
  'pledge',
  'pluck',
  'plug',
  'plunge',
  'poem',
  'poet',
  'point',
  'polar',
  'pole',
  'police',
  'pond',
  'pony',
  'pool',
  'popular',
  'portion',
  'position',
  'possible',
  'post',
  'potato',
  'pottery',
  'poverty',
  'powder',
  'power',
  'practice',
  'praise',
  'predict',
  'prefer',
  'prepare',
  'present',
  'pretty',
  'prevent',
  'price',
  'pride',
  'primary',
  'print',
  'priority',
  'prison',
  'private',
  'prize',
  'problem',
  'process',
  'produce',
  'profit',
  'program',
  'project',
  'promote',
  'proof',
  'property',
  'prosper',
  'protect',
  'proud',
  'provide',
  'public',
  'pudding',
  'pull',
  'pulp',
  'pulse',
  'pumpkin',
  'punch',
  'pupil',
  'puppy',
  'purchase',
  'purity',
  'purpose',
  'purse',
  'push',
  'put',
  'puzzle',
  'pyramid',
  'quality',
  'quantum',
  'quarter',
  'question',
  'quick',
  'quit',
  'quiz',
  'quote',
  'rabbit',
  'raccoon',
  'race',
  'rack',
  'radar',
  'radio',
  'rail',
  'rain',
  'raise',
  'rally',
  'ramp',
  'ranch',
  'random',
  'range',
  'rapid',
  'rare',
  'rate',
  'rather',
  'raven',
  'raw',
  'razor',
  'ready',
  'real',
  'reason',
  'rebel',
  'rebuild',
  'recall',
  'receive',
  'recipe',
  'record',
  'recycle',
  'reduce',
  'reflect',
  'reform',
  'refuse',
  'region',
  'regret',
  'regular',
  'reject',
  'relax',
  'release',
  'relief',
  'rely',
  'remain',
  'remember',
  'remind',
  'remove',
  'render',
  'renew',
  'rent',
  'reopen',
  'repair',
  'repeat',
  'replace',
  'report',
  'require',
  'rescue',
  'resemble',
  'resist',
  'resource',
  'response',
  'result',
  'retire',
  'retreat',
  'return',
  'reunion',
  'reveal',
  'review',
  'reward',
  'rhythm',
  'rib',
  'ribbon',
  'rice',
  'rich',
  'ride',
  'ridge',
  'rifle',
  'right',
  'rigid',
  'ring',
  'riot',
  'ripple',
  'risk',
  'ritual',
  'rival',
  'river',
  'road',
  'roast',
  'robot',
  'robust',
  'rocket',
  'romance',
  'roof',
  'rookie',
  'room',
  'rose',
  'rotate',
  'rough',
  'round',
  'route',
  'royal',
  'rubber',
  'rude',
  'rug',
  'rule',
  'run',
  'runway',
  'rural',
  'sad',
  'saddle',
  'sadness',
  'safe',
  'sail',
  'salad',
  'salmon',
  'salon',
  'salt',
  'salute',
  'same',
  'sample',
  'sand',
  'satisfy',
  'satoshi',
  'sauce',
  'sausage',
  'save',
  'say',
  'scale',
  'scan',
  'scare',
  'scatter',
  'scene',
  'scheme',
  'school',
  'science',
  'scissors',
  'scorpion',
  'scout',
  'scrap',
  'screen',
  'script',
  'scrub',
  'sea',
  'search',
  'season',
  'seat',
  'second',
  'secret',
  'section',
  'security',
  'seed',
  'seek',
  'segment',
  'select',
  'sell',
  'seminar',
  'senior',
  'sense',
  'sentence',
  'series',
  'service',
  'session',
  'settle',
  'setup',
  'seven',
  'shadow',
  'shaft',
  'shallow',
  'share',
  'shed',
  'shell',
  'sheriff',
  'shield',
  'shift',
  'shine',
  'ship',
  'shiver',
  'shock',
  'shoe',
  'shoot',
  'shop',
  'short',
  'shoulder',
  'shove',
  'shrimp',
  'shrug',
  'shuffle',
  'shy',
  'sibling',
  'sick',
  'side',
  'siege',
  'sight',
  'sign',
  'silent',
  'silk',
  'silly',
  'silver',
  'similar',
  'simple',
  'since',
  'sing',
  'siren',
  'sister',
  'situate',
  'six',
  'size',
  'skate',
  'sketch',
  'ski',
  'skill',
  'skin',
  'skirt',
  'skull',
  'slab',
  'slam',
  'sleep',
  'slender',
  'slice',
  'slide',
  'slight',
  'slim',
  'slogan',
  'slot',
  'slow',
  'slush',
  'small',
  'smart',
  'smile',
  'smoke',
  'smooth',
  'snack',
  'snake',
  'snap',
  'sniff',
  'snow',
  'soap',
  'soccer',
  'social',
  'sock',
  'soda',
  'soft',
  'solar',
  'soldier',
  'solid',
  'solution',
  'solve',
  'someone',
  'song',
  'soon',
  'sorry',
  'sort',
  'soul',
  'sound',
  'soup',
  'source',
  'south',
  'space',
  'spare',
  'spatial',
  'spawn',
  'speak',
  'special',
  'speed',
  'spell',
  'spend',
  'sphere',
  'spice',
  'spider',
  'spike',
  'spin',
  'spirit',
  'split',
  'spoil',
  'sponsor',
  'spoon',
  'sport',
  'spot',
  'spray',
  'spread',
  'spring',
  'spy',
  'square',
  'squeeze',
  'squirrel',
  'stable',
  'stadium',
  'staff',
  'stage',
  'stairs',
  'stamp',
  'stand',
  'start',
  'state',
  'stay',
  'steak',
  'steel',
  'stem',
  'step',
  'stereo',
  'stick',
  'still',
  'sting',
  'stock',
  'stomach',
  'stone',
  'stool',
  'story',
  'stove',
  'strategy',
  'street',
  'strike',
  'strong',
  'struggle',
  'student',
  'stuff',
  'stumble',
  'style',
  'subject',
  'submit',
  'subway',
  'success',
  'such',
  'sudden',
  'suffer',
  'sugar',
  'suggest',
  'suit',
  'summer',
  'sun',
  'sunny',
  'sunset',
  'super',
  'supply',
  'supreme',
  'sure',
  'surface',
  'surge',
  'surprise',
  'surround',
  'survey',
  'suspect',
  'sustain',
  'swallow',
  'swamp',
  'swap',
  'swarm',
  'swear',
  'sweet',
  'swift',
  'swim',
  'swing',
  'switch',
  'sword',
  'symbol',
  'symptom',
  'syrup',
  'system',
  'table',
  'tackle',
  'tag',
  'tail',
  'talent',
  'talk',
  'tank',
  'tape',
  'target',
  'task',
  'taste',
  'tattoo',
  'taxi',
  'teach',
  'team',
  'tell',
  'ten',
  'tenant',
  'tennis',
  'tent',
  'term',
  'test',
  'text',
  'thank',
  'that',
  'theme',
  'then',
  'theory',
  'there',
  'they',
  'thing',
  'this',
  'thought',
  'three',
  'thrive',
  'throw',
  'thumb',
  'thunder',
  'ticket',
  'tide',
  'tiger',
  'tilt',
  'timber',
  'time',
  'tiny',
  'tip',
  'tired',
  'tissue',
  'title',
  'toast',
  'tobacco',
  'today',
  'toddler',
  'toe',
  'together',
  'toilet',
  'token',
  'tomato',
  'tomorrow',
  'tone',
  'tongue',
  'tonight',
  'tool',
  'tooth',
  'top',
  'topic',
  'topple',
  'torch',
  'tornado',
  'tortoise',
  'toss',
  'total',
  'tourist',
  'toward',
  'tower',
  'town',
  'toy',
  'track',
  'trade',
  'traffic',
  'tragic',
  'train',
  'transfer',
  'trap',
  'trash',
  'travel',
  'tray',
  'treat',
  'tree',
  'trend',
  'trial',
  'tribe',
  'trick',
  'trigger',
  'trim',
  'trip',
  'trophy',
  'trouble',
  'truck',
  'true',
  'truly',
  'trumpet',
  'trust',
  'truth',
  'try',
  'tube',
  'tuition',
  'tumble',
  'tuna',
  'tunnel',
  'turkey',
  'turn',
  'turtle',
  'twelve',
  'twenty',
  'twice',
  'twin',
  'twist',
  'two',
  'type',
  'typical',
  'ugly',
  'umbrella',
  'unable',
  'unaware',
  'uncle',
  'uncover',
  'under',
  'undo',
  'unfair',
  'unfold',
  'unhappy',
  'uniform',
  'unique',
  'unit',
  'universe',
  'unknown',
  'unlock',
  'until',
  'unusual',
  'unveil',
  'update',
  'upgrade',
  'uphold',
  'upon',
  'upper',
  'upset',
  'urban',
  'urge',
  'usage',
  'use',
  'used',
  'useful',
  'useless',
  'usual',
  'utility',
  'vacant',
  'vacuum',
  'vague',
  'valid',
  'valley',
  'valve',
  'van',
  'vanish',
  'vapor',
  'various',
  'vast',
  'vault',
  'vehicle',
  'velvet',
  'vendor',
  'venture',
  'venue',
  'verb',
  'verify',
  'version',
  'very',
  'vessel',
  'veteran',
  'viable',
  'vibrant',
  'vicious',
  'victory',
  'video',
  'view',
  'village',
  'vintage',
  'violin',
  'virtual',
  'virus',
  'visa',
  'visit',
  'visual',
  'vital',
  'vivid',
  'vocal',
  'voice',
  'void',
  'volcano',
  'volume',
  'vote',
  'voyage',
  'wage',
  'wagon',
  'wait',
  'walk',
  'wall',
  'walnut',
  'want',
  'warfare',
  'warm',
  'warrior',
  'wash',
  'wasp',
  'waste',
  'water',
  'wave',
  'way',
  'wealth',
  'weapon',
  'wear',
  'weasel',
  'weather',
  'web',
  'wedding',
  'weekend',
  'weird',
  'welcome',
  'west',
  'wet',
  'whale',
  'what',
  'wheat',
  'wheel',
  'when',
  'where',
  'whip',
  'whisper',
  'wide',
  'width',
  'wife',
  'wild',
  'will',
  'win',
  'window',
  'wine',
  'wing',
  'wink',
  'winner',
  'winter',
  'wire',
  'wisdom',
  'wise',
  'wish',
  'witness',
  'wolf',
  'woman',
  'wonder',
  'wood',
  'wool',
  'word',
  'work',
  'world',
  'worry',
  'worth',
  'wrap',
  'wreck',
  'wrestle',
  'wrist',
  'write',
  'wrong',
  'yard',
  'year',
  'yellow',
  'you',
  'young',
  'youth',
  'zebra',
  'zero',
  'zone',
  'zoo'
];


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = [
  'abaisser',
  'abandon',
  'abdiquer',
  'abeille',
  'abolir',
  'aborder',
  'aboutir',
  'aboyer',
  'abrasif',
  'abreuver',
  'abriter',
  'abroger',
  'abrupt',
  'absence',
  'absolu',
  'absurde',
  'abusif',
  'abyssal',
  'academie',
  'acajou',
  'acarien',
  'accabler',
  'accepter',
  'acclamer',
  'accolade',
  'accroche',
  'accuser',
  'acerbe',
  'achat',
  'acheter',
  'aciduler',
  'acier',
  'acompte',
  'acquerir',
  'acronyme',
  'acteur',
  'actif',
  'actuel',
  'adepte',
  'adequat',
  'adhesif',
  'adjectif',
  'adjuger',
  'admettre',
  'admirer',
  'adopter',
  'adorer',
  'adoucir',
  'adresse',
  'adroit',
  'adulte',
  'adverbe',
  'aerer',
  'aeronef',
  'affaire',
  'affecter',
  'affiche',
  'affreux',
  'affubler',
  'agacer',
  'agencer',
  'agile',
  'agiter',
  'agrafer',
  'agreable',
  'agrume',
  'aider',
  'aiguille',
  'ailier',
  'aimable',
  'aisance',
  'ajouter',
  'ajuster',
  'alarmer',
  'alchimie',
  'alerte',
  'algebre',
  'algue',
  'aliener',
  'aliment',
  'alleger',
  'alliage',
  'allouer',
  'allumer',
  'alourdir',
  'alpaga',
  'altesse',
  'alveole',
  'amateur',
  'ambigu',
  'ambre',
  'amenager',
  'amertume',
  'amidon',
  'amiral',
  'amorcer',
  'amour',
  'amovible',
  'amphibie',
  'ampleur',
  'amusant',
  'analyse',
  'anaphore',
  'anarchie',
  'anatomie',
  'ancien',
  'aneantir',
  'angle',
  'angoisse',
  'anguleux',
  'animal',
  'annexer',
  'annonce',
  'annuel',
  'anodin',
  'anomalie',
  'anonyme',
  'anormal',
  'antenne',
  'antidote',
  'anxieux',
  'apaiser',
  'aperitif',
  'aplanir',
  'apologie',
  'appareil',
  'appeler',
  'apporter',
  'appuyer',
  'aquarium',
  'aqueduc',
  'arbitre',
  'arbuste',
  'ardeur',
  'ardoise',
  'argent',
  'arlequin',
  'armature',
  'armement',
  'armoire',
  'armure',
  'arpenter',
  'arracher',
  'arriver',
  'arroser',
  'arsenic',
  'arteriel',
  'article',
  'aspect',
  'asphalte',
  'aspirer',
  'assaut',
  'asservir',
  'assiette',
  'associer',
  'assurer',
  'asticot',
  'astre',
  'astuce',
  'atelier',
  'atome',
  'atrium',
  'atroce',
  'attaque',
  'attentif',
  'attirer',
  'attraper',
  'aubaine',
  'auberge',
  'audace',
  'audible',
  'augurer',
  'aurore',
  'automne',
  'autruche',
  'avaler',
  'avancer',
  'avarice',
  'avenir',
  'averse',
  'aveugle',
  'aviateur',
  'avide',
  'avion',
  'aviser',
  'avoine',
  'avouer',
  'avril',
  'axial',
  'axiome',
  'badge',
  'bafouer',
  'bagage',
  'baguette',
  'baignade',
  'balancer',
  'balcon',
  'baleine',
  'balisage',
  'bambin',
  'bancaire',
  'bandage',
  'banlieue',
  'banniere',
  'banquier',
  'barbier',
  'baril',
  'baron',
  'barque',
  'barrage',
  'bassin',
  'bastion',
  'bataille',
  'bateau',
  'batterie',
  'baudrier',
  'bavarder',
  'belette',
  'belier',
  'belote',
  'benefice',
  'berceau',
  'berger',
  'berline',
  'bermuda',
  'besace',
  'besogne',
  'betail',
  'beurre',
  'biberon',
  'bicycle',
  'bidule',
  'bijou',
  'bilan',
  'bilingue',
  'billard',
  'binaire',
  'biologie',
  'biopsie',
  'biotype',
  'biscuit',
  'bison',
  'bistouri',
  'bitume',
  'bizarre',
  'blafard',
  'blague',
  'blanchir',
  'blessant',
  'blinder',
  'blond',
  'bloquer',
  'blouson',
  'bobard',
  'bobine',
  'boire',
  'boiser',
  'bolide',
  'bonbon',
  'bondir',
  'bonheur',
  'bonifier',
  'bonus',
  'bordure',
  'borne',
  'botte',
  'boucle',
  'boueux',
  'bougie',
  'boulon',
  'bouquin',
  'bourse',
  'boussole',
  'boutique',
  'boxeur',
  'branche',
  'brasier',
  'brave',
  'brebis',
  'breche',
  'breuvage',
  'bricoler',
  'brigade',
  'brillant',
  'brioche',
  'brique',
  'brochure',
  'broder',
  'bronzer',
  'brousse',
  'broyeur',
  'brume',
  'brusque',
  'brutal',
  'bruyant',
  'buffle',
  'buisson',
  'bulletin',
  'bureau',
  'burin',
  'bustier',
  'butiner',
  'butoir',
  'buvable',
  'buvette',
  'cabanon',
  'cabine',
  'cachette',
  'cadeau',
  'cadre',
  'cafeine',
  'caillou',
  'caisson',
  'calculer',
  'calepin',
  'calibre',
  'calmer',
  'calomnie',
  'calvaire',
  'camarade',
  'camera',
  'camion',
  'campagne',
  'canal',
  'caneton',
  'canon',
  'cantine',
  'canular',
  'capable',
  'caporal',
  'caprice',
  'capsule',
  'capter',
  'capuche',
  'carabine',
  'carbone',
  'caresser',
  'caribou',
  'carnage',
  'carotte',
  'carreau',
  'carton',
  'cascade',
  'casier',
  'casque',
  'cassure',
  'causer',
  'caution',
  'cavalier',
  'caverne',
  'caviar',
  'cedille',
  'ceinture',
  'celeste',
  'cellule',
  'cendrier',
  'censurer',
  'central',
  'cercle',
  'cerebral',
  'cerise',
  'cerner',
  'cerveau',
  'cesser',
  'chagrin',
  'chaise',
  'chaleur',
  'chambre',
  'chance',
  'chapitre',
  'charbon',
  'chasseur',
  'chaton',
  'chausson',
  'chavirer',
  'chemise',
  'chenille',
  'chequier',
  'chercher',
  'cheval',
  'chien',
  'chiffre',
  'chignon',
  'chimere',
  'chiot',
  'chlorure',
  'chocolat',
  'choisir',
  'chose',
  'chouette',
  'chrome',
  'chute',
  'cigare',
  'cigogne',
  'cimenter',
  'cinema',
  'cintrer',
  'circuler',
  'cirer',
  'cirque',
  'citerne',
  'citoyen',
  'citron',
  'civil',
  'clairon',
  'clameur',
  'claquer',
  'classe',
  'clavier',
  'client',
  'cligner',
  'climat',
  'clivage',
  'cloche',
  'clonage',
  'cloporte',
  'cobalt',
  'cobra',
  'cocasse',
  'cocotier',
  'coder',
  'codifier',
  'coffre',
  'cogner',
  'cohesion',
  'coiffer',
  'coincer',
  'colere',
  'colibri',
  'colline',
  'colmater',
  'colonel',
  'combat',
  'comedie',
  'commande',
  'compact',
  'concert',
  'conduire',
  'confier',
  'congeler',
  'connoter',
  'consonne',
  'contact',
  'convexe',
  'copain',
  'copie',
  'corail',
  'corbeau',
  'cordage',
  'corniche',
  'corpus',
  'correct',
  'cortege',
  'cosmique',
  'costume',
  'coton',
  'coude',
  'coupure',
  'courage',
  'couteau',
  'couvrir',
  'coyote',
  'crabe',
  'crainte',
  'cravate',
  'crayon',
  'creature',
  'crediter',
  'cremeux',
  'creuser',
  'crevette',
  'cribler',
  'crier',
  'cristal',
  'critere',
  'croire',
  'croquer',
  'crotale',
  'crucial',
  'cruel',
  'crypter',
  'cubique',
  'cueillir',
  'cuillere',
  'cuisine',
  'cuivre',
  'culminer',
  'cultiver',
  'cumuler',
  'cupide',
  'curatif',
  'curseur',
  'cyanure',
  'cycle',
  'cylindre',
  'cynique',
  'daigner',
  'damier',
  'danger',
  'danseur',
  'dauphin',
  'debattre',
  'debiter',
  'deborder',
  'debrider',
  'debutant',
  'decaler',
  'decembre',
  'dechirer',
  'decider',
  'declarer',
  'decorer',
  'decrire',
  'decupler',
  'dedale',
  'deductif',
  'deesse',
  'defensif',
  'defiler',
  'defrayer',
  'degager',
  'degivrer',
  'deglutir',
  'degrafer',
  'dejeuner',
  'delice',
  'deloger',
  'demander',
  'demeurer',
  'demolir',
  'denicher',
  'denouer',
  'dentelle',
  'denuder',
  'depart',
  'depenser',
  'dephaser',
  'deplacer',
  'deposer',
  'deranger',
  'derober',
  'desastre',
  'descente',
  'desert',
  'designer',
  'desobeir',
  'dessiner',
  'destrier',
  'detacher',
  'detester',
  'detourer',
  'detresse',
  'devancer',
  'devenir',
  'deviner',
  'devoir',
  'diable',
  'dialogue',
  'diamant',
  'dicter',
  'differer',
  'digerer',
  'digital',
  'digne',
  'diluer',
  'dimanche',
  'diminuer',
  'dioxyde',
  'directif',
  'diriger',
  'discuter',
  'disposer',
  'dissiper',
  'distance',
  'divertir',
  'diviser',
  'docile',
  'docteur',
  'dogme',
  'doigt',
  'domaine',
  'domicile',
  'dompter',
  'donateur',
  'donjon',
  'donner',
  'dopamine',
  'dortoir',
  'dorure',
  'dosage',
  'doseur',
  'dossier',
  'dotation',
  'douanier',
  'double',
  'douceur',
  'douter',
  'doyen',
  'dragon',
  'draper',
  'dresser',
  'dribbler',
  'droiture',
  'duperie',
  'duplexe',
  'durable',
  'durcir',
  'dynastie',
  'eblouir',
  'ecarter',
  'echarpe',
  'echelle',
  'eclairer',
  'eclipse',
  'eclore',
  'ecluse',
  'ecole',
  'economie',
  'ecorce',
  'ecouter',
  'ecraser',
  'ecremer',
  'ecrivain',
  'ecrou',
  'ecume',
  'ecureuil',
  'edifier',
  'eduquer',
  'effacer',
  'effectif',
  'effigie',
  'effort',
  'effrayer',
  'effusion',
  'egaliser',
  'egarer',
  'ejecter',
  'elaborer',
  'elargir',
  'electron',
  'elegant',
  'elephant',
  'eleve',
  'eligible',
  'elitisme',
  'eloge',
  'elucider',
  'eluder',
  'emballer',
  'embellir',
  'embryon',
  'emeraude',
  'emission',
  'emmener',
  'emotion',
  'emouvoir',
  'empereur',
  'employer',
  'emporter',
  'emprise',
  'emulsion',
  'encadrer',
  'enchere',
  'enclave',
  'encoche',
  'endiguer',
  'endosser',
  'endroit',
  'enduire',
  'energie',
  'enfance',
  'enfermer',
  'enfouir',
  'engager',
  'engin',
  'englober',
  'enigme',
  'enjamber',
  'enjeu',
  'enlever',
  'ennemi',
  'ennuyeux',
  'enrichir',
  'enrobage',
  'enseigne',
  'entasser',
  'entendre',
  'entier',
  'entourer',
  'entraver',
  'enumerer',
  'envahir',
  'enviable',
  'envoyer',
  'enzyme',
  'eolien',
  'epaissir',
  'epargne',
  'epatant',
  'epaule',
  'epicerie',
  'epidemie',
  'epier',
  'epilogue',
  'epine',
  'episode',
  'epitaphe',
  'epoque',
  'epreuve',
  'eprouver',
  'epuisant',
  'equerre',
  'equipe',
  'eriger',
  'erosion',
  'erreur',
  'eruption',
  'escalier',
  'espadon',
  'espece',
  'espiegle',
  'espoir',
  'esprit',
  'esquiver',
  'essayer',
  'essence',
  'essieu',
  'essorer',
  'estime',
  'estomac',
  'estrade',
  'etagere',
  'etaler',
  'etanche',
  'etatique',
  'eteindre',
  'etendoir',
  'eternel',
  'ethanol',
  'ethique',
  'ethnie',
  'etirer',
  'etoffer',
  'etoile',
  'etonnant',
  'etourdir',
  'etrange',
  'etroit',
  'etude',
  'euphorie',
  'evaluer',
  'evasion',
  'eventail',
  'evidence',
  'eviter',
  'evolutif',
  'evoquer',
  'exact',
  'exagerer',
  'exaucer',
  'exceller',
  'excitant',
  'exclusif',
  'excuse',
  'executer',
  'exemple',
  'exercer',
  'exhaler',
  'exhorter',
  'exigence',
  'exiler',
  'exister',
  'exotique',
  'expedier',
  'explorer',
  'exposer',
  'exprimer',
  'exquis',
  'extensif',
  'extraire',
  'exulter',
  'fable',
  'fabuleux',
  'facette',
  'facile',
  'facture',
  'faiblir',
  'falaise',
  'fameux',
  'famille',
  'farceur',
  'farfelu',
  'farine',
  'farouche',
  'fasciner',
  'fatal',
  'fatigue',
  'faucon',
  'fautif',
  'faveur',
  'favori',
  'febrile',
  'feconder',
  'federer',
  'felin',
  'femme',
  'femur',
  'fendoir',
  'feodal',
  'fermer',
  'feroce',
  'ferveur',
  'festival',
  'feuille',
  'feutre',
  'fevrier',
  'fiasco',
  'ficeler',
  'fictif',
  'fidele',
  'figure',
  'filature',
  'filetage',
  'filiere',
  'filleul',
  'filmer',
  'filou',
  'filtrer',
  'financer',
  'finir',
  'fiole',
  'firme',
  'fissure',
  'fixer',
  'flairer',
  'flamme',
  'flasque',
  'flatteur',
  'fleau',
  'fleche',
  'fleur',
  'flexion',
  'flocon',
  'flore',
  'fluctuer',
  'fluide',
  'fluvial',
  'folie',
  'fonderie',
  'fongible',
  'fontaine',
  'forcer',
  'forgeron',
  'formuler',
  'fortune',
  'fossile',
  'foudre',
  'fougere',
  'fouiller',
  'foulure',
  'fourmi',
  'fragile',
  'fraise',
  'franchir',
  'frapper',
  'frayeur',
  'fregate',
  'freiner',
  'frelon',
  'fremir',
  'frenesie',
  'frere',
  'friable',
  'friction',
  'frisson',
  'frivole',
  'froid',
  'fromage',
  'frontal',
  'frotter',
  'fruit',
  'fugitif',
  'fuite',
  'fureur',
  'furieux',
  'furtif',
  'fusion',
  'futur',
  'gagner',
  'galaxie',
  'galerie',
  'gambader',
  'garantir',
  'gardien',
  'garnir',
  'garrigue',
  'gazelle',
  'gazon',
  'geant',
  'gelatine',
  'gelule',
  'gendarme',
  'general',
  'genie',
  'genou',
  'gentil',
  'geologie',
  'geometre',
  'geranium',
  'germe',
  'gestuel',
  'geyser',
  'gibier',
  'gicler',
  'girafe',
  'givre',
  'glace',
  'glaive',
  'glisser',
  'globe',
  'gloire',
  'glorieux',
  'golfeur',
  'gomme',
  'gonfler',
  'gorge',
  'gorille',
  'goudron',
  'gouffre',
  'goulot',
  'goupille',
  'gourmand',
  'goutte',
  'graduel',
  'graffiti',
  'graine',
  'grand',
  'grappin',
  'gratuit',
  'gravir',
  'grenat',
  'griffure',
  'griller',
  'grimper',
  'grogner',
  'gronder',
  'grotte',
  'groupe',
  'gruger',
  'grutier',
  'gruyere',
  'guepard',
  'guerrier',
  'guide',
  'guimauve',
  'guitare',
  'gustatif',
  'gymnaste',
  'gyrostat',
  'habitude',
  'hachoir',
  'halte',
  'hameau',
  'hangar',
  'hanneton',
  'haricot',
  'harmonie',
  'harpon',
  'hasard',
  'helium',
  'hematome',
  'herbe',
  'herisson',
  'hermine',
  'heron',
  'hesiter',
  'heureux',
  'hiberner',
  'hibou',
  'hilarant',
  'histoire',
  'hiver',
  'homard',
  'hommage',
  'homogene',
  'honneur',
  'honorer',
  'honteux',
  'horde',
  'horizon',
  'horloge',
  'hormone',
  'horrible',
  'houleux',
  'housse',
  'hublot',
  'huileux',
  'humain',
  'humble',
  'humide',
  'humour',
  'hurler',
  'hydromel',
  'hygiene',
  'hymne',
  'hypnose',
  'idylle',
  'ignorer',
  'iguane',
  'illicite',
  'illusion',
  'image',
  'imbiber',
  'imiter',
  'immense',
  'immobile',
  'immuable',
  'impact',
  'imperial',
  'implorer',
  'imposer',
  'imprimer',
  'imputer',
  'incarner',
  'incendie',
  'incident',
  'incliner',
  'incolore',
  'indexer',
  'indice',
  'inductif',
  'inedit',
  'ineptie',
  'inexact',
  'infini',
  'infliger',
  'informer',
  'infusion',
  'ingerer',
  'inhaler',
  'inhiber',
  'injecter',
  'injure',
  'innocent',
  'inoculer',
  'inonder',
  'inscrire',
  'insecte',
  'insigne',
  'insolite',
  'inspirer',
  'instinct',
  'insulter',
  'intact',
  'intense',
  'intime',
  'intrigue',
  'intuitif',
  'inutile',
  'invasion',
  'inventer',
  'inviter',
  'invoquer',
  'ironique',
  'irradier',
  'irreel',
  'irriter',
  'isoler',
  'ivoire',
  'ivresse',
  'jaguar',
  'jaillir',
  'jambe',
  'janvier',
  'jardin',
  'jauger',
  'jaune',
  'javelot',
  'jetable',
  'jeton',
  'jeudi',
  'jeunesse',
  'joindre',
  'joncher',
  'jongler',
  'joueur',
  'jouissif',
  'journal',
  'jovial',
  'joyau',
  'joyeux',
  'jubiler',
  'jugement',
  'junior',
  'jupon',
  'juriste',
  'justice',
  'juteux',
  'juvenile',
  'kayak',
  'kimono',
  'kiosque',
  'label',
  'labial',
  'labourer',
  'lacerer',
  'lactose',
  'lagune',
  'laine',
  'laisser',
  'laitier',
  'lambeau',
  'lamelle',
  'lampe',
  'lanceur',
  'langage',
  'lanterne',
  'lapin',
  'largeur',
  'larme',
  'laurier',
  'lavabo',
  'lavoir',
  'lecture',
  'legal',
  'leger',
  'legume',
  'lessive',
  'lettre',
  'levier',
  'lexique',
  'lezard',
  'liasse',
  'liberer',
  'libre',
  'licence',
  'licorne',
  'liege',
  'lievre',
  'ligature',
  'ligoter',
  'ligue',
  'limer',
  'limite',
  'limonade',
  'limpide',
  'lineaire',
  'lingot',
  'lionceau',
  'liquide',
  'lisiere',
  'lister',
  'lithium',
  'litige',
  'littoral',
  'livreur',
  'logique',
  'lointain',
  'loisir',
  'lombric',
  'loterie',
  'louer',
  'lourd',
  'loutre',
  'louve',
  'loyal',
  'lubie',
  'lucide',
  'lucratif',
  'lueur',
  'lugubre',
  'luisant',
  'lumiere',
  'lunaire',
  'lundi',
  'luron',
  'lutter',
  'luxueux',
  'machine',
  'magasin',
  'magenta',
  'magique',
  'maigre',
  'maillon',
  'maintien',
  'mairie',
  'maison',
  'majorer',
  'malaxer',
  'malefice',
  'malheur',
  'malice',
  'mallette',
  'mammouth',
  'mandater',
  'maniable',
  'manquant',
  'manteau',
  'manuel',
  'marathon',
  'marbre',
  'marchand',
  'mardi',
  'maritime',
  'marqueur',
  'marron',
  'marteler',
  'mascotte',
  'massif',
  'materiel',
  'matiere',
  'matraque',
  'maudire',
  'maussade',
  'mauve',
  'maximal',
  'mechant',
  'meconnu',
  'medaille',
  'medecin',
  'mediter',
  'meduse',
  'meilleur',
  'melange',
  'melodie',
  'membre',
  'memoire',
  'menacer',
  'mener',
  'menhir',
  'mensonge',
  'mentor',
  'mercredi',
  'merite',
  'merle',
  'messager',
  'mesure',
  'metal',
  'meteore',
  'methode',
  'metier',
  'meuble',
  'miauler',
  'microbe',
  'miette',
  'mignon',
  'migrer',
  'milieu',
  'million',
  'mimique',
  'mince',
  'mineral',
  'minimal',
  'minorer',
  'minute',
  'miracle',
  'miroiter',
  'missile',
  'mixte',
  'mobile',
  'moderne',
  'moelleux',
  'mondial',
  'moniteur',
  'monnaie',
  'monotone',
  'monstre',
  'montagne',
  'monument',
  'moqueur',
  'morceau',
  'morsure',
  'mortier',
  'moteur',
  'motif',
  'mouche',
  'moufle',
  'moulin',
  'mousson',
  'mouton',
  'mouvant',
  'multiple',
  'munition',
  'muraille',
  'murene',
  'murmure',
  'muscle',
  'museum',
  'musicien',
  'mutation',
  'muter',
  'mutuel',
  'myriade',
  'myrtille',
  'mystere',
  'mythique',
  'nageur',
  'nappe',
  'narquois',
  'narrer',
  'natation',
  'nation',
  'nature',
  'naufrage',
  'nautique',
  'navire',
  'nebuleux',
  'nectar',
  'nefaste',
  'negation',
  'negliger',
  'negocier',
  'neige',
  'nerveux',
  'nettoyer',
  'neurone',
  'neutron',
  'neveu',
  'niche',
  'nickel',
  'nitrate',
  'niveau',
  'noble',
  'nocif',
  'nocturne',
  'noirceur',
  'noisette',
  'nomade',
  'nombreux',
  'nommer',
  'normatif',
  'notable',
  'notifier',
  'notoire',
  'nourrir',
  'nouveau',
  'novateur',
  'novembre',
  'novice',
  'nuage',
  'nuancer',
  'nuire',
  'nuisible',
  'numero',
  'nuptial',
  'nuque',
  'nutritif',
  'obeir',
  'objectif',
  'obliger',
  'obscur',
  'observer',
  'obstacle',
  'obtenir',
  'obturer',
  'occasion',
  'occuper',
  'ocean',
  'octobre',
  'octroyer',
  'octupler',
  'oculaire',
  'odeur',
  'odorant',
  'offenser',
  'officier',
  'offrir',
  'ogive',
  'oiseau',
  'oisillon',
  'olfactif',
  'olivier',
  'ombrage',
  'omettre',
  'onctueux',
  'onduler',
  'onereux',
  'onirique',
  'opale',
  'opaque',
  'operer',
  'opinion',
  'opportun',
  'opprimer',
  'opter',
  'optique',
  'orageux',
  'orange',
  'orbite',
  'ordonner',
  'oreille',
  'organe',
  'orgueil',
  'orifice',
  'ornement',
  'orque',
  'ortie',
  'osciller',
  'osmose',
  'ossature',
  'otarie',
  'ouragan',
  'ourson',
  'outil',
  'outrager',
  'ouvrage',
  'ovation',
  'oxyde',
  'oxygene',
  'ozone',
  'paisible',
  'palace',
  'palmares',
  'palourde',
  'palper',
  'panache',
  'panda',
  'pangolin',
  'paniquer',
  'panneau',
  'panorama',
  'pantalon',
  'papaye',
  'papier',
  'papoter',
  'papyrus',
  'paradoxe',
  'parcelle',
  'paresse',
  'parfumer',
  'parler',
  'parole',
  'parrain',
  'parsemer',
  'partager',
  'parure',
  'parvenir',
  'passion',
  'pasteque',
  'paternel',
  'patience',
  'patron',
  'pavillon',
  'pavoiser',
  'payer',
  'paysage',
  'peigne',
  'peintre',
  'pelage',
  'pelican',
  'pelle',
  'pelouse',
  'peluche',
  'pendule',
  'penetrer',
  'penible',
  'pensif',
  'penurie',
  'pepite',
  'peplum',
  'perdrix',
  'perforer',
  'periode',
  'permuter',
  'perplexe',
  'persil',
  'perte',
  'peser',
  'petale',
  'petit',
  'petrir',
  'peuple',
  'pharaon',
  'phobie',
  'phoque',
  'photon',
  'phrase',
  'physique',
  'piano',
  'pictural',
  'piece',
  'pierre',
  'pieuvre',
  'pilote',
  'pinceau',
  'pipette',
  'piquer',
  'pirogue',
  'piscine',
  'piston',
  'pivoter',
  'pixel',
  'pizza',
  'placard',
  'plafond',
  'plaisir',
  'planer',
  'plaque',
  'plastron',
  'plateau',
  'pleurer',
  'plexus',
  'pliage',
  'plomb',
  'plonger',
  'pluie',
  'plumage',
  'pochette',
  'poesie',
  'poete',
  'pointe',
  'poirier',
  'poisson',
  'poivre',
  'polaire',
  'policier',
  'pollen',
  'polygone',
  'pommade',
  'pompier',
  'ponctuel',
  'ponderer',
  'poney',
  'portique',
  'position',
  'posseder',
  'posture',
  'potager',
  'poteau',
  'potion',
  'pouce',
  'poulain',
  'poumon',
  'pourpre',
  'poussin',
  'pouvoir',
  'prairie',
  'pratique',
  'precieux',
  'predire',
  'prefixe',
  'prelude',
  'prenom',
  'presence',
  'pretexte',
  'prevoir',
  'primitif',
  'prince',
  'prison',
  'priver',
  'probleme',
  'proceder',
  'prodige',
  'profond',
  'progres',
  'proie',
  'projeter',
  'prologue',
  'promener',
  'propre',
  'prospere',
  'proteger',
  'prouesse',
  'proverbe',
  'prudence',
  'pruneau',
  'psychose',
  'public',
  'puceron',
  'puiser',
  'pulpe',
  'pulsar',
  'punaise',
  'punitif',
  'pupitre',
  'purifier',
  'puzzle',
  'pyramide',
  'quasar',
  'querelle',
  'question',
  'quietude',
  'quitter',
  'quotient',
  'racine',
  'raconter',
  'radieux',
  'ragondin',
  'raideur',
  'raisin',
  'ralentir',
  'rallonge',
  'ramasser',
  'rapide',
  'rasage',
  'ratisser',
  'ravager',
  'ravin',
  'rayonner',
  'reactif',
  'reagir',
  'realiser',
  'reanimer',
  'recevoir',
  'reciter',
  'reclamer',
  'recolter',
  'recruter',
  'reculer',
  'recycler',
  'rediger',
  'redouter',
  'refaire',
  'reflexe',
  'reformer',
  'refrain',
  'refuge',
  'regalien',
  'region',
  'reglage',
  'regulier',
  'reiterer',
  'rejeter',
  'rejouer',
  'relatif',
  'relever',
  'relief',
  'remarque',
  'remede',
  'remise',
  'remonter',
  'remplir',
  'remuer',
  'renard',
  'renfort',
  'renifler',
  'renoncer',
  'rentrer',
  'renvoi',
  'replier',
  'reporter',
  'reprise',
  'reptile',
  'requin',
  'reserve',
  'resineux',
  'resoudre',
  'respect',
  'rester',
  'resultat',
  'retablir',
  'retenir',
  'reticule',
  'retomber',
  'retracer',
  'reunion',
  'reussir',
  'revanche',
  'revivre',
  'revolte',
  'revulsif',
  'richesse',
  'rideau',
  'rieur',
  'rigide',
  'rigoler',
  'rincer',
  'riposter',
  'risible',
  'risque',
  'rituel',
  'rival',
  'riviere',
  'rocheux',
  'romance',
  'rompre',
  'ronce',
  'rondin',
  'roseau',
  'rosier',
  'rotatif',
  'rotor',
  'rotule',
  'rouge',
  'rouille',
  'rouleau',
  'routine',
  'royaume',
  'ruban',
  'rubis',
  'ruche',
  'ruelle',
  'rugueux',
  'ruiner',
  'ruisseau',
  'ruser',
  'rustique',
  'rythme',
  'sabler',
  'saboter',
  'sabre',
  'sacoche',
  'safari',
  'sagesse',
  'saisir',
  'salade',
  'salive',
  'salon',
  'saluer',
  'samedi',
  'sanction',
  'sanglier',
  'sarcasme',
  'sardine',
  'saturer',
  'saugrenu',
  'saumon',
  'sauter',
  'sauvage',
  'savant',
  'savonner',
  'scalpel',
  'scandale',
  'scelerat',
  'scenario',
  'sceptre',
  'schema',
  'science',
  'scinder',
  'score',
  'scrutin',
  'sculpter',
  'seance',
  'secable',
  'secher',
  'secouer',
  'secreter',
  'sedatif',
  'seduire',
  'seigneur',
  'sejour',
  'selectif',
  'semaine',
  'sembler',
  'semence',
  'seminal',
  'senateur',
  'sensible',
  'sentence',
  'separer',
  'sequence',
  'serein',
  'sergent',
  'serieux',
  'serrure',
  'serum',
  'service',
  'sesame',
  'sevir',
  'sevrage',
  'sextuple',
  'sideral',
  'siecle',
  'sieger',
  'siffler',
  'sigle',
  'signal',
  'silence',
  'silicium',
  'simple',
  'sincere',
  'sinistre',
  'siphon',
  'sirop',
  'sismique',
  'situer',
  'skier',
  'social',
  'socle',
  'sodium',
  'soigneux',
  'soldat',
  'soleil',
  'solitude',
  'soluble',
  'sombre',
  'sommeil',
  'somnoler',
  'sonde',
  'songeur',
  'sonnette',
  'sonore',
  'sorcier',
  'sortir',
  'sosie',
  'sottise',
  'soucieux',
  'soudure',
  'souffle',
  'soulever',
  'soupape',
  'source',
  'soutirer',
  'souvenir',
  'spacieux',
  'spatial',
  'special',
  'sphere',
  'spiral',
  'stable',
  'station',
  'sternum',
  'stimulus',
  'stipuler',
  'strict',
  'studieux',
  'stupeur',
  'styliste',
  'sublime',
  'substrat',
  'subtil',
  'subvenir',
  'succes',
  'sucre',
  'suffixe',
  'suggerer',
  'suiveur',
  'sulfate',
  'superbe',
  'supplier',
  'surface',
  'suricate',
  'surmener',
  'surprise',
  'sursaut',
  'survie',
  'suspect',
  'syllabe',
  'symbole',
  'symetrie',
  'synapse',
  'syntaxe',
  'systeme',
  'tabac',
  'tablier',
  'tactile',
  'tailler',
  'talent',
  'talisman',
  'talonner',
  'tambour',
  'tamiser',
  'tangible',
  'tapis',
  'taquiner',
  'tarder',
  'tarif',
  'tartine',
  'tasse',
  'tatami',
  'tatouage',
  'taupe',
  'taureau',
  'taxer',
  'temoin',
  'temporel',
  'tenaille',
  'tendre',
  'teneur',
  'tenir',
  'tension',
  'terminer',
  'terne',
  'terrible',
  'tetine',
  'texte',
  'theme',
  'theorie',
  'therapie',
  'thorax',
  'tibia',
  'tiede',
  'timide',
  'tirelire',
  'tiroir',
  'tissu',
  'titane',
  'titre',
  'tituber',
  'toboggan',
  'tolerant',
  'tomate',
  'tonique',
  'tonneau',
  'toponyme',
  'torche',
  'tordre',
  'tornade',
  'torpille',
  'torrent',
  'torse',
  'tortue',
  'totem',
  'toucher',
  'tournage',
  'tousser',
  'toxine',
  'traction',
  'trafic',
  'tragique',
  'trahir',
  'train',
  'trancher',
  'travail',
  'trefle',
  'tremper',
  'tresor',
  'treuil',
  'triage',
  'tribunal',
  'tricoter',
  'trilogie',
  'triomphe',
  'tripler',
  'triturer',
  'trivial',
  'trombone',
  'tronc',
  'tropical',
  'troupeau',
  'tuile',
  'tulipe',
  'tumulte',
  'tunnel',
  'turbine',
  'tuteur',
  'tutoyer',
  'tuyau',
  'tympan',
  'typhon',
  'typique',
  'tyran',
  'ubuesque',
  'ultime',
  'ultrason',
  'unanime',
  'unifier',
  'union',
  'unique',
  'unitaire',
  'univers',
  'uranium',
  'urbain',
  'urticant',
  'usage',
  'usine',
  'usuel',
  'usure',
  'utile',
  'utopie',
  'vacarme',
  'vaccin',
  'vagabond',
  'vague',
  'vaillant',
  'vaincre',
  'vaisseau',
  'valable',
  'valise',
  'vallon',
  'valve',
  'vampire',
  'vanille',
  'vapeur',
  'varier',
  'vaseux',
  'vassal',
  'vaste',
  'vecteur',
  'vedette',
  'vegetal',
  'vehicule',
  'veinard',
  'veloce',
  'vendredi',
  'venerer',
  'venger',
  'venimeux',
  'ventouse',
  'verdure',
  'verin',
  'vernir',
  'verrou',
  'verser',
  'vertu',
  'veston',
  'veteran',
  'vetuste',
  'vexant',
  'vexer',
  'viaduc',
  'viande',
  'victoire',
  'vidange',
  'video',
  'vignette',
  'vigueur',
  'vilain',
  'village',
  'vinaigre',
  'violon',
  'vipere',
  'virement',
  'virtuose',
  'virus',
  'visage',
  'viseur',
  'vision',
  'visqueux',
  'visuel',
  'vital',
  'vitesse',
  'viticole',
  'vitrine',
  'vivace',
  'vivipare',
  'vocation',
  'voguer',
  'voile',
  'voisin',
  'voiture',
  'volaille',
  'volcan',
  'voltiger',
  'volume',
  'vorace',
  'vortex',
  'voter',
  'vouloir',
  'voyage',
  'voyelle',
  'wagon',
  'xenon',
  'yacht',
  'zebre',
  'zenith',
  'zeste',
  'zoologie'
];


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = [
  'abaco',
  'abbaglio',
  'abbinato',
  'abete',
  'abisso',
  'abolire',
  'abrasivo',
  'abrogato',
  'accadere',
  'accenno',
  'accusato',
  'acetone',
  'achille',
  'acido',
  'acqua',
  'acre',
  'acrilico',
  'acrobata',
  'acuto',
  'adagio',
  'addebito',
  'addome',
  'adeguato',
  'aderire',
  'adipe',
  'adottare',
  'adulare',
  'affabile',
  'affetto',
  'affisso',
  'affranto',
  'aforisma',
  'afoso',
  'africano',
  'agave',
  'agente',
  'agevole',
  'aggancio',
  'agire',
  'agitare',
  'agonismo',
  'agricolo',
  'agrumeto',
  'aguzzo',
  'alabarda',
  'alato',
  'albatro',
  'alberato',
  'albo',
  'albume',
  'alce',
  'alcolico',
  'alettone',
  'alfa',
  'algebra',
  'aliante',
  'alibi',
  'alimento',
  'allagato',
  'allegro',
  'allievo',
  'allodola',
  'allusivo',
  'almeno',
  'alogeno',
  'alpaca',
  'alpestre',
  'altalena',
  'alterno',
  'alticcio',
  'altrove',
  'alunno',
  'alveolo',
  'alzare',
  'amalgama',
  'amanita',
  'amarena',
  'ambito',
  'ambrato',
  'ameba',
  'america',
  'ametista',
  'amico',
  'ammasso',
  'ammenda',
  'ammirare',
  'ammonito',
  'amore',
  'ampio',
  'ampliare',
  'amuleto',
  'anacardo',
  'anagrafe',
  'analista',
  'anarchia',
  'anatra',
  'anca',
  'ancella',
  'ancora',
  'andare',
  'andrea',
  'anello',
  'angelo',
  'angolare',
  'angusto',
  'anima',
  'annegare',
  'annidato',
  'anno',
  'annuncio',
  'anonimo',
  'anticipo',
  'anzi',
  'apatico',
  'apertura',
  'apode',
  'apparire',
  'appetito',
  'appoggio',
  'approdo',
  'appunto',
  'aprile',
  'arabica',
  'arachide',
  'aragosta',
  'araldica',
  'arancio',
  'aratura',
  'arazzo',
  'arbitro',
  'archivio',
  'ardito',
  'arenile',
  'argento',
  'argine',
  'arguto',
  'aria',
  'armonia',
  'arnese',
  'arredato',
  'arringa',
  'arrosto',
  'arsenico',
  'arso',
  'artefice',
  'arzillo',
  'asciutto',
  'ascolto',
  'asepsi',
  'asettico',
  'asfalto',
  'asino',
  'asola',
  'aspirato',
  'aspro',
  'assaggio',
  'asse',
  'assoluto',
  'assurdo',
  'asta',
  'astenuto',
  'astice',
  'astratto',
  'atavico',
  'ateismo',
  'atomico',
  'atono',
  'attesa',
  'attivare',
  'attorno',
  'attrito',
  'attuale',
  'ausilio',
  'austria',
  'autista',
  'autonomo',
  'autunno',
  'avanzato',
  'avere',
  'avvenire',
  'avviso',
  'avvolgere',
  'azione',
  'azoto',
  'azzimo',
  'azzurro',
  'babele',
  'baccano',
  'bacino',
  'baco',
  'badessa',
  'badilata',
  'bagnato',
  'baita',
  'balcone',
  'baldo',
  'balena',
  'ballata',
  'balzano',
  'bambino',
  'bandire',
  'baraonda',
  'barbaro',
  'barca',
  'baritono',
  'barlume',
  'barocco',
  'basilico',
  'basso',
  'batosta',
  'battuto',
  'baule',
  'bava',
  'bavosa',
  'becco',
  'beffa',
  'belgio',
  'belva',
  'benda',
  'benevole',
  'benigno',
  'benzina',
  'bere',
  'berlina',
  'beta',
  'bibita',
  'bici',
  'bidone',
  'bifido',
  'biga',
  'bilancia',
  'bimbo',
  'binocolo',
  'biologo',
  'bipede',
  'bipolare',
  'birbante',
  'birra',
  'biscotto',
  'bisesto',
  'bisnonno',
  'bisonte',
  'bisturi',
  'bizzarro',
  'blando',
  'blatta',
  'bollito',
  'bonifico',
  'bordo',
  'bosco',
  'botanico',
  'bottino',
  'bozzolo',
  'braccio',
  'bradipo',
  'brama',
  'branca',
  'bravura',
  'bretella',
  'brevetto',
  'brezza',
  'briglia',
  'brillante',
  'brindare',
  'broccolo',
  'brodo',
  'bronzina',
  'brullo',
  'bruno',
  'bubbone',
  'buca',
  'budino',
  'buffone',
  'buio',
  'bulbo',
  'buono',
  'burlone',
  'burrasca',
  'bussola',
  'busta',
  'cadetto',
  'caduco',
  'calamaro',
  'calcolo',
  'calesse',
  'calibro',
  'calmo',
  'caloria',
  'cambusa',
  'camerata',
  'camicia',
  'cammino',
  'camola',
  'campale',
  'canapa',
  'candela',
  'cane',
  'canino',
  'canotto',
  'cantina',
  'capace',
  'capello',
  'capitolo',
  'capogiro',
  'cappero',
  'capra',
  'capsula',
  'carapace',
  'carcassa',
  'cardo',
  'carisma',
  'carovana',
  'carretto',
  'cartolina',
  'casaccio',
  'cascata',
  'caserma',
  'caso',
  'cassone',
  'castello',
  'casuale',
  'catasta',
  'catena',
  'catrame',
  'cauto',
  'cavillo',
  'cedibile',
  'cedrata',
  'cefalo',
  'celebre',
  'cellulare',
  'cena',
  'cenone',
  'centesimo',
  'ceramica',
  'cercare',
  'certo',
  'cerume',
  'cervello',
  'cesoia',
  'cespo',
  'ceto',
  'chela',
  'chiaro',
  'chicca',
  'chiedere',
  'chimera',
  'china',
  'chirurgo',
  'chitarra',
  'ciao',
  'ciclismo',
  'cifrare',
  'cigno',
  'cilindro',
  'ciottolo',
  'circa',
  'cirrosi',
  'citrico',
  'cittadino',
  'ciuffo',
  'civetta',
  'civile',
  'classico',
  'clinica',
  'cloro',
  'cocco',
  'codardo',
  'codice',
  'coerente',
  'cognome',
  'collare',
  'colmato',
  'colore',
  'colposo',
  'coltivato',
  'colza',
  'coma',
  'cometa',
  'commando',
  'comodo',
  'computer',
  'comune',
  'conciso',
  'condurre',
  'conferma',
  'congelare',
  'coniuge',
  'connesso',
  'conoscere',
  'consumo',
  'continuo',
  'convegno',
  'coperto',
  'copione',
  'coppia',
  'copricapo',
  'corazza',
  'cordata',
  'coricato',
  'cornice',
  'corolla',
  'corpo',
  'corredo',
  'corsia',
  'cortese',
  'cosmico',
  'costante',
  'cottura',
  'covato',
  'cratere',
  'cravatta',
  'creato',
  'credere',
  'cremoso',
  'crescita',
  'creta',
  'criceto',
  'crinale',
  'crisi',
  'critico',
  'croce',
  'cronaca',
  'crostata',
  'cruciale',
  'crusca',
  'cucire',
  'cuculo',
  'cugino',
  'cullato',
  'cupola',
  'curatore',
  'cursore',
  'curvo',
  'cuscino',
  'custode',
  'dado',
  'daino',
  'dalmata',
  'damerino',
  'daniela',
  'dannoso',
  'danzare',
  'datato',
  'davanti',
  'davvero',
  'debutto',
  'decennio',
  'deciso',
  'declino',
  'decollo',
  'decreto',
  'dedicato',
  'definito',
  'deforme',
  'degno',
  'delegare',
  'delfino',
  'delirio',
  'delta',
  'demenza',
  'denotato',
  'dentro',
  'deposito',
  'derapata',
  'derivare',
  'deroga',
  'descritto',
  'deserto',
  'desiderio',
  'desumere',
  'detersivo',
  'devoto',
  'diametro',
  'dicembre',
  'diedro',
  'difeso',
  'diffuso',
  'digerire',
  'digitale',
  'diluvio',
  'dinamico',
  'dinnanzi',
  'dipinto',
  'diploma',
  'dipolo',
  'diradare',
  'dire',
  'dirotto',
  'dirupo',
  'disagio',
  'discreto',
  'disfare',
  'disgelo',
  'disposto',
  'distanza',
  'disumano',
  'dito',
  'divano',
  'divelto',
  'dividere',
  'divorato',
  'doblone',
  'docente',
  'doganale',
  'dogma',
  'dolce',
  'domato',
  'domenica',
  'dominare',
  'dondolo',
  'dono',
  'dormire',
  'dote',
  'dottore',
  'dovuto',
  'dozzina',
  'drago',
  'druido',
  'dubbio',
  'dubitare',
  'ducale',
  'duna',
  'duomo',
  'duplice',
  'duraturo',
  'ebano',
  'eccesso',
  'ecco',
  'eclissi',
  'economia',
  'edera',
  'edicola',
  'edile',
  'editoria',
  'educare',
  'egemonia',
  'egli',
  'egoismo',
  'egregio',
  'elaborato',
  'elargire',
  'elegante',
  'elencato',
  'eletto',
  'elevare',
  'elfico',
  'elica',
  'elmo',
  'elsa',
  'eluso',
  'emanato',
  'emblema',
  'emesso',
  'emiro',
  'emotivo',
  'emozione',
  'empirico',
  'emulo',
  'endemico',
  'enduro',
  'energia',
  'enfasi',
  'enoteca',
  'entrare',
  'enzima',
  'epatite',
  'epilogo',
  'episodio',
  'epocale',
  'eppure',
  'equatore',
  'erario',
  'erba',
  'erboso',
  'erede',
  'eremita',
  'erigere',
  'ermetico',
  'eroe',
  'erosivo',
  'errante',
  'esagono',
  'esame',
  'esanime',
  'esaudire',
  'esca',
  'esempio',
  'esercito',
  'esibito',
  'esigente',
  'esistere',
  'esito',
  'esofago',
  'esortato',
  'esoso',
  'espanso',
  'espresso',
  'essenza',
  'esso',
  'esteso',
  'estimare',
  'estonia',
  'estroso',
  'esultare',
  'etilico',
  'etnico',
  'etrusco',
  'etto',
  'euclideo',
  'europa',
  'evaso',
  'evidenza',
  'evitato',
  'evoluto',
  'evviva',
  'fabbrica',
  'faccenda',
  'fachiro',
  'falco',
  'famiglia',
  'fanale',
  'fanfara',
  'fango',
  'fantasma',
  'fare',
  'farfalla',
  'farinoso',
  'farmaco',
  'fascia',
  'fastoso',
  'fasullo',
  'faticare',
  'fato',
  'favoloso',
  'febbre',
  'fecola',
  'fede',
  'fegato',
  'felpa',
  'feltro',
  'femmina',
  'fendere',
  'fenomeno',
  'fermento',
  'ferro',
  'fertile',
  'fessura',
  'festivo',
  'fetta',
  'feudo',
  'fiaba',
  'fiducia',
  'fifa',
  'figurato',
  'filo',
  'finanza',
  'finestra',
  'finire',
  'fiore',
  'fiscale',
  'fisico',
  'fiume',
  'flacone',
  'flamenco',
  'flebo',
  'flemma',
  'florido',
  'fluente',
  'fluoro',
  'fobico',
  'focaccia',
  'focoso',
  'foderato',
  'foglio',
  'folata',
  'folclore',
  'folgore',
  'fondente',
  'fonetico',
  'fonia',
  'fontana',
  'forbito',
  'forchetta',
  'foresta',
  'formica',
  'fornaio',
  'foro',
  'fortezza',
  'forzare',
  'fosfato',
  'fosso',
  'fracasso',
  'frana',
  'frassino',
  'fratello',
  'freccetta',
  'frenata',
  'fresco',
  'frigo',
  'frollino',
  'fronde',
  'frugale',
  'frutta',
  'fucilata',
  'fucsia',
  'fuggente',
  'fulmine',
  'fulvo',
  'fumante',
  'fumetto',
  'fumoso',
  'fune',
  'funzione',
  'fuoco',
  'furbo',
  'furgone',
  'furore',
  'fuso',
  'futile',
  'gabbiano',
  'gaffe',
  'galateo',
  'gallina',
  'galoppo',
  'gambero',
  'gamma',
  'garanzia',
  'garbo',
  'garofano',
  'garzone',
  'gasdotto',
  'gasolio',
  'gastrico',
  'gatto',
  'gaudio',
  'gazebo',
  'gazzella',
  'geco',
  'gelatina',
  'gelso',
  'gemello',
  'gemmato',
  'gene',
  'genitore',
  'gennaio',
  'genotipo',
  'gergo',
  'ghepardo',
  'ghiaccio',
  'ghisa',
  'giallo',
  'gilda',
  'ginepro',
  'giocare',
  'gioiello',
  'giorno',
  'giove',
  'girato',
  'girone',
  'gittata',
  'giudizio',
  'giurato',
  'giusto',
  'globulo',
  'glutine',
  'gnomo',
  'gobba',
  'golf',
  'gomito',
  'gommone',
  'gonfio',
  'gonna',
  'governo',
  'gracile',
  'grado',
  'grafico',
  'grammo',
  'grande',
  'grattare',
  'gravoso',
  'grazia',
  'greca',
  'gregge',
  'grifone',
  'grigio',
  'grinza',
  'grotta',
  'gruppo',
  'guadagno',
  'guaio',
  'guanto',
  'guardare',
  'gufo',
  'guidare',
  'ibernato',
  'icona',
  'identico',
  'idillio',
  'idolo',
  'idra',
  'idrico',
  'idrogeno',
  'igiene',
  'ignaro',
  'ignorato',
  'ilare',
  'illeso',
  'illogico',
  'illudere',
  'imballo',
  'imbevuto',
  'imbocco',
  'imbuto',
  'immane',
  'immerso',
  'immolato',
  'impacco',
  'impeto',
  'impiego',
  'importo',
  'impronta',
  'inalare',
  'inarcare',
  'inattivo',
  'incanto',
  'incendio',
  'inchino',
  'incisivo',
  'incluso',
  'incontro',
  'incrocio',
  'incubo',
  'indagine',
  'india',
  'indole',
  'inedito',
  'infatti',
  'infilare',
  'inflitto',
  'ingaggio',
  'ingegno',
  'inglese',
  'ingordo',
  'ingrosso',
  'innesco',
  'inodore',
  'inoltrare',
  'inondato',
  'insano',
  'insetto',
  'insieme',
  'insonnia',
  'insulina',
  'intasato',
  'intero',
  'intonaco',
  'intuito',
  'inumidire',
  'invalido',
  'invece',
  'invito',
  'iperbole',
  'ipnotico',
  'ipotesi',
  'ippica',
  'iride',
  'irlanda',
  'ironico',
  'irrigato',
  'irrorare',
  'isolato',
  'isotopo',
  'isterico',
  'istituto',
  'istrice',
  'italia',
  'iterare',
  'labbro',
  'labirinto',
  'lacca',
  'lacerato',
  'lacrima',
  'lacuna',
  'laddove',
  'lago',
  'lampo',
  'lancetta',
  'lanterna',
  'lardoso',
  'larga',
  'laringe',
  'lastra',
  'latenza',
  'latino',
  'lattuga',
  'lavagna',
  'lavoro',
  'legale',
  'leggero',
  'lembo',
  'lentezza',
  'lenza',
  'leone',
  'lepre',
  'lesivo',
  'lessato',
  'lesto',
  'letterale',
  'leva',
  'levigato',
  'libero',
  'lido',
  'lievito',
  'lilla',
  'limatura',
  'limitare',
  'limpido',
  'lineare',
  'lingua',
  'liquido',
  'lira',
  'lirica',
  'lisca',
  'lite',
  'litigio',
  'livrea',
  'locanda',
  'lode',
  'logica',
  'lombare',
  'londra',
  'longevo',
  'loquace',
  'lorenzo',
  'loto',
  'lotteria',
  'luce',
  'lucidato',
  'lumaca',
  'luminoso',
  'lungo',
  'lupo',
  'luppolo',
  'lusinga',
  'lusso',
  'lutto',
  'macabro',
  'macchina',
  'macero',
  'macinato',
  'madama',
  'magico',
  'maglia',
  'magnete',
  'magro',
  'maiolica',
  'malafede',
  'malgrado',
  'malinteso',
  'malsano',
  'malto',
  'malumore',
  'mana',
  'mancia',
  'mandorla',
  'mangiare',
  'manifesto',
  'mannaro',
  'manovra',
  'mansarda',
  'mantide',
  'manubrio',
  'mappa',
  'maratona',
  'marcire',
  'maretta',
  'marmo',
  'marsupio',
  'maschera',
  'massaia',
  'mastino',
  'materasso',
  'matricola',
  'mattone',
  'maturo',
  'mazurca',
  'meandro',
  'meccanico',
  'mecenate',
  'medesimo',
  'meditare',
  'mega',
  'melassa',
  'melis',
  'melodia',
  'meninge',
  'meno',
  'mensola',
  'mercurio',
  'merenda',
  'merlo',
  'meschino',
  'mese',
  'messere',
  'mestolo',
  'metallo',
  'metodo',
  'mettere',
  'miagolare',
  'mica',
  'micelio',
  'michele',
  'microbo',
  'midollo',
  'miele',
  'migliore',
  'milano',
  'milite',
  'mimosa',
  'minerale',
  'mini',
  'minore',
  'mirino',
  'mirtillo',
  'miscela',
  'missiva',
  'misto',
  'misurare',
  'mitezza',
  'mitigare',
  'mitra',
  'mittente',
  'mnemonico',
  'modello',
  'modifica',
  'modulo',
  'mogano',
  'mogio',
  'mole',
  'molosso',
  'monastero',
  'monco',
  'mondina',
  'monetario',
  'monile',
  'monotono',
  'monsone',
  'montato',
  'monviso',
  'mora',
  'mordere',
  'morsicato',
  'mostro',
  'motivato',
  'motosega',
  'motto',
  'movenza',
  'movimento',
  'mozzo',
  'mucca',
  'mucosa',
  'muffa',
  'mughetto',
  'mugnaio',
  'mulatto',
  'mulinello',
  'multiplo',
  'mummia',
  'munto',
  'muovere',
  'murale',
  'musa',
  'muscolo',
  'musica',
  'mutevole',
  'muto',
  'nababbo',
  'nafta',
  'nanometro',
  'narciso',
  'narice',
  'narrato',
  'nascere',
  'nastrare',
  'naturale',
  'nautica',
  'naviglio',
  'nebulosa',
  'necrosi',
  'negativo',
  'negozio',
  'nemmeno',
  'neofita',
  'neretto',
  'nervo',
  'nessuno',
  'nettuno',
  'neutrale',
  'neve',
  'nevrotico',
  'nicchia',
  'ninfa',
  'nitido',
  'nobile',
  'nocivo',
  'nodo',
  'nome',
  'nomina',
  'nordico',
  'normale',
  'norvegese',
  'nostrano',
  'notare',
  'notizia',
  'notturno',
  'novella',
  'nucleo',
  'nulla',
  'numero',
  'nuovo',
  'nutrire',
  'nuvola',
  'nuziale',
  'oasi',
  'obbedire',
  'obbligo',
  'obelisco',
  'oblio',
  'obolo',
  'obsoleto',
  'occasione',
  'occhio',
  'occidente',
  'occorrere',
  'occultare',
  'ocra',
  'oculato',
  'odierno',
  'odorare',
  'offerta',
  'offrire',
  'offuscato',
  'oggetto',
  'oggi',
  'ognuno',
  'olandese',
  'olfatto',
  'oliato',
  'oliva',
  'ologramma',
  'oltre',
  'omaggio',
  'ombelico',
  'ombra',
  'omega',
  'omissione',
  'ondoso',
  'onere',
  'onice',
  'onnivoro',
  'onorevole',
  'onta',
  'operato',
  'opinione',
  'opposto',
  'oracolo',
  'orafo',
  'ordine',
  'orecchino',
  'orefice',
  'orfano',
  'organico',
  'origine',
  'orizzonte',
  'orma',
  'ormeggio',
  'ornativo',
  'orologio',
  'orrendo',
  'orribile',
  'ortensia',
  'ortica',
  'orzata',
  'orzo',
  'osare',
  'oscurare',
  'osmosi',
  'ospedale',
  'ospite',
  'ossa',
  'ossidare',
  'ostacolo',
  'oste',
  'otite',
  'otre',
  'ottagono',
  'ottimo',
  'ottobre',
  'ovale',
  'ovest',
  'ovino',
  'oviparo',
  'ovocito',
  'ovunque',
  'ovviare',
  'ozio',
  'pacchetto',
  'pace',
  'pacifico',
  'padella',
  'padrone',
  'paese',
  'paga',
  'pagina',
  'palazzina',
  'palesare',
  'pallido',
  'palo',
  'palude',
  'pandoro',
  'pannello',
  'paolo',
  'paonazzo',
  'paprica',
  'parabola',
  'parcella',
  'parere',
  'pargolo',
  'pari',
  'parlato',
  'parola',
  'partire',
  'parvenza',
  'parziale',
  'passivo',
  'pasticca',
  'patacca',
  'patologia',
  'pattume',
  'pavone',
  'peccato',
  'pedalare',
  'pedonale',
  'peggio',
  'peloso',
  'penare',
  'pendice',
  'penisola',
  'pennuto',
  'penombra',
  'pensare',
  'pentola',
  'pepe',
  'pepita',
  'perbene',
  'percorso',
  'perdonato',
  'perforare',
  'pergamena',
  'periodo',
  'permesso',
  'perno',
  'perplesso',
  'persuaso',
  'pertugio',
  'pervaso',
  'pesatore',
  'pesista',
  'peso',
  'pestifero',
  'petalo',
  'pettine',
  'petulante',
  'pezzo',
  'piacere',
  'pianta',
  'piattino',
  'piccino',
  'picozza',
  'piega',
  'pietra',
  'piffero',
  'pigiama',
  'pigolio',
  'pigro',
  'pila',
  'pilifero',
  'pillola',
  'pilota',
  'pimpante',
  'pineta',
  'pinna',
  'pinolo',
  'pioggia',
  'piombo',
  'piramide',
  'piretico',
  'pirite',
  'pirolisi',
  'pitone',
  'pizzico',
  'placebo',
  'planare',
  'plasma',
  'platano',
  'plenario',
  'pochezza',
  'poderoso',
  'podismo',
  'poesia',
  'poggiare',
  'polenta',
  'poligono',
  'pollice',
  'polmonite',
  'polpetta',
  'polso',
  'poltrona',
  'polvere',
  'pomice',
  'pomodoro',
  'ponte',
  'popoloso',
  'porfido',
  'poroso',
  'porpora',
  'porre',
  'portata',
  'posa',
  'positivo',
  'possesso',
  'postulato',
  'potassio',
  'potere',
  'pranzo',
  'prassi',
  'pratica',
  'precluso',
  'predica',
  'prefisso',
  'pregiato',
  'prelievo',
  'premere',
  'prenotare',
  'preparato',
  'presenza',
  'pretesto',
  'prevalso',
  'prima',
  'principe',
  'privato',
  'problema',
  'procura',
  'produrre',
  'profumo',
  'progetto',
  'prolunga',
  'promessa',
  'pronome',
  'proposta',
  'proroga',
  'proteso',
  'prova',
  'prudente',
  'prugna',
  'prurito',
  'psiche',
  'pubblico',
  'pudica',
  'pugilato',
  'pugno',
  'pulce',
  'pulito',
  'pulsante',
  'puntare',
  'pupazzo',
  'pupilla',
  'puro',
  'quadro',
  'qualcosa',
  'quasi',
  'querela',
  'quota',
  'raccolto',
  'raddoppio',
  'radicale',
  'radunato',
  'raffica',
  'ragazzo',
  'ragione',
  'ragno',
  'ramarro',
  'ramingo',
  'ramo',
  'randagio',
  'rantolare',
  'rapato',
  'rapina',
  'rappreso',
  'rasatura',
  'raschiato',
  'rasente',
  'rassegna',
  'rastrello',
  'rata',
  'ravveduto',
  'reale',
  'recepire',
  'recinto',
  'recluta',
  'recondito',
  'recupero',
  'reddito',
  'redimere',
  'regalato',
  'registro',
  'regola',
  'regresso',
  'relazione',
  'remare',
  'remoto',
  'renna',
  'replica',
  'reprimere',
  'reputare',
  'resa',
  'residente',
  'responso',
  'restauro',
  'rete',
  'retina',
  'retorica',
  'rettifica',
  'revocato',
  'riassunto',
  'ribadire',
  'ribelle',
  'ribrezzo',
  'ricarica',
  'ricco',
  'ricevere',
  'riciclato',
  'ricordo',
  'ricreduto',
  'ridicolo',
  'ridurre',
  'rifasare',
  'riflesso',
  'riforma',
  'rifugio',
  'rigare',
  'rigettato',
  'righello',
  'rilassato',
  'rilevato',
  'rimanere',
  'rimbalzo',
  'rimedio',
  'rimorchio',
  'rinascita',
  'rincaro',
  'rinforzo',
  'rinnovo',
  'rinomato',
  'rinsavito',
  'rintocco',
  'rinuncia',
  'rinvenire',
  'riparato',
  'ripetuto',
  'ripieno',
  'riportare',
  'ripresa',
  'ripulire',
  'risata',
  'rischio',
  'riserva',
  'risibile',
  'riso',
  'rispetto',
  'ristoro',
  'risultato',
  'risvolto',
  'ritardo',
  'ritegno',
  'ritmico',
  'ritrovo',
  'riunione',
  'riva',
  'riverso',
  'rivincita',
  'rivolto',
  'rizoma',
  'roba',
  'robotico',
  'robusto',
  'roccia',
  'roco',
  'rodaggio',
  'rodere',
  'roditore',
  'rogito',
  'rollio',
  'romantico',
  'rompere',
  'ronzio',
  'rosolare',
  'rospo',
  'rotante',
  'rotondo',
  'rotula',
  'rovescio',
  'rubizzo',
  'rubrica',
  'ruga',
  'rullino',
  'rumine',
  'rumoroso',
  'ruolo',
  'rupe',
  'russare',
  'rustico',
  'sabato',
  'sabbiare',
  'sabotato',
  'sagoma',
  'salasso',
  'saldatura',
  'salgemma',
  'salivare',
  'salmone',
  'salone',
  'saltare',
  'saluto',
  'salvo',
  'sapere',
  'sapido',
  'saporito',
  'saraceno',
  'sarcasmo',
  'sarto',
  'sassoso',
  'satellite',
  'satira',
  'satollo',
  'saturno',
  'savana',
  'savio',
  'saziato',
  'sbadiglio',
  'sbalzo',
  'sbancato',
  'sbarra',
  'sbattere',
  'sbavare',
  'sbendare',
  'sbirciare',
  'sbloccato',
  'sbocciato',
  'sbrinare',
  'sbruffone',
  'sbuffare',
  'scabroso',
  'scadenza',
  'scala',
  'scambiare',
  'scandalo',
  'scapola',
  'scarso',
  'scatenare',
  'scavato',
  'scelto',
  'scenico',
  'scettro',
  'scheda',
  'schiena',
  'sciarpa',
  'scienza',
  'scindere',
  'scippo',
  'sciroppo',
  'scivolo',
  'sclerare',
  'scodella',
  'scolpito',
  'scomparto',
  'sconforto',
  'scoprire',
  'scorta',
  'scossone',
  'scozzese',
  'scriba',
  'scrollare',
  'scrutinio',
  'scuderia',
  'scultore',
  'scuola',
  'scuro',
  'scusare',
  'sdebitare',
  'sdoganare',
  'seccatura',
  'secondo',
  'sedano',
  'seggiola',
  'segnalato',
  'segregato',
  'seguito',
  'selciato',
  'selettivo',
  'sella',
  'selvaggio',
  'semaforo',
  'sembrare',
  'seme',
  'seminato',
  'sempre',
  'senso',
  'sentire',
  'sepolto',
  'sequenza',
  'serata',
  'serbato',
  'sereno',
  'serio',
  'serpente',
  'serraglio',
  'servire',
  'sestina',
  'setola',
  'settimana',
  'sfacelo',
  'sfaldare',
  'sfamato',
  'sfarzoso',
  'sfaticato',
  'sfera',
  'sfida',
  'sfilato',
  'sfinge',
  'sfocato',
  'sfoderare',
  'sfogo',
  'sfoltire',
  'sforzato',
  'sfratto',
  'sfruttato',
  'sfuggito',
  'sfumare',
  'sfuso',
  'sgabello',
  'sgarbato',
  'sgonfiare',
  'sgorbio',
  'sgrassato',
  'sguardo',
  'sibilo',
  'siccome',
  'sierra',
  'sigla',
  'signore',
  'silenzio',
  'sillaba',
  'simbolo',
  'simpatico',
  'simulato',
  'sinfonia',
  'singolo',
  'sinistro',
  'sino',
  'sintesi',
  'sinusoide',
  'sipario',
  'sisma',
  'sistole',
  'situato',
  'slitta',
  'slogatura',
  'sloveno',
  'smarrito',
  'smemorato',
  'smentito',
  'smeraldo',
  'smilzo',
  'smontare',
  'smottato',
  'smussato',
  'snellire',
  'snervato',
  'snodo',
  'sobbalzo',
  'sobrio',
  'soccorso',
  'sociale',
  'sodale',
  'soffitto',
  'sogno',
  'soldato',
  'solenne',
  'solido',
  'sollazzo',
  'solo',
  'solubile',
  'solvente',
  'somatico',
  'somma',
  'sonda',
  'sonetto',
  'sonnifero',
  'sopire',
  'soppeso',
  'sopra',
  'sorgere',
  'sorpasso',
  'sorriso',
  'sorso',
  'sorteggio',
  'sorvolato',
  'sospiro',
  'sosta',
  'sottile',
  'spada',
  'spalla',
  'spargere',
  'spatola',
  'spavento',
  'spazzola',
  'specie',
  'spedire',
  'spegnere',
  'spelatura',
  'speranza',
  'spessore',
  'spettrale',
  'spezzato',
  'spia',
  'spigoloso',
  'spillato',
  'spinoso',
  'spirale',
  'splendido',
  'sportivo',
  'sposo',
  'spranga',
  'sprecare',
  'spronato',
  'spruzzo',
  'spuntino',
  'squillo',
  'sradicare',
  'srotolato',
  'stabile',
  'stacco',
  'staffa',
  'stagnare',
  'stampato',
  'stantio',
  'starnuto',
  'stasera',
  'statuto',
  'stelo',
  'steppa',
  'sterzo',
  'stiletto',
  'stima',
  'stirpe',
  'stivale',
  'stizzoso',
  'stonato',
  'storico',
  'strappo',
  'stregato',
  'stridulo',
  'strozzare',
  'strutto',
  'stuccare',
  'stufo',
  'stupendo',
  'subentro',
  'succoso',
  'sudore',
  'suggerito',
  'sugo',
  'sultano',
  'suonare',
  'superbo',
  'supporto',
  'surgelato',
  'surrogato',
  'sussurro',
  'sutura',
  'svagare',
  'svedese',
  'sveglio',
  'svelare',
  'svenuto',
  'svezia',
  'sviluppo',
  'svista',
  'svizzera',
  'svolta',
  'svuotare',
  'tabacco',
  'tabulato',
  'tacciare',
  'taciturno',
  'tale',
  'talismano',
  'tampone',
  'tannino',
  'tara',
  'tardivo',
  'targato',
  'tariffa',
  'tarpare',
  'tartaruga',
  'tasto',
  'tattico',
  'taverna',
  'tavolata',
  'tazza',
  'teca',
  'tecnico',
  'telefono',
  'temerario',
  'tempo',
  'temuto',
  'tendone',
  'tenero',
  'tensione',
  'tentacolo',
  'teorema',
  'terme',
  'terrazzo',
  'terzetto',
  'tesi',
  'tesserato',
  'testato',
  'tetro',
  'tettoia',
  'tifare',
  'tigella',
  'timbro',
  'tinto',
  'tipico',
  'tipografo',
  'tiraggio',
  'tiro',
  'titanio',
  'titolo',
  'titubante',
  'tizio',
  'tizzone',
  'toccare',
  'tollerare',
  'tolto',
  'tombola',
  'tomo',
  'tonfo',
  'tonsilla',
  'topazio',
  'topologia',
  'toppa',
  'torba',
  'tornare',
  'torrone',
  'tortora',
  'toscano',
  'tossire',
  'tostatura',
  'totano',
  'trabocco',
  'trachea',
  'trafila',
  'tragedia',
  'tralcio',
  'tramonto',
  'transito',
  'trapano',
  'trarre',
  'trasloco',
  'trattato',
  'trave',
  'treccia',
  'tremolio',
  'trespolo',
  'tributo',
  'tricheco',
  'trifoglio',
  'trillo',
  'trincea',
  'trio',
  'tristezza',
  'triturato',
  'trivella',
  'tromba',
  'trono',
  'troppo',
  'trottola',
  'trovare',
  'truccato',
  'tubatura',
  'tuffato',
  'tulipano',
  'tumulto',
  'tunisia',
  'turbare',
  'turchino',
  'tuta',
  'tutela',
  'ubicato',
  'uccello',
  'uccisore',
  'udire',
  'uditivo',
  'uffa',
  'ufficio',
  'uguale',
  'ulisse',
  'ultimato',
  'umano',
  'umile',
  'umorismo',
  'uncinetto',
  'ungere',
  'ungherese',
  'unicorno',
  'unificato',
  'unisono',
  'unitario',
  'unte',
  'uovo',
  'upupa',
  'uragano',
  'urgenza',
  'urlo',
  'usanza',
  'usato',
  'uscito',
  'usignolo',
  'usuraio',
  'utensile',
  'utilizzo',
  'utopia',
  'vacante',
  'vaccinato',
  'vagabondo',
  'vagliato',
  'valanga',
  'valgo',
  'valico',
  'valletta',
  'valoroso',
  'valutare',
  'valvola',
  'vampata',
  'vangare',
  'vanitoso',
  'vano',
  'vantaggio',
  'vanvera',
  'vapore',
  'varano',
  'varcato',
  'variante',
  'vasca',
  'vedetta',
  'vedova',
  'veduto',
  'vegetale',
  'veicolo',
  'velcro',
  'velina',
  'velluto',
  'veloce',
  'venato',
  'vendemmia',
  'vento',
  'verace',
  'verbale',
  'vergogna',
  'verifica',
  'vero',
  'verruca',
  'verticale',
  'vescica',
  'vessillo',
  'vestale',
  'veterano',
  'vetrina',
  'vetusto',
  'viandante',
  'vibrante',
  'vicenda',
  'vichingo',
  'vicinanza',
  'vidimare',
  'vigilia',
  'vigneto',
  'vigore',
  'vile',
  'villano',
  'vimini',
  'vincitore',
  'viola',
  'vipera',
  'virgola',
  'virologo',
  'virulento',
  'viscoso',
  'visione',
  'vispo',
  'vissuto',
  'visura',
  'vita',
  'vitello',
  'vittima',
  'vivanda',
  'vivido',
  'viziare',
  'voce',
  'voga',
  'volatile',
  'volere',
  'volpe',
  'voragine',
  'vulcano',
  'zampogna',
  'zanna',
  'zappato',
  'zattera',
  'zavorra',
  'zefiro',
  'zelante',
  'zelo',
  'zenzero',
  'zerbino',
  'zibetto',
  'zinco',
  'zircone',
  'zitto',
  'zolla',
  'zotico',
  'zucchero',
  'zufolo',
  'zulu',
  'zuppa'
];


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = [
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  ''
];


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = [
  'abaco',
  'abdomen',
  'abeja',
  'abierto',
  'abogado',
  'abono',
  'aborto',
  'abrazo',
  'abrir',
  'abuelo',
  'abuso',
  'acabar',
  'academia',
  'acceso',
  'accion',
  'aceite',
  'acelga',
  'acento',
  'aceptar',
  'acido',
  'aclarar',
  'acne',
  'acoger',
  'acoso',
  'activo',
  'acto',
  'actriz',
  'actuar',
  'acudir',
  'acuerdo',
  'acusar',
  'adicto',
  'admitir',
  'adoptar',
  'adorno',
  'aduana',
  'adulto',
  'aereo',
  'afectar',
  'aficion',
  'afinar',
  'afirmar',
  'agil',
  'agitar',
  'agonia',
  'agosto',
  'agotar',
  'agregar',
  'agrio',
  'agua',
  'agudo',
  'aguila',
  'aguja',
  'ahogo',
  'ahorro',
  'aire',
  'aislar',
  'ajedrez',
  'ajeno',
  'ajuste',
  'alacran',
  'alambre',
  'alarma',
  'alba',
  'album',
  'alcalde',
  'aldea',
  'alegre',
  'alejar',
  'alerta',
  'aleta',
  'alfiler',
  'alga',
  'algodon',
  'aliado',
  'aliento',
  'alivio',
  'alma',
  'almeja',
  'almibar',
  'altar',
  'alteza',
  'altivo',
  'alto',
  'altura',
  'alumno',
  'alzar',
  'amable',
  'amante',
  'amapola',
  'amargo',
  'amasar',
  'ambar',
  'ambito',
  'ameno',
  'amigo',
  'amistad',
  'amor',
  'amparo',
  'amplio',
  'ancho',
  'anciano',
  'ancla',
  'andar',
  'anden',
  'anemia',
  'angulo',
  'anillo',
  'animo',
  'anis',
  'anotar',
  'antena',
  'antiguo',
  'antojo',
  'anual',
  'anular',
  'anuncio',
  'anadir',
  'anejo',
  'ano',
  'apagar',
  'aparato',
  'apetito',
  'apio',
  'aplicar',
  'apodo',
  'aporte',
  'apoyo',
  'aprender',
  'aprobar',
  'apuesta',
  'apuro',
  'arado',
  'arana',
  'arar',
  'arbitro',
  'arbol',
  'arbusto',
  'archivo',
  'arco',
  'arder',
  'ardilla',
  'arduo',
  'area',
  'arido',
  'aries',
  'armonia',
  'arnes',
  'aroma',
  'arpa',
  'arpon',
  'arreglo',
  'arroz',
  'arruga',
  'arte',
  'artista',
  'asa',
  'asado',
  'asalto',
  'ascenso',
  'asegurar',
  'aseo',
  'asesor',
  'asiento',
  'asilo',
  'asistir',
  'asno',
  'asombro',
  'aspero',
  'astilla',
  'astro',
  'astuto',
  'asumir',
  'asunto',
  'atajo',
  'ataque',
  'atar',
  'atento',
  'ateo',
  'atico',
  'atleta',
  'atomo',
  'atraer',
  'atroz',
  'atun',
  'audaz',
  'audio',
  'auge',
  'aula',
  'aumento',
  'ausente',
  'autor',
  'aval',
  'avance',
  'avaro',
  'ave',
  'avellana',
  'avena',
  'avestruz',
  'avion',
  'aviso',
  'ayer',
  'ayuda',
  'ayuno',
  'azafran',
  'azar',
  'azote',
  'azucar',
  'azufre',
  'azul',
  'baba',
  'babor',
  'bache',
  'bahia',
  'baile',
  'bajar',
  'balanza',
  'balcon',
  'balde',
  'bambu',
  'banco',
  'banda',
  'bano',
  'barba',
  'barco',
  'barniz',
  'barro',
  'bascula',
  'baston',
  'basura',
  'batalla',
  'bateria',
  'batir',
  'batuta',
  'baul',
  'bazar',
  'bebe',
  'bebida',
  'bello',
  'besar',
  'beso',
  'bestia',
  'bicho',
  'bien',
  'bingo',
  'blanco',
  'bloque',
  'blusa',
  'boa',
  'bobina',
  'bobo',
  'boca',
  'bocina',
  'boda',
  'bodega',
  'boina',
  'bola',
  'bolero',
  'bolsa',
  'bomba',
  'bondad',
  'bonito',
  'bono',
  'bonsai',
  'borde',
  'borrar',
  'bosque',
  'bote',
  'botin',
  'boveda',
  'bozal',
  'bravo',
  'brazo',
  'brecha',
  'breve',
  'brillo',
  'brinco',
  'brisa',
  'broca',
  'broma',
  'bronce',
  'brote',
  'bruja',
  'brusco',
  'bruto',
  'buceo',
  'bucle',
  'bueno',
  'buey',
  'bufanda',
  'bufon',
  'buho',
  'buitre',
  'bulto',
  'burbuja',
  'burla',
  'burro',
  'buscar',
  'butaca',
  'buzon',
  'caballo',
  'cabeza',
  'cabina',
  'cabra',
  'cacao',
  'cadaver',
  'cadena',
  'caer',
  'cafe',
  'caida',
  'caiman',
  'caja',
  'cajon',
  'cal',
  'calamar',
  'calcio',
  'caldo',
  'calidad',
  'calle',
  'calma',
  'calor',
  'calvo',
  'cama',
  'cambio',
  'camello',
  'camino',
  'campo',
  'cancer',
  'candil',
  'canela',
  'canguro',
  'canica',
  'canto',
  'cana',
  'canon',
  'caoba',
  'caos',
  'capaz',
  'capitan',
  'capote',
  'captar',
  'capucha',
  'cara',
  'carbon',
  'carcel',
  'careta',
  'carga',
  'carino',
  'carne',
  'carpeta',
  'carro',
  'carta',
  'casa',
  'casco',
  'casero',
  'caspa',
  'castor',
  'catorce',
  'catre',
  'caudal',
  'causa',
  'cazo',
  'cebolla',
  'ceder',
  'cedro',
  'celda',
  'celebre',
  'celoso',
  'celula',
  'cemento',
  'ceniza',
  'centro',
  'cerca',
  'cerdo',
  'cereza',
  'cero',
  'cerrar',
  'certeza',
  'cesped',
  'cetro',
  'chacal',
  'chaleco',
  'champu',
  'chancla',
  'chapa',
  'charla',
  'chico',
  'chiste',
  'chivo',
  'choque',
  'choza',
  'chuleta',
  'chupar',
  'ciclon',
  'ciego',
  'cielo',
  'cien',
  'cierto',
  'cifra',
  'cigarro',
  'cima',
  'cinco',
  'cine',
  'cinta',
  'cipres',
  'circo',
  'ciruela',
  'cisne',
  'cita',
  'ciudad',
  'clamor',
  'clan',
  'claro',
  'clase',
  'clave',
  'cliente',
  'clima',
  'clinica',
  'cobre',
  'coccion',
  'cochino',
  'cocina',
  'coco',
  'codigo',
  'codo',
  'cofre',
  'coger',
  'cohete',
  'cojin',
  'cojo',
  'cola',
  'colcha',
  'colegio',
  'colgar',
  'colina',
  'collar',
  'colmo',
  'columna',
  'combate',
  'comer',
  'comida',
  'comodo',
  'compra',
  'conde',
  'conejo',
  'conga',
  'conocer',
  'consejo',
  'contar',
  'copa',
  'copia',
  'corazon',
  'corbata',
  'corcho',
  'cordon',
  'corona',
  'correr',
  'coser',
  'cosmos',
  'costa',
  'craneo',
  'crater',
  'crear',
  'crecer',
  'creido',
  'crema',
  'cria',
  'crimen',
  'cripta',
  'crisis',
  'cromo',
  'cronica',
  'croqueta',
  'crudo',
  'cruz',
  'cuadro',
  'cuarto',
  'cuatro',
  'cubo',
  'cubrir',
  'cuchara',
  'cuello',
  'cuento',
  'cuerda',
  'cuesta',
  'cueva',
  'cuidar',
  'culebra',
  'culpa',
  'culto',
  'cumbre',
  'cumplir',
  'cuna',
  'cuneta',
  'cuota',
  'cupon',
  'cupula',
  'curar',
  'curioso',
  'curso',
  'curva',
  'cutis',
  'dama',
  'danza',
  'dar',
  'dardo',
  'datil',
  'deber',
  'debil',
  'decada',
  'decir',
  'dedo',
  'defensa',
  'definir',
  'dejar',
  'delfin',
  'delgado',
  'delito',
  'demora',
  'denso',
  'dental',
  'deporte',
  'derecho',
  'derrota',
  'desayuno',
  'deseo',
  'desfile',
  'desnudo',
  'destino',
  'desvio',
  'detalle',
  'detener',
  'deuda',
  'dia',
  'diablo',
  'diadema',
  'diamante',
  'diana',
  'diario',
  'dibujo',
  'dictar',
  'diente',
  'dieta',
  'diez',
  'dificil',
  'digno',
  'dilema',
  'diluir',
  'dinero',
  'directo',
  'dirigir',
  'disco',
  'diseno',
  'disfraz',
  'diva',
  'divino',
  'doble',
  'doce',
  'dolor',
  'domingo',
  'don',
  'donar',
  'dorado',
  'dormir',
  'dorso',
  'dos',
  'dosis',
  'dragon',
  'droga',
  'ducha',
  'duda',
  'duelo',
  'dueno',
  'dulce',
  'duo',
  'duque',
  'durar',
  'dureza',
  'duro',
  'ebano',
  'ebrio',
  'echar',
  'eco',
  'ecuador',
  'edad',
  'edicion',
  'edificio',
  'editor',
  'educar',
  'efecto',
  'eficaz',
  'eje',
  'ejemplo',
  'elefante',
  'elegir',
  'elemento',
  'elevar',
  'elipse',
  'elite',
  'elixir',
  'elogio',
  'eludir',
  'embudo',
  'emitir',
  'emocion',
  'empate',
  'empeno',
  'empleo',
  'empresa',
  'enano',
  'encargo',
  'enchufe',
  'encia',
  'enemigo',
  'enero',
  'enfado',
  'enfermo',
  'engano',
  'enigma',
  'enlace',
  'enorme',
  'enredo',
  'ensayo',
  'ensenar',
  'entero',
  'entrar',
  'envase',
  'envio',
  'epoca',
  'equipo',
  'erizo',
  'escala',
  'escena',
  'escolar',
  'escribir',
  'escudo',
  'esencia',
  'esfera',
  'esfuerzo',
  'espada',
  'espejo',
  'espia',
  'esposa',
  'espuma',
  'esqui',
  'estar',
  'este',
  'estilo',
  'estufa',
  'etapa',
  'eterno',
  'etica',
  'etnia',
  'evadir',
  'evaluar',
  'evento',
  'evitar',
  'exacto',
  'examen',
  'exceso',
  'excusa',
  'exento',
  'exigir',
  'exilio',
  'existir',
  'exito',
  'experto',
  'explicar',
  'exponer',
  'extremo',
  'fabrica',
  'fabula',
  'fachada',
  'facil',
  'factor',
  'faena',
  'faja',
  'falda',
  'fallo',
  'falso',
  'faltar',
  'fama',
  'familia',
  'famoso',
  'faraon',
  'farmacia',
  'farol',
  'farsa',
  'fase',
  'fatiga',
  'fauna',
  'favor',
  'fax',
  'febrero',
  'fecha',
  'feliz',
  'feo',
  'feria',
  'feroz',
  'fertil',
  'fervor',
  'festin',
  'fiable',
  'fianza',
  'fiar',
  'fibra',
  'ficcion',
  'ficha',
  'fideo',
  'fiebre',
  'fiel',
  'fiera',
  'fiesta',
  'figura',
  'fijar',
  'fijo',
  'fila',
  'filete',
  'filial',
  'filtro',
  'fin',
  'finca',
  'fingir',
  'finito',
  'firma',
  'flaco',
  'flauta',
  'flecha',
  'flor',
  'flota',
  'fluir',
  'flujo',
  'fluor',
  'fobia',
  'foca',
  'fogata',
  'fogon',
  'folio',
  'folleto',
  'fondo',
  'forma',
  'forro',
  'fortuna',
  'forzar',
  'fosa',
  'foto',
  'fracaso',
  'fragil',
  'franja',
  'frase',
  'fraude',
  'freir',
  'freno',
  'fresa',
  'frio',
  'frito',
  'fruta',
  'fuego',
  'fuente',
  'fuerza',
  'fuga',
  'fumar',
  'funcion',
  'funda',
  'furgon',
  'furia',
  'fusil',
  'futbol',
  'futuro',
  'gacela',
  'gafas',
  'gaita',
  'gajo',
  'gala',
  'galeria',
  'gallo',
  'gamba',
  'ganar',
  'gancho',
  'ganga',
  'ganso',
  'garaje',
  'garza',
  'gasolina',
  'gastar',
  'gato',
  'gavilan',
  'gemelo',
  'gemir',
  'gen',
  'genero',
  'genio',
  'gente',
  'geranio',
  'gerente',
  'germen',
  'gesto',
  'gigante',
  'gimnasio',
  'girar',
  'giro',
  'glaciar',
  'globo',
  'gloria',
  'gol',
  'golfo',
  'goloso',
  'golpe',
  'goma',
  'gordo',
  'gorila',
  'gorra',
  'gota',
  'goteo',
  'gozar',
  'grada',
  'grafico',
  'grano',
  'grasa',
  'gratis',
  'grave',
  'grieta',
  'grillo',
  'gripe',
  'gris',
  'grito',
  'grosor',
  'grua',
  'grueso',
  'grumo',
  'grupo',
  'guante',
  'guapo',
  'guardia',
  'guerra',
  'guia',
  'guino',
  'guion',
  'guiso',
  'guitarra',
  'gusano',
  'gustar',
  'haber',
  'habil',
  'hablar',
  'hacer',
  'hacha',
  'hada',
  'hallar',
  'hamaca',
  'harina',
  'haz',
  'hazana',
  'hebilla',
  'hebra',
  'hecho',
  'helado',
  'helio',
  'hembra',
  'herir',
  'hermano',
  'heroe',
  'hervir',
  'hielo',
  'hierro',
  'higado',
  'higiene',
  'hijo',
  'himno',
  'historia',
  'hocico',
  'hogar',
  'hoguera',
  'hoja',
  'hombre',
  'hongo',
  'honor',
  'honra',
  'hora',
  'hormiga',
  'horno',
  'hostil',
  'hoyo',
  'hueco',
  'huelga',
  'huerta',
  'hueso',
  'huevo',
  'huida',
  'huir',
  'humano',
  'humedo',
  'humilde',
  'humo',
  'hundir',
  'huracan',
  'hurto',
  'icono',
  'ideal',
  'idioma',
  'idolo',
  'iglesia',
  'iglu',
  'igual',
  'ilegal',
  'ilusion',
  'imagen',
  'iman',
  'imitar',
  'impar',
  'imperio',
  'imponer',
  'impulso',
  'incapaz',
  'indice',
  'inerte',
  'infiel',
  'informe',
  'ingenio',
  'inicio',
  'inmenso',
  'inmune',
  'innato',
  'insecto',
  'instante',
  'interes',
  'intimo',
  'intuir',
  'inutil',
  'invierno',
  'ira',
  'iris',
  'ironia',
  'isla',
  'islote',
  'jabali',
  'jabon',
  'jamon',
  'jarabe',
  'jardin',
  'jarra',
  'jaula',
  'jazmin',
  'jefe',
  'jeringa',
  'jinete',
  'jornada',
  'joroba',
  'joven',
  'joya',
  'juerga',
  'jueves',
  'juez',
  'jugador',
  'jugo',
  'juguete',
  'juicio',
  'junco',
  'jungla',
  'junio',
  'juntar',
  'jupiter',
  'jurar',
  'justo',
  'juvenil',
  'juzgar',
  'kilo',
  'koala',
  'labio',
  'lacio',
  'lacra',
  'lado',
  'ladron',
  'lagarto',
  'lagrima',
  'laguna',
  'laico',
  'lamer',
  'lamina',
  'lampara',
  'lana',
  'lancha',
  'langosta',
  'lanza',
  'lapiz',
  'largo',
  'larva',
  'lastima',
  'lata',
  'latex',
  'latir',
  'laurel',
  'lavar',
  'lazo',
  'leal',
  'leccion',
  'leche',
  'lector',
  'leer',
  'legion',
  'legumbre',
  'lejano',
  'lengua',
  'lento',
  'lena',
  'leon',
  'leopardo',
  'lesion',
  'letal',
  'letra',
  'leve',
  'leyenda',
  'libertad',
  'libro',
  'licor',
  'lider',
  'lidiar',
  'lienzo',
  'liga',
  'ligero',
  'lima',
  'limite',
  'limon',
  'limpio',
  'lince',
  'lindo',
  'linea',
  'lingote',
  'lino',
  'linterna',
  'liquido',
  'liso',
  'lista',
  'litera',
  'litio',
  'litro',
  'llaga',
  'llama',
  'llanto',
  'llave',
  'llegar',
  'llenar',
  'llevar',
  'llorar',
  'llover',
  'lluvia',
  'lobo',
  'locion',
  'loco',
  'locura',
  'logica',
  'logro',
  'lombriz',
  'lomo',
  'lonja',
  'lote',
  'lucha',
  'lucir',
  'lugar',
  'lujo',
  'luna',
  'lunes',
  'lupa',
  'lustro',
  'luto',
  'luz',
  'maceta',
  'macho',
  'madera',
  'madre',
  'maduro',
  'maestro',
  'mafia',
  'magia',
  'mago',
  'maiz',
  'maldad',
  'maleta',
  'malla',
  'malo',
  'mama',
  'mambo',
  'mamut',
  'manco',
  'mando',
  'manejar',
  'manga',
  'maniqui',
  'manjar',
  'mano',
  'manso',
  'manta',
  'manana',
  'mapa',
  'maquina',
  'mar',
  'marco',
  'marea',
  'marfil',
  'margen',
  'marido',
  'marmol',
  'marron',
  'martes',
  'marzo',
  'masa',
  'mascara',
  'masivo',
  'matar',
  'materia',
  'matiz',
  'matriz',
  'maximo',
  'mayor',
  'mazorca',
  'mecha',
  'medalla',
  'medio',
  'medula',
  'mejilla',
  'mejor',
  'melena',
  'melon',
  'memoria',
  'menor',
  'mensaje',
  'mente',
  'menu',
  'mercado',
  'merengue',
  'merito',
  'mes',
  'meson',
  'meta',
  'meter',
  'metodo',
  'metro',
  'mezcla',
  'miedo',
  'miel',
  'miembro',
  'miga',
  'mil',
  'milagro',
  'militar',
  'millon',
  'mimo',
  'mina',
  'minero',
  'minimo',
  'minuto',
  'miope',
  'mirar',
  'misa',
  'miseria',
  'misil',
  'mismo',
  'mitad',
  'mito',
  'mochila',
  'mocion',
  'moda',
  'modelo',
  'moho',
  'mojar',
  'molde',
  'moler',
  'molino',
  'momento',
  'momia',
  'monarca',
  'moneda',
  'monja',
  'monto',
  'mono',
  'morada',
  'morder',
  'moreno',
  'morir',
  'morro',
  'morsa',
  'mortal',
  'mosca',
  'mostrar',
  'motivo',
  'mover',
  'movil',
  'mozo',
  'mucho',
  'mudar',
  'mueble',
  'muela',
  'muerte',
  'muestra',
  'mugre',
  'mujer',
  'mula',
  'muleta',
  'multa',
  'mundo',
  'muneca',
  'mural',
  'muro',
  'musculo',
  'museo',
  'musgo',
  'musica',
  'muslo',
  'nacar',
  'nacion',
  'nadar',
  'naipe',
  'naranja',
  'nariz',
  'narrar',
  'nasal',
  'natal',
  'nativo',
  'natural',
  'nausea',
  'naval',
  'nave',
  'navidad',
  'necio',
  'nectar',
  'negar',
  'negocio',
  'negro',
  'neon',
  'nervio',
  'neto',
  'neutro',
  'nevar',
  'nevera',
  'nicho',
  'nido',
  'niebla',
  'nieto',
  'ninez',
  'nino',
  'nitido',
  'nivel',
  'nobleza',
  'noche',
  'nomina',
  'noria',
  'norma',
  'norte',
  'nota',
  'noticia',
  'novato',
  'novela',
  'novio',
  'nube',
  'nuca',
  'nucleo',
  'nudillo',
  'nudo',
  'nuera',
  'nueve',
  'nuez',
  'nulo',
  'numero',
  'nutria',
  'oasis',
  'obeso',
  'obispo',
  'objeto',
  'obra',
  'obrero',
  'observar',
  'obtener',
  'obvio',
  'oca',
  'ocaso',
  'oceano',
  'ochenta',
  'ocho',
  'ocio',
  'ocre',
  'octavo',
  'octubre',
  'oculto',
  'ocupar',
  'ocurrir',
  'odiar',
  'odio',
  'odisea',
  'oeste',
  'ofensa',
  'oferta',
  'oficio',
  'ofrecer',
  'ogro',
  'oido',
  'oir',
  'ojo',
  'ola',
  'oleada',
  'olfato',
  'olivo',
  'olla',
  'olmo',
  'olor',
  'olvido',
  'ombligo',
  'onda',
  'onza',
  'opaco',
  'opcion',
  'opera',
  'opinar',
  'oponer',
  'optar',
  'optica',
  'opuesto',
  'oracion',
  'orador',
  'oral',
  'orbita',
  'orca',
  'orden',
  'oreja',
  'organo',
  'orgia',
  'orgullo',
  'oriente',
  'origen',
  'orilla',
  'oro',
  'orquesta',
  'oruga',
  'osadia',
  'oscuro',
  'osezno',
  'oso',
  'ostra',
  'otono',
  'otro',
  'oveja',
  'ovulo',
  'oxido',
  'oxigeno',
  'oyente',
  'ozono',
  'pacto',
  'padre',
  'paella',
  'pagina',
  'pago',
  'pais',
  'pajaro',
  'palabra',
  'palco',
  'paleta',
  'palido',
  'palma',
  'paloma',
  'palpar',
  'pan',
  'panal',
  'panico',
  'pantera',
  'panuelo',
  'papa',
  'papel',
  'papilla',
  'paquete',
  'parar',
  'parcela',
  'pared',
  'parir',
  'paro',
  'parpado',
  'parque',
  'parrafo',
  'parte',
  'pasar',
  'paseo',
  'pasion',
  'paso',
  'pasta',
  'pata',
  'patio',
  'patria',
  'pausa',
  'pauta',
  'pavo',
  'payaso',
  'peaton',
  'pecado',
  'pecera',
  'pecho',
  'pedal',
  'pedir',
  'pegar',
  'peine',
  'pelar',
  'peldano',
  'pelea',
  'peligro',
  'pellejo',
  'pelo',
  'peluca',
  'pena',
  'pensar',
  'penon',
  'peon',
  'peor',
  'pepino',
  'pequeno',
  'pera',
  'percha',
  'perder',
  'pereza',
  'perfil',
  'perico',
  'perla',
  'permiso',
  'perro',
  'persona',
  'pesa',
  'pesca',
  'pesimo',
  'pestana',
  'petalo',
  'petroleo',
  'pez',
  'pezuna',
  'picar',
  'pichon',
  'pie',
  'piedra',
  'pierna',
  'pieza',
  'pijama',
  'pilar',
  'piloto',
  'pimienta',
  'pino',
  'pintor',
  'pinza',
  'pina',
  'piojo',
  'pipa',
  'pirata',
  'pisar',
  'piscina',
  'piso',
  'pista',
  'piton',
  'pizca',
  'placa',
  'plan',
  'plata',
  'playa',
  'plaza',
  'pleito',
  'pleno',
  'plomo',
  'pluma',
  'plural',
  'pobre',
  'poco',
  'poder',
  'podio',
  'poema',
  'poesia',
  'poeta',
  'polen',
  'policia',
  'pollo',
  'polvo',
  'pomada',
  'pomelo',
  'pomo',
  'pompa',
  'poner',
  'porcion',
  'portal',
  'posada',
  'poseer',
  'posible',
  'poste',
  'potencia',
  'potro',
  'pozo',
  'prado',
  'precoz',
  'pregunta',
  'premio',
  'prensa',
  'preso',
  'previo',
  'primo',
  'principe',
  'prision',
  'privar',
  'proa',
  'probar',
  'proceso',
  'producto',
  'proeza',
  'profesor',
  'programa',
  'prole',
  'promesa',
  'pronto',
  'propio',
  'proximo',
  'prueba',
  'publico',
  'puchero',
  'pudor',
  'pueblo',
  'puerta',
  'puesto',
  'pulga',
  'pulir',
  'pulmon',
  'pulpo',
  'pulso',
  'puma',
  'punto',
  'punal',
  'puno',
  'pupa',
  'pupila',
  'pure',
  'quedar',
  'queja',
  'quemar',
  'querer',
  'queso',
  'quieto',
  'quimica',
  'quince',
  'quitar',
  'rabano',
  'rabia',
  'rabo',
  'racion',
  'radical',
  'raiz',
  'rama',
  'rampa',
  'rancho',
  'rango',
  'rapaz',
  'rapido',
  'rapto',
  'rasgo',
  'raspa',
  'rato',
  'rayo',
  'raza',
  'razon',
  'reaccion',
  'realidad',
  'rebano',
  'rebote',
  'recaer',
  'receta',
  'rechazo',
  'recoger',
  'recreo',
  'recto',
  'recurso',
  'red',
  'redondo',
  'reducir',
  'reflejo',
  'reforma',
  'refran',
  'refugio',
  'regalo',
  'regir',
  'regla',
  'regreso',
  'rehen',
  'reino',
  'reir',
  'reja',
  'relato',
  'relevo',
  'relieve',
  'relleno',
  'reloj',
  'remar',
  'remedio',
  'remo',
  'rencor',
  'rendir',
  'renta',
  'reparto',
  'repetir',
  'reposo',
  'reptil',
  'res',
  'rescate',
  'resina',
  'respeto',
  'resto',
  'resumen',
  'retiro',
  'retorno',
  'retrato',
  'reunir',
  'reves',
  'revista',
  'rey',
  'rezar',
  'rico',
  'riego',
  'rienda',
  'riesgo',
  'rifa',
  'rigido',
  'rigor',
  'rincon',
  'rinon',
  'rio',
  'riqueza',
  'risa',
  'ritmo',
  'rito',
  'rizo',
  'roble',
  'roce',
  'rociar',
  'rodar',
  'rodeo',
  'rodilla',
  'roer',
  'rojizo',
  'rojo',
  'romero',
  'romper',
  'ron',
  'ronco',
  'ronda',
  'ropa',
  'ropero',
  'rosa',
  'rosca',
  'rostro',
  'rotar',
  'rubi',
  'rubor',
  'rudo',
  'rueda',
  'rugir',
  'ruido',
  'ruina',
  'ruleta',
  'rulo',
  'rumbo',
  'rumor',
  'ruptura',
  'ruta',
  'rutina',
  'sabado',
  'saber',
  'sabio',
  'sable',
  'sacar',
  'sagaz',
  'sagrado',
  'sala',
  'saldo',
  'salero',
  'salir',
  'salmon',
  'salon',
  'salsa',
  'salto',
  'salud',
  'salvar',
  'samba',
  'sancion',
  'sandia',
  'sanear',
  'sangre',
  'sanidad',
  'sano',
  'santo',
  'sapo',
  'saque',
  'sardina',
  'sarten',
  'sastre',
  'satan',
  'sauna',
  'saxofon',
  'seccion',
  'seco',
  'secreto',
  'secta',
  'sed',
  'seguir',
  'seis',
  'sello',
  'selva',
  'semana',
  'semilla',
  'senda',
  'sensor',
  'senal',
  'senor',
  'separar',
  'sepia',
  'sequia',
  'ser',
  'serie',
  'sermon',
  'servir',
  'sesenta',
  'sesion',
  'seta',
  'setenta',
  'severo',
  'sexo',
  'sexto',
  'sidra',
  'siesta',
  'siete',
  'siglo',
  'signo',
  'silaba',
  'silbar',
  'silencio',
  'silla',
  'simbolo',
  'simio',
  'sirena',
  'sistema',
  'sitio',
  'situar',
  'sobre',
  'socio',
  'sodio',
  'sol',
  'solapa',
  'soldado',
  'soledad',
  'solido',
  'soltar',
  'solucion',
  'sombra',
  'sondeo',
  'sonido',
  'sonoro',
  'sonrisa',
  'sopa',
  'soplar',
  'soporte',
  'sordo',
  'sorpresa',
  'sorteo',
  'sosten',
  'sotano',
  'suave',
  'subir',
  'suceso',
  'sudor',
  'suegra',
  'suelo',
  'sueno',
  'suerte',
  'sufrir',
  'sujeto',
  'sultan',
  'sumar',
  'superar',
  'suplir',
  'suponer',
  'supremo',
  'sur',
  'surco',
  'sureno',
  'surgir',
  'susto',
  'sutil',
  'tabaco',
  'tabique',
  'tabla',
  'tabu',
  'taco',
  'tacto',
  'tajo',
  'talar',
  'talco',
  'talento',
  'talla',
  'talon',
  'tamano',
  'tambor',
  'tango',
  'tanque',
  'tapa',
  'tapete',
  'tapia',
  'tapon',
  'taquilla',
  'tarde',
  'tarea',
  'tarifa',
  'tarjeta',
  'tarot',
  'tarro',
  'tarta',
  'tatuaje',
  'tauro',
  'taza',
  'tazon',
  'teatro',
  'techo',
  'tecla',
  'tecnica',
  'tejado',
  'tejer',
  'tejido',
  'tela',
  'telefono',
  'tema',
  'temor',
  'templo',
  'tenaz',
  'tender',
  'tener',
  'tenis',
  'tenso',
  'teoria',
  'terapia',
  'terco',
  'termino',
  'ternura',
  'terror',
  'tesis',
  'tesoro',
  'testigo',
  'tetera',
  'texto',
  'tez',
  'tibio',
  'tiburon',
  'tiempo',
  'tienda',
  'tierra',
  'tieso',
  'tigre',
  'tijera',
  'tilde',
  'timbre',
  'timido',
  'timo',
  'tinta',
  'tio',
  'tipico',
  'tipo',
  'tira',
  'tiron',
  'titan',
  'titere',
  'titulo',
  'tiza',
  'toalla',
  'tobillo',
  'tocar',
  'tocino',
  'todo',
  'toga',
  'toldo',
  'tomar',
  'tono',
  'tonto',
  'topar',
  'tope',
  'toque',
  'torax',
  'torero',
  'tormenta',
  'torneo',
  'toro',
  'torpedo',
  'torre',
  'torso',
  'tortuga',
  'tos',
  'tosco',
  'toser',
  'toxico',
  'trabajo',
  'tractor',
  'traer',
  'trafico',
  'trago',
  'traje',
  'tramo',
  'trance',
  'trato',
  'trauma',
  'trazar',
  'trebol',
  'tregua',
  'treinta',
  'tren',
  'trepar',
  'tres',
  'tribu',
  'trigo',
  'tripa',
  'triste',
  'triunfo',
  'trofeo',
  'trompa',
  'tronco',
  'tropa',
  'trote',
  'trozo',
  'truco',
  'trueno',
  'trufa',
  'tuberia',
  'tubo',
  'tuerto',
  'tumba',
  'tumor',
  'tunel',
  'tunica',
  'turbina',
  'turismo',
  'turno',
  'tutor',
  'ubicar',
  'ulcera',
  'umbral',
  'unidad',
  'unir',
  'universo',
  'uno',
  'untar',
  'una',
  'urbano',
  'urbe',
  'urgente',
  'urna',
  'usar',
  'usuario',
  'util',
  'utopia',
  'uva',
  'vaca',
  'vacio',
  'vacuna',
  'vagar',
  'vago',
  'vaina',
  'vajilla',
  'vale',
  'valido',
  'valle',
  'valor',
  'valvula',
  'vampiro',
  'vara',
  'variar',
  'varon',
  'vaso',
  'vecino',
  'vector',
  'vehiculo',
  'veinte',
  'vejez',
  'vela',
  'velero',
  'veloz',
  'vena',
  'vencer',
  'venda',
  'veneno',
  'vengar',
  'venir',
  'venta',
  'venus',
  'ver',
  'verano',
  'verbo',
  'verde',
  'vereda',
  'verja',
  'verso',
  'verter',
  'via',
  'viaje',
  'vibrar',
  'vicio',
  'victima',
  'vida',
  'video',
  'vidrio',
  'viejo',
  'viernes',
  'vigor',
  'vil',
  'villa',
  'vinagre',
  'vino',
  'vinedo',
  'violin',
  'viral',
  'virgo',
  'virtud',
  'visor',
  'vispera',
  'vista',
  'vitamina',
  'viudo',
  'vivaz',
  'vivero',
  'vivir',
  'vivo',
  'volcan',
  'volumen',
  'volver',
  'voraz',
  'votar',
  'voto',
  'voz',
  'vuelo',
  'vulgar',
  'yacer',
  'yate',
  'yegua',
  'yema',
  'yerno',
  'yeso',
  'yodo',
  'yoga',
  'yogur',
  'zafiro',
  'zanja',
  'zapato',
  'zarza',
  'zona',
  'zorro',
  'zumo',
  'zurdo'
];


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2015-2016, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * private.js - hd private keys for wmcc_core.
 */



const assert = __webpack_require__(0);
const util = __webpack_require__(1);
const digest = __webpack_require__(5);
const cleanse = __webpack_require__(70);
const random = __webpack_require__(29);
const secp256k1 = __webpack_require__(12);
const Network = __webpack_require__(6);
const StaticWriter = __webpack_require__(4);
const BufferReader = __webpack_require__(2);
const base58 = __webpack_require__(26);
const encoding = __webpack_require__(3);
const common = __webpack_require__(108);
const Mnemonic = __webpack_require__(210);
const HDPublicKey = __webpack_require__(213);

/*
 * Constants
 */

const SEED_SALT = Buffer.from('WMCoin seed', 'ascii');

/**
 * HDPrivateKey
 * @alias module:hd.PrivateKey
 * @constructor
 * @param {Object|Base58String} options
 * @param {Base58String?} options.xkey - Serialized base58 key.
 * @param {Number?} options.depth
 * @param {Number?} options.parentFingerPrint
 * @param {Number?} options.childIndex
 * @param {Buffer?} options.chainCode
 * @param {Buffer?} options.privateKey
 * @property {Network} network
 * @property {Number} depth
 * @property {Number} parentFingerPrint
 * @property {Number} childIndex
 * @property {Buffer} chainCode
 * @property {Buffer} privateKey
 */

function HDPrivateKey(options) {
  if (!(this instanceof HDPrivateKey))
    return new HDPrivateKey(options);

  this.network = Network.primary;
  this.depth = 0;
  this.parentFingerPrint = 0;
  this.childIndex = 0;
  this.chainCode = encoding.ZERO_HASH;
  this.privateKey = encoding.ZERO_HASH;

  this.publicKey = encoding.ZERO_KEY;
  this.fingerPrint = -1;

  this._xprivkey = null;

  this._hdPublicKey = null;

  if (options)
    this.fromOptions(options);
}

/**
 * Inject properties from options object.
 * @private
 * @param {Object} options
 */

HDPrivateKey.prototype.fromOptions = function fromOptions(options) {
  assert(options, 'No options for HD private key.');
  assert(util.isU8(options.depth));
  assert(util.isU32(options.parentFingerPrint));
  assert(util.isU32(options.childIndex));
  assert(Buffer.isBuffer(options.chainCode));
  assert(Buffer.isBuffer(options.privateKey));

  if (options.network)
    this.network = Network.get(options.network);

  this.depth = options.depth;
  this.parentFingerPrint = options.parentFingerPrint;
  this.childIndex = options.childIndex;
  this.chainCode = options.chainCode;
  this.privateKey = options.privateKey;
  this.publicKey = secp256k1.publicKeyCreate(options.privateKey, true);

  return this;
};

/**
 * Instantiate HD private key from options object.
 * @param {Object} options
 * @returns {HDPrivateKey}
 */

HDPrivateKey.fromOptions = function fromOptions(options) {
  return new HDPrivateKey().fromOptions(options);
};

/**
 * Get HD public key.
 * @returns {HDPublicKey}
 */

HDPrivateKey.prototype.toPublic = function toPublic() {
  let key = this._hdPublicKey;

  if (!key) {
    key = new HDPublicKey();
    key.network = this.network;
    key.depth = this.depth;
    key.parentFingerPrint = this.parentFingerPrint;
    key.childIndex = this.childIndex;
    key.chainCode = this.chainCode;
    key.publicKey = this.publicKey;
    this._hdPublicKey = key;
  }

  return key;
};

/**
 * Get cached base58 xprivkey.
 * @returns {Base58String}
 */

HDPrivateKey.prototype.xprivkey = function xprivkey() {
  if (!this._xprivkey)
    this._xprivkey = this.toBase58();
  return this._xprivkey;
};

/**
 * Get cached base58 xpubkey.
 * @returns {Base58String}
 */

HDPrivateKey.prototype.xpubkey = function xpubkey() {
  return this.toPublic().xpubkey();
};

/**
 * Destroy the key (zeroes chain code, privkey, and pubkey).
 * @param {Boolean} pub - Destroy hd public key as well.
 */

HDPrivateKey.prototype.destroy = function destroy(pub) {
  this.depth = 0;
  this.childIndex = 0;
  this.parentFingerPrint = 0;

  cleanse(this.chainCode);
  cleanse(this.privateKey);
  cleanse(this.publicKey);

  this.fingerPrint = -1;

  if (this._hdPublicKey) {
    if (pub)
      this._hdPublicKey.destroy();
    this._hdPublicKey = null;
  }

  this._xprivkey = null;
};

/**
 * Derive a child key.
 * @param {Number} index - Derivation index.
 * @param {Boolean?} hardened - Whether the derivation should be hardened.
 * @returns {HDPrivateKey}
 */

HDPrivateKey.prototype.derive = function derive(index, hardened) {
  assert(typeof index === 'number');

  if ((index >>> 0) !== index)
    throw new Error('Index out of range.');

  if (this.depth >= 0xff)
    throw new Error('Depth too high.');

  if (hardened) {
    index |= common.HARDENED;
    index >>>= 0;
  }

  const id = this.getID(index);
  const cache = common.cache.get(id);

  if (cache)
    return cache;

  const bw = StaticWriter.pool(37);

  if (index & common.HARDENED) {
    bw.writeU8(0);
    bw.writeBytes(this.privateKey);
    bw.writeU32BE(index);
  } else {
    bw.writeBytes(this.publicKey);
    bw.writeU32BE(index);
  }

  const data = bw.render();

  const hash = digest.hmac('sha512', data, this.chainCode);
  const left = hash.slice(0, 32);
  const right = hash.slice(32, 64);

  let key;
  try {
    key = secp256k1.privateKeyTweakAdd(this.privateKey, left);
  } catch (e) {
    return this.derive(index + 1);
  }

  if (this.fingerPrint === -1) {
    const fp = digest.hash160(this.publicKey);
    this.fingerPrint = fp.readUInt32BE(0, true);
  }

  const child = new HDPrivateKey();
  child.network = this.network;
  child.depth = this.depth + 1;
  child.parentFingerPrint = this.fingerPrint;
  child.childIndex = index;
  child.chainCode = right;
  child.privateKey = key;
  child.publicKey = secp256k1.publicKeyCreate(key, true);

  common.cache.set(id, child);

  return child;
};

/**
 * Unique HD key ID.
 * @private
 * @param {Number} index
 * @returns {String}
 */

HDPrivateKey.prototype.getID = function getID(index) {
  return this.network.keyPrefix.xprivkey58
    + this.publicKey.toString('hex')
    + index;
};

/**
 * Derive a BIP44 account key.
 * @param {Number} purpose
 * @param {Number} account
 * @returns {HDPrivateKey}
 * @throws Error if key is not a master key.
 */

HDPrivateKey.prototype.deriveAccount = function deriveAccount(purpose, account) {
  assert(util.isU32(purpose), 'Purpose must be a number.');
  assert(util.isU32(account), 'Account index must be a number.');
  assert(this.isMaster(), 'Cannot derive account index.');
  return this
    .derive(purpose, true)
    .derive(this.network.keyPrefix.coinType, true)
    .derive(account, true);
};

/**
 * Test whether the key is a master key.
 * @returns {Boolean}
 */

HDPrivateKey.prototype.isMaster = function isMaster() {
  return common.isMaster(this);
};

/**
 * Test whether the key is (most likely) a BIP44 account key.
 * @param {Number?} account
 * @returns {Boolean}
 */

HDPrivateKey.prototype.isAccount = function isAccount(account) {
  return common.isAccount(this, account);
};

/**
 * Test whether an object is in the form of a base58 xprivkey.
 * @param {String} data
 * @param {Network?} network
 * @returns {Boolean}
 */

HDPrivateKey.isBase58 = function isBase58(data, network) {
  if (typeof data !== 'string')
    return false;

  if (data.length < 4)
    return false;

  const prefix = data.substring(0, 4);

  try {
    Network.fromPrivate58(prefix, network);
    return true;
  } catch (e) {
    return false;
  }
};

/**
 * Test whether a buffer has a valid network prefix.
 * @param {Buffer} data
 * @param {Network?} network
 * @returns {Boolean}
 */

HDPrivateKey.isRaw = function isRaw(data, network) {
  if (!Buffer.isBuffer(data))
    return false;

  if (data.length < 4)
    return false;

  const version = data.readUInt32BE(0, true);

  try {
    Network.fromPrivate(version, network);
    return true;
  } catch (e) {
    return false;
  }
};

/**
 * Test whether a string is a valid path.
 * @param {String} path
 * @returns {Boolean}
 */

HDPrivateKey.isValidPath = function isValidPath(path) {
  try {
    common.parsePath(path, true);
    return true;
  } catch (e) {
    return false;
  }
};

/**
 * Derive a key from a derivation path.
 * @param {String} path
 * @returns {HDPrivateKey}
 * @throws Error if `path` is not a valid path.
 */

HDPrivateKey.prototype.derivePath = function derivePath(path) {
  const indexes = common.parsePath(path, true);

  let key = this;

  for (const index of indexes)
    key = key.derive(index);

  return key;
};

/**
 * Compare a key against an object.
 * @param {Object} obj
 * @returns {Boolean}
 */

HDPrivateKey.prototype.equals = function equals(obj) {
  assert(HDPrivateKey.isHDPrivateKey(obj));

  return this.network === obj.network
    && this.depth === obj.depth
    && this.parentFingerPrint === obj.parentFingerPrint
    && this.childIndex === obj.childIndex
    && this.chainCode.equals(obj.chainCode)
    && this.privateKey.equals(obj.privateKey);
};

/**
 * Compare a key against an object.
 * @param {Object} obj
 * @returns {Boolean}
 */

HDPrivateKey.prototype.compare = function compare(key) {
  assert(HDPrivateKey.isHDPrivateKey(key));

  let cmp = this.depth - key.depth;

  if (cmp !== 0)
    return cmp;

  cmp = this.parentFingerPrint - key.parentFingerPrint;

  if (cmp !== 0)
    return cmp;

  cmp = this.childIndex - key.childIndex;

  if (cmp !== 0)
    return cmp;

  cmp = this.chainCode.compare(key.chainCode);

  if (cmp !== 0)
    return cmp;

  cmp = this.privateKey.compare(key.privateKey);

  if (cmp !== 0)
    return cmp;

  return 0;
};

/**
 * Inject properties from seed.
 * @private
 * @param {Buffer} seed
 * @param {(Network|NetworkType)?} network
 */

HDPrivateKey.prototype.fromSeed = function fromSeed(seed, network) {
  assert(Buffer.isBuffer(seed));

  if (seed.length * 8 < common.MIN_ENTROPY
      || seed.length * 8 > common.MAX_ENTROPY) {
    throw new Error('Entropy not in range.');
  }

  const hash = digest.hmac('sha512', seed, SEED_SALT);
  const left = hash.slice(0, 32);
  const right = hash.slice(32, 64);

  // Only a 1 in 2^127 chance of happening.
  if (!secp256k1.privateKeyVerify(left))
    throw new Error('Master private key is invalid.');

  this.network = Network.get(network);
  this.depth = 0;
  this.parentFingerPrint = 0;
  this.childIndex = 0;
  this.chainCode = right;
  this.privateKey = left;
  this.publicKey = secp256k1.publicKeyCreate(left, true);

  return this;
};

/**
 * Instantiate an hd private key from a 512 bit seed.
 * @param {Buffer} seed
 * @param {(Network|NetworkType)?} network
 * @returns {HDPrivateKey}
 */

HDPrivateKey.fromSeed = function fromSeed(seed, network) {
  return new HDPrivateKey().fromSeed(seed, network);
};

/**
 * Inject properties from a mnemonic.
 * @private
 * @param {Mnemonic} mnemonic
 * @param {(Network|NetworkType)?} network
 */

HDPrivateKey.prototype.fromMnemonic = function fromMnemonic(mnemonic, network) {
  assert(mnemonic instanceof Mnemonic);
  return this.fromSeed(mnemonic.toSeed(), network);
};

/**
 * Instantiate an hd private key from a mnemonic.
 * @param {Mnemonic} mnemonic
 * @param {(Network|NetworkType)?} network
 * @returns {HDPrivateKey}
 */

HDPrivateKey.fromMnemonic = function fromMnemonic(mnemonic, network) {
  return new HDPrivateKey().fromMnemonic(mnemonic, network);
};

/**
 * Inject properties from a mnemonic.
 * @private
 * @param {String} mnemonic
 * @param {(Network|NetworkType)?} network
 */

HDPrivateKey.prototype.fromPhrase = function fromPhrase(phrase, network) {
  const mnemonic = Mnemonic.fromPhrase(phrase);
  this.fromMnemonic(mnemonic, network);
  return this;
};

/**
 * Instantiate an hd private key from a phrase.
 * @param {String} phrase
 * @param {(Network|NetworkType)?} network
 * @returns {HDPrivateKey}
 */

HDPrivateKey.fromPhrase = function fromPhrase(phrase, network) {
  return new HDPrivateKey().fromPhrase(phrase, network);
};

/**
 * Inject properties from privateKey and entropy.
 * @private
 * @param {Buffer} key
 * @param {Buffer} entropy
 * @param {(Network|NetworkType)?} network
 */

HDPrivateKey.prototype.fromKey = function fromKey(key, entropy, network) {
  assert(Buffer.isBuffer(key) && key.length === 32);
  assert(Buffer.isBuffer(entropy) && entropy.length === 32);
  this.network = Network.get(network);
  this.depth = 0;
  this.parentFingerPrint = 0;
  this.childIndex = 0;
  this.chainCode = entropy;
  this.privateKey = key;
  this.publicKey = secp256k1.publicKeyCreate(key, true);
  return this;
};

/**
 * Create an hd private key from a key and entropy bytes.
 * @param {Buffer} key
 * @param {Buffer} entropy
 * @param {(Network|NetworkType)?} network
 * @returns {HDPrivateKey}
 */

HDPrivateKey.fromKey = function fromKey(key, entropy, network) {
  return new HDPrivateKey().fromKey(key, entropy, network);
};

/**
 * Generate an hd private key.
 * @param {(Network|NetworkType)?} network
 * @returns {HDPrivateKey}
 */

HDPrivateKey.generate = function generate(network) {
  const key = secp256k1.generatePrivateKey();
  const entropy = random.randomBytes(32);
  return HDPrivateKey.fromKey(key, entropy, network);
};

/**
 * Inject properties from base58 key.
 * @private
 * @param {Base58String} xkey
 * @param {Network?} network
 */

HDPrivateKey.prototype.fromBase58 = function fromBase58(xkey, network) {
  assert(typeof xkey === 'string');
  this._xprivkey = xkey;
  return this.fromRaw(base58.decode(xkey), network);
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {BufferReader} br
 * @param {(Network|NetworkType)?} network
 */

HDPrivateKey.prototype.fromReader = function fromReader(br, network) {
  const version = br.readU32BE();

  this.network = Network.fromPrivate(version, network);
  this.depth = br.readU8();
  this.parentFingerPrint = br.readU32BE();
  this.childIndex = br.readU32BE();
  this.chainCode = br.readBytes(32);
  assert(br.readU8() === 0);
  this.privateKey = br.readBytes(32);
  this.publicKey = secp256k1.publicKeyCreate(this.privateKey, true);

  br.verifyChecksum();

  return this;
};

/**
 * Inject properties from serialized data.
 * @private
 * @param {Buffer} data
 * @param {(Network|NetworkType)?} network
 */

HDPrivateKey.prototype.fromRaw = function fromRaw(data, network) {
  return this.fromReader(new BufferReader(data), network);
};

/**
 * Serialize key to a base58 string.
 * @param {(Network|NetworkType)?} network
 * @returns {Base58String}
 */

HDPrivateKey.prototype.toBase58 = function toBase58(network) {
  return base58.encode(this.toRaw(network));
};

/**
 * Calculate serialization size.
 * @returns {Number}
 */

HDPrivateKey.prototype.getSize = function getSize() {
  return 82;
};

/**
 * Write the key to a buffer writer.
 * @param {BufferWriter} bw
 * @param {(Network|NetworkType)?} network
 */

HDPrivateKey.prototype.toWriter = function toWriter(bw, network) {
  if (!network)
    network = this.network;

  network = Network.get(network);

  bw.writeU32BE(network.keyPrefix.xprivkey);
  bw.writeU8(this.depth);
  bw.writeU32BE(this.parentFingerPrint);
  bw.writeU32BE(this.childIndex);
  bw.writeBytes(this.chainCode);
  bw.writeU8(0);
  bw.writeBytes(this.privateKey);
  bw.writeChecksum();

  return bw;
};

/**
 * Serialize the key.
 * @param {(Network|NetworkType)?} network
 * @returns {Buffer}
 */

HDPrivateKey.prototype.toRaw = function toRaw(network) {
  return this.toWriter(new StaticWriter(82), network).render();
};

/**
 * Instantiate an HD private key from a base58 string.
 * @param {Base58String} xkey
 * @param {Network?} network
 * @returns {HDPrivateKey}
 */

HDPrivateKey.fromBase58 = function fromBase58(xkey, network) {
  return new HDPrivateKey().fromBase58(xkey, network);
};

/**
 * Instantiate key from buffer reader.
 * @param {BufferReader} br
 * @param {(Network|NetworkType)?} network
 * @returns {HDPrivateKey}
 */

HDPrivateKey.fromReader = function fromReader(br, network) {
  return new HDPrivateKey().fromReader(br, network);
};

/**
 * Instantiate key from serialized data.
 * @param {Buffer} data
 * @param {(Network|NetworkType)?} network
 * @returns {HDPrivateKey}
 */

HDPrivateKey.fromRaw = function fromRaw(data, network) {
  return new HDPrivateKey().fromRaw(data, network);
};

/**
 * Convert key to a more json-friendly object.
 * @returns {Object}
 */

HDPrivateKey.prototype.toJSON = function toJSON() {
  return {
    xprivkey: this.xprivkey()
  };
};

/**
 * Inject properties from json object.
 * @private
 * @param {Object} json
 * @param {Network?} network
 */

HDPrivateKey.prototype.fromJSON = function fromJSON(json, network) {
  assert(json.xprivkey, 'Could not handle key JSON.');

  this.fromBase58(json.xprivkey, network);

  return this;
};

/**
 * Instantiate an HDPrivateKey from a jsonified key object.
 * @param {Object} json - The jsonified key object.
 * @param {Network?} network
 * @returns {HDPrivateKey}
 */

HDPrivateKey.fromJSON = function fromJSON(json, network) {
  return new HDPrivateKey().fromJSON(json, network);
};

/**
 * Test whether an object is an HDPrivateKey.
 * @param {Object} obj
 * @returns {Boolean}
 */

HDPrivateKey.isHDPrivateKey = function isHDPrivateKey(obj) {
  return obj instanceof HDPrivateKey;
};

/*
 * Expose
 */

module.exports = HDPrivateKey;


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * http/index.js - http for wmcc_core.
 */



/**
 * @module http
 */

exports.Base = __webpack_require__(169);
exports.Client = __webpack_require__(214);
exports.request = __webpack_require__(92);
exports.RPCBase = __webpack_require__(178);
exports.RPCClient = __webpack_require__(215);
exports.RPC = __webpack_require__(115);
exports.Server = __webpack_require__(180);
exports.Wallet = __webpack_require__(308);


/***/ }),
/* 278 */
/***/ (function(module, exports) {

module.exports = require("querystring");

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var parseuri = __webpack_require__(218);
var debug = __webpack_require__(110)('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url (uri, loc) {
  var obj = uri;

  // default to window.location
  loc = loc || (typeof location !== 'undefined' && location);
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' === typeof uri) {
    if ('/' === uri.charAt(0)) {
      if ('/' === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' !== typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));

  return obj;
}


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(219);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),
/* 281 */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var tty = __webpack_require__(171);
var util = __webpack_require__(38);

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(219);
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [ 6, 2, 3, 4, 5, 1 ];

try {
  var supportsColor = __webpack_require__(172);
  if (supportsColor && supportsColor.level >= 2) {
    exports.colors = [
      20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68,
      69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134,
      135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171,
      172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204,
      205, 206, 207, 208, 209, 214, 215, 220, 221
    ];
  }
} catch (err) {
  // swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(process.stderr.fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var colorCode = '\u001b[3' + (c < 8 ? c : '8;5;' + c);
    var prefix = '  ' + colorCode + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push(colorCode + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = getDate() + name + ' ' + args[0];
  }
}

function getDate() {
  if (exports.inspectOpts.hideDate) {
    return '';
  } else {
    return new Date().toISOString() + ' ';
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log() {
  return process.stderr.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer') {
  module.exports = __webpack_require__(284);
} else {
  module.exports = __webpack_require__(286);
}


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(220);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),
/* 285 */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var tty = __webpack_require__(171);
var util = __webpack_require__(38);

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(220);
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [ 6, 2, 3, 4, 5, 1 ];

try {
  var supportsColor = __webpack_require__(172);
  if (supportsColor && supportsColor.level >= 2) {
    exports.colors = [
      20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68,
      69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134,
      135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171,
      172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204,
      205, 206, 207, 208, 209, 214, 215, 220, 221
    ];
  }
} catch (err) {
  // swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(process.stderr.fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var colorCode = '\u001b[3' + (c < 8 ? c : '8;5;' + c);
    var prefix = '  ' + colorCode + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push(colorCode + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = getDate() + name + ' ' + args[0];
  }
}

function getDate() {
  if (exports.inspectOpts.hideDate) {
    return '';
  } else {
    return new Date().toISOString() + ' ';
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log() {
  return process.stderr.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = __webpack_require__(221);
var isBuf = __webpack_require__(222);
var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]');
var withNativeFile = typeof File === 'function' || (typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuf(data)) {
    var placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === 'object' && !(data instanceof Date)) {
    var newData = {};
    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }
    return newData;
  }
  return data;
}

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful
  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {


module.exports = __webpack_require__(289);

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = __webpack_require__(74);


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var transports = __webpack_require__(224);
var Emitter = __webpack_require__(73);
var debug = __webpack_require__(113)('engine.io-client:socket');
var index = __webpack_require__(235);
var parser = __webpack_require__(74);
var parseuri = __webpack_require__(218);
var parseqs = __webpack_require__(111);

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket (uri, opts) {
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure
    : (typeof location !== 'undefined' && 'https:' === location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (typeof location !== 'undefined' ? location.hostname : 'localhost');
  this.port = opts.port || (typeof location !== 'undefined' && location.port
      ? location.port
      : (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.transportOptions = opts.transportOptions || {};
  this.readyState = '';
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode;

  // detect ReactNative environment
  this.isReactNative = (typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative');

  // other options for Node.js or ReactNative client
  if (typeof self === 'undefined' || this.isReactNative) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }

    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  }

  // set on handshake
  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null;

  // set on heartbeat
  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = __webpack_require__(175);
Socket.transports = __webpack_require__(224);
Socket.parser = __webpack_require__(74);

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // per-transport options
  var options = this.transportOptions[name] || {};

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    query: query,
    socket: this,
    agent: options.agent || this.agent,
    hostname: options.hostname || this.hostname,
    port: options.port || this.port,
    secure: options.secure || this.secure,
    path: options.path || this.path,
    forceJSONP: options.forceJSONP || this.forceJSONP,
    jsonp: options.jsonp || this.jsonp,
    forceBase64: options.forceBase64 || this.forceBase64,
    enablesXDR: options.enablesXDR || this.enablesXDR,
    timestampRequests: options.timestampRequests || this.timestampRequests,
    timestampParam: options.timestampParam || this.timestampParam,
    policyPort: options.policyPort || this.policyPort,
    pfx: options.pfx || this.pfx,
    key: options.key || this.key,
    passphrase: options.passphrase || this.passphrase,
    cert: options.cert || this.cert,
    ca: options.ca || this.ca,
    ciphers: options.ciphers || this.ciphers,
    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
    extraHeaders: options.extraHeaders || this.extraHeaders,
    forceNode: options.forceNode || this.forceNode,
    localAddress: options.localAddress || this.localAddress,
    requestTimeout: options.requestTimeout || this.requestTimeout,
    protocols: options.protocols || void (0),
    isReactNative: this.isReactNative
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function () {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function (transport) {
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function () {
    self.onDrain();
  })
  .on('packet', function (packet) {
    self.onPacket(packet);
  })
  .on('error', function (e) {
    self.onError(e);
  })
  .on('close', function () {
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 });
  var failed = false;
  var self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen () {
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' === msg.type && 'probe' === msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' === transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' === self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport () {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  // Handle any error that happens while probing
  function onerror (err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose () {
    onerror('transport closed');
  }

  // When the socket is closed while we're probing
  function onclose () {
    onerror('socket closed');
  }

  // When the socket is upgraded while we're probing
  function onupgrade (to) {
    if (transport && to.name !== transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  // Remove all listeners on the transport and on self
  function cleanup () {
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();
};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' === this.readyState || 'open' === this.readyState ||
      'closing' === this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(JSON.parse(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if ('closed' === this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' === self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function () {
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function () {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' !== this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if ('function' === typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' === typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' === this.readyState || 'closed' === this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function () {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close () {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose () {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade () {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i < j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

/* global attachEvent */

/**
 * Module requirements.
 */

var XMLHttpRequest = __webpack_require__(174);
var Polling = __webpack_require__(226);
var Emitter = __webpack_require__(73);
var inherit = __webpack_require__(112);
var debug = __webpack_require__(113)('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty () {}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR (opts) {
  Polling.call(this, opts);
  this.requestTimeout = opts.requestTimeout;
  this.extraHeaders = opts.extraHeaders;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = (typeof location !== 'undefined' && opts.hostname !== location.hostname) ||
      port !== opts.port;
    this.xs = opts.secure !== isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function (opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function (data, fn) {
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function (err) {
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function () {
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function (data) {
    self.onData(data);
  });
  req.on('error', function (err) {
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request (opts) {
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.requestTimeout = opts.requestTimeout;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function () {
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}

    if ('POST' === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    try {
      xhr.setRequestHeader('Accept', '*/*');
    } catch (e) {}

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }

    if (this.hasXDR()) {
      xhr.onload = function () {
        self.onLoad();
      };
      xhr.onerror = function () {
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 2) {
          try {
            var contentType = xhr.getResponseHeader('Content-Type');
            if (self.supportsBinary && contentType === 'application/octet-stream') {
              xhr.responseType = 'arraybuffer';
            }
          } catch (e) {}
        }
        if (4 !== xhr.readyState) return;
        if (200 === xhr.status || 1223 === xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function () {
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function () {
      self.onError(e);
    }, 0);
    return;
  }

  if (typeof document !== 'undefined') {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function () {
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function (data) {
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function (err) {
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function (fromError) {
  if ('undefined' === typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {}
  }

  if (typeof document !== 'undefined') {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function () {
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type');
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response || this.xhr.responseText;
    } else {
      data = this.xhr.responseText;
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function () {
  return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function () {
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

Request.requestsCount = 0;
Request.requests = {};

if (typeof document !== 'undefined') {
  if (typeof attachEvent === 'function') {
    attachEvent('onunload', unloadHandler);
  } else if (typeof addEventListener === 'function') {
    var terminationEvent = 'onpagehide' in self ? 'pagehide' : 'unload';
    addEventListener(terminationEvent, unloadHandler, false);
  }
}

function unloadHandler () {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}


/***/ }),
/* 291 */
/***/ (function(module, exports) {

/*! https://mths.be/utf8js v2.1.2 by @mathias */

var stringFromCharCode = String.fromCharCode;

// Taken from https://mths.be/punycode
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	var value;
	var extra;
	while (counter < length) {
		value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// high surrogate, and there is a next character
			extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) { // low surrogate
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// unmatched surrogate; only append this code unit, in case the next
				// code unit is the high surrogate of a surrogate pair
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

// Taken from https://mths.be/punycode
function ucs2encode(array) {
	var length = array.length;
	var index = -1;
	var value;
	var output = '';
	while (++index < length) {
		value = array[index];
		if (value > 0xFFFF) {
			value -= 0x10000;
			output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
			value = 0xDC00 | value & 0x3FF;
		}
		output += stringFromCharCode(value);
	}
	return output;
}

function checkScalarValue(codePoint, strict) {
	if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
		if (strict) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
		return false;
	}
	return true;
}
/*--------------------------------------------------------------------------*/

function createByte(codePoint, shift) {
	return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
}

function encodeCodePoint(codePoint, strict) {
	if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
		return stringFromCharCode(codePoint);
	}
	var symbol = '';
	if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
		symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
	}
	else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
		if (!checkScalarValue(codePoint, strict)) {
			codePoint = 0xFFFD;
		}
		symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
		symbol += createByte(codePoint, 6);
	}
	else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
		symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
		symbol += createByte(codePoint, 12);
		symbol += createByte(codePoint, 6);
	}
	symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
	return symbol;
}

function utf8encode(string, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	var codePoints = ucs2decode(string);
	var length = codePoints.length;
	var index = -1;
	var codePoint;
	var byteString = '';
	while (++index < length) {
		codePoint = codePoints[index];
		byteString += encodeCodePoint(codePoint, strict);
	}
	return byteString;
}

/*--------------------------------------------------------------------------*/

function readContinuationByte() {
	if (byteIndex >= byteCount) {
		throw Error('Invalid byte index');
	}

	var continuationByte = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	if ((continuationByte & 0xC0) == 0x80) {
		return continuationByte & 0x3F;
	}

	// If we end up here, its not a continuation byte
	throw Error('Invalid continuation byte');
}

function decodeSymbol(strict) {
	var byte1;
	var byte2;
	var byte3;
	var byte4;
	var codePoint;

	if (byteIndex > byteCount) {
		throw Error('Invalid byte index');
	}

	if (byteIndex == byteCount) {
		return false;
	}

	// Read first byte
	byte1 = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	// 1-byte sequence (no continuation bytes)
	if ((byte1 & 0x80) == 0) {
		return byte1;
	}

	// 2-byte sequence
	if ((byte1 & 0xE0) == 0xC0) {
		byte2 = readContinuationByte();
		codePoint = ((byte1 & 0x1F) << 6) | byte2;
		if (codePoint >= 0x80) {
			return codePoint;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 3-byte sequence (may include unpaired surrogates)
	if ((byte1 & 0xF0) == 0xE0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
		if (codePoint >= 0x0800) {
			return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 4-byte sequence
	if ((byte1 & 0xF8) == 0xF0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		byte4 = readContinuationByte();
		codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
			(byte3 << 0x06) | byte4;
		if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
			return codePoint;
		}
	}

	throw Error('Invalid UTF-8 detected');
}

var byteArray;
var byteCount;
var byteIndex;
function utf8decode(byteString, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	byteArray = ucs2decode(byteString);
	byteCount = byteArray.length;
	byteIndex = 0;
	var codePoints = [];
	var tmp;
	while ((tmp = decodeSymbol(strict)) !== false) {
		codePoints.push(tmp);
	}
	return ucs2encode(codePoints);
}

module.exports = {
	version: '2.1.2',
	encode: utf8encode,
	decode: utf8decode
};


/***/ }),
/* 292 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 293 */
/***/ (function(module, exports) {

module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}


/***/ }),
/* 294 */
/***/ (function(module, exports) {


/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(229);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),
/* 296 */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var tty = __webpack_require__(171);
var util = __webpack_require__(38);

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(229);
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [ 6, 2, 3, 4, 5, 1 ];

try {
  var supportsColor = __webpack_require__(172);
  if (supportsColor && supportsColor.level >= 2) {
    exports.colors = [
      20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68,
      69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134,
      135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171,
      172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204,
      205, 206, 207, 208, 209, 214, 215, 220, 221
    ];
  }
} catch (err) {
  // swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(process.stderr.fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var colorCode = '\u001b[3' + (c < 8 ? c : '8;5;' + c);
    var prefix = '  ' + colorCode + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push(colorCode + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = getDate() + name + ' ' + args[0];
  }
}

function getDate() {
  if (exports.inspectOpts.hideDate) {
    return '';
  } else {
    return new Date().toISOString() + ' ';
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log() {
  return process.stderr.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module requirements.
 */

var Polling = __webpack_require__(226);
var inherit = __webpack_require__(112);

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Noop.
 */

function empty () { }

/**
 * Until https://github.com/tc39/proposal-global is shipped.
 */
function glob () {
  return typeof self !== 'undefined' ? self
      : typeof window !== 'undefined' ? window
      : typeof global !== 'undefined' ? global : {};
}

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    var global = glob();
    callbacks = global.___eio = (global.___eio || []);
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (typeof addEventListener === 'function') {
    addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function (e) {
    self.onError('jsonp poll error', e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch (e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function () {
      if (self.iframe.readyState === 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var Transport = __webpack_require__(175);
var parser = __webpack_require__(74);
var parseqs = __webpack_require__(111);
var inherit = __webpack_require__(112);
var yeast = __webpack_require__(228);
var debug = __webpack_require__(113)('engine.io-client:websocket');

var BrowserWebSocket, NodeWebSocket;

if (typeof WebSocket !== 'undefined') {
  BrowserWebSocket = WebSocket;
} else if (typeof self !== 'undefined') {
  BrowserWebSocket = self.WebSocket || self.MozWebSocket;
} else {
  try {
    NodeWebSocket = __webpack_require__(300);
  } catch (e) { }
}

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocketImpl = BrowserWebSocket || NodeWebSocket;

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  this.protocols = opts.protocols;
  if (!this.usingBrowserWebSocket) {
    WebSocketImpl = NodeWebSocket;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function () {
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var uri = this.uri();
  var protocols = this.protocols;
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }
  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }

  try {
    this.ws =
      this.usingBrowserWebSocket && !this.isReactNative
        ? protocols
          ? new WebSocketImpl(uri, protocols)
          : new WebSocketImpl(uri)
        : new WebSocketImpl(uri, protocols, opts);
  } catch (err) {
    return this.emit('error', err);
  }

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'nodebuffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function () {
  var self = this;

  this.ws.onopen = function () {
    self.onOpen();
  };
  this.ws.onclose = function () {
    self.onClose();
  };
  this.ws.onmessage = function (ev) {
    self.onData(ev.data);
  };
  this.ws.onerror = function (e) {
    self.onError('websocket error', e);
  };
};

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function (packets) {
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function (packet) {
      parser.encodePacket(packet, self.supportsBinary, function (data) {
        if (!self.usingBrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error
        try {
          if (self.usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e) {
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done () {
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function () {
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function () {
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function () {
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
    ('ws' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function () {
  return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);
};


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const WebSocket = __webpack_require__(230);

WebSocket.Server = __webpack_require__(305);
WebSocket.Receiver = __webpack_require__(232);
WebSocket.Sender = __webpack_require__(234);

module.exports = WebSocket;


/***/ }),
/* 301 */
/***/ (function(module, exports) {

module.exports = require("tls");

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function Queue(options) {
  if (!(this instanceof Queue)) {
    return new Queue(options);
  }

  options = options || {};
  this.concurrency = options.concurrency || Infinity;
  this.pending = 0;
  this.jobs = [];
  this.cbs = [];
  this._done = done.bind(this);
}

var arrayAddMethods = [
  'push',
  'unshift',
  'splice'
];

arrayAddMethods.forEach(function(method) {
  Queue.prototype[method] = function() {
    var methodResult = Array.prototype[method].apply(this.jobs, arguments);
    this._run();
    return methodResult;
  };
});

Object.defineProperty(Queue.prototype, 'length', {
  get: function() {
    return this.pending + this.jobs.length;
  }
});

Queue.prototype._run = function() {
  if (this.pending === this.concurrency) {
    return;
  }
  if (this.jobs.length) {
    var job = this.jobs.shift();
    this.pending++;
    job(this._done);
    this._run();
  }

  if (this.pending === 0) {
    while (this.cbs.length !== 0) {
      var cb = this.cbs.pop();
      process.nextTick(cb);
    }
  }
};

Queue.prototype.onDone = function(cb) {
  if (typeof cb === 'function') {
    this.cbs.push(cb);
    this._run();
  }
};

function done() {
  this.pending--;
  this._run();
}

module.exports = Queue;


/***/ }),
/* 303 */
/***/ (function(module, exports) {

module.exports = require("zlib");

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Class representing an event.
 *
 * @private
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @param {Object} target A reference to the target to which the event was dispatched
   */
  constructor(type, target) {
    this.target = target;
    this.type = type;
  }
}

/**
 * Class representing a message event.
 *
 * @extends Event
 * @private
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(data, target) {
    super('message', target);

    this.data = data;
  }
}

/**
 * Class representing a close event.
 *
 * @extends Event
 * @private
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {Number} code The status code explaining why the connection is being closed
   * @param {String} reason A human-readable string explaining why the connection is closing
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(code, reason, target) {
    super('close', target);

    this.wasClean = target._closeFrameReceived && target._closeFrameSent;
    this.reason = reason;
    this.code = code;
  }
}

/**
 * Class representing an open event.
 *
 * @extends Event
 * @private
 */
class OpenEvent extends Event {
  /**
   * Create a new `OpenEvent`.
   *
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(target) {
    super('open', target);
  }
}

/**
 * Class representing an error event.
 *
 * @extends Event
 * @private
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {Object} error The error that generated this event
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(error, target) {
    super('error', target);

    this.message = error.message;
    this.error = error;
  }
}

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} method A string representing the event type to listen for
   * @param {Function} listener The listener to add
   * @public
   */
  addEventListener(method, listener) {
    if (typeof listener !== 'function') return;

    function onMessage(data) {
      listener.call(this, new MessageEvent(data, this));
    }

    function onClose(code, message) {
      listener.call(this, new CloseEvent(code, message, this));
    }

    function onError(error) {
      listener.call(this, new ErrorEvent(error, this));
    }

    function onOpen() {
      listener.call(this, new OpenEvent(this));
    }

    if (method === 'message') {
      onMessage._listener = listener;
      this.on(method, onMessage);
    } else if (method === 'close') {
      onClose._listener = listener;
      this.on(method, onClose);
    } else if (method === 'error') {
      onError._listener = listener;
      this.on(method, onError);
    } else if (method === 'open') {
      onOpen._listener = listener;
      this.on(method, onOpen);
    } else {
      this.on(method, listener);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} method A string representing the event type to remove
   * @param {Function} listener The listener to remove
   * @public
   */
  removeEventListener(method, listener) {
    const listeners = this.listeners(method);

    for (var i = 0; i < listeners.length; i++) {
      if (listeners[i] === listener || listeners[i]._listener === listener) {
        this.removeListener(method, listeners[i]);
      }
    }
  }
};

module.exports = EventTarget;


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const EventEmitter = __webpack_require__(10);
const crypto = __webpack_require__(24);
const http = __webpack_require__(72);

const PerMessageDeflate = __webpack_require__(114);
const extension = __webpack_require__(231);
const constants = __webpack_require__(93);
const WebSocket = __webpack_require__(230);

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {String} options.host The hostname where to bind the server
   * @param {Number} options.port The port where to bind the server
   * @param {http.Server} options.server A pre-created HTTP/S server to use
   * @param {Function} options.verifyClient An hook to reject connections
   * @param {Function} options.handleProtocols An hook to handle protocols
   * @param {String} options.path Accept only connections matching this path
   * @param {Boolean} options.noServer Enable no server mode
   * @param {Boolean} options.clientTracking Specifies whether or not to track clients
   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate
   * @param {Number} options.maxPayload The maximum allowed message size
   * @param {Function} callback A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = Object.assign(
      {
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null, // use default (511 as implemented in net.js)
        server: null,
        host: null,
        path: null,
        port: null
      },
      options
    );

    if (options.port == null && !options.server && !options.noServer) {
      throw new TypeError(
        'One of the "port", "server", or "noServer" options must be specified'
      );
    }

    if (options.port != null) {
      this._server = http.createServer((req, res) => {
        const body = http.STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, (ws) => {
            this.emit('connection', ws, req);
          });
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) this.clients = new Set();
    this.options = options;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Close the server.
   *
   * @param {Function} cb Callback
   * @public
   */
  close(cb) {
    if (cb) this.once('close', cb);

    //
    // Terminate all associated clients.
    //
    if (this.clients) {
      for (const client of this.clients) client.terminate();
    }

    const server = this._server;

    if (server) {
      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // Close the http server if it was internally created.
      //
      if (this.options.port != null) {
        server.close(() => this.emit('close'));
        return;
      }
    }

    process.nextTick(emitClose, this);
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const version = +req.headers['sec-websocket-version'];
    const extensions = {};

    if (
      req.method !== 'GET' ||
      req.headers.upgrade.toLowerCase() !== 'websocket' ||
      !req.headers['sec-websocket-key'] ||
      (version !== 8 && version !== 13) ||
      !this.shouldHandle(req)
    ) {
      return abortHandshake(socket, 400);
    }

    if (this.options.perMessageDeflate) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = extension.parse(req.headers['sec-websocket-extensions']);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        return abortHandshake(socket, 400);
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.connection.authorized || req.connection.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(extensions, req, socket, head, cb);
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(extensions, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @private
   */
  completeUpgrade(extensions, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    const key = crypto
      .createHash('sha1')
      .update(req.headers['sec-websocket-key'] + constants.GUID, 'binary')
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${key}`
    ];

    const ws = new WebSocket(null);
    var protocol = req.headers['sec-websocket-protocol'];

    if (protocol) {
      protocol = protocol.trim().split(/ *, */);

      //
      // Optionally call external protocol selection handler.
      //
      if (this.options.handleProtocols) {
        protocol = this.options.handleProtocols(protocol, req);
      } else {
        protocol = protocol[0];
      }

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws.protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = extension.format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, this.options.maxPayload);

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => this.clients.delete(ws));
    }

    cb(ws);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server.emit('close');
}

/**
 * Handle premature socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {net.Socket} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  if (socket.writable) {
    message = message || http.STATUS_CODES[code];
    headers = Object.assign(
      {
        Connection: 'close',
        'Content-type': 'text/html',
        'Content-Length': Buffer.byteLength(message)
      },
      headers
    );

    socket.write(
      `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
        Object.keys(headers)
          .map((h) => `${h}: ${headers[h]}`)
          .join('\r\n') +
        '\r\n\r\n' +
        message
    );
  }

  socket.removeListener('error', socketOnError);
  socket.destroy();
}


/***/ }),
/* 306 */
/***/ (function(module, exports) {

module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}


/***/ }),
/* 307 */
/***/ (function(module, exports) {


/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};



/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2015, Fedor Indutny
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * wallet.js - http wallet for wmcc_core.
 */



const assert = __webpack_require__(0);
const EventEmitter = __webpack_require__(10);
const Network = __webpack_require__(6);
const Client = __webpack_require__(214);

/**
 * HTTPWallet
 * @alias module:http.Wallet
 * @constructor
 * @param {String} uri
 */

function HTTPWallet(options) {
  if (!(this instanceof HTTPWallet))
    return new HTTPWallet(options);

  EventEmitter.call(this);

  if (!options)
    options = {};

  if (typeof options === 'string')
    options = { uri: options };

  this.options = options;
  this.network = Network.get(options.network);

  this.client = new Client(options);
  this.uri = options.uri;
  this.id = null;
  this.token = null;

  if (options.id)
    this.id = options.id;

  if (options.token) {
    this.token = options.token;
    if (Buffer.isBuffer(this.token))
      this.token = this.token.toString('hex');
    this.client.token = this.token;
  }

  this._init();
}

Object.setPrototypeOf(HTTPWallet.prototype, EventEmitter.prototype);

/**
 * Initialize the wallet.
 * @private
 */

HTTPWallet.prototype._init = function _init() {
  this.client.on('tx', (details) => {
    this.emit('tx', details);
  });

  this.client.on('confirmed', (details) => {
    this.emit('confirmed', details);
  });

  this.client.on('unconfirmed', (tx, details) => {
    this.emit('unconfirmed', details);
  });

  this.client.on('conflict', (tx, details) => {
    this.emit('conflict', details);
  });

  this.client.on('balance', (balance) => {
    this.emit('balance', balance);
  });

  this.client.on('address', (receive) => {
    this.emit('address', receive);
  });

  this.client.on('error', (err) => {
    this.emit('error', err);
  });
};

/**
 * Open the client and get a wallet.
 * @alias HTTPWallet#open
 * @returns {Promise}
 */

HTTPWallet.prototype.open = async function open(options) {
  if (options) {
    if (options.id)
      this.id = options.id;

    if (options.token) {
      this.token = options.token;
      if (Buffer.isBuffer(this.token))
        this.token = this.token.toString('hex');
      this.client.token = this.token;
    }
  }

  assert(this.id, 'No ID provided.');

  await this.client.open();
  await this.client.sendWalletAuth();
  await this.client.join(this.id, this.token);
};

/**
 * Open the client and create a wallet.
 * @alias HTTPWallet#open
 * @returns {Promise}
 */

HTTPWallet.prototype.create = async function create(options) {
  await this.client.open();
  await this.client.sendWalletAuth();

  const wallet = await this.client.createWallet(options);

  this.id = wallet.id;
  this.token = wallet.token;
  this.client.token = this.token;

  await this.client.join(this.id, this.token);

  return wallet;
};

/**
 * Close the client, wait for the socket to close.
 * @alias HTTPWallet#close
 * @returns {Promise}
 */

HTTPWallet.prototype.close = function close() {
  return this.client.close();
};

/**
 * Wait for websocket disconnection.
 * @private
 * @returns {Promise}
 */

HTTPWallet.prototype.onDisconnect = function onDisconnect() {
  return this.client.onDisconnect();
};

/**
 * @see Wallet#getHistory
 */

HTTPWallet.prototype.getHistory = function getHistory(account) {
  return this.client.getHistory(this.id, account);
};

/**
 * @see Wallet#getCoins
 */

HTTPWallet.prototype.getCoins = function getCoins(account) {
  return this.client.getCoins(this.id, account);
};

/**
 * @see Wallet#getPending
 */

HTTPWallet.prototype.getPending = function getPending(account) {
  return this.client.getPending(this.id, account);
};

/**
 * @see Wallet#getBalance
 */

HTTPWallet.prototype.getBalance = function getBalance(account) {
  return this.client.getBalance(this.id, account);
};

/**
 * @see Wallet#getLast
 */

HTTPWallet.prototype.getLast = function getLast(account, limit) {
  return this.client.getLast(this.id, account, limit);
};

/**
 * @see Wallet#getRange
 */

HTTPWallet.prototype.getRange = function getRange(account, options) {
  return this.client.getRange(this.id, account, options);
};

/**
 * @see Wallet#getTX
 */

HTTPWallet.prototype.getTX = function getTX(hash) {
  return this.client.getWalletTX(this.id, hash);
};

/**
 * @see Wallet#getBlocks
 */

HTTPWallet.prototype.getBlocks = function getBlocks() {
  return this.client.getWalletBlocks(this.id);
};

/**
 * @see Wallet#getBlock
 */

HTTPWallet.prototype.getBlock = function getBlock(height) {
  return this.client.getWalletBlock(this.id, height);
};

/**
 * @see Wallet#getCoin
 */

HTTPWallet.prototype.getCoin = function getCoin(account, hash, index) {
  return this.client.getWalletCoin(this.id, account, hash, index);
};

/**
 * @see Wallet#zap
 */

HTTPWallet.prototype.zap = function zap(account, age) {
  return this.client.zapWallet(this.id, account, age);
};

/**
 * @see Wallet#createTX
 */

HTTPWallet.prototype.createTX = function createTX(options, outputs) {
  return this.client.createTX(this.id, options, outputs);
};

/**
 * @see HTTPClient#walletSend
 */

HTTPWallet.prototype.send = function send(options) {
  return this.client.send(this.id, options);
};

/**
 * @see Wallet#sign
 */

HTTPWallet.prototype.sign = function sign(tx, options) {
  return this.client.sign(this.id, tx, options);
};

/**
 * @see HTTPClient#getWallet
 */

HTTPWallet.prototype.getInfo = function getInfo() {
  return this.client.getWallet(this.id);
};

/**
 * @see Wallet#getAccounts
 */

HTTPWallet.prototype.getAccounts = function getAccounts() {
  return this.client.getAccounts(this.id);
};

/**
 * @see Wallet#master
 */

HTTPWallet.prototype.getMaster = function getMaster() {
  return this.client.getMaster(this.id);
};

/**
 * @see Wallet#getAccount
 */

HTTPWallet.prototype.getAccount = function getAccount(account) {
  return this.client.getAccount(this.id, account);
};

/**
 * @see Wallet#createAccount
 */

HTTPWallet.prototype.createAccount = function createAccount(name, options) {
  return this.client.createAccount(this.id, name, options);
};

/**
 * @see Wallet#createAddress
 */

HTTPWallet.prototype.createAddress = function createAddress(account) {
  return this.client.createAddress(this.id, account);
};

/**
 * @see Wallet#createAddress
 */

HTTPWallet.prototype.createChange = function createChange(account) {
  return this.client.createChange(this.id, account);
};

/**
 * @see Wallet#createAddress
 */

HTTPWallet.prototype.createNested = function createNested(account) {
  return this.client.createNested(this.id, account);
};

/**
 * @see Wallet#setPassphrase
 */

HTTPWallet.prototype.setPassphrase = function setPassphrase(old, new_) {
  return this.client.setPassphrase(this.id, old, new_);
};

/**
 * @see Wallet#retoken
 */

HTTPWallet.prototype.retoken = async function retoken(passphrase) {
  const token = await this.client.retoken(this.id, passphrase);

  this.token = token;
  this.client.token = token;

  return token;
};

/**
 * Import private key.
 * @param {Number|String} account
 * @param {String} key
 * @returns {Promise}
 */

HTTPWallet.prototype.importPrivate = function importPrivate(account, key) {
  return this.client.importPrivate(this.id, account, key);
};

/**
 * Import public key.
 * @param {Number|String} account
 * @param {String} key
 * @returns {Promise}
 */

HTTPWallet.prototype.importPublic = function importPublic(account, key) {
  return this.client.importPublic(this.id, account, key);
};

/**
 * Import address.
 * @param {Number|String} account
 * @param {String} address
 * @returns {Promise}
 */

HTTPWallet.prototype.importAddress = function importAddress(account, address) {
  return this.client.importAddress(this.id, account, address);
};

/**
 * Lock a coin.
 * @param {String} hash
 * @param {Number} index
 * @returns {Promise}
 */

HTTPWallet.prototype.lockCoin = function lockCoin(hash, index) {
  return this.client.lockCoin(this.id, hash, index);
};

/**
 * Unlock a coin.
 * @param {String} hash
 * @param {Number} index
 * @returns {Promise}
 */

HTTPWallet.prototype.unlockCoin = function unlockCoin(hash, index) {
  return this.client.unlockCoin(this.id, hash, index);
};

/**
 * Get locked coins.
 * @returns {Promise}
 */

HTTPWallet.prototype.getLocked = function getLocked() {
  return this.client.getLocked(this.id);
};

/**
 * Lock wallet.
 * @returns {Promise}
 */

HTTPWallet.prototype.lock = function lock() {
  return this.client.lock(this.id);
};

/**
 * Unlock wallet.
 * @param {String} passphrase
 * @param {Number} timeout
 * @returns {Promise}
 */

HTTPWallet.prototype.unlock = function unlock(passphrase, timeout) {
  return this.client.unlock(this.id, passphrase, timeout);
};

/**
 * Get wallet key.
 * @param {String} address
 * @returns {Promise}
 */

HTTPWallet.prototype.getKey = function getKey(address) {
  return this.client.getKey(this.id, address);
};

/**
 * Get wallet key WIF dump.
 * @param {String} address
 * @param {String?} passphrase
 * @returns {Promise}
 */

HTTPWallet.prototype.getWIF = function getWIF(address, passphrase) {
  return this.client.getWIF(this.id, address, passphrase);
};

/**
 * Add a public account/purpose key to the wallet for multisig.
 * @param {(String|Number)?} account
 * @param {Base58String} key - Account (bip44) or
 * Purpose (bip45) key (can be in base58 form).
 * @returns {Promise}
 */

HTTPWallet.prototype.addSharedKey = function addSharedKey(account, key) {
  return this.client.addSharedKey(this.id, account, key);
};

/**
 * Remove a public account/purpose key to the wallet for multisig.
 * @param {(String|Number)?} account
 * @param {Base58String} key - Account (bip44) or Purpose
 * (bip45) key (can be in base58 form).
 * @returns {Promise}
 */

HTTPWallet.prototype.removeSharedKey = function removeSharedKey(account, key) {
  return this.client.removeSharedKey(this.id, account, key);
};

/**
 * Resend wallet transactions.
 * @returns {Promise}
 */

HTTPWallet.prototype.resend = function resend() {
  return this.client.resendWallet(this.id);
};

/*
 * Expose
 */

module.exports = HTTPWallet;


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * mempool/index.js - mempool for wmcc_core.
 */



/**
 * @module mempool
 */

exports.Fees = __webpack_require__(117);
exports.layout = __webpack_require__(239);
exports.MempoolEntry = __webpack_require__(181);
exports.Mempool = __webpack_require__(182);


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * mining/index.js - mining infrastructure for wmcc_core.
 */



/**
 * @module mining
 */

exports.common = __webpack_require__(184);
exports.CPUMiner = __webpack_require__(240);
exports.mine = __webpack_require__(95);
exports.Miner = __webpack_require__(185);
exports.BlockTemplate = __webpack_require__(186);


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * net/index.js - p2p for wmcc_core.
 */



/**
 * @module net
 */

exports.BIP150 = __webpack_require__(119);
exports.BIP151 = __webpack_require__(120);
exports.bip152 = __webpack_require__(96);
exports.common = __webpack_require__(59);
exports.dns = __webpack_require__(97);
exports.external = __webpack_require__(242);
exports.Framer = __webpack_require__(243);
exports.HostList = __webpack_require__(244);
exports.packets = __webpack_require__(60);
exports.Parser = __webpack_require__(245);
exports.Peer = __webpack_require__(188);
exports.Pool = __webpack_require__(122);
exports.socks = __webpack_require__(187);
exports.tcp = __webpack_require__(121);
exports.UPNP = __webpack_require__(246);


/***/ }),
/* 312 */
/***/ (function(module, exports) {

module.exports = require("dns");

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * seeds.js - seeds for wmcc_core.
 */



const mainnet = __webpack_require__(314);
const testnet = __webpack_require__(315);

exports.get = function get(type) {
  switch (type) {
    case 'mainnet':
      return mainnet;
    case 'testnet':
      return testnet;
    default:
      return [];
  }
};


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = [];


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = [];


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * node/index.js - node for wmcc_core.
 */



/**
 * @module node
 */

exports.Config = __webpack_require__(123);
exports.FullNode = __webpack_require__(247);
exports.Logger = __webpack_require__(34);
exports.Node = __webpack_require__(189);
exports.SPVNode = __webpack_require__(248);


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * child.js - child processes for wmcc_core.
 */



const EventEmitter = __webpack_require__(10);
const path = __webpack_require__(25);
const cp = __webpack_require__(225);

const children = new Set();
let exitBound = false;

/**
 * Represents a child process.
 * @alias module:workers.Child
 * @constructor
 * @param {String} file
 */

function Child(file) {
  if (!(this instanceof Child))
    return new Child(file);

  EventEmitter.call(this);

  bindExit();
  children.add(this);

  this.init(file);
}

Object.setPrototypeOf(Child.prototype, EventEmitter.prototype);

/**
 * Test whether child process support is available.
 * @returns {Boolean}
 */

Child.hasSupport = function hasSupport() {
  return true;
};

/**
 * Initialize child process (node.js).
 * @private
 * @param {String} file
 */

Child.prototype.init = function init(file) {
  const bin = process.argv[0];
  const filename = path.resolve(__dirname, file);
  const env = (process.versions.electron) ? Object.assign({}, process.env, {ELECTRON_RUN_AS_NODE: "1"}) : process.env;
  const options = { stdio: 'pipe', env: env };

  this.child = cp.spawn(bin, [filename], options);

  this.child.unref();
  this.child.stdin.unref();
  this.child.stdout.unref();
  this.child.stderr.unref();

  this.child.on('error', (err) => {
    this.emit('error', err);
  });

  this.child.once('exit', (code, signal) => {
    children.delete(this);
    this.emit('exit', code == null ? -1 : code, signal);
  });

  this.child.stdin.on('error', (err) => {
    this.emit('error', err);
  });

  this.child.stdout.on('error', (err) => {
    this.emit('error', err);
  });

  this.child.stderr.on('error', (err) => {
    this.emit('error', err);
  });

  this.child.stdout.on('data', (data) => {
    this.emit('data', data);
  });
};

/**
 * Send data to child process.
 * @param {Buffer} data
 * @returns {Boolean}
 */

Child.prototype.write = function write(data) {
  return this.child.stdin.write(data);
};

/**
 * Destroy the child process.
 */

Child.prototype.destroy = function destroy() {
  this.child.kill('SIGTERM');
};

/**
 * Cleanup all child processes.
 * @private
 */

function bindExit() {
  if (exitBound)
    return;

  exitBound = true;

  listenExit(() => {
    for (const child of children)
      child.destroy();
  });
}

/**
 * Listen for exit.
 * @param {Function} handler
 * @private
 */

function listenExit(handler) {
  const onSighup = () => {
    process.exit(1 | 0x80);
  };

  const onSigint = () => {
    process.exit(2 | 0x80);
  };

  const onSigterm = () => {
    process.exit(15 | 0x80);
  };

  const onError = (err) => {
    if (err && err.stack)
      console.error(String(err.stack));
    else
      console.error(String(err));

    process.exit(1);
  };

  process.once('exit', handler);

  if (process.listenerCount('SIGHUP') === 0)
    process.once('SIGHUP', onSighup);

  if (process.listenerCount('SIGINT') === 0)
    process.once('SIGINT', onSigint);

  if (process.listenerCount('SIGTERM') === 0)
    process.once('SIGTERM', onSigterm);

  if (process.listenerCount('uncaughtException') === 0)
    process.once('uncaughtException', onError);

  process.on('newListener', (name) => {
    switch (name) {
      case 'SIGHUP':
        process.removeListener(name, onSighup);
        break;
      case 'SIGINT':
        process.removeListener(name, onSigint);
        break;
      case 'SIGTERM':
        process.removeListener(name, onSigterm);
        break;
      case 'uncaughtException':
        process.removeListener(name, onError);
        break;
    }
  });
}

/*
 * Expose
 */

module.exports = Child;


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * primitives/index.js - WMCC primitives for wmcc_core.
 */



/**
 * @module primitives
 */

exports.AbstractBlock = __webpack_require__(67);
exports.Address = __webpack_require__(11);
exports.Block = __webpack_require__(51);
exports.Coin = __webpack_require__(44);
exports.Headers = __webpack_require__(37);
exports.Input = __webpack_require__(42);
exports.InvItem = __webpack_require__(36);
exports.KeyRing = __webpack_require__(47);
exports.MemBlock = __webpack_require__(241);
exports.MerkleBlock = __webpack_require__(69);
exports.MTX = __webpack_require__(48);
exports.NetAddress = __webpack_require__(75);
exports.Outpoint = __webpack_require__(21);
exports.Output = __webpack_require__(13);
exports.TX = __webpack_require__(16);
exports.TXMeta = __webpack_require__(165);


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * protocol/index.js - protocol constants for wmcc_core.
 */



/**
 * @module protocol
 */

exports.consensus = __webpack_require__(7);
exports.errors = __webpack_require__(105);
exports.Network = __webpack_require__(6);
exports.networks = __webpack_require__(79);
exports.policy = __webpack_require__(19);
exports.timedata = __webpack_require__(80);


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * script/index.js - WMCC scripting for wmcc_core.
 */



/**
 * @module script
 */

exports.common = __webpack_require__(28);
exports.Opcode = __webpack_require__(86);
exports.Program = __webpack_require__(81);
exports.Script = __webpack_require__(8);
exports.ScriptError = __webpack_require__(35);
exports.ScriptNum = __webpack_require__(33);
exports.sigcache = __webpack_require__(249);
exports.Stack = __webpack_require__(41);
exports.Witness = __webpack_require__(55);


/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * stratum.js - stratum server for wmcc.
 */



/**
 * @module stratum
 */

exports.Stratum = __webpack_require__(250);

/***/ }),
/* 322 */
/***/ (function(module, exports) {

module.exports = require("wmcc-mutex");

/***/ }),
/* 323 */
/***/ (function(module, exports) {

module.exports = require("wmcc-tcp");

/***/ }),
/* 324 */
/***/ (function(module, exports) {

module.exports = require("wmcc-inet");

/***/ }),
/* 325 */
/***/ (function(module, exports) {

module.exports = require("wmcc-logger");

/***/ }),
/* 326 */
/***/ (function(module, exports) {

module.exports = require("wmcc-file");

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2016-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * sha256.js - SHA256 implementation for wmcc_core.
 * Parts of this software based on hash.js.
 */



/**
 * @module crypto/sha256
 * @ignore
 */

/*
 * Constants
 */

const DESC = Buffer.allocUnsafe(8);
const BUFFER64 = Buffer.allocUnsafe(64);
const PADDING = Buffer.allocUnsafe(64);

const K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

PADDING.fill(0);
PADDING[0] = 0x80;

/**
 * SHA256
 * @alias module:crypto/sha256.SHA256
 * @constructor
 * @property {Number[]} s
 * @property {Number[]} w
 * @property {Buffer} block
 * @property {Number} bytes
 */

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  this.s = new Array(8);
  this.w = new Array(64);
  this.block = Buffer.allocUnsafe(64);
  this.bytes = 0;
}

/**
 * Initialize SHA256 context.
 */

SHA256.prototype.init = function init() {
  this.s[0] = 0x6a09e667;
  this.s[1] = 0xbb67ae85;
  this.s[2] = 0x3c6ef372;
  this.s[3] = 0xa54ff53a;
  this.s[4] = 0x510e527f;
  this.s[5] = 0x9b05688c;
  this.s[6] = 0x1f83d9ab;
  this.s[7] = 0x5be0cd19;
  this.bytes = 0;
};

/**
 * Update SHA256 context.
 * @param {Buffer} data
 */

SHA256.prototype.update = function update(data) {
  return this._update(data, data.length);
};

/**
 * Finalize SHA256 context.
 * @returns {Buffer}
 */

SHA256.prototype.finish = function finish() {
  return this._finish(Buffer.allocUnsafe(32));
};

/**
 * Update SHA256 context.
 * @private
 * @param {Buffer} data
 * @param {Number} len
 */

SHA256.prototype._update = function _update(data, len) {
  let size = this.bytes & 0x3f;
  let pos = 0;

  this.bytes += len;

  if (size > 0) {
    let want = 64 - size;

    if (want > len)
      want = len;

    for (let i = 0; i < want; i++)
      this.block[size + i] = data[i];

    size += want;
    len -= want;
    pos += want;

    if (size < 64)
      return;

    this.transform(this.block, 0);
  }

  while (len >= 64) {
    this.transform(data, pos);
    pos += 64;
    len -= 64;
  }

  for (let i = 0; i < len; i++)
    this.block[i] = data[pos + i];
};

/**
 * Finalize SHA256 context.
 * @private
 * @param {Buffer} out
 * @returns {Buffer}
 */

SHA256.prototype._finish = function _finish(out) {
  writeU32(DESC, this.bytes >>> 29, 0);
  writeU32(DESC, this.bytes << 3, 4);

  this._update(PADDING, 1 + ((119 - (this.bytes % 64)) % 64));
  this._update(DESC, 8);

  for (let i = 0; i < 8; i++) {
    writeU32(out, this.s[i], i * 4);
    this.s[i] = 0;
  }

  return out;
};

/**
 * Transform SHA256 block.
 * @param {Buffer} chunk
 * @param {Number} pos
 */

SHA256.prototype.transform = function transform(chunk, pos) {
  const w = this.w;
  let a = this.s[0];
  let b = this.s[1];
  let c = this.s[2];
  let d = this.s[3];
  let e = this.s[4];
  let f = this.s[5];
  let g = this.s[6];
  let h = this.s[7];
  let i = 0;

  for (; i < 16; i++)
    w[i] = readU32(chunk, pos + i * 4);

  for (; i < 64; i++)
    w[i] = sigma1(w[i - 2]) + w[i - 7] + sigma0(w[i - 15]) + w[i - 16];

  for (i = 0; i < 64; i++) {
    let t1 = h + Sigma1(e);
    t1 += Ch(e, f, g);
    t1 += K[i] + w[i];

    let t2 = Sigma0(a);
    t2 += Maj(a, b, c);

    h = g;
    g = f;
    f = e;

    e = d + t1;

    d = c;
    c = b;
    b = a;

    a = t1 + t2;
  }

  this.s[0] += a;
  this.s[1] += b;
  this.s[2] += c;
  this.s[3] += d;
  this.s[4] += e;
  this.s[5] += f;
  this.s[6] += g;
  this.s[7] += h;

  this.s[0] >>>= 0;
  this.s[1] >>>= 0;
  this.s[2] >>>= 0;
  this.s[3] >>>= 0;
  this.s[4] >>>= 0;
  this.s[5] >>>= 0;
  this.s[6] >>>= 0;
  this.s[7] >>>= 0;
};

/**
 * SHA256Hmac
 * @alias module:crypto/sha256.SHA256Hmac
 * @constructor
 * @property {SHA256} inner
 * @property {SHA256} outer
 */

function SHA256Hmac() {
  if (!(this instanceof SHA256Hmac))
    return new SHA256Hmac();

  this.inner = new SHA256();
  this.outer = new SHA256();
}

/**
 * Initialize HMAC context.
 * @param {Buffer} data
 */

SHA256Hmac.prototype.init = function init(data) {
  const key = BUFFER64;

  if (data.length > 64) {
    this.inner.init();
    this.inner.update(data);
    this.inner._finish(key);
    key.fill(0, 32, 64);
  } else {
    data.copy(key, 0);
    key.fill(0, data.length, 64);
  }

  for (let i = 0; i < key.length; i++)
    key[i] ^= 0x36;

  this.inner.init();
  this.inner.update(key);

  for (let i = 0; i < key.length; i++)
    key[i] ^= 0x6a;

  this.outer.init();
  this.outer.update(key);
};

/**
 * Update HMAC context.
 * @param {Buffer} data
 */

SHA256Hmac.prototype.update = function update(data) {
  this.inner.update(data);
};

/**
 * Finalize HMAC context.
 * @returns {Buffer}
 */

SHA256Hmac.prototype.finish = function finish() {
  this.outer.update(this.inner.finish());
  return this.outer.finish();
};

/*
 * Helpers
 * @see https://github.com/bitcoin-core/secp256k1/blob/master/src/hash_impl.h
 */

function Sigma0(x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
}

function Sigma1(x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
}

function sigma0(x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3);
}

function sigma1(x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10);
}

function Ch(x, y, z) {
  return z ^ (x & (y ^ z));
}

function Maj(x, y, z) {
  return (x & y) | (z & (x | y));
}

function writeU32(buf, value, offset) {
  buf[offset] = value >>> 24;
  buf[offset + 1] = (value >> 16) & 0xff;
  buf[offset + 2] = (value >> 8) & 0xff;
  buf[offset + 3] = value & 0xff;
}

function readU32(buf, offset) {
  return ((buf[offset] & 0xff) * 0x1000000)
    + ((buf[offset + 1] & 0xff) << 16)
    | ((buf[offset + 2] & 0xff) << 8)
    | (buf[offset + 3] & 0xff);
}

/*
 * Context Helpers
 */

const ctx = new SHA256();
const mctx = new SHA256Hmac();

/**
 * Hash buffer with sha256.
 * @alias module:crypto/sha256.sha256
 * @param {Buffer} data
 * @returns {Buffer}
 */

function sha256(data) {
  ctx.init();
  ctx.update(data);
  return ctx.finish();
}

/**
 * Hash buffer with double sha256.
 * @alias module:crypto/sha256.hash256
 * @param {Buffer} data
 * @returns {Buffer}
 */

function hash256(data) {
  const out = Buffer.allocUnsafe(32);
  ctx.init();
  ctx.update(data);
  ctx._finish(out);
  ctx.init();
  ctx.update(out);
  ctx._finish(out);
  return out;
}

/**
 * Create a sha256 HMAC from buffer and key.
 * @alias module:crypto/sha256.hmac
 * @param {Buffer} data
 * @param {Buffer} key
 * @returns {Buffer}
 */

function hmac(data, key) {
  mctx.init(key);
  mctx.update(data);
  return mctx.finish();
}

/*
 * Expose
 */

exports = SHA256;
exports.SHA256 = SHA256;
exports.SHA256Hmac = SHA256Hmac;
exports.digest = sha256;
exports.hmac = hmac;
exports.hash256 = hash256;

module.exports = exports;


/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * utils/index.js - utils for wmcc_core.
 */



/**
 * @module utils
 */

exports.ASN1 = __webpack_require__(196);
// exports.AsyncEmitter = require('./asyncemitter');
exports.AsyncObject = __webpack_require__(31);
exports.base32 = __webpack_require__(179);
exports.base58 = __webpack_require__(26);
exports.bech32 = __webpack_require__(99);
exports.Bloom = __webpack_require__(43);
exports.co = __webpack_require__(17);
exports.encoding = __webpack_require__(3);
exports.enforce = __webpack_require__(329);
exports.fs = __webpack_require__(58);
exports.GCSFilter = __webpack_require__(330);
exports.Heap = __webpack_require__(183);
exports.Int64 = __webpack_require__(49);
exports.IP = __webpack_require__(46);
exports.List = __webpack_require__(91);
exports.Lock = __webpack_require__(23);
exports.LRU = __webpack_require__(56);
exports.MappedLock = __webpack_require__(190);
exports.murmur3 = __webpack_require__(66);
exports.nfkd = __webpack_require__(212);
exports.PEM = __webpack_require__(100);
exports.ProtoWriter = __webpack_require__(78);
exports.ProtoReader = __webpack_require__(77);
exports.RBT = __webpack_require__(203);
exports.BufferReader = __webpack_require__(2);
exports.RollingFilter = __webpack_require__(118);
exports.StaticWriter = __webpack_require__(4);
exports.util = __webpack_require__(1);
exports.Validator = __webpack_require__(71);
exports.BufferWriter = __webpack_require__(62);


/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * enforce.js - type enforcement for wmcc_core.
 */



const util = __webpack_require__(1);

function enforce(value, name, type, func) {
  if (!value) {
    if (!func)
      func = enforce;

    if (name && !type)
      throwError(name, func);

    if (!name)
      name = 'value';

    throwError(`'${name}' must be a(n) ${type}.`, func);
  }
}

function throwError(msg, func) {
  const error = new TypeError(msg);
  if (Error.captureStackTrace && func)
    Error.captureStackTrace(error, func);
  throw error;
}

enforce.none = function none(value, name) {
  enforce(value == null, name, 'object', none);
};

enforce.nul = function nul(value, name) {
  enforce(value === null, name, 'object', nul);
};

enforce.undef = function undef(value, name) {
  enforce(value === undefined, name, 'object', undef);
};

enforce.str = function str(value, name) {
  enforce(typeof value === 'string', name, 'string', str);
};

enforce.bool = function bool(value, name) {
  enforce(typeof value === 'boolean', name, 'boolean', bool);
};

enforce.num = function num(value, name) {
  enforce(util.isNumber(value), name, 'number', num);
};

enforce.obj = function obj(v, name) {
  enforce(v && typeof v === 'object' && !Array.isArray(v), name, 'object', obj);
};

enforce.array = function array(value, name) {
  enforce(Array.isArray(value), name, 'object', array);
};

enforce.func = function func(value, name) {
  enforce(typeof value === 'function', name, 'function', func);
};

enforce.error = function error(value, name) {
  enforce(value instanceof Error, name, 'object', error);
};

enforce.regexp = function regexp(value, name) {
  enforce(value && typeof value.exec === 'function' , name, 'object', regexp);
};

enforce.buf = function buf(value, name) {
  enforce(Buffer.isBuffer(value), name, 'buffer', buf);
};

enforce.len = function len(value, length, name) {
  if ((typeof value !== 'string' && !value) || value.length !== length) {
    if (!name)
      name = 'value';
    throwError(`'${name}' must have a length of ${length}.`, len);
  }
};

enforce.instance = function instance(obj, parent, name) {
  if (!(obj instanceof parent)) {
    if (!name)
      name = 'value';
    throwError(`'${name}' must be an instance of ${parent.name}.`, instance);
  }
};

enforce.uint = function uint(value, name) {
  enforce(util.isUInt(value), name, 'uint', uint);
};

enforce.int = function int(value, name) {
  enforce(util.isInt(value), name, 'int', int);
};

enforce.u8 = function u8(value, name) {
  enforce(util.isU8(value), name, 'uint8', u8);
};

enforce.u16 = function u16(value, name) {
  enforce(util.isU16(value), name, 'uint16', u16);
};

enforce.u32 = function u32(value, name) {
  enforce(util.isU32(value), name, 'uint32', u32);
};

enforce.u64 = function u64(value, name) {
  enforce(util.isU64(value), name, 'uint64', u64);
};

enforce.i8 = function i8(value, name) {
  enforce(util.isI8(value), name, 'int8', i8);
};

enforce.i16 = function i16(value, name) {
  enforce(util.isI16(value), name, 'int16', i16);
};

enforce.i32 = function i32(value, name) {
  enforce(util.isI32(value), name, 'int32', i32);
};

enforce.i64 = function i64(value, name) {
  enforce(util.isI64(value), name, 'int64', i64);
};

enforce.ufloat = function ufloat(value, name) {
  enforce(util.isUfloat(value), name, 'positive float', ufloat);
};

enforce.float = function float(value, name) {
  enforce(util.isFloat(value), name, 'float', float);
};

enforce.ascii = function ascii(value, name) {
  enforce(util.isAscii(value), name, 'ascii string', ascii);
};

enforce.hex = function hex(value, name) {
  enforce(util.isHex(value), name, 'hex string', hex);
};

enforce.hex160 = function hex160(value, name) {
  enforce(util.isHex160(value), name, '160 bit hex string', hex160);
};

enforce.hex256 = function hex256(value, name) {
  enforce(util.isHex256(value), name, '256 bit hex string', hex256);
};

enforce.base58 = function base58(value, name) {
  enforce(util.isBase58(value), name, 'base58 string', base58);
};

module.exports = enforce;


/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * gcs.js - gcs filters for wmcc_core.
 */



const assert = __webpack_require__(0);
const {U64} = __webpack_require__(49);
const digest = __webpack_require__(5);
const siphash = __webpack_require__(168);
const DUMMY = Buffer.alloc(0);
const EOF = new U64(-1);

/**
 * GCSFilter
 * @alias module:utils.GCSFilter
 * @constructor
 */

function GCSFilter() {
  this.n = 0;
  this.p = 0;
  this.m = new U64(0);
  this.data = DUMMY;
}

GCSFilter.prototype.hash = function hash(enc) {
  const h = digest.hash256(this.data);
  return enc === 'hex' ? h.toString('hex') : h;
};

GCSFilter.prototype.header = function header(prev) {
  return digest.root256(this.hash(), prev);
};

GCSFilter.prototype.match = function match(key, data) {
  const br = new BitReader(this.data);
  const term = siphash24(data, key).imod(this.m);
  let last = new U64(0);

  while (last.lt(term)) {
    const value = this.readU64(br);

    if (value === EOF)
      return false;

    value.iadd(last);

    if (value.eq(term))
      return true;

    last = value;
  }

  return false;
};

GCSFilter.prototype.matchAny = function matchAny(key, items) {
  assert(items.length > 0);

  const br = new BitReader(this.data);
  const last1 = new U64(0);
  const values = [];

  for (const item of items) {
    const hash = siphash24(item, key).imod(this.m);
    values.push(hash);
  }

  values.sort(compare);

  let last2 = values[0];
  let i = 1;

  for (;;) {
    const cmp = last1.cmp(last2);

    if (cmp === 0)
      break;

    if (cmp > 0) {
      if (i < values.length) {
        last2 = values[i];
        i += 1;
        continue;
      }
      return false;
    }

    const value = this.readU64(br);

    if (value === EOF)
      return false;

    last1.iadd(value);
  }

  return true;
};

GCSFilter.prototype.readU64 = function readU64(br) {
  try {
    return this._readU64(br);
  } catch (e) {
    if (e.message === 'EOF')
      return EOF;
    throw e;
  }
};

GCSFilter.prototype._readU64 = function _readU64(br) {
  const num = new U64(0);

  // Unary
  while (br.readBit())
    num.iaddn(1);

  const rem = br.readBits64(this.p);

  return num.ishln(this.p).ior(rem);
};

GCSFilter.prototype.toBytes = function toBytes() {
  return this.data;
};

GCSFilter.prototype.toNBytes = function toNBytes() {
  const data = Buffer.allocUnsafe(4 + this.data.length);
  data.writeUInt32BE(this.n, 0, true);
  this.data.copy(data, 4);
  return data;
};

GCSFilter.prototype.toPBytes = function toPBytes() {
  const data = Buffer.allocUnsafe(1 + this.data.length);
  data.writeUInt8(this.p, 0, true);
  this.data.copy(data, 1);
  return data;
};

GCSFilter.prototype.toNPBytes = function toNPBytes() {
  const data = Buffer.allocUnsafe(5 + this.data.length);
  data.writeUInt32BE(this.n, 0, true);
  data.writeUInt8(this.p, 4, true);
  this.data.copy(data, 5);
  return data;
};

GCSFilter.prototype.toRaw = function toRaw() {
  assert(this.p === 20);
  return this.toNBytes();
};

GCSFilter.prototype.fromItems = function fromItems(P, key, items) {
  assert(typeof P === 'number' && isFinite(P));
  assert(P >= 0 && P <= 32);

  assert(Buffer.isBuffer(key));
  assert(key.length === 16);

  assert(Array.isArray(items));
  assert(items.length > 0);
  assert(items.length <= 0xffffffff);

  this.n = items.length;
  this.p = P;
  this.m = U64(this.n).ishln(this.p);

  const values = [];

  for (const item of items) {
    assert(Buffer.isBuffer(item));
    const hash = siphash24(item, key).imod(this.m);
    values.push(hash);
  }

  values.sort(compare);

  const bw = new BitWriter();
  let last = new U64(0);

  for (const hash of values) {
    const rem = hash.sub(last).imaskn(this.p);
    const value = hash.sub(last).isub(rem).ishrn(this.p);

    last = hash;

    // Unary
    while (!value.isZero()) {
      bw.writeBit(1);
      value.isubn(1);
    }
    bw.writeBit(0);

    bw.writeBits64(rem, this.p);
  }

  this.data = bw.render();

  return this;
};

GCSFilter.prototype.fromBytes = function fromBytes(N, P, data) {
  assert(typeof N === 'number' && isFinite(N));
  assert(typeof P === 'number' && isFinite(P));
  assert(P >= 0 && P <= 32);
  assert(Buffer.isBuffer(data));

  this.n = N;
  this.p = P;
  this.m = U64(this.n).ishln(this.p);
  this.data = data;

  return this;
};

GCSFilter.prototype.fromNBytes = function fromNBytes(P, data) {
  assert(typeof P === 'number' && isFinite(P));
  assert(Buffer.isBuffer(data));
  assert(data.length >= 4);

  const N = data.readUInt32BE(0, true);

  return this.fromBytes(N, P, data.slice(4));
};

GCSFilter.prototype.fromPBytes = function fromPBytes(N, data) {
  assert(typeof N === 'number' && isFinite(N));
  assert(Buffer.isBuffer(data));
  assert(data.length >= 1);

  const P = data.readUInt8(0, true);

  return this.fromBytes(N, P, data.slice(1));
};

GCSFilter.prototype.fromNPBytes = function fromNPBytes(data) {
  assert(Buffer.isBuffer(data));
  assert(data.length >= 5);

  const N = data.readUInt32BE(0, true);
  const P = data.readUInt8(4, true);

  return this.fromBytes(N, P, data.slice(5));
};

GCSFilter.prototype.fromRaw = function fromRaw(data) {
  return this.fromNBytes(20, data);
};

GCSFilter.prototype.fromBlock = function fromBlock(block) {
  const hash = block.hash();
  const key = hash.slice(0, 16);
  const items = [];

  for (let i = 0; i < block.txs.length; i++) {
    const tx = block.txs[i];

    if (i > 0) {
      for (const input of tx.inputs)
        items.push(input.prevout.toRaw());
    }

    for (const output of tx.outputs)
      getPushes(items, output.script);
  }

  return this.fromItems(20, key, items);
};

GCSFilter.prototype.fromExtended = function fromExtended(block) {
  const hash = block.hash();
  const key = hash.slice(0, 16);
  const items = [];

  for (let i = 0; i < block.txs.length; i++) {
    const tx = block.txs[i];

    items.push(tx.hash());

    if (i > 0) {
      for (const input of tx.inputs) {
        getWitness(items, input.witness);
        getPushes(items, input.script);
      }
    }
  }

  return this.fromItems(20, key, items);
};

GCSFilter.fromItems = function fromItems(P, key, items) {
  return new GCSFilter().fromItems(P, key, items);
};

GCSFilter.fromBytes = function fromBytes(N, P, data) {
  return new GCSFilter().fromBytes(N, P, data);
};

GCSFilter.fromNBytes = function fromNBytes(P, data) {
  return new GCSFilter().fromNBytes(P, data);
};

GCSFilter.fromPBytes = function fromPBytes(N, data) {
  return new GCSFilter().fromPBytes(N, data);
};

GCSFilter.fromNPBytes = function fromNPBytes(data) {
  return new GCSFilter().fromNPBytes(data);
};

GCSFilter.fromRaw = function fromRaw(data) {
  return new GCSFilter().fromRaw(data);
};

GCSFilter.fromBlock = function fromBlock(block) {
  return new GCSFilter().fromBlock(block);
};

GCSFilter.fromExtended = function fromExtended(block) {
  return new GCSFilter().fromExtended(block);
};

/**
 * BitWriter
 * @constructor
 * @ignore
 */

function BitWriter() {
  this.stream = [];
  this.remain = 0;
}

BitWriter.prototype.writeBit = function writeBit(bit) {
  if (this.remain === 0) {
    this.stream.push(0);
    this.remain = 8;
  }

  if (bit) {
    const index = this.stream.length - 1;
    this.stream[index] |= 1 << (this.remain - 1);
  }

  this.remain--;
};

BitWriter.prototype.writeByte = function writeByte(ch) {
  if (this.remain === 0) {
    this.stream.push(0);
    this.remain = 8;
  }

  const index = this.stream.length - 1;

  this.stream[index] |= (ch >> (8 - this.remain)) & 0xff;
  this.stream.push(0);
  this.stream[index + 1] = (ch << this.remain) & 0xff;
};

BitWriter.prototype.writeBits = function writeBits(num, count) {
  assert(count >= 0);
  assert(count <= 32);

  num <<= 32 - count;

  while (count >= 8) {
    const ch = num >>> 24;
    this.writeByte(ch);
    num <<= 8;
    count -= 8;
  }

  while (count > 0) {
    const bit = num >>> 31;
    this.writeBit(bit);
    num <<= 1;
    count -= 1;
  }
};

BitWriter.prototype.writeBits64 = function writeBits64(num, count) {
  assert(count >= 0);
  assert(count <= 64);

  if (count > 32) {
    this.writeBits(num.hi, count - 32);
    this.writeBits(num.lo, 32);
  } else {
    this.writeBits(num.lo, count);
  }
};

BitWriter.prototype.render = function render() {
  const data = Buffer.allocUnsafe(this.stream.length);

  for (let i = 0; i < this.stream.length; i++)
    data[i] = this.stream[i];

  return data;
};

/**
 * BitReader
 * @constructor
 * @ignore
 */

function BitReader(data) {
  this.stream = data;
  this.pos = 0;
  this.remain = 8;
}

BitReader.prototype.readBit = function readBit() {
  if (this.pos >= this.stream.length)
    throw new Error('EOF');

  if (this.remain === 0) {
    this.pos += 1;

    if (this.pos >= this.stream.length)
      throw new Error('EOF');

    this.remain = 8;
  }

  this.remain -= 1;

  return (this.stream[this.pos] >> this.remain) & 1;
};

BitReader.prototype.readByte = function readByte() {
  if (this.pos >= this.stream.length)
    throw new Error('EOF');

  if (this.remain === 0) {
    this.pos += 1;

    if (this.pos >= this.stream.length)
      throw new Error('EOF');

    this.remain = 8;
  }

  if (this.remain === 8) {
    const ch = this.stream[this.pos];
    this.pos += 1;
    return ch;
  }

  let ch = this.stream[this.pos] & ((1 << this.remain) - 1);
  ch <<= 8 - this.remain;

  this.pos += 1;

  if (this.pos >= this.stream.length)
    throw new Error('EOF');

  ch |= this.stream[this.pos] >> this.remain;

  return ch;
};

BitReader.prototype.readBits = function readBits(count) {
  assert(count >= 0);
  assert(count <= 32);

  let num = 0;

  while (count >= 8) {
    num <<= 8;
    num |= this.readByte();
    count -= 8;
  }

  while (count > 0) {
    num <<= 1;
    num |= this.readBit();
    count -= 1;
  }

  return num;
};

BitReader.prototype.readBits64 = function readBits64(count) {
  assert(count >= 0);
  assert(count <= 64);

  const num = new U64();

  if (count > 32) {
    num.hi = this.readBits(count - 32);
    num.lo = this.readBits(32);
  } else {
    num.lo = this.readBits(count);
  }

  return num;
};

/*
 * Helpers
 */

function compare(a, b) {
  return a.cmp(b) < 0 ? -1 : 1;
}

function siphash24(data, key) {
  const [hi, lo] = siphash(data, key);
  return U64.fromBits(hi, lo);
}

function getPushes(items, script) {
  for (const op of script.code) {
    if (!op.data || op.data.length === 0)
      continue;

    items.push(op.data);
  }
}

function getWitness(items, witness) {
  for (const item of witness.items) {
    if (item.length === 0)
      continue;

    items.push(item);
  }
}

/*
 * Expose
 */

module.exports = GCSFilter;


/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * wallet/index.js - wallet for wmcc_core.
 */



/**
 * @module wallet
 */

exports.Account = __webpack_require__(191);
exports.Client = __webpack_require__(251);
exports.common = __webpack_require__(61);
exports.HTTPServer = __webpack_require__(252);
exports.layout = __webpack_require__(192);
exports.MasterKey = __webpack_require__(253);
exports.NodeClient = __webpack_require__(254);
exports.Path = __webpack_require__(76);
exports.plugin = __webpack_require__(332);
exports.records = __webpack_require__(129);
exports.RPC = __webpack_require__(257);
exports.server = __webpack_require__(333);
exports.TXDB = __webpack_require__(256);
exports.WalletDB = __webpack_require__(130);
exports.Wallet = __webpack_require__(255);
exports.WalletKey = __webpack_require__(128);


/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * plugin.js - wallet plugin for wmcc_core.
 */



const WalletDB = __webpack_require__(130);
const NodeClient = __webpack_require__(254);

/**
 * @exports wallet/plugin
 */

const plugin = exports;

/**
 * Plugin name.
 * @const {String}
 */

plugin.id = 'walletdb';

/**
 * Plugin initialization.
 * @param {Node} node
 * @returns {WalletDB}
 */

plugin.init = function init(node) {
  const config = node.config;
  const client = new NodeClient(node);

  const wdb = new WalletDB({
    network: node.network,
    logger: node.logger,
    workers: node.workers,
    client: client,
    prefix: config.prefix,
    db: config.str(['wallet-db', 'db']),
    maxFiles: config.uint('wallet-max-files'),
    cacheSize: config.mb('wallet-cache-size'),
    witness: config.bool('wallet-witness'),
    checkpoints: config.bool('wallet-checkpoints'),
    startHeight: config.uint('wallet-start-height'),
    wipeNoReally: config.bool('wallet-wipe-no-really'),
    apiKey: config.str(['wallet-api-key', 'api-key']),
    walletAuth: config.bool('wallet-auth'),
    noAuth: config.bool(['wallet-no-auth', 'no-auth']),
    ssl: config.str('wallet-ssl'),
    host: config.str('wallet-host'),
    port: config.uint('wallet-port'),
    spv: node.spv,
    verify: node.spv,
    listen: false
  });

  if (node.http && wdb.http)
    wdb.http.attach(node.http);

  wdb.rpc.attach(node.rpc);

  return wdb;
};


/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * server.js - wallet server for wmcc_core.
 */



const WalletDB = __webpack_require__(130);
const WorkerPool = __webpack_require__(124);
const Config = __webpack_require__(123);
const Logger = __webpack_require__(34);
const Client = __webpack_require__(251);

/**
 * @exports wallet/server
 */

const server = exports;

/**
 * Create a wallet server.
 * @param {Object} options
 * @returns {WalletDB}
 */

server.create = function create(options) {
  const config = new Config('wmcc');
  let logger = new Logger('debug');

  config.inject(options);
  config.load(options);

  if (options.config)
    config.open('wallet.conf');

  if (config.has('logger'))
    logger = config.obj('logger');

  const client = new Client({
    network: config.network,
    uri: config.str('node-uri'),
    apiKey: config.str('node-api-key')
  });

  logger.set({
    filename: config.bool('log-file')
      ? config.location('wallet.log')
      : null,
    level: config.str('log-level'),
    console: config.bool('log-console'),
    shrink: config.bool('log-shrink')
  });

  const workers = new WorkerPool({
    enabled: config.str('workers-enabled'),
    size: config.uint('workers-size'),
    timeout: config.uint('workers-timeout')
  });

  const wdb = new WalletDB({
    network: config.network,
    logger: logger,
    workers: workers,
    client: client,
    prefix: config.prefix,
    db: config.str('db'),
    maxFiles: config.uint('max-files'),
    cacheSize: config.mb('cache-size'),
    witness: config.bool('witness'),
    checkpoints: config.bool('checkpoints'),
    startHeight: config.uint('start-height'),
    wipeNoReally: config.bool('wipe-no-really'),
    apiKey: config.str('api-key'),
    walletAuth: config.bool('auth'),
    noAuth: config.bool('no-auth'),
    ssl: config.str('ssl'),
    host: config.str('host'),
    port: config.uint('port'),
    spv: config.bool('spv'),
    verify: config.bool('spv'),
    listen: true
  });

  wdb.on('error', () => {});

  workers.on('spawn', (child) => {
    logger.info('Spawning worker process: %d.', child.id);
  });

  workers.on('exit', (code, child) => {
    logger.warning('Worker %d exited: %s.', child.id, code);
  });

  workers.on('log', (text, child) => {
    logger.debug('Worker %d says:', child.id);
    logger.debug(text);
  });

  workers.on('error', (err, child) => {
    if (child) {
      logger.error('Worker %d error: %s', child.id, err.message);
      return;
    }
    wdb.emit('error', err);
  });

  return wdb;
};


/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2014-2017, Christopher Jeffrey
 * Copyright (c) 2017, Park Alter (pseudonym)
 * Distributed under the MIT software license, see the accompanying
 * file COPYING or http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/park-alter/wmcc-core
 * workers/index.js - workers for wmcc_core.
 */



/**
 * @module workers
 */

exports.Framer = __webpack_require__(127);
exports.jobs = __webpack_require__(125);
exports.packets = __webpack_require__(53);
exports.Parser = __webpack_require__(126);
exports.WorkerPool = __webpack_require__(124);


/***/ })
/******/ ]);